#ifndef __pl011_uart_DEV_H
#define __pl011_uart_DEV_H 1
/*
 * DEVICE DEFINITION: PL011 UART
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) pl011_uart ## _ ## x
/*
 * Constants defn: pl011_uart.word_len (Word Length)
 *  - no width specified
 */
typedef uint8_t pl011_uart_word_len_t;
#define pl011_uart_bits5 ((pl011_uart_word_len_t)0x0)
#define pl011_uart_bits6 ((pl011_uart_word_len_t)0x1)
#define pl011_uart_bits7 ((pl011_uart_word_len_t)0x2)
#define pl011_uart_bits8 ((pl011_uart_word_len_t)0x3)

static inline char *pl011_uart_word_len_describe(pl011_uart_word_len_t _e) __attribute__ ((always_inline));
static inline char *pl011_uart_word_len_describe(pl011_uart_word_len_t _e)
{
    switch (_e) {
    case pl011_uart_bits5:
        return("bits5: 5 bits");
    case pl011_uart_bits6:
        return("bits6: 6 bits");
    case pl011_uart_bits7:
        return("bits7: 7 bits");
    case pl011_uart_bits8:
        return("bits8: 8 bits");
    default:
        return(NULL);
    }
}

static inline int pl011_uart_word_len_prtval(char *_s, size_t _size, pl011_uart_word_len_t _e) __attribute__ ((always_inline));
static inline int pl011_uart_word_len_prtval(char *_s, size_t _size, pl011_uart_word_len_t _e)
{
    char *d = pl011_uart_word_len_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pl011_uart_word_len_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: pl011_uart.rx_lvl (Receive interrupt FIFO level)
 *  - no width specified
 */
typedef uint8_t pl011_uart_rx_lvl_t;
#define pl011_uart_geq_1_8 ((pl011_uart_rx_lvl_t)0x0)
#define pl011_uart_geq_1_4 ((pl011_uart_rx_lvl_t)0x1)
#define pl011_uart_geq_1_2 ((pl011_uart_rx_lvl_t)0x2)
#define pl011_uart_geq_3_4 ((pl011_uart_rx_lvl_t)0x3)
#define pl011_uart_geq_7_8 ((pl011_uart_rx_lvl_t)0x4)

static inline char *pl011_uart_rx_lvl_describe(pl011_uart_rx_lvl_t _e) __attribute__ ((always_inline));
static inline char *pl011_uart_rx_lvl_describe(pl011_uart_rx_lvl_t _e)
{
    switch (_e) {
    case pl011_uart_geq_1_8:
        return("geq_1_8: geq_1_8");
    case pl011_uart_geq_1_4:
        return("geq_1_4: geq_1_4");
    case pl011_uart_geq_1_2:
        return("geq_1_2: geq_1_2");
    case pl011_uart_geq_3_4:
        return("geq_3_4: geq_3_4");
    case pl011_uart_geq_7_8:
        return("geq_7_8: geq_7_8");
    default:
        return(NULL);
    }
}

static inline int pl011_uart_rx_lvl_prtval(char *_s, size_t _size, pl011_uart_rx_lvl_t _e) __attribute__ ((always_inline));
static inline int pl011_uart_rx_lvl_prtval(char *_s, size_t _size, pl011_uart_rx_lvl_t _e)
{
    char *d = pl011_uart_rx_lvl_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pl011_uart_rx_lvl_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: pl011_uart.tx_lvl (Transmit interrupt FIFO level)
 *  - no width specified
 */
typedef uint8_t pl011_uart_tx_lvl_t;
#define pl011_uart_leq_1_8 ((pl011_uart_tx_lvl_t)0x0)
#define pl011_uart_leq_1_4 ((pl011_uart_tx_lvl_t)0x1)
#define pl011_uart_leq_1_2 ((pl011_uart_tx_lvl_t)0x2)
#define pl011_uart_leq_3_4 ((pl011_uart_tx_lvl_t)0x3)
#define pl011_uart_leq_7_8 ((pl011_uart_tx_lvl_t)0x4)

static inline char *pl011_uart_tx_lvl_describe(pl011_uart_tx_lvl_t _e) __attribute__ ((always_inline));
static inline char *pl011_uart_tx_lvl_describe(pl011_uart_tx_lvl_t _e)
{
    switch (_e) {
    case pl011_uart_leq_1_8:
        return("leq_1_8: leq_1_8");
    case pl011_uart_leq_1_4:
        return("leq_1_4: leq_1_4");
    case pl011_uart_leq_1_2:
        return("leq_1_2: leq_1_2");
    case pl011_uart_leq_3_4:
        return("leq_3_4: leq_3_4");
    case pl011_uart_leq_7_8:
        return("leq_7_8: leq_7_8");
    default:
        return(NULL);
    }
}

static inline int pl011_uart_tx_lvl_prtval(char *_s, size_t _size, pl011_uart_tx_lvl_t _e) __attribute__ ((always_inline));
static inline int pl011_uart_tx_lvl_prtval(char *_s, size_t _size, pl011_uart_tx_lvl_t _e)
{
    char *d = pl011_uart_tx_lvl_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pl011_uart_tx_lvl_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: pl011_uart_DR_t
 * Description: Implicit type of UARTDR data register register
 * Fields:
 *   data	(size 8, offset 0, init 0):	RW	Data character
 *   fe	(size 1, offset 8, init 0):	RO	Framing error
 *   pe	(size 1, offset 9, init 0):	RO	Parity error
 *   be	(size 1, offset 10, init 0):	RO	Break error
 *   oe	(size 1, offset 11, init 0):	RO	Overrun error
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_DR_t;
#define pl011_uart_DR_default 0x0
static inline uint8_t pl011_uart_DR_data_extract(pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_data_extract(pl011_uart_DR_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl011_uart_DR_t pl011_uart_DR_data_insert(pl011_uart_DR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_data_insert(pl011_uart_DR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl011_uart_DR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_DR_fe_extract(pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_fe_extract(pl011_uart_DR_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_DR_t pl011_uart_DR_fe_insert(pl011_uart_DR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_fe_insert(pl011_uart_DR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_DR_t )(_fieldval)) << 8)));
}

static inline uint8_t pl011_uart_DR_pe_extract(pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_pe_extract(pl011_uart_DR_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline pl011_uart_DR_t pl011_uart_DR_pe_insert(pl011_uart_DR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_pe_insert(pl011_uart_DR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((pl011_uart_DR_t )(_fieldval)) << 9)));
}

static inline uint8_t pl011_uart_DR_be_extract(pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_be_extract(pl011_uart_DR_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl011_uart_DR_t pl011_uart_DR_be_insert(pl011_uart_DR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_be_insert(pl011_uart_DR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl011_uart_DR_t )(_fieldval)) << 10)));
}

static inline uint8_t pl011_uart_DR_oe_extract(pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_oe_extract(pl011_uart_DR_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline pl011_uart_DR_t pl011_uart_DR_oe_insert(pl011_uart_DR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_oe_insert(pl011_uart_DR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((pl011_uart_DR_t )(_fieldval)) << 11)));
}

static inline int pl011_uart_DR_prtval(char *_s, size_t _size, pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_DR_prtval(char *_s, size_t _size, pl011_uart_DR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data character)\n", pl011_uart_DR_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fe =\t%" PRIx8 "\t(Framing error)\n", pl011_uart_DR_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Parity error)\n", pl011_uart_DR_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Break error)\n", pl011_uart_DR_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe =\t%" PRIx8 "\t(Overrun error)\n", pl011_uart_DR_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_RSR_ECR_t
 * Description: Implicit type of UART receive status / error clear register
 * Fields:
 *   fe	(size 1, offset 0, init 0):	RWZC	Framing error
 *   pe	(size 1, offset 1, init 0):	RWZC	Parity error
 *   be	(size 1, offset 2, init 0):	RWZC	Break error
 *   oe	(size 1, offset 3, init 0):	RWZC	Overrun error
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_RSR_ECR_t;
#define pl011_uart_RSR_ECR_default 0x0
static inline uint8_t pl011_uart_RSR_ECR_fe_extract(pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_fe_extract(pl011_uart_RSR_ECR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_fe_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_fe_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_RSR_ECR_pe_extract(pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_pe_extract(pl011_uart_RSR_ECR_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_pe_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_pe_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_RSR_ECR_be_extract(pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_be_extract(pl011_uart_RSR_ECR_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_be_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_be_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_RSR_ECR_oe_extract(pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_oe_extract(pl011_uart_RSR_ECR_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_oe_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_oe_insert(pl011_uart_RSR_ECR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 3)));
}

static inline int pl011_uart_RSR_ECR_prtval(char *_s, size_t _size, pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_RSR_ECR_prtval(char *_s, size_t _size, pl011_uart_RSR_ECR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fe =\t%" PRIx8 "\t(Framing error)\n", pl011_uart_RSR_ECR_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Parity error)\n", pl011_uart_RSR_ECR_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Break error)\n", pl011_uart_RSR_ECR_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe =\t%" PRIx8 "\t(Overrun error)\n", pl011_uart_RSR_ECR_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_FR_t
 * Description: Implicit type of UARTFR flag register register
 * Fields:
 *   cts	(size 1, offset 0, init 0):	RO	Clear to send.
 *   dsr	(size 1, offset 1, init 0):	RO	Data set ready.
 *   dcd	(size 1, offset 2, init 0):	RO	Data carrier detect
 *   busy	(size 1, offset 3, init 0):	RO	UART Busy (transmit active)
 *   rxfe	(size 1, offset 4, init 0):	RO	Receive FIFO empty
 *   txff	(size 1, offset 5, init 0):	RO	Transmit FIFO full
 *   rxff	(size 1, offset 6, init 0):	RO	Receive FIFO full
 *   txfe	(size 1, offset 7, init 0):	RO	Transmit FIFO empty
 *   ri	(size 1, offset 8, init 0):	RO	Ring indicator
 *   _anon9	(size 23, offset 9, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_FR_t;
#define pl011_uart_FR_default 0x0
static inline uint8_t pl011_uart_FR_cts_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_cts_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_FR_t pl011_uart_FR_cts_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_cts_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_FR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_FR_dsr_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_dsr_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_FR_t pl011_uart_FR_dsr_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_dsr_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_FR_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_FR_dcd_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_dcd_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_FR_t pl011_uart_FR_dcd_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_dcd_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_FR_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_FR_busy_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_busy_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_FR_t pl011_uart_FR_busy_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_busy_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_FR_t )(_fieldval)) << 3)));
}

static inline uint8_t pl011_uart_FR_rxfe_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_rxfe_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pl011_uart_FR_t pl011_uart_FR_rxfe_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_rxfe_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((pl011_uart_FR_t )(_fieldval)) << 4)));
}

static inline uint8_t pl011_uart_FR_txff_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_txff_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pl011_uart_FR_t pl011_uart_FR_txff_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_txff_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((pl011_uart_FR_t )(_fieldval)) << 5)));
}

static inline uint8_t pl011_uart_FR_rxff_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_rxff_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pl011_uart_FR_t pl011_uart_FR_rxff_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_rxff_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((pl011_uart_FR_t )(_fieldval)) << 6)));
}

static inline uint8_t pl011_uart_FR_txfe_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_txfe_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_FR_t pl011_uart_FR_txfe_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_txfe_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_FR_t )(_fieldval)) << 7)));
}

static inline uint8_t pl011_uart_FR_ri_extract(pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_ri_extract(pl011_uart_FR_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_FR_t pl011_uart_FR_ri_insert(pl011_uart_FR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_ri_insert(pl011_uart_FR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_FR_t )(_fieldval)) << 8)));
}

static inline int pl011_uart_FR_prtval(char *_s, size_t _size, pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_FR_prtval(char *_s, size_t _size, pl011_uart_FR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts =\t%" PRIx8 "\t(Clear to send.)\n", pl011_uart_FR_cts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr =\t%" PRIx8 "\t(Data set ready.)\n", pl011_uart_FR_dsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcd =\t%" PRIx8 "\t(Data carrier detect)\n", pl011_uart_FR_dcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " busy =\t%" PRIx8 "\t(UART Busy (transmit active))\n", pl011_uart_FR_busy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfe =\t%" PRIx8 "\t(Receive FIFO empty)\n", pl011_uart_FR_rxfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txff =\t%" PRIx8 "\t(Transmit FIFO full)\n", pl011_uart_FR_txff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxff =\t%" PRIx8 "\t(Receive FIFO full)\n", pl011_uart_FR_rxff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfe =\t%" PRIx8 "\t(Transmit FIFO empty)\n", pl011_uart_FR_txfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Ring indicator)\n", pl011_uart_FR_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_ILPR_t
 * Description: Implicit type of UARTIPLR low power counter register
 * Fields:
 *   ilpdvsr	(size 8, offset 0, init 0):	RW	Low power divisor
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_ILPR_t;
#define pl011_uart_ILPR_default 0x0
static inline uint8_t pl011_uart_ILPR_ilpdvsr_extract(pl011_uart_ILPR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ILPR_ilpdvsr_extract(pl011_uart_ILPR_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl011_uart_ILPR_t pl011_uart_ILPR_ilpdvsr_insert(pl011_uart_ILPR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ILPR_t pl011_uart_ILPR_ilpdvsr_insert(pl011_uart_ILPR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl011_uart_ILPR_t )(_fieldval)) << 0)));
}

static inline int pl011_uart_ILPR_prtval(char *_s, size_t _size, pl011_uart_ILPR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_ILPR_prtval(char *_s, size_t _size, pl011_uart_ILPR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ilpdvsr =\t%" PRIx8 "\t(Low power divisor)\n", pl011_uart_ILPR_ilpdvsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_IBRD_t
 * Description: Implicit type of UARTIBRD integer baud rate register
 * Fields:
 *   divint	(size 16, offset 0, init 0):	RW	Integer divisor
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_IBRD_t;
#define pl011_uart_IBRD_default 0x0
static inline uint16_t pl011_uart_IBRD_divint_extract(pl011_uart_IBRD_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl011_uart_IBRD_divint_extract(pl011_uart_IBRD_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline pl011_uart_IBRD_t pl011_uart_IBRD_divint_insert(pl011_uart_IBRD_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IBRD_t pl011_uart_IBRD_divint_insert(pl011_uart_IBRD_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((pl011_uart_IBRD_t )(_fieldval)) << 0)));
}

static inline int pl011_uart_IBRD_prtval(char *_s, size_t _size, pl011_uart_IBRD_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_IBRD_prtval(char *_s, size_t _size, pl011_uart_IBRD_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " divint =\t%" PRIx16 "\t(Integer divisor)\n", pl011_uart_IBRD_divint_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_FBRD_t
 * Description: Implicit type of UARTFBRD fractional baud rate register
 * Fields:
 *   divfrac	(size 6, offset 0, init 0):	RW	Fractional divisor
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_FBRD_t;
#define pl011_uart_FBRD_default 0x0
static inline uint8_t pl011_uart_FBRD_divfrac_extract(pl011_uart_FBRD_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FBRD_divfrac_extract(pl011_uart_FBRD_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline pl011_uart_FBRD_t pl011_uart_FBRD_divfrac_insert(pl011_uart_FBRD_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_FBRD_t pl011_uart_FBRD_divfrac_insert(pl011_uart_FBRD_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((pl011_uart_FBRD_t )(_fieldval)) << 0)));
}

static inline int pl011_uart_FBRD_prtval(char *_s, size_t _size, pl011_uart_FBRD_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_FBRD_prtval(char *_s, size_t _size, pl011_uart_FBRD_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " divfrac =\t%" PRIx8 "\t(Fractional divisor)\n", pl011_uart_FBRD_divfrac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_LCR_H_t
 * Description: Implicit type of UARTLCD_H Line control register register
 * Fields:
 *   brk	(size 1, offset 0, init 0):	RW	Send break
 *   pen	(size 1, offset 1, init 0):	RW	Parity enable
 *   eps	(size 1, offset 2, init 0):	RW	Even parity select
 *   stp2	(size 1, offset 3, init 0):	RW	Two stop bits select
 *   fen	(size 1, offset 4, init 0):	RW	FIFOs enable
 *   wlen	(size 2, offset 5, init 0):	RW	Word length
 *   sps	(size 1, offset 7, init 0):	RW	Stick parity select
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_LCR_H_t;
#define pl011_uart_LCR_H_default 0x0
static inline uint8_t pl011_uart_LCR_H_brk_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_brk_extract(pl011_uart_LCR_H_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_brk_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_brk_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_LCR_H_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_LCR_H_pen_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_pen_extract(pl011_uart_LCR_H_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_pen_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_pen_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_LCR_H_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_LCR_H_eps_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_eps_extract(pl011_uart_LCR_H_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_eps_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_eps_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_LCR_H_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_LCR_H_stp2_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_stp2_extract(pl011_uart_LCR_H_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_stp2_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_stp2_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_LCR_H_t )(_fieldval)) << 3)));
}

static inline uint8_t pl011_uart_LCR_H_fen_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_fen_extract(pl011_uart_LCR_H_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_fen_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_fen_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((pl011_uart_LCR_H_t )(_fieldval)) << 4)));
}

static inline pl011_uart_word_len_t pl011_uart_LCR_H_wlen_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline pl011_uart_word_len_t pl011_uart_LCR_H_wlen_extract(pl011_uart_LCR_H_t _regval)
{
    return((pl011_uart_word_len_t )((_regval & 0x60) >> 5));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_wlen_insert(pl011_uart_LCR_H_t _regval, pl011_uart_word_len_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_wlen_insert(pl011_uart_LCR_H_t _regval, pl011_uart_word_len_t _fieldval)
{
    return((_regval & 0xffffff9f) | (0x60 & (((pl011_uart_LCR_H_t )(_fieldval)) << 5)));
}

static inline uint8_t pl011_uart_LCR_H_sps_extract(pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_sps_extract(pl011_uart_LCR_H_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_sps_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_sps_insert(pl011_uart_LCR_H_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_LCR_H_t )(_fieldval)) << 7)));
}

static inline int pl011_uart_LCR_H_prtval(char *_s, size_t _size, pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_LCR_H_prtval(char *_s, size_t _size, pl011_uart_LCR_H_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " brk =\t%" PRIx8 "\t(Send break)\n", pl011_uart_LCR_H_brk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pen =\t%" PRIx8 "\t(Parity enable)\n", pl011_uart_LCR_H_pen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eps =\t%" PRIx8 "\t(Even parity select)\n", pl011_uart_LCR_H_eps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stp2 =\t%" PRIx8 "\t(Two stop bits select)\n", pl011_uart_LCR_H_stp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fen =\t%" PRIx8 "\t(FIFOs enable)\n", pl011_uart_LCR_H_fen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wlen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_word_len_prtval(_s + _r, _avail, pl011_uart_LCR_H_wlen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Word length)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sps =\t%" PRIx8 "\t(Stick parity select)\n", pl011_uart_LCR_H_sps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_CR_t
 * Description: Implicit type of UARTCR control register register
 * Fields:
 *   uarten	(size 1, offset 0, init 0):	RW	UART enable
 *   siren	(size 1, offset 1, init 0):	RW	SIR enable
 *   sirlp	(size 1, offset 2, init 0):	RW	SIR low-power IrDA mode
 *   _anon3	(size 4, offset 3, init 0):	RSVD	_
 *   lbe	(size 1, offset 7, init 0):	RW	Loopback enable
 *   txe	(size 1, offset 8, init 0):	RW	Transmit enable
 *   rxe	(size 1, offset 9, init 0):	RW	Receive enable
 *   dtr	(size 1, offset 10, init 0):	RW	Data transmit ready
 *   rts	(size 1, offset 11, init 0):	RW	Request to send
 *   out1	(size 1, offset 12, init 0):	RW	Out1 modem status output
 *   out2	(size 1, offset 13, init 0):	RW	Out2 modem status output
 *   rtsen	(size 1, offset 14, init 0):	RW	RTS hardware flow control enable
 *   ctsen	(size 1, offset 15, init 0):	RW	CTS hardware flow control enable
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_CR_t;
#define pl011_uart_CR_default 0x0
static inline uint8_t pl011_uart_CR_uarten_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_uarten_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_CR_t pl011_uart_CR_uarten_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_uarten_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_CR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_CR_siren_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_siren_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_CR_t pl011_uart_CR_siren_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_siren_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_CR_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_CR_sirlp_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_sirlp_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_CR_t pl011_uart_CR_sirlp_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_sirlp_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_CR_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_CR_lbe_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_lbe_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_CR_t pl011_uart_CR_lbe_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_lbe_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_CR_t )(_fieldval)) << 7)));
}

static inline uint8_t pl011_uart_CR_txe_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_txe_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_CR_t pl011_uart_CR_txe_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_txe_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_CR_t )(_fieldval)) << 8)));
}

static inline uint8_t pl011_uart_CR_rxe_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_rxe_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline pl011_uart_CR_t pl011_uart_CR_rxe_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_rxe_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((pl011_uart_CR_t )(_fieldval)) << 9)));
}

static inline uint8_t pl011_uart_CR_dtr_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_dtr_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl011_uart_CR_t pl011_uart_CR_dtr_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_dtr_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl011_uart_CR_t )(_fieldval)) << 10)));
}

static inline uint8_t pl011_uart_CR_rts_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_rts_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline pl011_uart_CR_t pl011_uart_CR_rts_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_rts_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((pl011_uart_CR_t )(_fieldval)) << 11)));
}

static inline uint8_t pl011_uart_CR_out1_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_out1_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline pl011_uart_CR_t pl011_uart_CR_out1_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_out1_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((pl011_uart_CR_t )(_fieldval)) << 12)));
}

static inline uint8_t pl011_uart_CR_out2_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_out2_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline pl011_uart_CR_t pl011_uart_CR_out2_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_out2_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((pl011_uart_CR_t )(_fieldval)) << 13)));
}

static inline uint8_t pl011_uart_CR_rtsen_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_rtsen_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline pl011_uart_CR_t pl011_uart_CR_rtsen_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_rtsen_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((pl011_uart_CR_t )(_fieldval)) << 14)));
}

static inline uint8_t pl011_uart_CR_ctsen_extract(pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_ctsen_extract(pl011_uart_CR_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline pl011_uart_CR_t pl011_uart_CR_ctsen_insert(pl011_uart_CR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_ctsen_insert(pl011_uart_CR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((pl011_uart_CR_t )(_fieldval)) << 15)));
}

static inline int pl011_uart_CR_prtval(char *_s, size_t _size, pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_CR_prtval(char *_s, size_t _size, pl011_uart_CR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uarten =\t%" PRIx8 "\t(UART enable)\n", pl011_uart_CR_uarten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " siren =\t%" PRIx8 "\t(SIR enable)\n", pl011_uart_CR_siren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sirlp =\t%" PRIx8 "\t(SIR low-power IrDA mode)\n", pl011_uart_CR_sirlp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbe =\t%" PRIx8 "\t(Loopback enable)\n", pl011_uart_CR_lbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txe =\t%" PRIx8 "\t(Transmit enable)\n", pl011_uart_CR_txe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(Receive enable)\n", pl011_uart_CR_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtr =\t%" PRIx8 "\t(Data transmit ready)\n", pl011_uart_CR_dtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts =\t%" PRIx8 "\t(Request to send)\n", pl011_uart_CR_rts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out1 =\t%" PRIx8 "\t(Out1 modem status output)\n", pl011_uart_CR_out1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out2 =\t%" PRIx8 "\t(Out2 modem status output)\n", pl011_uart_CR_out2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtsen =\t%" PRIx8 "\t(RTS hardware flow control enable)\n", pl011_uart_CR_rtsen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsen =\t%" PRIx8 "\t(CTS hardware flow control enable)\n", pl011_uart_CR_ctsen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_IFLS_t
 * Description: Implicit type of Interrupt FIFO Level Selector register
 * Fields:
 *   txiflsel	(size 3, offset 0, init 0):	RW	Transmit interrupt FIFO level select
 *   rxiflsel	(size 3, offset 3, init 0):	RW	Receive interrupt FIFO level select
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_IFLS_t;
#define pl011_uart_IFLS_default 0x0
static inline pl011_uart_tx_lvl_t pl011_uart_IFLS_txiflsel_extract(pl011_uart_IFLS_t _regval) __attribute__ ((always_inline));
static inline pl011_uart_tx_lvl_t pl011_uart_IFLS_txiflsel_extract(pl011_uart_IFLS_t _regval)
{
    return((pl011_uart_tx_lvl_t )((_regval & 0x7) >> 0));
}

static inline pl011_uart_IFLS_t pl011_uart_IFLS_txiflsel_insert(pl011_uart_IFLS_t _regval, pl011_uart_tx_lvl_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IFLS_t pl011_uart_IFLS_txiflsel_insert(pl011_uart_IFLS_t _regval, pl011_uart_tx_lvl_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((pl011_uart_IFLS_t )(_fieldval)) << 0)));
}

static inline pl011_uart_rx_lvl_t pl011_uart_IFLS_rxiflsel_extract(pl011_uart_IFLS_t _regval) __attribute__ ((always_inline));
static inline pl011_uart_rx_lvl_t pl011_uart_IFLS_rxiflsel_extract(pl011_uart_IFLS_t _regval)
{
    return((pl011_uart_rx_lvl_t )((_regval & 0x38) >> 3));
}

static inline pl011_uart_IFLS_t pl011_uart_IFLS_rxiflsel_insert(pl011_uart_IFLS_t _regval, pl011_uart_rx_lvl_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IFLS_t pl011_uart_IFLS_rxiflsel_insert(pl011_uart_IFLS_t _regval, pl011_uart_rx_lvl_t _fieldval)
{
    return((_regval & 0xffffffc7) | (0x38 & (((pl011_uart_IFLS_t )(_fieldval)) << 3)));
}

static inline int pl011_uart_IFLS_prtval(char *_s, size_t _size, pl011_uart_IFLS_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_IFLS_prtval(char *_s, size_t _size, pl011_uart_IFLS_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txiflsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_tx_lvl_prtval(_s + _r, _avail, pl011_uart_IFLS_txiflsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transmit interrupt FIFO level select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxiflsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_rx_lvl_prtval(_s + _r, _avail, pl011_uart_IFLS_rxiflsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive interrupt FIFO level select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_IMSC_t
 * Description: Implicit type of Interrupt mask set/clear register
 * Fields:
 *   rimim	(size 1, offset 0, init 0):	RW	nUARTRI modem interrupt mask
 *   ctsmim	(size 1, offset 1, init 0):	RW	nUARTCTS modem interrupt mask
 *   dcdmim	(size 1, offset 2, init 0):	RW	nUARTDCD modem interrupt mask
 *   dsrmim	(size 1, offset 3, init 0):	RW	nUARTDSR modem interrupt mask
 *   rxim	(size 1, offset 4, init 0):	RW	Receive interrupt mask
 *   txim	(size 1, offset 5, init 0):	RW	Transmit interrupt mask
 *   rtim	(size 1, offset 6, init 0):	RW	Receive timeout interrupt mask
 *   feim	(size 1, offset 7, init 0):	RW	Framing error interrupt mask
 *   peim	(size 1, offset 8, init 0):	RW	Parity error interrupt mask
 *   beim	(size 1, offset 9, init 0):	RW	Break error interrupt mask
 *   oeim	(size 1, offset 10, init 0):	RW	Overrun error interrupt mask
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_IMSC_t;
#define pl011_uart_IMSC_default 0x0
static inline uint8_t pl011_uart_IMSC_rimim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_rimim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_rimim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_rimim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_IMSC_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_IMSC_ctsmim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_ctsmim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_ctsmim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_ctsmim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_IMSC_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_IMSC_dcdmim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_dcdmim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_dcdmim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_dcdmim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_IMSC_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_IMSC_dsrmim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_dsrmim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_dsrmim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_dsrmim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_IMSC_t )(_fieldval)) << 3)));
}

static inline uint8_t pl011_uart_IMSC_rxim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_rxim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_rxim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_rxim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((pl011_uart_IMSC_t )(_fieldval)) << 4)));
}

static inline uint8_t pl011_uart_IMSC_txim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_txim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_txim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_txim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((pl011_uart_IMSC_t )(_fieldval)) << 5)));
}

static inline uint8_t pl011_uart_IMSC_rtim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_rtim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_rtim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_rtim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((pl011_uart_IMSC_t )(_fieldval)) << 6)));
}

static inline uint8_t pl011_uart_IMSC_feim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_feim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_feim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_feim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_IMSC_t )(_fieldval)) << 7)));
}

static inline uint8_t pl011_uart_IMSC_peim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_peim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_peim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_peim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_IMSC_t )(_fieldval)) << 8)));
}

static inline uint8_t pl011_uart_IMSC_beim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_beim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_beim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_beim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((pl011_uart_IMSC_t )(_fieldval)) << 9)));
}

static inline uint8_t pl011_uart_IMSC_oeim_extract(pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_oeim_extract(pl011_uart_IMSC_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_oeim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_oeim_insert(pl011_uart_IMSC_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl011_uart_IMSC_t )(_fieldval)) << 10)));
}

static inline int pl011_uart_IMSC_prtval(char *_s, size_t _size, pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_IMSC_prtval(char *_s, size_t _size, pl011_uart_IMSC_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rimim =\t%" PRIx8 "\t(nUARTRI modem interrupt mask)\n", pl011_uart_IMSC_rimim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsmim =\t%" PRIx8 "\t(nUARTCTS modem interrupt mask)\n", pl011_uart_IMSC_ctsmim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdmim =\t%" PRIx8 "\t(nUARTDCD modem interrupt mask)\n", pl011_uart_IMSC_dcdmim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrmim =\t%" PRIx8 "\t(nUARTDSR modem interrupt mask)\n", pl011_uart_IMSC_dsrmim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxim =\t%" PRIx8 "\t(Receive interrupt mask)\n", pl011_uart_IMSC_rxim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txim =\t%" PRIx8 "\t(Transmit interrupt mask)\n", pl011_uart_IMSC_txim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtim =\t%" PRIx8 "\t(Receive timeout interrupt mask)\n", pl011_uart_IMSC_rtim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feim =\t%" PRIx8 "\t(Framing error interrupt mask)\n", pl011_uart_IMSC_feim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " peim =\t%" PRIx8 "\t(Parity error interrupt mask)\n", pl011_uart_IMSC_peim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beim =\t%" PRIx8 "\t(Break error interrupt mask)\n", pl011_uart_IMSC_beim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oeim =\t%" PRIx8 "\t(Overrun error interrupt mask)\n", pl011_uart_IMSC_oeim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_RIS_t
 * Description: Implicit type of Raw interrupt status register
 * Fields:
 *   rirmis	(size 1, offset 0, init 0):	RO	nUARTRI modem interrupt status
 *   ctsrmis	(size 1, offset 1, init 0):	RO	nUARTCTS modem interrupt status
 *   dcdrmis	(size 1, offset 2, init 0):	RO	nUARTDCD modem interrupt status
 *   dsrrmis	(size 1, offset 3, init 0):	RO	nUARTDSR modem interrupt status
 *   rxris	(size 1, offset 4, init 0):	RO	Receive interrupt status
 *   txris	(size 1, offset 5, init 0):	RO	Transmit interrupt status
 *   rtris	(size 1, offset 6, init 0):	RO	Receive timeout interrupt status
 *   feris	(size 1, offset 7, init 0):	RO	Framing error interrupt status
 *   peris	(size 1, offset 8, init 0):	RO	Parity error interrupt status
 *   beris	(size 1, offset 9, init 0):	RO	Break error interrupt status
 *   oeris	(size 1, offset 10, init 0):	RO	Overrun error interrupt status
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_RIS_t;
#define pl011_uart_RIS_default 0x0
static inline uint8_t pl011_uart_RIS_rirmis_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_rirmis_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_rirmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_rirmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_RIS_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_RIS_ctsrmis_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_ctsrmis_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_ctsrmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_ctsrmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_RIS_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_RIS_dcdrmis_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_dcdrmis_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_dcdrmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_dcdrmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_RIS_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_RIS_dsrrmis_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_dsrrmis_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_dsrrmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_dsrrmis_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_RIS_t )(_fieldval)) << 3)));
}

static inline uint8_t pl011_uart_RIS_rxris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_rxris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_rxris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_rxris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((pl011_uart_RIS_t )(_fieldval)) << 4)));
}

static inline uint8_t pl011_uart_RIS_txris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_txris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_txris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_txris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((pl011_uart_RIS_t )(_fieldval)) << 5)));
}

static inline uint8_t pl011_uart_RIS_rtris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_rtris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_rtris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_rtris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((pl011_uart_RIS_t )(_fieldval)) << 6)));
}

static inline uint8_t pl011_uart_RIS_feris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_feris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_feris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_feris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_RIS_t )(_fieldval)) << 7)));
}

static inline uint8_t pl011_uart_RIS_peris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_peris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_peris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_peris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_RIS_t )(_fieldval)) << 8)));
}

static inline uint8_t pl011_uart_RIS_beris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_beris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_beris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_beris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((pl011_uart_RIS_t )(_fieldval)) << 9)));
}

static inline uint8_t pl011_uart_RIS_oeris_extract(pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_oeris_extract(pl011_uart_RIS_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_oeris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_oeris_insert(pl011_uart_RIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl011_uart_RIS_t )(_fieldval)) << 10)));
}

static inline int pl011_uart_RIS_prtval(char *_s, size_t _size, pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_RIS_prtval(char *_s, size_t _size, pl011_uart_RIS_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rirmis =\t%" PRIx8 "\t(nUARTRI modem interrupt status)\n", pl011_uart_RIS_rirmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsrmis =\t%" PRIx8 "\t(nUARTCTS modem interrupt status)\n", pl011_uart_RIS_ctsrmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdrmis =\t%" PRIx8 "\t(nUARTDCD modem interrupt status)\n", pl011_uart_RIS_dcdrmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrrmis =\t%" PRIx8 "\t(nUARTDSR modem interrupt status)\n", pl011_uart_RIS_dsrrmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxris =\t%" PRIx8 "\t(Receive interrupt status)\n", pl011_uart_RIS_rxris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txris =\t%" PRIx8 "\t(Transmit interrupt status)\n", pl011_uart_RIS_txris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtris =\t%" PRIx8 "\t(Receive timeout interrupt status)\n", pl011_uart_RIS_rtris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feris =\t%" PRIx8 "\t(Framing error interrupt status)\n", pl011_uart_RIS_feris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " peris =\t%" PRIx8 "\t(Parity error interrupt status)\n", pl011_uart_RIS_peris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beris =\t%" PRIx8 "\t(Break error interrupt status)\n", pl011_uart_RIS_beris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oeris =\t%" PRIx8 "\t(Overrun error interrupt status)\n", pl011_uart_RIS_oeris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_MIS_t
 * Description: Implicit type of Masked interrupt status register register
 * Fields:
 *   rimmis	(size 1, offset 0, init 0):	RO	nUARTRI modem masked interrupt status
 *   ctsmmis	(size 1, offset 1, init 0):	RO	nUARTCTS modem masked interrupt status
 *   dcdmmis	(size 1, offset 2, init 0):	RO	nUARTDCD modem masked interrupt status
 *   dsrmmis	(size 1, offset 3, init 0):	RO	nUARTDSR modem masked interrupt status
 *   rxmis	(size 1, offset 4, init 0):	RO	Receive masked interrupt status
 *   txmis	(size 1, offset 5, init 0):	RO	Transmit masked interrupt status
 *   rtmis	(size 1, offset 6, init 0):	RO	Receive timeout masked interrupt status
 *   femis	(size 1, offset 7, init 0):	RO	Framing error masked interrupt status
 *   pemis	(size 1, offset 8, init 0):	RO	Parity error masked interrupt status
 *   bemis	(size 1, offset 9, init 0):	RO	Break error masked interrupt status
 *   oemis	(size 1, offset 10, init 0):	RO	Overrun error masked interrupt status
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_MIS_t;
#define pl011_uart_MIS_default 0x0
static inline uint8_t pl011_uart_MIS_rimmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_rimmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_rimmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_rimmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_MIS_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_MIS_ctsmmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_ctsmmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_ctsmmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_ctsmmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_MIS_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_MIS_dcdmmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_dcdmmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_dcdmmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_dcdmmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_MIS_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_MIS_dsrmmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_dsrmmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_dsrmmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_dsrmmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_MIS_t )(_fieldval)) << 3)));
}

static inline uint8_t pl011_uart_MIS_rxmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_rxmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_rxmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_rxmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((pl011_uart_MIS_t )(_fieldval)) << 4)));
}

static inline uint8_t pl011_uart_MIS_txmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_txmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_txmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_txmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((pl011_uart_MIS_t )(_fieldval)) << 5)));
}

static inline uint8_t pl011_uart_MIS_rtmis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_rtmis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_rtmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_rtmis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((pl011_uart_MIS_t )(_fieldval)) << 6)));
}

static inline uint8_t pl011_uart_MIS_femis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_femis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_femis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_femis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_MIS_t )(_fieldval)) << 7)));
}

static inline uint8_t pl011_uart_MIS_pemis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_pemis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_pemis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_pemis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_MIS_t )(_fieldval)) << 8)));
}

static inline uint8_t pl011_uart_MIS_bemis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_bemis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_bemis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_bemis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((pl011_uart_MIS_t )(_fieldval)) << 9)));
}

static inline uint8_t pl011_uart_MIS_oemis_extract(pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_oemis_extract(pl011_uart_MIS_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_oemis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_oemis_insert(pl011_uart_MIS_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl011_uart_MIS_t )(_fieldval)) << 10)));
}

static inline int pl011_uart_MIS_prtval(char *_s, size_t _size, pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_MIS_prtval(char *_s, size_t _size, pl011_uart_MIS_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rimmis =\t%" PRIx8 "\t(nUARTRI modem masked interrupt status)\n", pl011_uart_MIS_rimmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsmmis =\t%" PRIx8 "\t(nUARTCTS modem masked interrupt status)\n", pl011_uart_MIS_ctsmmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdmmis =\t%" PRIx8 "\t(nUARTDCD modem masked interrupt status)\n", pl011_uart_MIS_dcdmmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrmmis =\t%" PRIx8 "\t(nUARTDSR modem masked interrupt status)\n", pl011_uart_MIS_dsrmmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxmis =\t%" PRIx8 "\t(Receive masked interrupt status)\n", pl011_uart_MIS_rxmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txmis =\t%" PRIx8 "\t(Transmit masked interrupt status)\n", pl011_uart_MIS_txmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtmis =\t%" PRIx8 "\t(Receive timeout masked interrupt status)\n", pl011_uart_MIS_rtmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " femis =\t%" PRIx8 "\t(Framing error masked interrupt status)\n", pl011_uart_MIS_femis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pemis =\t%" PRIx8 "\t(Parity error masked interrupt status)\n", pl011_uart_MIS_pemis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bemis =\t%" PRIx8 "\t(Break error masked interrupt status)\n", pl011_uart_MIS_bemis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oemis =\t%" PRIx8 "\t(Overrun error masked interrupt status)\n", pl011_uart_MIS_oemis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_ICR_t
 * Description: Implicit type of Interrupt clear register register
 * Fields:
 *   rimic	(size 1, offset 0, init 0):	RWC	nUARTRI modem interrupt clear
 *   ctsmic	(size 1, offset 1, init 0):	RWC	nUARTCTS modem interrupt clear
 *   dcdmic	(size 1, offset 2, init 0):	RWC	nUARTDCD modem interrupt clear
 *   dsrmic	(size 1, offset 3, init 0):	RWC	nUARTDSR modem interrupt clear
 *   rxic	(size 1, offset 4, init 0):	RWC	Receive interrupt clear
 *   txic	(size 1, offset 5, init 0):	RWC	Transmit interrupt clear
 *   rtic	(size 1, offset 6, init 0):	RWC	Receive timeout interrupt clear
 *   feic	(size 1, offset 7, init 0):	RWC	Framing error interrupt clear
 *   peic	(size 1, offset 8, init 0):	RWC	Parity error interrupt clear
 *   beic	(size 1, offset 9, init 0):	RWC	Break error interrupt clear
 *   oeic	(size 1, offset 10, init 0):	RWC	Overrun error interrupt clear
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t pl011_uart_ICR_t;
#define pl011_uart_ICR_default 0x0
static inline uint8_t pl011_uart_ICR_rimic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_rimic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_rimic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_rimic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_ICR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_ICR_ctsmic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_ctsmic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_ctsmic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_ctsmic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_ICR_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_ICR_dcdmic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_dcdmic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_dcdmic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_dcdmic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_ICR_t )(_fieldval)) << 2)));
}

static inline uint8_t pl011_uart_ICR_dsrmic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_dsrmic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_dsrmic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_dsrmic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl011_uart_ICR_t )(_fieldval)) << 3)));
}

static inline uint8_t pl011_uart_ICR_rxic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_rxic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_rxic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_rxic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((pl011_uart_ICR_t )(_fieldval)) << 4)));
}

static inline uint8_t pl011_uart_ICR_txic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_txic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_txic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_txic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((pl011_uart_ICR_t )(_fieldval)) << 5)));
}

static inline uint8_t pl011_uart_ICR_rtic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_rtic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_rtic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_rtic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((pl011_uart_ICR_t )(_fieldval)) << 6)));
}

static inline uint8_t pl011_uart_ICR_feic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_feic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_feic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_feic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl011_uart_ICR_t )(_fieldval)) << 7)));
}

static inline uint8_t pl011_uart_ICR_peic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_peic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_peic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_peic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((pl011_uart_ICR_t )(_fieldval)) << 8)));
}

static inline uint8_t pl011_uart_ICR_beic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_beic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_beic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_beic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((pl011_uart_ICR_t )(_fieldval)) << 9)));
}

static inline uint8_t pl011_uart_ICR_oeic_extract(pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_oeic_extract(pl011_uart_ICR_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_oeic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_oeic_insert(pl011_uart_ICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl011_uart_ICR_t )(_fieldval)) << 10)));
}

static inline int pl011_uart_ICR_prtval(char *_s, size_t _size, pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_ICR_prtval(char *_s, size_t _size, pl011_uart_ICR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rimic =\t%" PRIx8 "\t(nUARTRI modem interrupt clear)\n", pl011_uart_ICR_rimic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsmic =\t%" PRIx8 "\t(nUARTCTS modem interrupt clear)\n", pl011_uart_ICR_ctsmic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdmic =\t%" PRIx8 "\t(nUARTDCD modem interrupt clear)\n", pl011_uart_ICR_dcdmic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrmic =\t%" PRIx8 "\t(nUARTDSR modem interrupt clear)\n", pl011_uart_ICR_dsrmic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxic =\t%" PRIx8 "\t(Receive interrupt clear)\n", pl011_uart_ICR_rxic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txic =\t%" PRIx8 "\t(Transmit interrupt clear)\n", pl011_uart_ICR_txic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtic =\t%" PRIx8 "\t(Receive timeout interrupt clear)\n", pl011_uart_ICR_rtic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feic =\t%" PRIx8 "\t(Framing error interrupt clear)\n", pl011_uart_ICR_feic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " peic =\t%" PRIx8 "\t(Parity error interrupt clear)\n", pl011_uart_ICR_peic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beic =\t%" PRIx8 "\t(Break error interrupt clear)\n", pl011_uart_ICR_beic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oeic =\t%" PRIx8 "\t(Overrun error interrupt clear)\n", pl011_uart_ICR_oeic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl011_uart_DMACR_t
 * Description: Implicit type of DMA control register register
 * Fields:
 *   rxdmae	(size 1, offset 0, init 0):	RW	Receive DMA enable
 *   txdmae	(size 1, offset 1, init 0):	RW	Transmit DMA enable
 *   dmaonerr	(size 1, offset 2, init 0):	RW	DMA on error
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t pl011_uart_DMACR_t;
#define pl011_uart_DMACR_default 0x0
static inline uint8_t pl011_uart_DMACR_rxdmae_extract(pl011_uart_DMACR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DMACR_rxdmae_extract(pl011_uart_DMACR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl011_uart_DMACR_t pl011_uart_DMACR_rxdmae_insert(pl011_uart_DMACR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DMACR_t pl011_uart_DMACR_rxdmae_insert(pl011_uart_DMACR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl011_uart_DMACR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl011_uart_DMACR_txdmae_extract(pl011_uart_DMACR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DMACR_txdmae_extract(pl011_uart_DMACR_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl011_uart_DMACR_t pl011_uart_DMACR_txdmae_insert(pl011_uart_DMACR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DMACR_t pl011_uart_DMACR_txdmae_insert(pl011_uart_DMACR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl011_uart_DMACR_t )(_fieldval)) << 1)));
}

static inline uint8_t pl011_uart_DMACR_dmaonerr_extract(pl011_uart_DMACR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DMACR_dmaonerr_extract(pl011_uart_DMACR_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pl011_uart_DMACR_t pl011_uart_DMACR_dmaonerr_insert(pl011_uart_DMACR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl011_uart_DMACR_t pl011_uart_DMACR_dmaonerr_insert(pl011_uart_DMACR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((pl011_uart_DMACR_t )(_fieldval)) << 2)));
}

static inline int pl011_uart_DMACR_prtval(char *_s, size_t _size, pl011_uart_DMACR_t _regval) __attribute__ ((always_inline));
static inline int pl011_uart_DMACR_prtval(char *_s, size_t _size, pl011_uart_DMACR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmae =\t%" PRIx8 "\t(Receive DMA enable)\n", pl011_uart_DMACR_rxdmae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdmae =\t%" PRIx8 "\t(Transmit DMA enable)\n", pl011_uart_DMACR_txdmae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaonerr =\t%" PRIx8 "\t(DMA on error)\n", pl011_uart_DMACR_dmaonerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum pl011_uart_initials {
    pl011_uart_DR_initial = 0x0,
    pl011_uart_RSR_ECR_initial = 0x0,
    pl011_uart_FR_initial = 0x0,
    pl011_uart_ILPR_initial = 0x0,
    pl011_uart_IBRD_initial = 0x0,
    pl011_uart_FBRD_initial = 0x0,
    pl011_uart_LCR_H_initial = 0x0,
    pl011_uart_CR_initial = 0x0,
    pl011_uart_IFLS_initial = 0x0,
    pl011_uart_IMSC_initial = 0x0,
    pl011_uart_RIS_initial = 0x0,
    pl011_uart_MIS_initial = 0x0,
    pl011_uart_ICR_initial = 0x0,
    pl011_uart_DMACR_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void pl011_uart_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void pl011_uart_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register DR: UARTDR data register
 * Type: pl011_uart.DR (Implicit type of UARTDR data register register)
 *   data	(size 8, offset 0, init 0):	RW	Data character
 *   fe	(size 1, offset 8, init 0):	RO	Framing error
 *   pe	(size 1, offset 9, init 0):	RO	Parity error
 *   be	(size 1, offset 10, init 0):	RO	Break error
 *   oe	(size 1, offset 11, init 0):	RO	Overrun error
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static inline pl011_uart_DR_t pl011_uart_DR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline pl011_uart_DR_t pl011_uart_DR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_DR_t pl011_uart_DR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void pl011_uart_DR_rawwr(__DN(t) *_dev, pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_DR_rawwr(__DN(t) *_dev, pl011_uart_DR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void pl011_uart_DR_wr(__DN(t) *_dev, pl011_uart_DR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_DR_wr(__DN(t) *_dev, pl011_uart_DR_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x0)));
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int pl011_uart_DR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_DR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_DR_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DR (UARTDR data register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data character)\n", pl011_uart_DR_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fe =\t%" PRIx8 "\t(Framing error)\n", pl011_uart_DR_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Parity error)\n", pl011_uart_DR_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Break error)\n", pl011_uart_DR_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe =\t%" PRIx8 "\t(Overrun error)\n", pl011_uart_DR_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_DR_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_data_rdf(__DN(t) *_dev)
{
    pl011_uart_DR_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(pl011_uart_DR_data_extract(_regval));
}

static inline uint8_t pl011_uart_DR_fe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_fe_rdf(__DN(t) *_dev)
{
    pl011_uart_DR_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(pl011_uart_DR_fe_extract(_regval));
}

static inline uint8_t pl011_uart_DR_pe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_pe_rdf(__DN(t) *_dev)
{
    pl011_uart_DR_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(pl011_uart_DR_pe_extract(_regval));
}

static inline uint8_t pl011_uart_DR_be_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_be_rdf(__DN(t) *_dev)
{
    pl011_uart_DR_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(pl011_uart_DR_be_extract(_regval));
}

static inline uint8_t pl011_uart_DR_oe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DR_oe_rdf(__DN(t) *_dev)
{
    pl011_uart_DR_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(pl011_uart_DR_oe_extract(_regval));
}

static inline void pl011_uart_DR_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_DR_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_DR_t _regval = 0xff & (((pl011_uart_DR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register RSR_ECR: UART receive status / error clear
 * Type: pl011_uart.RSR_ECR (Implicit type of UART receive status / error clear register)
 *   fe	(size 1, offset 0, init 0):	RWZC	Framing error
 *   pe	(size 1, offset 1, init 0):	RWZC	Parity error
 *   be	(size 1, offset 2, init 0):	RWZC	Break error
 *   oe	(size 1, offset 3, init 0):	RWZC	Overrun error
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_RSR_ECR_t pl011_uart_RSR_ECR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void pl011_uart_RSR_ECR_rawwr(__DN(t) *_dev, pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_RSR_ECR_rawwr(__DN(t) *_dev, pl011_uart_RSR_ECR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void pl011_uart_RSR_ECR_wr(__DN(t) *_dev, pl011_uart_RSR_ECR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_RSR_ECR_wr(__DN(t) *_dev, pl011_uart_RSR_ECR_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4)));
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int pl011_uart_RSR_ECR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_RSR_ECR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_RSR_ECR_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register RSR_ECR (UART receive status / error clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fe =\t%" PRIx8 "\t(Framing error)\n", pl011_uart_RSR_ECR_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Parity error)\n", pl011_uart_RSR_ECR_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Break error)\n", pl011_uart_RSR_ECR_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe =\t%" PRIx8 "\t(Overrun error)\n", pl011_uart_RSR_ECR_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_RSR_ECR_fe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_fe_rdf(__DN(t) *_dev)
{
    pl011_uart_RSR_ECR_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(pl011_uart_RSR_ECR_fe_extract(_regval));
}

static inline uint8_t pl011_uart_RSR_ECR_pe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_pe_rdf(__DN(t) *_dev)
{
    pl011_uart_RSR_ECR_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(pl011_uart_RSR_ECR_pe_extract(_regval));
}

static inline uint8_t pl011_uart_RSR_ECR_be_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_be_rdf(__DN(t) *_dev)
{
    pl011_uart_RSR_ECR_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(pl011_uart_RSR_ECR_be_extract(_regval));
}

static inline uint8_t pl011_uart_RSR_ECR_oe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RSR_ECR_oe_rdf(__DN(t) *_dev)
{
    pl011_uart_RSR_ECR_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(pl011_uart_RSR_ECR_oe_extract(_regval));
}

static inline void pl011_uart_RSR_ECR_fe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_RSR_ECR_fe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_RSR_ECR_t _regval = 0x1 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_RSR_ECR_pe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_RSR_ECR_pe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_RSR_ECR_t _regval = 0x2 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_RSR_ECR_be_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_RSR_ECR_be_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_RSR_ECR_t _regval = 0x4 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_RSR_ECR_oe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_RSR_ECR_oe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_RSR_ECR_t _regval = 0x8 & (((pl011_uart_RSR_ECR_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register FR: UARTFR flag register
 * Type: pl011_uart.FR (Implicit type of UARTFR flag register register)
 *   cts	(size 1, offset 0, init 0):	RO	Clear to send.
 *   dsr	(size 1, offset 1, init 0):	RO	Data set ready.
 *   dcd	(size 1, offset 2, init 0):	RO	Data carrier detect
 *   busy	(size 1, offset 3, init 0):	RO	UART Busy (transmit active)
 *   rxfe	(size 1, offset 4, init 0):	RO	Receive FIFO empty
 *   txff	(size 1, offset 5, init 0):	RO	Transmit FIFO full
 *   rxff	(size 1, offset 6, init 0):	RO	Receive FIFO full
 *   txfe	(size 1, offset 7, init 0):	RO	Transmit FIFO empty
 *   ri	(size 1, offset 8, init 0):	RO	Ring indicator
 *   _anon9	(size 23, offset 9, init 0):	RSVD	_
 */
static inline pl011_uart_FR_t pl011_uart_FR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline pl011_uart_FR_t pl011_uart_FR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_FR_t pl011_uart_FR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void pl011_uart_FR_rawwr(__DN(t) *_dev, pl011_uart_FR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_FR_rawwr(__DN(t) *_dev, pl011_uart_FR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

// Register FR is not writeable
static inline int pl011_uart_FR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_FR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register FR (UARTFR flag register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts =\t%" PRIx8 "\t(Clear to send.)\n", pl011_uart_FR_cts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr =\t%" PRIx8 "\t(Data set ready.)\n", pl011_uart_FR_dsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcd =\t%" PRIx8 "\t(Data carrier detect)\n", pl011_uart_FR_dcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " busy =\t%" PRIx8 "\t(UART Busy (transmit active))\n", pl011_uart_FR_busy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfe =\t%" PRIx8 "\t(Receive FIFO empty)\n", pl011_uart_FR_rxfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txff =\t%" PRIx8 "\t(Transmit FIFO full)\n", pl011_uart_FR_txff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxff =\t%" PRIx8 "\t(Receive FIFO full)\n", pl011_uart_FR_rxff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfe =\t%" PRIx8 "\t(Transmit FIFO empty)\n", pl011_uart_FR_txfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Ring indicator)\n", pl011_uart_FR_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_FR_cts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_cts_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_cts_extract(_regval));
}

static inline uint8_t pl011_uart_FR_dsr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_dsr_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_dsr_extract(_regval));
}

static inline uint8_t pl011_uart_FR_dcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_dcd_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_dcd_extract(_regval));
}

static inline uint8_t pl011_uart_FR_busy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_busy_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_busy_extract(_regval));
}

static inline uint8_t pl011_uart_FR_rxfe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_rxfe_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_rxfe_extract(_regval));
}

static inline uint8_t pl011_uart_FR_txff_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_txff_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_txff_extract(_regval));
}

static inline uint8_t pl011_uart_FR_rxff_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_rxff_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_rxff_extract(_regval));
}

static inline uint8_t pl011_uart_FR_txfe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_txfe_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_txfe_extract(_regval));
}

static inline uint8_t pl011_uart_FR_ri_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FR_ri_rdf(__DN(t) *_dev)
{
    pl011_uart_FR_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(pl011_uart_FR_ri_extract(_regval));
}

/*
 * Register ILPR: UARTIPLR low power counter
 * Type: pl011_uart.ILPR (Implicit type of UARTIPLR low power counter register)
 *   ilpdvsr	(size 8, offset 0, init 0):	RW	Low power divisor
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl011_uart_ILPR_t pl011_uart_ILPR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_ILPR_t pl011_uart_ILPR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline pl011_uart_ILPR_t pl011_uart_ILPR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_ILPR_t pl011_uart_ILPR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void pl011_uart_ILPR_rawwr(__DN(t) *_dev, pl011_uart_ILPR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_ILPR_rawwr(__DN(t) *_dev, pl011_uart_ILPR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void pl011_uart_ILPR_wr(__DN(t) *_dev, pl011_uart_ILPR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_ILPR_wr(__DN(t) *_dev, pl011_uart_ILPR_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x20)));
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int pl011_uart_ILPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_ILPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_ILPR_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ILPR (UARTIPLR low power counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ilpdvsr =\t%" PRIx8 "\t(Low power divisor)\n", pl011_uart_ILPR_ilpdvsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_ILPR_ilpdvsr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ILPR_ilpdvsr_rdf(__DN(t) *_dev)
{
    pl011_uart_ILPR_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(pl011_uart_ILPR_ilpdvsr_extract(_regval));
}

static inline void pl011_uart_ILPR_ilpdvsr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ILPR_ilpdvsr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ILPR_t _regval = 0xff & (((pl011_uart_ILPR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register IBRD: UARTIBRD integer baud rate
 * Type: pl011_uart.IBRD (Implicit type of UARTIBRD integer baud rate register)
 *   divint	(size 16, offset 0, init 0):	RW	Integer divisor
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline pl011_uart_IBRD_t pl011_uart_IBRD_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_IBRD_t pl011_uart_IBRD_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline pl011_uart_IBRD_t pl011_uart_IBRD_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_IBRD_t pl011_uart_IBRD_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void pl011_uart_IBRD_rawwr(__DN(t) *_dev, pl011_uart_IBRD_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_IBRD_rawwr(__DN(t) *_dev, pl011_uart_IBRD_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void pl011_uart_IBRD_wr(__DN(t) *_dev, pl011_uart_IBRD_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_IBRD_wr(__DN(t) *_dev, pl011_uart_IBRD_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x24)));
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int pl011_uart_IBRD_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_IBRD_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_IBRD_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register IBRD (UARTIBRD integer baud rate): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " divint =\t%" PRIx16 "\t(Integer divisor)\n", pl011_uart_IBRD_divint_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t pl011_uart_IBRD_divint_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl011_uart_IBRD_divint_rdf(__DN(t) *_dev)
{
    pl011_uart_IBRD_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(pl011_uart_IBRD_divint_extract(_regval));
}

static inline void pl011_uart_IBRD_divint_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IBRD_divint_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    pl011_uart_IBRD_t _regval = 0xffff & (((pl011_uart_IBRD_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register FBRD: UARTFBRD fractional baud rate
 * Type: pl011_uart.FBRD (Implicit type of UARTFBRD fractional baud rate register)
 *   divfrac	(size 6, offset 0, init 0):	RW	Fractional divisor
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
static inline pl011_uart_FBRD_t pl011_uart_FBRD_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_FBRD_t pl011_uart_FBRD_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline pl011_uart_FBRD_t pl011_uart_FBRD_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_FBRD_t pl011_uart_FBRD_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void pl011_uart_FBRD_rawwr(__DN(t) *_dev, pl011_uart_FBRD_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_FBRD_rawwr(__DN(t) *_dev, pl011_uart_FBRD_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void pl011_uart_FBRD_wr(__DN(t) *_dev, pl011_uart_FBRD_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_FBRD_wr(__DN(t) *_dev, pl011_uart_FBRD_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffc0 & mackerel_read_addr_32(_dev->base, 0x28)));
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int pl011_uart_FBRD_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_FBRD_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_FBRD_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register FBRD (UARTFBRD fractional baud rate): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " divfrac =\t%" PRIx8 "\t(Fractional divisor)\n", pl011_uart_FBRD_divfrac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_FBRD_divfrac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_FBRD_divfrac_rdf(__DN(t) *_dev)
{
    pl011_uart_FBRD_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(pl011_uart_FBRD_divfrac_extract(_regval));
}

static inline void pl011_uart_FBRD_divfrac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_FBRD_divfrac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_FBRD_t _regval = 0x3f & (((pl011_uart_FBRD_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffffc0 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register LCR_H: UARTLCD_H Line control register
 * Type: pl011_uart.LCR_H (Implicit type of UARTLCD_H Line control register register)
 *   brk	(size 1, offset 0, init 0):	RW	Send break
 *   pen	(size 1, offset 1, init 0):	RW	Parity enable
 *   eps	(size 1, offset 2, init 0):	RW	Even parity select
 *   stp2	(size 1, offset 3, init 0):	RW	Two stop bits select
 *   fen	(size 1, offset 4, init 0):	RW	FIFOs enable
 *   wlen	(size 2, offset 5, init 0):	RW	Word length
 *   sps	(size 1, offset 7, init 0):	RW	Stick parity select
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_LCR_H_t pl011_uart_LCR_H_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void pl011_uart_LCR_H_rawwr(__DN(t) *_dev, pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_rawwr(__DN(t) *_dev, pl011_uart_LCR_H_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void pl011_uart_LCR_H_wr(__DN(t) *_dev, pl011_uart_LCR_H_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_wr(__DN(t) *_dev, pl011_uart_LCR_H_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x2c)));
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int pl011_uart_LCR_H_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_LCR_H_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register LCR_H (UARTLCD_H Line control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " brk =\t%" PRIx8 "\t(Send break)\n", pl011_uart_LCR_H_brk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pen =\t%" PRIx8 "\t(Parity enable)\n", pl011_uart_LCR_H_pen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eps =\t%" PRIx8 "\t(Even parity select)\n", pl011_uart_LCR_H_eps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stp2 =\t%" PRIx8 "\t(Two stop bits select)\n", pl011_uart_LCR_H_stp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fen =\t%" PRIx8 "\t(FIFOs enable)\n", pl011_uart_LCR_H_fen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wlen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_word_len_prtval(_s + _r, _avail, pl011_uart_LCR_H_wlen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Word length)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sps =\t%" PRIx8 "\t(Stick parity select)\n", pl011_uart_LCR_H_sps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_LCR_H_brk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_brk_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_brk_extract(_regval));
}

static inline uint8_t pl011_uart_LCR_H_pen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_pen_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_pen_extract(_regval));
}

static inline uint8_t pl011_uart_LCR_H_eps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_eps_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_eps_extract(_regval));
}

static inline uint8_t pl011_uart_LCR_H_stp2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_stp2_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_stp2_extract(_regval));
}

static inline uint8_t pl011_uart_LCR_H_fen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_fen_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_fen_extract(_regval));
}

static inline pl011_uart_word_len_t pl011_uart_LCR_H_wlen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_word_len_t pl011_uart_LCR_H_wlen_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_wlen_extract(_regval));
}

static inline uint8_t pl011_uart_LCR_H_sps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_LCR_H_sps_rdf(__DN(t) *_dev)
{
    pl011_uart_LCR_H_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(pl011_uart_LCR_H_sps_extract(_regval));
}

static inline void pl011_uart_LCR_H_brk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_brk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x1 & (((pl011_uart_LCR_H_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_LCR_H_pen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_pen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x2 & (((pl011_uart_LCR_H_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_LCR_H_eps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_eps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x4 & (((pl011_uart_LCR_H_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_LCR_H_stp2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_stp2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x8 & (((pl011_uart_LCR_H_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_LCR_H_fen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_fen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x10 & (((pl011_uart_LCR_H_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_LCR_H_wlen_wrf(__DN(t) *_dev, pl011_uart_word_len_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_wlen_wrf(__DN(t) *_dev, pl011_uart_word_len_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x60 & (((pl011_uart_LCR_H_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffff9f & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_LCR_H_sps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_LCR_H_sps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_LCR_H_t _regval = 0x80 & (((pl011_uart_LCR_H_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register CR: UARTCR control register
 * Type: pl011_uart.CR (Implicit type of UARTCR control register register)
 *   uarten	(size 1, offset 0, init 0):	RW	UART enable
 *   siren	(size 1, offset 1, init 0):	RW	SIR enable
 *   sirlp	(size 1, offset 2, init 0):	RW	SIR low-power IrDA mode
 *   _anon3	(size 4, offset 3, init 0):	RSVD	_
 *   lbe	(size 1, offset 7, init 0):	RW	Loopback enable
 *   txe	(size 1, offset 8, init 0):	RW	Transmit enable
 *   rxe	(size 1, offset 9, init 0):	RW	Receive enable
 *   dtr	(size 1, offset 10, init 0):	RW	Data transmit ready
 *   rts	(size 1, offset 11, init 0):	RW	Request to send
 *   out1	(size 1, offset 12, init 0):	RW	Out1 modem status output
 *   out2	(size 1, offset 13, init 0):	RW	Out2 modem status output
 *   rtsen	(size 1, offset 14, init 0):	RW	RTS hardware flow control enable
 *   ctsen	(size 1, offset 15, init 0):	RW	CTS hardware flow control enable
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline pl011_uart_CR_t pl011_uart_CR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline pl011_uart_CR_t pl011_uart_CR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_CR_t pl011_uart_CR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void pl011_uart_CR_rawwr(__DN(t) *_dev, pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_rawwr(__DN(t) *_dev, pl011_uart_CR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void pl011_uart_CR_wr(__DN(t) *_dev, pl011_uart_CR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_wr(__DN(t) *_dev, pl011_uart_CR_t _regval)
{
    _regval = (_regval & 0xff87);
    // No MB1 fields present
    _regval = (_regval | (0xffff0078 & mackerel_read_addr_32(_dev->base, 0x30)));
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int pl011_uart_CR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_CR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CR (UARTCR control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uarten =\t%" PRIx8 "\t(UART enable)\n", pl011_uart_CR_uarten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " siren =\t%" PRIx8 "\t(SIR enable)\n", pl011_uart_CR_siren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sirlp =\t%" PRIx8 "\t(SIR low-power IrDA mode)\n", pl011_uart_CR_sirlp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbe =\t%" PRIx8 "\t(Loopback enable)\n", pl011_uart_CR_lbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txe =\t%" PRIx8 "\t(Transmit enable)\n", pl011_uart_CR_txe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(Receive enable)\n", pl011_uart_CR_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtr =\t%" PRIx8 "\t(Data transmit ready)\n", pl011_uart_CR_dtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts =\t%" PRIx8 "\t(Request to send)\n", pl011_uart_CR_rts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out1 =\t%" PRIx8 "\t(Out1 modem status output)\n", pl011_uart_CR_out1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out2 =\t%" PRIx8 "\t(Out2 modem status output)\n", pl011_uart_CR_out2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtsen =\t%" PRIx8 "\t(RTS hardware flow control enable)\n", pl011_uart_CR_rtsen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsen =\t%" PRIx8 "\t(CTS hardware flow control enable)\n", pl011_uart_CR_ctsen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_CR_uarten_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_uarten_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_uarten_extract(_regval));
}

static inline uint8_t pl011_uart_CR_siren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_siren_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_siren_extract(_regval));
}

static inline uint8_t pl011_uart_CR_sirlp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_sirlp_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_sirlp_extract(_regval));
}

static inline uint8_t pl011_uart_CR_lbe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_lbe_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_lbe_extract(_regval));
}

static inline uint8_t pl011_uart_CR_txe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_txe_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_txe_extract(_regval));
}

static inline uint8_t pl011_uart_CR_rxe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_rxe_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_rxe_extract(_regval));
}

static inline uint8_t pl011_uart_CR_dtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_dtr_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_dtr_extract(_regval));
}

static inline uint8_t pl011_uart_CR_rts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_rts_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_rts_extract(_regval));
}

static inline uint8_t pl011_uart_CR_out1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_out1_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_out1_extract(_regval));
}

static inline uint8_t pl011_uart_CR_out2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_out2_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_out2_extract(_regval));
}

static inline uint8_t pl011_uart_CR_rtsen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_rtsen_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_rtsen_extract(_regval));
}

static inline uint8_t pl011_uart_CR_ctsen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_CR_ctsen_rdf(__DN(t) *_dev)
{
    pl011_uart_CR_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(pl011_uart_CR_ctsen_extract(_regval));
}

static inline void pl011_uart_CR_uarten_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_uarten_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x1 & (((pl011_uart_CR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_siren_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_siren_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x2 & (((pl011_uart_CR_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_sirlp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_sirlp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x4 & (((pl011_uart_CR_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_lbe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_lbe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x80 & (((pl011_uart_CR_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_txe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_txe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x100 & (((pl011_uart_CR_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_rxe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_rxe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x200 & (((pl011_uart_CR_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_dtr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_dtr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x400 & (((pl011_uart_CR_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_rts_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_rts_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x800 & (((pl011_uart_CR_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_out1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_out1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x1000 & (((pl011_uart_CR_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_out2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_out2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x2000 & (((pl011_uart_CR_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_rtsen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_rtsen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x4000 & (((pl011_uart_CR_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_CR_ctsen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_CR_ctsen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_CR_t _regval = 0x8000 & (((pl011_uart_CR_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register IFLS: Interrupt FIFO Level Selector
 * Type: pl011_uart.IFLS (Implicit type of Interrupt FIFO Level Selector register)
 *   txiflsel	(size 3, offset 0, init 0):	RW	Transmit interrupt FIFO level select
 *   rxiflsel	(size 3, offset 3, init 0):	RW	Receive interrupt FIFO level select
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
static inline pl011_uart_IFLS_t pl011_uart_IFLS_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_IFLS_t pl011_uart_IFLS_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline pl011_uart_IFLS_t pl011_uart_IFLS_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_IFLS_t pl011_uart_IFLS_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void pl011_uart_IFLS_rawwr(__DN(t) *_dev, pl011_uart_IFLS_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_IFLS_rawwr(__DN(t) *_dev, pl011_uart_IFLS_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void pl011_uart_IFLS_wr(__DN(t) *_dev, pl011_uart_IFLS_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_IFLS_wr(__DN(t) *_dev, pl011_uart_IFLS_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffc0 & mackerel_read_addr_32(_dev->base, 0x34)));
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int pl011_uart_IFLS_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_IFLS_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_IFLS_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register IFLS (Interrupt FIFO Level Selector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txiflsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_tx_lvl_prtval(_s + _r, _avail, pl011_uart_IFLS_txiflsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transmit interrupt FIFO level select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxiflsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_rx_lvl_prtval(_s + _r, _avail, pl011_uart_IFLS_rxiflsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive interrupt FIFO level select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline pl011_uart_tx_lvl_t pl011_uart_IFLS_txiflsel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_tx_lvl_t pl011_uart_IFLS_txiflsel_rdf(__DN(t) *_dev)
{
    pl011_uart_IFLS_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(pl011_uart_IFLS_txiflsel_extract(_regval));
}

static inline pl011_uart_rx_lvl_t pl011_uart_IFLS_rxiflsel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_rx_lvl_t pl011_uart_IFLS_rxiflsel_rdf(__DN(t) *_dev)
{
    pl011_uart_IFLS_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(pl011_uart_IFLS_rxiflsel_extract(_regval));
}

static inline void pl011_uart_IFLS_txiflsel_wrf(__DN(t) *_dev, pl011_uart_tx_lvl_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IFLS_txiflsel_wrf(__DN(t) *_dev, pl011_uart_tx_lvl_t _fieldval)
{
    pl011_uart_IFLS_t _regval = 0x7 & (((pl011_uart_IFLS_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IFLS_rxiflsel_wrf(__DN(t) *_dev, pl011_uart_rx_lvl_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IFLS_rxiflsel_wrf(__DN(t) *_dev, pl011_uart_rx_lvl_t _fieldval)
{
    pl011_uart_IFLS_t _regval = 0x38 & (((pl011_uart_IFLS_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

/*
 * Register IMSC: Interrupt mask set/clear
 * Type: pl011_uart.IMSC (Implicit type of Interrupt mask set/clear register)
 *   rimim	(size 1, offset 0, init 0):	RW	nUARTRI modem interrupt mask
 *   ctsmim	(size 1, offset 1, init 0):	RW	nUARTCTS modem interrupt mask
 *   dcdmim	(size 1, offset 2, init 0):	RW	nUARTDCD modem interrupt mask
 *   dsrmim	(size 1, offset 3, init 0):	RW	nUARTDSR modem interrupt mask
 *   rxim	(size 1, offset 4, init 0):	RW	Receive interrupt mask
 *   txim	(size 1, offset 5, init 0):	RW	Transmit interrupt mask
 *   rtim	(size 1, offset 6, init 0):	RW	Receive timeout interrupt mask
 *   feim	(size 1, offset 7, init 0):	RW	Framing error interrupt mask
 *   peim	(size 1, offset 8, init 0):	RW	Parity error interrupt mask
 *   beim	(size 1, offset 9, init 0):	RW	Break error interrupt mask
 *   oeim	(size 1, offset 10, init 0):	RW	Overrun error interrupt mask
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
static inline pl011_uart_IMSC_t pl011_uart_IMSC_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline pl011_uart_IMSC_t pl011_uart_IMSC_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_IMSC_t pl011_uart_IMSC_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void pl011_uart_IMSC_rawwr(__DN(t) *_dev, pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_rawwr(__DN(t) *_dev, pl011_uart_IMSC_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void pl011_uart_IMSC_wr(__DN(t) *_dev, pl011_uart_IMSC_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_wr(__DN(t) *_dev, pl011_uart_IMSC_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff800 & mackerel_read_addr_32(_dev->base, 0x38)));
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int pl011_uart_IMSC_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_IMSC_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register IMSC (Interrupt mask set/clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rimim =\t%" PRIx8 "\t(nUARTRI modem interrupt mask)\n", pl011_uart_IMSC_rimim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsmim =\t%" PRIx8 "\t(nUARTCTS modem interrupt mask)\n", pl011_uart_IMSC_ctsmim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdmim =\t%" PRIx8 "\t(nUARTDCD modem interrupt mask)\n", pl011_uart_IMSC_dcdmim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrmim =\t%" PRIx8 "\t(nUARTDSR modem interrupt mask)\n", pl011_uart_IMSC_dsrmim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxim =\t%" PRIx8 "\t(Receive interrupt mask)\n", pl011_uart_IMSC_rxim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txim =\t%" PRIx8 "\t(Transmit interrupt mask)\n", pl011_uart_IMSC_txim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtim =\t%" PRIx8 "\t(Receive timeout interrupt mask)\n", pl011_uart_IMSC_rtim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feim =\t%" PRIx8 "\t(Framing error interrupt mask)\n", pl011_uart_IMSC_feim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " peim =\t%" PRIx8 "\t(Parity error interrupt mask)\n", pl011_uart_IMSC_peim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beim =\t%" PRIx8 "\t(Break error interrupt mask)\n", pl011_uart_IMSC_beim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oeim =\t%" PRIx8 "\t(Overrun error interrupt mask)\n", pl011_uart_IMSC_oeim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_IMSC_rimim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_rimim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_rimim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_ctsmim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_ctsmim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_ctsmim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_dcdmim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_dcdmim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_dcdmim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_dsrmim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_dsrmim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_dsrmim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_rxim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_rxim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_rxim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_txim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_txim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_txim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_rtim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_rtim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_rtim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_feim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_feim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_feim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_peim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_peim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_peim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_beim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_beim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_beim_extract(_regval));
}

static inline uint8_t pl011_uart_IMSC_oeim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_IMSC_oeim_rdf(__DN(t) *_dev)
{
    pl011_uart_IMSC_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(pl011_uart_IMSC_oeim_extract(_regval));
}

static inline void pl011_uart_IMSC_rimim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_rimim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x1 & (((pl011_uart_IMSC_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_ctsmim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_ctsmim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x2 & (((pl011_uart_IMSC_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_dcdmim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_dcdmim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x4 & (((pl011_uart_IMSC_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_dsrmim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_dsrmim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x8 & (((pl011_uart_IMSC_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_rxim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_rxim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x10 & (((pl011_uart_IMSC_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_txim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_txim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x20 & (((pl011_uart_IMSC_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_rtim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_rtim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x40 & (((pl011_uart_IMSC_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_feim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_feim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x80 & (((pl011_uart_IMSC_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_peim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_peim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x100 & (((pl011_uart_IMSC_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_beim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_beim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x200 & (((pl011_uart_IMSC_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_IMSC_oeim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_IMSC_oeim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_IMSC_t _regval = 0x400 & (((pl011_uart_IMSC_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register RIS: Raw interrupt status
 * Type: pl011_uart.RIS (Implicit type of Raw interrupt status register)
 *   rirmis	(size 1, offset 0, init 0):	RO	nUARTRI modem interrupt status
 *   ctsrmis	(size 1, offset 1, init 0):	RO	nUARTCTS modem interrupt status
 *   dcdrmis	(size 1, offset 2, init 0):	RO	nUARTDCD modem interrupt status
 *   dsrrmis	(size 1, offset 3, init 0):	RO	nUARTDSR modem interrupt status
 *   rxris	(size 1, offset 4, init 0):	RO	Receive interrupt status
 *   txris	(size 1, offset 5, init 0):	RO	Transmit interrupt status
 *   rtris	(size 1, offset 6, init 0):	RO	Receive timeout interrupt status
 *   feris	(size 1, offset 7, init 0):	RO	Framing error interrupt status
 *   peris	(size 1, offset 8, init 0):	RO	Parity error interrupt status
 *   beris	(size 1, offset 9, init 0):	RO	Break error interrupt status
 *   oeris	(size 1, offset 10, init 0):	RO	Overrun error interrupt status
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
static inline pl011_uart_RIS_t pl011_uart_RIS_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline pl011_uart_RIS_t pl011_uart_RIS_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_RIS_t pl011_uart_RIS_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void pl011_uart_RIS_rawwr(__DN(t) *_dev, pl011_uart_RIS_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_RIS_rawwr(__DN(t) *_dev, pl011_uart_RIS_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

// Register RIS is not writeable
static inline int pl011_uart_RIS_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_RIS_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register RIS (Raw interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rirmis =\t%" PRIx8 "\t(nUARTRI modem interrupt status)\n", pl011_uart_RIS_rirmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsrmis =\t%" PRIx8 "\t(nUARTCTS modem interrupt status)\n", pl011_uart_RIS_ctsrmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdrmis =\t%" PRIx8 "\t(nUARTDCD modem interrupt status)\n", pl011_uart_RIS_dcdrmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrrmis =\t%" PRIx8 "\t(nUARTDSR modem interrupt status)\n", pl011_uart_RIS_dsrrmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxris =\t%" PRIx8 "\t(Receive interrupt status)\n", pl011_uart_RIS_rxris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txris =\t%" PRIx8 "\t(Transmit interrupt status)\n", pl011_uart_RIS_txris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtris =\t%" PRIx8 "\t(Receive timeout interrupt status)\n", pl011_uart_RIS_rtris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feris =\t%" PRIx8 "\t(Framing error interrupt status)\n", pl011_uart_RIS_feris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " peris =\t%" PRIx8 "\t(Parity error interrupt status)\n", pl011_uart_RIS_peris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beris =\t%" PRIx8 "\t(Break error interrupt status)\n", pl011_uart_RIS_beris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oeris =\t%" PRIx8 "\t(Overrun error interrupt status)\n", pl011_uart_RIS_oeris_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_RIS_rirmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_rirmis_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_rirmis_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_ctsrmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_ctsrmis_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_ctsrmis_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_dcdrmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_dcdrmis_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_dcdrmis_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_dsrrmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_dsrrmis_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_dsrrmis_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_rxris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_rxris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_rxris_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_txris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_txris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_txris_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_rtris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_rtris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_rtris_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_feris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_feris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_feris_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_peris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_peris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_peris_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_beris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_beris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_beris_extract(_regval));
}

static inline uint8_t pl011_uart_RIS_oeris_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_RIS_oeris_rdf(__DN(t) *_dev)
{
    pl011_uart_RIS_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(pl011_uart_RIS_oeris_extract(_regval));
}

/*
 * Register MIS: Masked interrupt status register
 * Type: pl011_uart.MIS (Implicit type of Masked interrupt status register register)
 *   rimmis	(size 1, offset 0, init 0):	RO	nUARTRI modem masked interrupt status
 *   ctsmmis	(size 1, offset 1, init 0):	RO	nUARTCTS modem masked interrupt status
 *   dcdmmis	(size 1, offset 2, init 0):	RO	nUARTDCD modem masked interrupt status
 *   dsrmmis	(size 1, offset 3, init 0):	RO	nUARTDSR modem masked interrupt status
 *   rxmis	(size 1, offset 4, init 0):	RO	Receive masked interrupt status
 *   txmis	(size 1, offset 5, init 0):	RO	Transmit masked interrupt status
 *   rtmis	(size 1, offset 6, init 0):	RO	Receive timeout masked interrupt status
 *   femis	(size 1, offset 7, init 0):	RO	Framing error masked interrupt status
 *   pemis	(size 1, offset 8, init 0):	RO	Parity error masked interrupt status
 *   bemis	(size 1, offset 9, init 0):	RO	Break error masked interrupt status
 *   oemis	(size 1, offset 10, init 0):	RO	Overrun error masked interrupt status
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
static inline pl011_uart_MIS_t pl011_uart_MIS_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline pl011_uart_MIS_t pl011_uart_MIS_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_MIS_t pl011_uart_MIS_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void pl011_uart_MIS_rawwr(__DN(t) *_dev, pl011_uart_MIS_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_MIS_rawwr(__DN(t) *_dev, pl011_uart_MIS_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

// Register MIS is not writeable
static inline int pl011_uart_MIS_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_MIS_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register MIS (Masked interrupt status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rimmis =\t%" PRIx8 "\t(nUARTRI modem masked interrupt status)\n", pl011_uart_MIS_rimmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsmmis =\t%" PRIx8 "\t(nUARTCTS modem masked interrupt status)\n", pl011_uart_MIS_ctsmmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdmmis =\t%" PRIx8 "\t(nUARTDCD modem masked interrupt status)\n", pl011_uart_MIS_dcdmmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrmmis =\t%" PRIx8 "\t(nUARTDSR modem masked interrupt status)\n", pl011_uart_MIS_dsrmmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxmis =\t%" PRIx8 "\t(Receive masked interrupt status)\n", pl011_uart_MIS_rxmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txmis =\t%" PRIx8 "\t(Transmit masked interrupt status)\n", pl011_uart_MIS_txmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtmis =\t%" PRIx8 "\t(Receive timeout masked interrupt status)\n", pl011_uart_MIS_rtmis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " femis =\t%" PRIx8 "\t(Framing error masked interrupt status)\n", pl011_uart_MIS_femis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pemis =\t%" PRIx8 "\t(Parity error masked interrupt status)\n", pl011_uart_MIS_pemis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bemis =\t%" PRIx8 "\t(Break error masked interrupt status)\n", pl011_uart_MIS_bemis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oemis =\t%" PRIx8 "\t(Overrun error masked interrupt status)\n", pl011_uart_MIS_oemis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_MIS_rimmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_rimmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_rimmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_ctsmmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_ctsmmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_ctsmmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_dcdmmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_dcdmmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_dcdmmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_dsrmmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_dsrmmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_dsrmmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_rxmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_rxmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_rxmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_txmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_txmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_txmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_rtmis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_rtmis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_rtmis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_femis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_femis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_femis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_pemis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_pemis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_pemis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_bemis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_bemis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_bemis_extract(_regval));
}

static inline uint8_t pl011_uart_MIS_oemis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_MIS_oemis_rdf(__DN(t) *_dev)
{
    pl011_uart_MIS_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(pl011_uart_MIS_oemis_extract(_regval));
}

/*
 * Register ICR: Interrupt clear register
 * Type: pl011_uart.ICR (Implicit type of Interrupt clear register register)
 *   rimic	(size 1, offset 0, init 0):	RWC	nUARTRI modem interrupt clear
 *   ctsmic	(size 1, offset 1, init 0):	RWC	nUARTCTS modem interrupt clear
 *   dcdmic	(size 1, offset 2, init 0):	RWC	nUARTDCD modem interrupt clear
 *   dsrmic	(size 1, offset 3, init 0):	RWC	nUARTDSR modem interrupt clear
 *   rxic	(size 1, offset 4, init 0):	RWC	Receive interrupt clear
 *   txic	(size 1, offset 5, init 0):	RWC	Transmit interrupt clear
 *   rtic	(size 1, offset 6, init 0):	RWC	Receive timeout interrupt clear
 *   feic	(size 1, offset 7, init 0):	RWC	Framing error interrupt clear
 *   peic	(size 1, offset 8, init 0):	RWC	Parity error interrupt clear
 *   beic	(size 1, offset 9, init 0):	RWC	Break error interrupt clear
 *   oeic	(size 1, offset 10, init 0):	RWC	Overrun error interrupt clear
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static inline pl011_uart_ICR_t pl011_uart_ICR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline pl011_uart_ICR_t pl011_uart_ICR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_ICR_t pl011_uart_ICR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void pl011_uart_ICR_rawwr(__DN(t) *_dev, pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_rawwr(__DN(t) *_dev, pl011_uart_ICR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void pl011_uart_ICR_wr(__DN(t) *_dev, pl011_uart_ICR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_wr(__DN(t) *_dev, pl011_uart_ICR_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int pl011_uart_ICR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_ICR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICR (Interrupt clear register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rimic =\t%" PRIx8 "\t(nUARTRI modem interrupt clear)\n", pl011_uart_ICR_rimic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctsmic =\t%" PRIx8 "\t(nUARTCTS modem interrupt clear)\n", pl011_uart_ICR_ctsmic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcdmic =\t%" PRIx8 "\t(nUARTDCD modem interrupt clear)\n", pl011_uart_ICR_dcdmic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsrmic =\t%" PRIx8 "\t(nUARTDSR modem interrupt clear)\n", pl011_uart_ICR_dsrmic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxic =\t%" PRIx8 "\t(Receive interrupt clear)\n", pl011_uart_ICR_rxic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txic =\t%" PRIx8 "\t(Transmit interrupt clear)\n", pl011_uart_ICR_txic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtic =\t%" PRIx8 "\t(Receive timeout interrupt clear)\n", pl011_uart_ICR_rtic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feic =\t%" PRIx8 "\t(Framing error interrupt clear)\n", pl011_uart_ICR_feic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " peic =\t%" PRIx8 "\t(Parity error interrupt clear)\n", pl011_uart_ICR_peic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beic =\t%" PRIx8 "\t(Break error interrupt clear)\n", pl011_uart_ICR_beic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oeic =\t%" PRIx8 "\t(Overrun error interrupt clear)\n", pl011_uart_ICR_oeic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_ICR_rimic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_rimic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_rimic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_ctsmic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_ctsmic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_ctsmic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_dcdmic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_dcdmic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_dcdmic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_dsrmic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_dsrmic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_dsrmic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_rxic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_rxic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_rxic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_txic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_txic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_txic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_rtic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_rtic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_rtic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_feic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_feic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_feic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_peic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_peic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_peic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_beic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_beic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_beic_extract(_regval));
}

static inline uint8_t pl011_uart_ICR_oeic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_ICR_oeic_rdf(__DN(t) *_dev)
{
    pl011_uart_ICR_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(pl011_uart_ICR_oeic_extract(_regval));
}

static inline void pl011_uart_ICR_rimic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_rimic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x1 & (((pl011_uart_ICR_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_ctsmic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_ctsmic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x2 & (((pl011_uart_ICR_t )(_fieldval)) << 1);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_dcdmic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_dcdmic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x4 & (((pl011_uart_ICR_t )(_fieldval)) << 2);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_dsrmic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_dsrmic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x8 & (((pl011_uart_ICR_t )(_fieldval)) << 3);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_rxic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_rxic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x10 & (((pl011_uart_ICR_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_txic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_txic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x20 & (((pl011_uart_ICR_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_rtic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_rtic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x40 & (((pl011_uart_ICR_t )(_fieldval)) << 6);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_feic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_feic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x80 & (((pl011_uart_ICR_t )(_fieldval)) << 7);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_peic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_peic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x100 & (((pl011_uart_ICR_t )(_fieldval)) << 8);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_beic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_beic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x200 & (((pl011_uart_ICR_t )(_fieldval)) << 9);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_ICR_oeic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_ICR_oeic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_ICR_t _regval = 0x400 & (((pl011_uart_ICR_t )(_fieldval)) << 10);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register DMACR: DMA control register
 * Type: pl011_uart.DMACR (Implicit type of DMA control register register)
 *   rxdmae	(size 1, offset 0, init 0):	RW	Receive DMA enable
 *   txdmae	(size 1, offset 1, init 0):	RW	Transmit DMA enable
 *   dmaonerr	(size 1, offset 2, init 0):	RW	DMA on error
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline pl011_uart_DMACR_t pl011_uart_DMACR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_DMACR_t pl011_uart_DMACR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline pl011_uart_DMACR_t pl011_uart_DMACR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl011_uart_DMACR_t pl011_uart_DMACR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void pl011_uart_DMACR_rawwr(__DN(t) *_dev, pl011_uart_DMACR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_DMACR_rawwr(__DN(t) *_dev, pl011_uart_DMACR_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void pl011_uart_DMACR_wr(__DN(t) *_dev, pl011_uart_DMACR_t _regval) __attribute__ ((always_inline));
static inline void pl011_uart_DMACR_wr(__DN(t) *_dev, pl011_uart_DMACR_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x48)));
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int pl011_uart_DMACR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_DMACR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl011_uart_DMACR_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DMACR (DMA control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmae =\t%" PRIx8 "\t(Receive DMA enable)\n", pl011_uart_DMACR_rxdmae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdmae =\t%" PRIx8 "\t(Transmit DMA enable)\n", pl011_uart_DMACR_txdmae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaonerr =\t%" PRIx8 "\t(DMA on error)\n", pl011_uart_DMACR_dmaonerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t pl011_uart_DMACR_rxdmae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DMACR_rxdmae_rdf(__DN(t) *_dev)
{
    pl011_uart_DMACR_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(pl011_uart_DMACR_rxdmae_extract(_regval));
}

static inline uint8_t pl011_uart_DMACR_txdmae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DMACR_txdmae_rdf(__DN(t) *_dev)
{
    pl011_uart_DMACR_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(pl011_uart_DMACR_txdmae_extract(_regval));
}

static inline uint8_t pl011_uart_DMACR_dmaonerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl011_uart_DMACR_dmaonerr_rdf(__DN(t) *_dev)
{
    pl011_uart_DMACR_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(pl011_uart_DMACR_dmaonerr_extract(_regval));
}

static inline void pl011_uart_DMACR_rxdmae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_DMACR_rxdmae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_DMACR_t _regval = 0x1 & (((pl011_uart_DMACR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_DMACR_txdmae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_DMACR_txdmae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_DMACR_t _regval = 0x2 & (((pl011_uart_DMACR_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void pl011_uart_DMACR_dmaonerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl011_uart_DMACR_dmaonerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl011_uart_DMACR_t _regval = 0x4 & (((pl011_uart_DMACR_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline int pl011_uart_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl011_uart_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device pl011_uart (PL011 UART):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_DR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_RSR_ECR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_FR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_ILPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_IBRD_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_FBRD_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_LCR_H_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_CR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_IFLS_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_IMSC_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_RIS_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_MIS_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_ICR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl011_uart_DMACR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device pl011_uart\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __pl011_uart_DEV_H
