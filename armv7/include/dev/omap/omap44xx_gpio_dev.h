#ifndef __omap44xx_gpio_DEV_H
#define __omap44xx_gpio_DEV_H 1
/*
 * DEVICE DEFINITION: OMAP44xx Gen. Purpose I/O
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_gpio ## _ ## x
/*
 * Constants defn: omap44xx_gpio.idle_m (Idle mode)
 *  - width 2 bits
 */
typedef uint8_t omap44xx_gpio_idle_m_t;
#define omap44xx_gpio_im_force ((omap44xx_gpio_idle_m_t)0x0)
#define omap44xx_gpio_im_none ((omap44xx_gpio_idle_m_t)0x1)
#define omap44xx_gpio_im_smart ((omap44xx_gpio_idle_m_t)0x2)
#define omap44xx_gpio_im_smartw ((omap44xx_gpio_idle_m_t)0x3)

static inline char *omap44xx_gpio_idle_m_describe(omap44xx_gpio_idle_m_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_gpio_idle_m_describe(omap44xx_gpio_idle_m_t _e)
{
    switch (_e) {
    case omap44xx_gpio_im_force:
        return("im_force: Force idle");
    case omap44xx_gpio_im_none:
        return("im_none: No idle");
    case omap44xx_gpio_im_smart:
        return("im_smart: Smart idle");
    case omap44xx_gpio_im_smartw:
        return("im_smartw: Smart idle wakeup");
    default:
        return(NULL);
    }
}

static inline int omap44xx_gpio_idle_m_prtval(char *_s, size_t _size, omap44xx_gpio_idle_m_t _e) __attribute__ ((always_inline));
static inline int omap44xx_gpio_idle_m_prtval(char *_s, size_t _size, omap44xx_gpio_idle_m_t _e)
{
    char *d = omap44xx_gpio_idle_m_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_gpio_idle_m_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_gpio_sysconfig_t
 * Description: Implicit type of System configuration register
 * Fields:
 *   autoidle	(size 1, offset 0, init 0):	RW	OCP clock gating control
 *   softreset	(size 1, offset 1, init 0):	RW	Software reset
 *   enawakeup	(size 1, offset 2, init 0):	RW	Wake-up enable
 *   idlemode	(size 2, offset 3, init 0):	RW	Idle mode
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_gpio_sysconfig_t;
#define omap44xx_gpio_sysconfig_default 0x0
static inline uint8_t omap44xx_gpio_sysconfig_autoidle_extract(omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysconfig_autoidle_extract(omap44xx_gpio_sysconfig_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_autoidle_insert(omap44xx_gpio_sysconfig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_autoidle_insert(omap44xx_gpio_sysconfig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_gpio_sysconfig_softreset_extract(omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysconfig_softreset_extract(omap44xx_gpio_sysconfig_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_softreset_insert(omap44xx_gpio_sysconfig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_softreset_insert(omap44xx_gpio_sysconfig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_gpio_sysconfig_enawakeup_extract(omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysconfig_enawakeup_extract(omap44xx_gpio_sysconfig_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_enawakeup_insert(omap44xx_gpio_sysconfig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_enawakeup_insert(omap44xx_gpio_sysconfig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 2)));
}

static inline omap44xx_gpio_idle_m_t omap44xx_gpio_sysconfig_idlemode_extract(omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_gpio_idle_m_t omap44xx_gpio_sysconfig_idlemode_extract(omap44xx_gpio_sysconfig_t _regval)
{
    return((omap44xx_gpio_idle_m_t )((_regval & 0x18) >> 3));
}

static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_idlemode_insert(omap44xx_gpio_sysconfig_t _regval, omap44xx_gpio_idle_m_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_idlemode_insert(omap44xx_gpio_sysconfig_t _regval, omap44xx_gpio_idle_m_t _fieldval)
{
    return((_regval & 0xffffffe7) | (0x18 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 3)));
}

static inline int omap44xx_gpio_sysconfig_prtval(char *_s, size_t _size, omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_gpio_sysconfig_prtval(char *_s, size_t _size, omap44xx_gpio_sysconfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoidle =\t%" PRIx8 "\t(OCP clock gating control)\n", omap44xx_gpio_sysconfig_autoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t%" PRIx8 "\t(Software reset)\n", omap44xx_gpio_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enawakeup =\t%" PRIx8 "\t(Wake-up enable)\n", omap44xx_gpio_sysconfig_enawakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_idle_m_prtval(_s + _r, _avail, omap44xx_gpio_sysconfig_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Idle mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_gpio_sysstatus_t
 * Description: Implicit type of System status register
 * Fields:
 *   resetdone	(size 1, offset 0, init 0):	RO	Reset is complete
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_gpio_sysstatus_t;
#define omap44xx_gpio_sysstatus_default 0x0
static inline uint8_t omap44xx_gpio_sysstatus_resetdone_extract(omap44xx_gpio_sysstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysstatus_resetdone_extract(omap44xx_gpio_sysstatus_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_gpio_sysstatus_t omap44xx_gpio_sysstatus_resetdone_insert(omap44xx_gpio_sysstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysstatus_t omap44xx_gpio_sysstatus_resetdone_insert(omap44xx_gpio_sysstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_gpio_sysstatus_t )(_fieldval)) << 0)));
}

static inline int omap44xx_gpio_sysstatus_prtval(char *_s, size_t _size, omap44xx_gpio_sysstatus_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_gpio_sysstatus_prtval(char *_s, size_t _size, omap44xx_gpio_sysstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t%" PRIx8 "\t(Reset is complete)\n", omap44xx_gpio_sysstatus_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_gpio_ctrl_t
 * Description: Implicit type of Control register
 * Fields:
 *   disablemodule	(size 1, offset 0, init 0):	RW	Disable module; gate clocks
 *   gatingratio	(size 2, offset 1, init 0):	RW	Clock gating ratio (1<<x)
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_gpio_ctrl_t;
#define omap44xx_gpio_ctrl_default 0x0
static inline uint8_t omap44xx_gpio_ctrl_disablemodule_extract(omap44xx_gpio_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_ctrl_disablemodule_extract(omap44xx_gpio_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_disablemodule_insert(omap44xx_gpio_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_disablemodule_insert(omap44xx_gpio_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_gpio_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_gpio_ctrl_gatingratio_extract(omap44xx_gpio_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_ctrl_gatingratio_extract(omap44xx_gpio_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_gatingratio_insert(omap44xx_gpio_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_gatingratio_insert(omap44xx_gpio_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_gpio_ctrl_t )(_fieldval)) << 1)));
}

static inline int omap44xx_gpio_ctrl_prtval(char *_s, size_t _size, omap44xx_gpio_ctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_gpio_ctrl_prtval(char *_s, size_t _size, omap44xx_gpio_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " disablemodule =\t%" PRIx8 "\t(Disable module; gate clocks)\n", omap44xx_gpio_ctrl_disablemodule_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gatingratio =\t%" PRIx8 "\t(Clock gating ratio (1<<x))\n", omap44xx_gpio_ctrl_gatingratio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_gpio_debouncingtime_t
 * Description: Implicit type of Debouncing time register
 * Fields:
 *   time	(size 8, offset 0, init 0):	RW	Debouncing time in 31us steps
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_gpio_debouncingtime_t;
#define omap44xx_gpio_debouncingtime_default 0x0
static inline uint8_t omap44xx_gpio_debouncingtime_time_extract(omap44xx_gpio_debouncingtime_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_debouncingtime_time_extract(omap44xx_gpio_debouncingtime_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_gpio_debouncingtime_t omap44xx_gpio_debouncingtime_time_insert(omap44xx_gpio_debouncingtime_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_gpio_debouncingtime_t omap44xx_gpio_debouncingtime_time_insert(omap44xx_gpio_debouncingtime_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_gpio_debouncingtime_t )(_fieldval)) << 0)));
}

static inline int omap44xx_gpio_debouncingtime_prtval(char *_s, size_t _size, omap44xx_gpio_debouncingtime_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_gpio_debouncingtime_prtval(char *_s, size_t _size, omap44xx_gpio_debouncingtime_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " time =\t%" PRIx8 "\t(Debouncing time in 31us steps)\n", omap44xx_gpio_debouncingtime_time_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_gpio_initials {
    omap44xx_gpio_revision_initial = 0x0,
    omap44xx_gpio_sysconfig_initial = 0x0,
    omap44xx_gpio_irqstatus_raw_0_initial = 0x0,
    omap44xx_gpio_irqstatus_raw_1_initial = 0x0,
    omap44xx_gpio_irqstatus_0_initial = 0x0,
    omap44xx_gpio_irqstatus_1_initial = 0x0,
    omap44xx_gpio_irqstatus_set_0_initial = 0x0,
    omap44xx_gpio_irqstatus_set_1_initial = 0x0,
    omap44xx_gpio_irqstatus_clr_0_initial = 0x0,
    omap44xx_gpio_irqstatus_clr_1_initial = 0x0,
    omap44xx_gpio_irqwaken_0_initial = 0x0,
    omap44xx_gpio_irqwaken_1_initial = 0x0,
    omap44xx_gpio_sysstatus_initial = 0x0,
    omap44xx_gpio_irqstatus1_initial = 0x0,
    omap44xx_gpio_irqenable1_initial = 0x0,
    omap44xx_gpio_wakeupenable_initial = 0x0,
    omap44xx_gpio_irqstatus2_initial = 0x0,
    omap44xx_gpio_irqenable2_initial = 0x0,
    omap44xx_gpio_ctrl_initial = 0x0,
    omap44xx_gpio_oe_initial = 0x0,
    omap44xx_gpio_datain_initial = 0x0,
    omap44xx_gpio_dataout_initial = 0x0,
    omap44xx_gpio_leveldetect0_initial = 0x0,
    omap44xx_gpio_leveldetect1_initial = 0x0,
    omap44xx_gpio_risingdetect_initial = 0x0,
    omap44xx_gpio_fallingdetect_initial = 0x0,
    omap44xx_gpio_debouncenable_initial = 0x0,
    omap44xx_gpio_debouncingtime_initial = 0x0,
    omap44xx_gpio_clearirqenable1_initial = 0x0,
    omap44xx_gpio_setirqenable1_initial = 0x0,
    omap44xx_gpio_clearirqenable2_initial = 0x0,
    omap44xx_gpio_setirqenable2_initial = 0x0,
    omap44xx_gpio_clearwkupena_initial = 0x0,
    omap44xx_gpio_setwkuena_initial = 0x0,
    omap44xx_gpio_cleardataout_initial = 0x0,
    omap44xx_gpio_setdataout_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_gpio_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_gpio_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register revision: IP revision number
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_revision_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_revision_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t omap44xx_gpio_revision_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_revision_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_gpio_revision_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_revision_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register revision is not writeable
static inline int omap44xx_gpio_revision_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_revision_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register revision (IP revision number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sysconfig: System configuration
 * Type: omap44xx_gpio.sysconfig (Implicit type of System configuration register)
 *   autoidle	(size 1, offset 0, init 0):	RW	OCP clock gating control
 *   softreset	(size 1, offset 1, init 0):	RW	Software reset
 *   enawakeup	(size 1, offset 2, init 0):	RW	Wake-up enable
 *   idlemode	(size 2, offset 3, init 0):	RW	Idle mode
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysconfig_t omap44xx_gpio_sysconfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_gpio_sysconfig_rawwr(__DN(t) *_dev, omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysconfig_rawwr(__DN(t) *_dev, omap44xx_gpio_sysconfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_gpio_sysconfig_wr(__DN(t) *_dev, omap44xx_gpio_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysconfig_wr(__DN(t) *_dev, omap44xx_gpio_sysconfig_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x10)));
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_gpio_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_gpio_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sysconfig (System configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoidle =\t%" PRIx8 "\t(OCP clock gating control)\n", omap44xx_gpio_sysconfig_autoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t%" PRIx8 "\t(Software reset)\n", omap44xx_gpio_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enawakeup =\t%" PRIx8 "\t(Wake-up enable)\n", omap44xx_gpio_sysconfig_enawakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_idle_m_prtval(_s + _r, _avail, omap44xx_gpio_sysconfig_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Idle mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_gpio_sysconfig_autoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysconfig_autoidle_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_gpio_sysconfig_autoidle_extract(_regval));
}

static inline uint8_t omap44xx_gpio_sysconfig_softreset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysconfig_softreset_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_gpio_sysconfig_softreset_extract(_regval));
}

static inline uint8_t omap44xx_gpio_sysconfig_enawakeup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysconfig_enawakeup_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_gpio_sysconfig_enawakeup_extract(_regval));
}

static inline omap44xx_gpio_idle_m_t omap44xx_gpio_sysconfig_idlemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_idle_m_t omap44xx_gpio_sysconfig_idlemode_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_gpio_sysconfig_idlemode_extract(_regval));
}

static inline void omap44xx_gpio_sysconfig_autoidle_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysconfig_autoidle_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_gpio_sysconfig_t _regval = 0x1 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_gpio_sysconfig_softreset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysconfig_softreset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_gpio_sysconfig_t _regval = 0x2 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_gpio_sysconfig_enawakeup_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysconfig_enawakeup_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_gpio_sysconfig_t _regval = 0x4 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_gpio_sysconfig_idlemode_wrf(__DN(t) *_dev, omap44xx_gpio_idle_m_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysconfig_idlemode_wrf(__DN(t) *_dev, omap44xx_gpio_idle_m_t _fieldval)
{
    omap44xx_gpio_sysconfig_t _regval = 0x18 & (((omap44xx_gpio_sysconfig_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffe7 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register irqstatus_raw_0: Per-event raw interrupt status vector (1st line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_raw_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_raw_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline uint32_t omap44xx_gpio_irqstatus_raw_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_raw_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void omap44xx_gpio_irqstatus_raw_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_raw_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void omap44xx_gpio_irqstatus_raw_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_raw_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int omap44xx_gpio_irqstatus_raw_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_raw_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_raw_0 (Per-event raw interrupt status vector (1st line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_raw_1: Per-event raw interrupt status vector (2nd line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_raw_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_raw_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline uint32_t omap44xx_gpio_irqstatus_raw_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_raw_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_gpio_irqstatus_raw_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_raw_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_gpio_irqstatus_raw_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_raw_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_gpio_irqstatus_raw_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_raw_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_raw_1 (Per-event raw interrupt status vector (2nd line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_0: Per-event interrupt status vector (1st line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline uint32_t omap44xx_gpio_irqstatus_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void omap44xx_gpio_irqstatus_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void omap44xx_gpio_irqstatus_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int omap44xx_gpio_irqstatus_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_0 (Per-event interrupt status vector (1st line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_1: Per-event interrupt status vector (2nd line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline uint32_t omap44xx_gpio_irqstatus_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_gpio_irqstatus_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_gpio_irqstatus_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_gpio_irqstatus_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_1 (Per-event interrupt status vector (2nd line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_set_0: Interrupt enable set vector (1st line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_set_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_set_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline uint32_t omap44xx_gpio_irqstatus_set_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_set_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void omap44xx_gpio_irqstatus_set_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_set_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void omap44xx_gpio_irqstatus_set_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_set_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int omap44xx_gpio_irqstatus_set_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_set_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_set_0 (Interrupt enable set vector (1st line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_set_1: Interrupt enable set vector (2nd line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_set_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_set_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline uint32_t omap44xx_gpio_irqstatus_set_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_set_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_gpio_irqstatus_set_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_set_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void omap44xx_gpio_irqstatus_set_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_set_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int omap44xx_gpio_irqstatus_set_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_set_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_set_1 (Interrupt enable set vector (2nd line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_clr_0: Interrupt enable clear vector (1st line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_clr_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_clr_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline uint32_t omap44xx_gpio_irqstatus_clr_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_clr_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void omap44xx_gpio_irqstatus_clr_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_clr_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline void omap44xx_gpio_irqstatus_clr_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_clr_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline int omap44xx_gpio_irqstatus_clr_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_clr_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_clr_0 (Interrupt enable clear vector (1st line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus_clr_1: Interrupt enable clear vector (1st line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus_clr_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_clr_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline uint32_t omap44xx_gpio_irqstatus_clr_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus_clr_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_gpio_irqstatus_clr_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_clr_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_gpio_irqstatus_clr_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus_clr_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_gpio_irqstatus_clr_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus_clr_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_clr_1 (Interrupt enable clear vector (1st line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqwaken_0: Per-event wakeup enable set vector (1st line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqwaken_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqwaken_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline uint32_t omap44xx_gpio_irqwaken_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqwaken_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void omap44xx_gpio_irqwaken_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqwaken_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void omap44xx_gpio_irqwaken_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqwaken_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int omap44xx_gpio_irqwaken_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqwaken_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqwaken_0 (Per-event wakeup enable set vector (1st line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqwaken_1: Per-event wakeup enable set vector (2nd line)
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqwaken_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqwaken_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline uint32_t omap44xx_gpio_irqwaken_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqwaken_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void omap44xx_gpio_irqwaken_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqwaken_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void omap44xx_gpio_irqwaken_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqwaken_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int omap44xx_gpio_irqwaken_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqwaken_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqwaken_1 (Per-event wakeup enable set vector (2nd line)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sysstatus: System status
 * Type: omap44xx_gpio.sysstatus (Implicit type of System status register)
 *   resetdone	(size 1, offset 0, init 0):	RO	Reset is complete
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline omap44xx_gpio_sysstatus_t omap44xx_gpio_sysstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysstatus_t omap44xx_gpio_sysstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x114));
}

static inline omap44xx_gpio_sysstatus_t omap44xx_gpio_sysstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_sysstatus_t omap44xx_gpio_sysstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x114));
}

static inline void omap44xx_gpio_sysstatus_rawwr(__DN(t) *_dev, omap44xx_gpio_sysstatus_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_sysstatus_rawwr(__DN(t) *_dev, omap44xx_gpio_sysstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x114, _regval);
}

// Register sysstatus is not writeable
static inline int omap44xx_gpio_sysstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_sysstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_gpio_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x114);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sysstatus (System status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t%" PRIx8 "\t(Reset is complete)\n", omap44xx_gpio_sysstatus_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_gpio_sysstatus_resetdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_sysstatus_resetdone_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x114);
    return(omap44xx_gpio_sysstatus_resetdone_extract(_regval));
}

/*
 * Register irqstatus1: Interrupt status (legacy) for 1st line
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x118));
}

static inline uint32_t omap44xx_gpio_irqstatus1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x118));
}

static inline void omap44xx_gpio_irqstatus1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x118, _regval);
}

static inline void omap44xx_gpio_irqstatus1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x118, _regval);
}

static inline int omap44xx_gpio_irqstatus1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x118);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus1 (Interrupt status (legacy) for 1st line): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqenable1: Interrupt enable (legacy) for 1st line
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqenable1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqenable1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11c));
}

static inline uint32_t omap44xx_gpio_irqenable1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqenable1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11c));
}

static inline void omap44xx_gpio_irqenable1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqenable1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
}

static inline void omap44xx_gpio_irqenable1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqenable1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
}

static inline int omap44xx_gpio_irqenable1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqenable1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x11c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqenable1 (Interrupt enable (legacy) for 1st line): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register wakeupenable: Wake-up enable (legacy) for 1st line
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_wakeupenable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_wakeupenable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x120));
}

static inline uint32_t omap44xx_gpio_wakeupenable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_wakeupenable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x120));
}

static inline void omap44xx_gpio_wakeupenable_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_wakeupenable_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
}

static inline void omap44xx_gpio_wakeupenable_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_wakeupenable_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
}

static inline int omap44xx_gpio_wakeupenable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_wakeupenable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x120);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wakeupenable (Wake-up enable (legacy) for 1st line): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqstatus2: Interrupt status (legacy) for 2nd line
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqstatus2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x128));
}

static inline uint32_t omap44xx_gpio_irqstatus2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqstatus2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x128));
}

static inline void omap44xx_gpio_irqstatus2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
}

static inline void omap44xx_gpio_irqstatus2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqstatus2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
}

static inline int omap44xx_gpio_irqstatus2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqstatus2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x128);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus2 (Interrupt status (legacy) for 2nd line): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register irqenable2: Interrupt enable (legacy) for 2nd line
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_irqenable2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqenable2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x12c));
}

static inline uint32_t omap44xx_gpio_irqenable2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_irqenable2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x12c));
}

static inline void omap44xx_gpio_irqenable2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqenable2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x12c, _regval);
}

static inline void omap44xx_gpio_irqenable2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_irqenable2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x12c, _regval);
}

static inline int omap44xx_gpio_irqenable2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_irqenable2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x12c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqenable2 (Interrupt enable (legacy) for 2nd line): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ctrl: Control
 * Type: omap44xx_gpio.ctrl (Implicit type of Control register)
 *   disablemodule	(size 1, offset 0, init 0):	RW	Disable module; gate clocks
 *   gatingratio	(size 2, offset 1, init 0):	RW	Clock gating ratio (1<<x)
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x130));
}

static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_ctrl_t omap44xx_gpio_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x130));
}

static inline void omap44xx_gpio_ctrl_rawwr(__DN(t) *_dev, omap44xx_gpio_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_ctrl_rawwr(__DN(t) *_dev, omap44xx_gpio_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x130, _regval);
}

static inline void omap44xx_gpio_ctrl_wr(__DN(t) *_dev, omap44xx_gpio_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_ctrl_wr(__DN(t) *_dev, omap44xx_gpio_ctrl_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x130)));
    mackerel_write_addr_32(_dev->base, 0x130, _regval);
}

static inline int omap44xx_gpio_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_gpio_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x130);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl (Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " disablemodule =\t%" PRIx8 "\t(Disable module; gate clocks)\n", omap44xx_gpio_ctrl_disablemodule_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gatingratio =\t%" PRIx8 "\t(Clock gating ratio (1<<x))\n", omap44xx_gpio_ctrl_gatingratio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_gpio_ctrl_disablemodule_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_ctrl_disablemodule_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x130);
    return(omap44xx_gpio_ctrl_disablemodule_extract(_regval));
}

static inline uint8_t omap44xx_gpio_ctrl_gatingratio_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_ctrl_gatingratio_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x130);
    return(omap44xx_gpio_ctrl_gatingratio_extract(_regval));
}

static inline void omap44xx_gpio_ctrl_disablemodule_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_ctrl_disablemodule_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_gpio_ctrl_t _regval = 0x1 & (((omap44xx_gpio_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x130)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x130, _regval);
    // No shadow register to write to
}

static inline void omap44xx_gpio_ctrl_gatingratio_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_ctrl_gatingratio_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_gpio_ctrl_t _regval = 0x6 & (((omap44xx_gpio_ctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff9 & mackerel_read_addr_32(_dev->base, 0x130)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x130, _regval);
    // No shadow register to write to
}

/*
 * Register oe: Output enable
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_oe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_oe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x134));
}

static inline uint32_t omap44xx_gpio_oe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_oe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x134));
}

static inline void omap44xx_gpio_oe_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_oe_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x134, _regval);
}

static inline void omap44xx_gpio_oe_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_oe_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x134, _regval);
}

static inline int omap44xx_gpio_oe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_oe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x134);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register oe (Output enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register datain: Data input
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_datain_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_datain_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x138));
}

static inline uint32_t omap44xx_gpio_datain_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_datain_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x138));
}

static inline void omap44xx_gpio_datain_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_datain_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
}

// Register datain is not writeable
static inline int omap44xx_gpio_datain_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_datain_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register datain (Data input): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register dataout: Data output
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_dataout_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_dataout_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x13c));
}

static inline uint32_t omap44xx_gpio_dataout_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_dataout_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x13c));
}

static inline void omap44xx_gpio_dataout_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_dataout_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x13c, _regval);
}

static inline void omap44xx_gpio_dataout_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_dataout_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x13c, _regval);
}

static inline int omap44xx_gpio_dataout_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_dataout_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x13c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dataout (Data output): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register leveldetect0: Detect low level
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_leveldetect0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_leveldetect0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline uint32_t omap44xx_gpio_leveldetect0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_leveldetect0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline void omap44xx_gpio_leveldetect0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_leveldetect0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline void omap44xx_gpio_leveldetect0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_leveldetect0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline int omap44xx_gpio_leveldetect0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_leveldetect0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register leveldetect0 (Detect low level): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register leveldetect1: Detect high level
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_leveldetect1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_leveldetect1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x144));
}

static inline uint32_t omap44xx_gpio_leveldetect1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_leveldetect1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x144));
}

static inline void omap44xx_gpio_leveldetect1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_leveldetect1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x144, _regval);
}

static inline void omap44xx_gpio_leveldetect1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_leveldetect1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x144, _regval);
}

static inline int omap44xx_gpio_leveldetect1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_leveldetect1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x144);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register leveldetect1 (Detect high level): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register risingdetect: Detect rising edge
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_risingdetect_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_risingdetect_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline uint32_t omap44xx_gpio_risingdetect_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_risingdetect_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline void omap44xx_gpio_risingdetect_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_risingdetect_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline void omap44xx_gpio_risingdetect_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_risingdetect_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline int omap44xx_gpio_risingdetect_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_risingdetect_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register risingdetect (Detect rising edge): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fallingdetect: Detect falling edge
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_fallingdetect_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_fallingdetect_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14c));
}

static inline uint32_t omap44xx_gpio_fallingdetect_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_fallingdetect_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14c));
}

static inline void omap44xx_gpio_fallingdetect_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_fallingdetect_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14c, _regval);
}

static inline void omap44xx_gpio_fallingdetect_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_fallingdetect_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14c, _regval);
}

static inline int omap44xx_gpio_fallingdetect_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_fallingdetect_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x14c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fallingdetect (Detect falling edge): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register debouncenable: Debounce enable
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_debouncenable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_debouncenable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x150));
}

static inline uint32_t omap44xx_gpio_debouncenable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_debouncenable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x150));
}

static inline void omap44xx_gpio_debouncenable_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_debouncenable_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
}

static inline void omap44xx_gpio_debouncenable_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_debouncenable_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
}

static inline int omap44xx_gpio_debouncenable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_debouncenable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x150);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register debouncenable (Debounce enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register debouncingtime: Debouncing time
 * Type: omap44xx_gpio.debouncingtime (Implicit type of Debouncing time register)
 *   time	(size 8, offset 0, init 0):	RW	Debouncing time in 31us steps
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline omap44xx_gpio_debouncingtime_t omap44xx_gpio_debouncingtime_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_debouncingtime_t omap44xx_gpio_debouncingtime_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x154));
}

static inline omap44xx_gpio_debouncingtime_t omap44xx_gpio_debouncingtime_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_gpio_debouncingtime_t omap44xx_gpio_debouncingtime_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x154));
}

static inline void omap44xx_gpio_debouncingtime_rawwr(__DN(t) *_dev, omap44xx_gpio_debouncingtime_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_debouncingtime_rawwr(__DN(t) *_dev, omap44xx_gpio_debouncingtime_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x154, _regval);
}

static inline void omap44xx_gpio_debouncingtime_wr(__DN(t) *_dev, omap44xx_gpio_debouncingtime_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_debouncingtime_wr(__DN(t) *_dev, omap44xx_gpio_debouncingtime_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x154)));
    mackerel_write_addr_32(_dev->base, 0x154, _regval);
}

static inline int omap44xx_gpio_debouncingtime_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_debouncingtime_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_gpio_debouncingtime_t _regval = mackerel_read_addr_32(_dev->base, 0x154);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register debouncingtime (Debouncing time): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " time =\t%" PRIx8 "\t(Debouncing time in 31us steps)\n", omap44xx_gpio_debouncingtime_time_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_gpio_debouncingtime_time_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_gpio_debouncingtime_time_rdf(__DN(t) *_dev)
{
    omap44xx_gpio_debouncingtime_t _regval = mackerel_read_addr_32(_dev->base, 0x154);
    return(omap44xx_gpio_debouncingtime_time_extract(_regval));
}

static inline void omap44xx_gpio_debouncingtime_time_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_debouncingtime_time_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_gpio_debouncingtime_t _regval = 0xff & (((omap44xx_gpio_debouncingtime_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x154)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x154, _regval);
    // No shadow register to write to
}

/*
 * Register clearirqenable1: Clear interrupt enable - legacy mode
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_clearirqenable1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_clearirqenable1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline uint32_t omap44xx_gpio_clearirqenable1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_clearirqenable1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline void omap44xx_gpio_clearirqenable1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_clearirqenable1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline void omap44xx_gpio_clearirqenable1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_clearirqenable1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline int omap44xx_gpio_clearirqenable1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_clearirqenable1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register clearirqenable1 (Clear interrupt enable - legacy mode): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register setirqenable1: Set interrupt enable - legacy mode
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_setirqenable1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setirqenable1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x164));
}

static inline uint32_t omap44xx_gpio_setirqenable1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setirqenable1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x164));
}

static inline void omap44xx_gpio_setirqenable1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setirqenable1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
}

static inline void omap44xx_gpio_setirqenable1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setirqenable1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
}

static inline int omap44xx_gpio_setirqenable1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_setirqenable1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register setirqenable1 (Set interrupt enable - legacy mode): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register clearirqenable2: Clear interrupt enable
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_clearirqenable2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_clearirqenable2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline uint32_t omap44xx_gpio_clearirqenable2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_clearirqenable2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline void omap44xx_gpio_clearirqenable2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_clearirqenable2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline void omap44xx_gpio_clearirqenable2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_clearirqenable2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline int omap44xx_gpio_clearirqenable2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_clearirqenable2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x170);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register clearirqenable2 (Clear interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register setirqenable2: Set interrupt enable
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_setirqenable2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setirqenable2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x174));
}

static inline uint32_t omap44xx_gpio_setirqenable2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setirqenable2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x174));
}

static inline void omap44xx_gpio_setirqenable2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setirqenable2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x174, _regval);
}

static inline void omap44xx_gpio_setirqenable2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setirqenable2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x174, _regval);
}

static inline int omap44xx_gpio_setirqenable2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_setirqenable2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x174);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register setirqenable2 (Set interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register clearwkupena: Clear Wakeup enable
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_clearwkupena_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_clearwkupena_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline uint32_t omap44xx_gpio_clearwkupena_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_clearwkupena_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline void omap44xx_gpio_clearwkupena_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_clearwkupena_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline void omap44xx_gpio_clearwkupena_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_clearwkupena_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline int omap44xx_gpio_clearwkupena_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_clearwkupena_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register clearwkupena (Clear Wakeup enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register setwkuena: Set wakeup enable
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_setwkuena_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setwkuena_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x184));
}

static inline uint32_t omap44xx_gpio_setwkuena_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setwkuena_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x184));
}

static inline void omap44xx_gpio_setwkuena_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setwkuena_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
}

static inline void omap44xx_gpio_setwkuena_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setwkuena_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
}

static inline int omap44xx_gpio_setwkuena_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_setwkuena_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register setwkuena (Set wakeup enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cleardataout: Clear data out
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_cleardataout_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_cleardataout_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x190));
}

static inline uint32_t omap44xx_gpio_cleardataout_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_cleardataout_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x190));
}

static inline void omap44xx_gpio_cleardataout_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_cleardataout_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x190, _regval);
}

static inline void omap44xx_gpio_cleardataout_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_cleardataout_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x190, _regval);
}

static inline int omap44xx_gpio_cleardataout_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_cleardataout_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x190);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cleardataout (Clear data out): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register setdataout: Set data out
 * Type: omap44xx_gpio.uint32 (primitive type)
 */
static inline uint32_t omap44xx_gpio_setdataout_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setdataout_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x194));
}

static inline uint32_t omap44xx_gpio_setdataout_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_gpio_setdataout_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x194));
}

static inline void omap44xx_gpio_setdataout_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setdataout_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x194, _regval);
}

static inline void omap44xx_gpio_setdataout_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_gpio_setdataout_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x194, _regval);
}

static inline int omap44xx_gpio_setdataout_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_setdataout_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x194);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register setdataout (Set data out): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int omap44xx_gpio_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_gpio_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_gpio (OMAP44xx Gen. Purpose I/O):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_revision_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_sysconfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_raw_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_raw_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_set_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_set_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_clr_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus_clr_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqwaken_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqwaken_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_sysstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqenable1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_wakeupenable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqstatus2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_irqenable2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_oe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_datain_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_dataout_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_leveldetect0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_leveldetect1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_risingdetect_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_fallingdetect_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_debouncenable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_debouncingtime_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_clearirqenable1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_setirqenable1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_clearirqenable2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_setirqenable2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_clearwkupena_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_setwkuena_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_cleardataout_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_gpio_setdataout_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_gpio\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_gpio_DEV_H
