#ifndef __omap44xx_scrm_DEV_H
#define __omap44xx_scrm_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_scrm ## _ ## x
/*
 * Constants defn: omap44xx_scrm.enable_ext_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_enable_ext_status_t;
#define omap44xx_scrm_ENABLE_EXT_0 ((omap44xx_scrm_enable_ext_status_t)0x0)
#define omap44xx_scrm_ENABLE_EXT_1 ((omap44xx_scrm_enable_ext_status_t)0x1)

static inline char *omap44xx_scrm_enable_ext_status_describe(omap44xx_scrm_enable_ext_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_enable_ext_status_describe(omap44xx_scrm_enable_ext_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_ENABLE_EXT_0:
        return("ENABLE_EXT_0: The alternate system clock version is disabled.");
    case omap44xx_scrm_ENABLE_EXT_1:
        return("ENABLE_EXT_1: The alternate system clock version is enabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_enable_ext_status_prtval(char *_s, size_t _size, omap44xx_scrm_enable_ext_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_enable_ext_status_prtval(char *_s, size_t _size, omap44xx_scrm_enable_ext_status_t _e)
{
    char *d = omap44xx_scrm_enable_ext_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_enable_ext_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.mode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_scrm_mode_status_t;
#define omap44xx_scrm_MODE_0 ((omap44xx_scrm_mode_status_t)0x0)
#define omap44xx_scrm_MODE_1 ((omap44xx_scrm_mode_status_t)0x1)
#define omap44xx_scrm_MODE_2 ((omap44xx_scrm_mode_status_t)0x2)
#define omap44xx_scrm_MODE_3 ((omap44xx_scrm_mode_status_t)0x3)

static inline char *omap44xx_scrm_mode_status_describe(omap44xx_scrm_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_mode_status_describe(omap44xx_scrm_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_MODE_0:
        return("MODE_0: The alternate system clock source supplier is powered-down.");
    case omap44xx_scrm_MODE_1:
        return("MODE_1: The alternate system clock source supplier is active.");
    case omap44xx_scrm_MODE_2:
        return("MODE_2: The alternate system clock source supplier is bypassed.");
    case omap44xx_scrm_MODE_3:
        return("MODE_3: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_mode_status_prtval(char *_s, size_t _size, omap44xx_scrm_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_mode_status_prtval(char *_s, size_t _size, omap44xx_scrm_mode_status_t _e)
{
    char *d = omap44xx_scrm_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.sysclk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_sysclk_status_t;
#define omap44xx_scrm_SYSCLK_0 ((omap44xx_scrm_sysclk_status_t)0x0)
#define omap44xx_scrm_SYSCLK_1 ((omap44xx_scrm_sysclk_status_t)0x1)

static inline char *omap44xx_scrm_sysclk_status_describe(omap44xx_scrm_sysclk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_sysclk_status_describe(omap44xx_scrm_sysclk_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_SYSCLK_0:
        return("SYSCLK_0: The system clock version for the external C2C interface is disabled.");
    case omap44xx_scrm_SYSCLK_1:
        return("SYSCLK_1: The system clock version for the external C2C interface is enabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_sysclk_status_prtval(char *_s, size_t _size, omap44xx_scrm_sysclk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_sysclk_status_prtval(char *_s, size_t _size, omap44xx_scrm_sysclk_status_t _e)
{
    char *d = omap44xx_scrm_sysclk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_sysclk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.mapping_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_scrm_mapping_status_t;
#define omap44xx_scrm_MAPPING_0 ((omap44xx_scrm_mapping_status_t)0x0)
#define omap44xx_scrm_MAPPING_1 ((omap44xx_scrm_mapping_status_t)0x1)
#define omap44xx_scrm_MAPPING_2 ((omap44xx_scrm_mapping_status_t)0x2)
#define omap44xx_scrm_MAPPING_3 ((omap44xx_scrm_mapping_status_t)0x3)
#define omap44xx_scrm_MAPPING_4 ((omap44xx_scrm_mapping_status_t)0x4)
#define omap44xx_scrm_MAPPING_5 ((omap44xx_scrm_mapping_status_t)0x5)
#define omap44xx_scrm_MAPPING_6 ((omap44xx_scrm_mapping_status_t)0x6)
#define omap44xx_scrm_MAPPING_7 ((omap44xx_scrm_mapping_status_t)0x7)

static inline char *omap44xx_scrm_mapping_status_describe(omap44xx_scrm_mapping_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_mapping_status_describe(omap44xx_scrm_mapping_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_MAPPING_0:
        return("MAPPING_0: The auxiliary clock request #0 is mapped on the auxiliary clock #0.");
    case omap44xx_scrm_MAPPING_1:
        return("MAPPING_1: The auxiliary clock request #0 is mapped on the auxiliary clock #1.");
    case omap44xx_scrm_MAPPING_2:
        return("MAPPING_2: The auxiliary clock request #0 is mapped on the auxiliary clock #2.");
    case omap44xx_scrm_MAPPING_3:
        return("MAPPING_3: The auxiliary clock request #0 is mapped on the auxiliary clock #3.");
    case omap44xx_scrm_MAPPING_4:
        return("MAPPING_4: The auxiliary clock request #0 is mapped on the auxiliary clock #4.");
    case omap44xx_scrm_MAPPING_5:
        return("MAPPING_5: The auxiliary clock request #0 is mapped on the auxiliary clock #5.");
    case omap44xx_scrm_MAPPING_6:
        return("MAPPING_6: Reserved");
    case omap44xx_scrm_MAPPING_7:
        return("MAPPING_7: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_mapping_status_prtval(char *_s, size_t _size, omap44xx_scrm_mapping_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_mapping_status_prtval(char *_s, size_t _size, omap44xx_scrm_mapping_status_t _e)
{
    char *d = omap44xx_scrm_mapping_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_mapping_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.clkdiv_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_scrm_clkdiv_status_t;
#define omap44xx_scrm_CLKDIV_0 ((omap44xx_scrm_clkdiv_status_t)0x0)
#define omap44xx_scrm_CLKDIV_1 ((omap44xx_scrm_clkdiv_status_t)0x1)
#define omap44xx_scrm_CLKDIV_2 ((omap44xx_scrm_clkdiv_status_t)0x2)
#define omap44xx_scrm_CLKDIV_3 ((omap44xx_scrm_clkdiv_status_t)0x3)
#define omap44xx_scrm_CLKDIV_4 ((omap44xx_scrm_clkdiv_status_t)0x4)
#define omap44xx_scrm_CLKDIV_5 ((omap44xx_scrm_clkdiv_status_t)0x5)
#define omap44xx_scrm_CLKDIV_6 ((omap44xx_scrm_clkdiv_status_t)0x6)
#define omap44xx_scrm_CLKDIV_7 ((omap44xx_scrm_clkdiv_status_t)0x7)
#define omap44xx_scrm_CLKDIV_8 ((omap44xx_scrm_clkdiv_status_t)0x8)
#define omap44xx_scrm_CLKDIV_9 ((omap44xx_scrm_clkdiv_status_t)0x9)
#define omap44xx_scrm_CLKDIV_10 ((omap44xx_scrm_clkdiv_status_t)0xa)
#define omap44xx_scrm_CLKDIV_11 ((omap44xx_scrm_clkdiv_status_t)0xb)
#define omap44xx_scrm_CLKDIV_12 ((omap44xx_scrm_clkdiv_status_t)0xc)
#define omap44xx_scrm_CLKDIV_13 ((omap44xx_scrm_clkdiv_status_t)0xd)
#define omap44xx_scrm_CLKDIV_14 ((omap44xx_scrm_clkdiv_status_t)0xe)
#define omap44xx_scrm_CLKDIV_15 ((omap44xx_scrm_clkdiv_status_t)0xf)

static inline char *omap44xx_scrm_clkdiv_status_describe(omap44xx_scrm_clkdiv_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_clkdiv_status_describe(omap44xx_scrm_clkdiv_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_CLKDIV_0:
        return("CLKDIV_0: The auxiliary clock #0 is divided by 1.");
    case omap44xx_scrm_CLKDIV_1:
        return("CLKDIV_1: The auxiliary clock #0 is divided by 2.");
    case omap44xx_scrm_CLKDIV_2:
        return("CLKDIV_2: The auxiliary clock #0 is divided by 3.");
    case omap44xx_scrm_CLKDIV_3:
        return("CLKDIV_3: The auxiliary clock #0 is divided by 4.");
    case omap44xx_scrm_CLKDIV_4:
        return("CLKDIV_4: The auxiliary clock #0 is divided by 5.");
    case omap44xx_scrm_CLKDIV_5:
        return("CLKDIV_5: The auxiliary clock #0 is divided by 6.");
    case omap44xx_scrm_CLKDIV_6:
        return("CLKDIV_6: The auxiliary clock #0 is divided by 7.");
    case omap44xx_scrm_CLKDIV_7:
        return("CLKDIV_7: The auxiliary clock #0 is divided by 8.");
    case omap44xx_scrm_CLKDIV_8:
        return("CLKDIV_8: The auxiliary clock #0 is divided by 9.");
    case omap44xx_scrm_CLKDIV_9:
        return("CLKDIV_9: The auxiliary clock #0 is divided by 10.");
    case omap44xx_scrm_CLKDIV_10:
        return("CLKDIV_10: The auxiliary clock #0 is divided by 11.");
    case omap44xx_scrm_CLKDIV_11:
        return("CLKDIV_11: The auxiliary clock #0 is divided by 12.");
    case omap44xx_scrm_CLKDIV_12:
        return("CLKDIV_12: The auxiliary clock #0 is divided by 13.");
    case omap44xx_scrm_CLKDIV_13:
        return("CLKDIV_13: The auxiliary clock #0 is divided by 14.");
    case omap44xx_scrm_CLKDIV_14:
        return("CLKDIV_14: The auxiliary clock #0 is divided by 15.");
    case omap44xx_scrm_CLKDIV_15:
        return("CLKDIV_15: The auxiliary clock #0 is divided by 16.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_clkdiv_status_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clkdiv_status_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status_t _e)
{
    char *d = omap44xx_scrm_clkdiv_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_clkdiv_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.disableclk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_disableclk_status_t;
#define omap44xx_scrm_DISABLECLK_0 ((omap44xx_scrm_disableclk_status_t)0x0)
#define omap44xx_scrm_DISABLECLK_1 ((omap44xx_scrm_disableclk_status_t)0x1)

static inline char *omap44xx_scrm_disableclk_status_describe(omap44xx_scrm_disableclk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_disableclk_status_describe(omap44xx_scrm_disableclk_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_DISABLECLK_0:
        return("DISABLECLK_0: The auxiliary clock #0 is gated upon normal condition: auxiliary clock requests mapped on this path or ENABLE bit set.");
    case omap44xx_scrm_DISABLECLK_1:
        return("DISABLECLK_1: The auxiliary clock #0 is gated wihout conditon.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_disableclk_status_prtval(char *_s, size_t _size, omap44xx_scrm_disableclk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_disableclk_status_prtval(char *_s, size_t _size, omap44xx_scrm_disableclk_status_t _e)
{
    char *d = omap44xx_scrm_disableclk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_disableclk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.srcselect_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_scrm_srcselect_status_t;
#define omap44xx_scrm_SRCSELECT_0 ((omap44xx_scrm_srcselect_status_t)0x0)
#define omap44xx_scrm_SRCSELECT_1 ((omap44xx_scrm_srcselect_status_t)0x1)
#define omap44xx_scrm_SRCSELECT_2 ((omap44xx_scrm_srcselect_status_t)0x2)
#define omap44xx_scrm_SRCSELECT_3 ((omap44xx_scrm_srcselect_status_t)0x3)

static inline char *omap44xx_scrm_srcselect_status_describe(omap44xx_scrm_srcselect_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_srcselect_status_describe(omap44xx_scrm_srcselect_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_SRCSELECT_0:
        return("SRCSELECT_0: The clock source is the system clock.");
    case omap44xx_scrm_SRCSELECT_1:
        return("SRCSELECT_1: The clock source is the version from the CORE DPLL.");
    case omap44xx_scrm_SRCSELECT_2:
        return("SRCSELECT_2: The clock source is the version from the PER DPLL.");
    case omap44xx_scrm_SRCSELECT_3:
        return("SRCSELECT_3: The clock source is the alternate clock.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_srcselect_status_prtval(char *_s, size_t _size, omap44xx_scrm_srcselect_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_srcselect_status_prtval(char *_s, size_t _size, omap44xx_scrm_srcselect_status_t _e)
{
    char *d = omap44xx_scrm_srcselect_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_srcselect_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.polarity_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_polarity_status_t;
#define omap44xx_scrm_POLARITY_0_10 ((omap44xx_scrm_polarity_status_t)0x0)
#define omap44xx_scrm_POLARITY_1_10 ((omap44xx_scrm_polarity_status_t)0x1)

static inline char *omap44xx_scrm_polarity_status_describe(omap44xx_scrm_polarity_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_polarity_status_describe(omap44xx_scrm_polarity_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_POLARITY_0_10:
        return("POLARITY_0_10: The auxiliary clock #0 is gated low.");
    case omap44xx_scrm_POLARITY_1_10:
        return("POLARITY_1_10: The auxiliary clock #0 is gated high.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_polarity_status_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_polarity_status_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status_t _e)
{
    char *d = omap44xx_scrm_polarity_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_polarity_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.clkdiv_status1 ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_scrm_clkdiv_status1_t;
#define omap44xx_scrm_CLKDIV_0_1 ((omap44xx_scrm_clkdiv_status1_t)0x0)
#define omap44xx_scrm_CLKDIV_1_1 ((omap44xx_scrm_clkdiv_status1_t)0x1)
#define omap44xx_scrm_CLKDIV_2_1 ((omap44xx_scrm_clkdiv_status1_t)0x2)
#define omap44xx_scrm_CLKDIV_3_1 ((omap44xx_scrm_clkdiv_status1_t)0x3)
#define omap44xx_scrm_CLKDIV_4_1 ((omap44xx_scrm_clkdiv_status1_t)0x4)
#define omap44xx_scrm_CLKDIV_5_1 ((omap44xx_scrm_clkdiv_status1_t)0x5)
#define omap44xx_scrm_CLKDIV_6_1 ((omap44xx_scrm_clkdiv_status1_t)0x6)
#define omap44xx_scrm_CLKDIV_7_1 ((omap44xx_scrm_clkdiv_status1_t)0x7)
#define omap44xx_scrm_CLKDIV_8_1 ((omap44xx_scrm_clkdiv_status1_t)0x8)
#define omap44xx_scrm_CLKDIV_9_1 ((omap44xx_scrm_clkdiv_status1_t)0x9)
#define omap44xx_scrm_CLKDIV_10_1 ((omap44xx_scrm_clkdiv_status1_t)0xa)
#define omap44xx_scrm_CLKDIV_11_1 ((omap44xx_scrm_clkdiv_status1_t)0xb)
#define omap44xx_scrm_CLKDIV_12_1 ((omap44xx_scrm_clkdiv_status1_t)0xc)
#define omap44xx_scrm_CLKDIV_13_1 ((omap44xx_scrm_clkdiv_status1_t)0xd)
#define omap44xx_scrm_CLKDIV_14_1 ((omap44xx_scrm_clkdiv_status1_t)0xe)
#define omap44xx_scrm_CLKDIV_15_1 ((omap44xx_scrm_clkdiv_status1_t)0xf)

static inline char *omap44xx_scrm_clkdiv_status1_describe(omap44xx_scrm_clkdiv_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_clkdiv_status1_describe(omap44xx_scrm_clkdiv_status1_t _e)
{
    switch (_e) {
    case omap44xx_scrm_CLKDIV_0_1:
        return("CLKDIV_0_1: The auxiliary clock #1 is divided by 1.");
    case omap44xx_scrm_CLKDIV_1_1:
        return("CLKDIV_1_1: The auxiliary clock #1 is divided by 2.");
    case omap44xx_scrm_CLKDIV_2_1:
        return("CLKDIV_2_1: The auxiliary clock #1 is divided by 3.");
    case omap44xx_scrm_CLKDIV_3_1:
        return("CLKDIV_3_1: The auxiliary clock #1 is divided by 4.");
    case omap44xx_scrm_CLKDIV_4_1:
        return("CLKDIV_4_1: The auxiliary clock #1 is divided by 5.");
    case omap44xx_scrm_CLKDIV_5_1:
        return("CLKDIV_5_1: The auxiliary clock #1 is divided by 6.");
    case omap44xx_scrm_CLKDIV_6_1:
        return("CLKDIV_6_1: The auxiliary clock #1 is divided by 7.");
    case omap44xx_scrm_CLKDIV_7_1:
        return("CLKDIV_7_1: The auxiliary clock #1 is divided by 8.");
    case omap44xx_scrm_CLKDIV_8_1:
        return("CLKDIV_8_1: The auxiliary clock #1 is divided by 9.");
    case omap44xx_scrm_CLKDIV_9_1:
        return("CLKDIV_9_1: The auxiliary clock #1 is divided by 10.");
    case omap44xx_scrm_CLKDIV_10_1:
        return("CLKDIV_10_1: The auxiliary clock #1 is divided by 11.");
    case omap44xx_scrm_CLKDIV_11_1:
        return("CLKDIV_11_1: The auxiliary clock #1 is divided by 12.");
    case omap44xx_scrm_CLKDIV_12_1:
        return("CLKDIV_12_1: The auxiliary clock #1 is divided by 13.");
    case omap44xx_scrm_CLKDIV_13_1:
        return("CLKDIV_13_1: The auxiliary clock #1 is divided by 14.");
    case omap44xx_scrm_CLKDIV_14_1:
        return("CLKDIV_14_1: The auxiliary clock #1 is divided by 15.");
    case omap44xx_scrm_CLKDIV_15_1:
        return("CLKDIV_15_1: The auxiliary clock #1 is divided by 16.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_clkdiv_status1_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clkdiv_status1_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status1_t _e)
{
    char *d = omap44xx_scrm_clkdiv_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_clkdiv_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.polarity_status1 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_polarity_status1_t;
#define omap44xx_scrm_POLARITY_0_11 ((omap44xx_scrm_polarity_status1_t)0x0)
#define omap44xx_scrm_POLARITY_1_11 ((omap44xx_scrm_polarity_status1_t)0x1)

static inline char *omap44xx_scrm_polarity_status1_describe(omap44xx_scrm_polarity_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_polarity_status1_describe(omap44xx_scrm_polarity_status1_t _e)
{
    switch (_e) {
    case omap44xx_scrm_POLARITY_0_11:
        return("POLARITY_0_11: The auxiliary clock #1 is gated low.");
    case omap44xx_scrm_POLARITY_1_11:
        return("POLARITY_1_11: The auxiliary clock #1 is gated high.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_polarity_status1_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_polarity_status1_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status1_t _e)
{
    char *d = omap44xx_scrm_polarity_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_polarity_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.clkdiv_status2 ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_scrm_clkdiv_status2_t;
#define omap44xx_scrm_CLKDIV_0_2 ((omap44xx_scrm_clkdiv_status2_t)0x0)
#define omap44xx_scrm_CLKDIV_1_2 ((omap44xx_scrm_clkdiv_status2_t)0x1)
#define omap44xx_scrm_CLKDIV_2_2 ((omap44xx_scrm_clkdiv_status2_t)0x2)
#define omap44xx_scrm_CLKDIV_3_2 ((omap44xx_scrm_clkdiv_status2_t)0x3)
#define omap44xx_scrm_CLKDIV_4_2 ((omap44xx_scrm_clkdiv_status2_t)0x4)
#define omap44xx_scrm_CLKDIV_5_2 ((omap44xx_scrm_clkdiv_status2_t)0x5)
#define omap44xx_scrm_CLKDIV_6_2 ((omap44xx_scrm_clkdiv_status2_t)0x6)
#define omap44xx_scrm_CLKDIV_7_2 ((omap44xx_scrm_clkdiv_status2_t)0x7)
#define omap44xx_scrm_CLKDIV_8_2 ((omap44xx_scrm_clkdiv_status2_t)0x8)
#define omap44xx_scrm_CLKDIV_9_2 ((omap44xx_scrm_clkdiv_status2_t)0x9)
#define omap44xx_scrm_CLKDIV_10_2 ((omap44xx_scrm_clkdiv_status2_t)0xa)
#define omap44xx_scrm_CLKDIV_11_2 ((omap44xx_scrm_clkdiv_status2_t)0xb)
#define omap44xx_scrm_CLKDIV_12_2 ((omap44xx_scrm_clkdiv_status2_t)0xc)
#define omap44xx_scrm_CLKDIV_13_2 ((omap44xx_scrm_clkdiv_status2_t)0xd)
#define omap44xx_scrm_CLKDIV_14_2 ((omap44xx_scrm_clkdiv_status2_t)0xe)
#define omap44xx_scrm_CLKDIV_15_2 ((omap44xx_scrm_clkdiv_status2_t)0xf)

static inline char *omap44xx_scrm_clkdiv_status2_describe(omap44xx_scrm_clkdiv_status2_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_clkdiv_status2_describe(omap44xx_scrm_clkdiv_status2_t _e)
{
    switch (_e) {
    case omap44xx_scrm_CLKDIV_0_2:
        return("CLKDIV_0_2: The auxiliary clock #2 is divided by 1.");
    case omap44xx_scrm_CLKDIV_1_2:
        return("CLKDIV_1_2: The auxiliary clock #2 is divided by 2.");
    case omap44xx_scrm_CLKDIV_2_2:
        return("CLKDIV_2_2: The auxiliary clock #2 is divided by 3.");
    case omap44xx_scrm_CLKDIV_3_2:
        return("CLKDIV_3_2: The auxiliary clock #2 is divided by 4.");
    case omap44xx_scrm_CLKDIV_4_2:
        return("CLKDIV_4_2: The auxiliary clock #2 is divided by 5.");
    case omap44xx_scrm_CLKDIV_5_2:
        return("CLKDIV_5_2: The auxiliary clock #2 is divided by 6.");
    case omap44xx_scrm_CLKDIV_6_2:
        return("CLKDIV_6_2: The auxiliary clock #2 is divided by 7.");
    case omap44xx_scrm_CLKDIV_7_2:
        return("CLKDIV_7_2: The auxiliary clock #2 is divided by 8.");
    case omap44xx_scrm_CLKDIV_8_2:
        return("CLKDIV_8_2: The auxiliary clock #2 is divided by 9.");
    case omap44xx_scrm_CLKDIV_9_2:
        return("CLKDIV_9_2: The auxiliary clock #2 is divided by 10.");
    case omap44xx_scrm_CLKDIV_10_2:
        return("CLKDIV_10_2: The auxiliary clock #2 is divided by 11.");
    case omap44xx_scrm_CLKDIV_11_2:
        return("CLKDIV_11_2: The auxiliary clock #2 is divided by 12.");
    case omap44xx_scrm_CLKDIV_12_2:
        return("CLKDIV_12_2: The auxiliary clock #2 is divided by 13.");
    case omap44xx_scrm_CLKDIV_13_2:
        return("CLKDIV_13_2: The auxiliary clock #2 is divided by 14.");
    case omap44xx_scrm_CLKDIV_14_2:
        return("CLKDIV_14_2: The auxiliary clock #2 is divided by 15.");
    case omap44xx_scrm_CLKDIV_15_2:
        return("CLKDIV_15_2: The auxiliary clock #2 is divided by 16.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_clkdiv_status2_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status2_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clkdiv_status2_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status2_t _e)
{
    char *d = omap44xx_scrm_clkdiv_status2_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_clkdiv_status2_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.polarity_status2 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_polarity_status2_t;
#define omap44xx_scrm_POLARITY_0_12 ((omap44xx_scrm_polarity_status2_t)0x0)
#define omap44xx_scrm_POLARITY_1_12 ((omap44xx_scrm_polarity_status2_t)0x1)

static inline char *omap44xx_scrm_polarity_status2_describe(omap44xx_scrm_polarity_status2_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_polarity_status2_describe(omap44xx_scrm_polarity_status2_t _e)
{
    switch (_e) {
    case omap44xx_scrm_POLARITY_0_12:
        return("POLARITY_0_12: The auxiliary clock #2 is gated low.");
    case omap44xx_scrm_POLARITY_1_12:
        return("POLARITY_1_12: The auxiliary clock #2 is gated high.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_polarity_status2_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status2_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_polarity_status2_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status2_t _e)
{
    char *d = omap44xx_scrm_polarity_status2_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_polarity_status2_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.clkdiv_status3 ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_scrm_clkdiv_status3_t;
#define omap44xx_scrm_CLKDIV_0_3 ((omap44xx_scrm_clkdiv_status3_t)0x0)
#define omap44xx_scrm_CLKDIV_1_3 ((omap44xx_scrm_clkdiv_status3_t)0x1)
#define omap44xx_scrm_CLKDIV_2_3 ((omap44xx_scrm_clkdiv_status3_t)0x2)
#define omap44xx_scrm_CLKDIV_3_3 ((omap44xx_scrm_clkdiv_status3_t)0x3)
#define omap44xx_scrm_CLKDIV_4_3 ((omap44xx_scrm_clkdiv_status3_t)0x4)
#define omap44xx_scrm_CLKDIV_5_3 ((omap44xx_scrm_clkdiv_status3_t)0x5)
#define omap44xx_scrm_CLKDIV_6_3 ((omap44xx_scrm_clkdiv_status3_t)0x6)
#define omap44xx_scrm_CLKDIV_7_3 ((omap44xx_scrm_clkdiv_status3_t)0x7)
#define omap44xx_scrm_CLKDIV_8_3 ((omap44xx_scrm_clkdiv_status3_t)0x8)
#define omap44xx_scrm_CLKDIV_9_3 ((omap44xx_scrm_clkdiv_status3_t)0x9)
#define omap44xx_scrm_CLKDIV_10_3 ((omap44xx_scrm_clkdiv_status3_t)0xa)
#define omap44xx_scrm_CLKDIV_11_3 ((omap44xx_scrm_clkdiv_status3_t)0xb)
#define omap44xx_scrm_CLKDIV_12_3 ((omap44xx_scrm_clkdiv_status3_t)0xc)
#define omap44xx_scrm_CLKDIV_13_3 ((omap44xx_scrm_clkdiv_status3_t)0xd)
#define omap44xx_scrm_CLKDIV_14_3 ((omap44xx_scrm_clkdiv_status3_t)0xe)
#define omap44xx_scrm_CLKDIV_15_3 ((omap44xx_scrm_clkdiv_status3_t)0xf)

static inline char *omap44xx_scrm_clkdiv_status3_describe(omap44xx_scrm_clkdiv_status3_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_clkdiv_status3_describe(omap44xx_scrm_clkdiv_status3_t _e)
{
    switch (_e) {
    case omap44xx_scrm_CLKDIV_0_3:
        return("CLKDIV_0_3: The auxiliary clock #3 is divided by 1.");
    case omap44xx_scrm_CLKDIV_1_3:
        return("CLKDIV_1_3: The auxiliary clock #3 is divided by 2.");
    case omap44xx_scrm_CLKDIV_2_3:
        return("CLKDIV_2_3: The auxiliary clock #3 is divided by 3.");
    case omap44xx_scrm_CLKDIV_3_3:
        return("CLKDIV_3_3: The auxiliary clock #3 is divided by 4.");
    case omap44xx_scrm_CLKDIV_4_3:
        return("CLKDIV_4_3: The auxiliary clock #3 is divided by 5.");
    case omap44xx_scrm_CLKDIV_5_3:
        return("CLKDIV_5_3: The auxiliary clock #3 is divided by 6.");
    case omap44xx_scrm_CLKDIV_6_3:
        return("CLKDIV_6_3: The auxiliary clock #3 is divided by 7.");
    case omap44xx_scrm_CLKDIV_7_3:
        return("CLKDIV_7_3: The auxiliary clock #3 is divided by 8.");
    case omap44xx_scrm_CLKDIV_8_3:
        return("CLKDIV_8_3: The auxiliary clock #3 is divided by 9.");
    case omap44xx_scrm_CLKDIV_9_3:
        return("CLKDIV_9_3: The auxiliary clock #3 is divided by 10.");
    case omap44xx_scrm_CLKDIV_10_3:
        return("CLKDIV_10_3: The auxiliary clock #3 is divided by 11.");
    case omap44xx_scrm_CLKDIV_11_3:
        return("CLKDIV_11_3: The auxiliary clock #3 is divided by 12.");
    case omap44xx_scrm_CLKDIV_12_3:
        return("CLKDIV_12_3: The auxiliary clock #3 is divided by 13.");
    case omap44xx_scrm_CLKDIV_13_3:
        return("CLKDIV_13_3: The auxiliary clock #3 is divided by 14.");
    case omap44xx_scrm_CLKDIV_14_3:
        return("CLKDIV_14_3: The auxiliary clock #3 is divided by 15.");
    case omap44xx_scrm_CLKDIV_15_3:
        return("CLKDIV_15_3: The auxiliary clock #3 is divided by 16.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_clkdiv_status3_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status3_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clkdiv_status3_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status3_t _e)
{
    char *d = omap44xx_scrm_clkdiv_status3_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_clkdiv_status3_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.polarity_status3 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_polarity_status3_t;
#define omap44xx_scrm_POLARITY_0_13 ((omap44xx_scrm_polarity_status3_t)0x0)
#define omap44xx_scrm_POLARITY_1_13 ((omap44xx_scrm_polarity_status3_t)0x1)

static inline char *omap44xx_scrm_polarity_status3_describe(omap44xx_scrm_polarity_status3_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_polarity_status3_describe(omap44xx_scrm_polarity_status3_t _e)
{
    switch (_e) {
    case omap44xx_scrm_POLARITY_0_13:
        return("POLARITY_0_13: The auxiliary clock #3 is gated low.");
    case omap44xx_scrm_POLARITY_1_13:
        return("POLARITY_1_13: The auxiliary clock #3 is gated high.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_polarity_status3_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status3_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_polarity_status3_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status3_t _e)
{
    char *d = omap44xx_scrm_polarity_status3_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_polarity_status3_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.clkdiv_status4 ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_scrm_clkdiv_status4_t;
#define omap44xx_scrm_CLKDIV_0_4 ((omap44xx_scrm_clkdiv_status4_t)0x0)
#define omap44xx_scrm_CLKDIV_1_4 ((omap44xx_scrm_clkdiv_status4_t)0x1)
#define omap44xx_scrm_CLKDIV_2_4 ((omap44xx_scrm_clkdiv_status4_t)0x2)
#define omap44xx_scrm_CLKDIV_3_4 ((omap44xx_scrm_clkdiv_status4_t)0x3)
#define omap44xx_scrm_CLKDIV_4_4 ((omap44xx_scrm_clkdiv_status4_t)0x4)
#define omap44xx_scrm_CLKDIV_5_4 ((omap44xx_scrm_clkdiv_status4_t)0x5)
#define omap44xx_scrm_CLKDIV_6_4 ((omap44xx_scrm_clkdiv_status4_t)0x6)
#define omap44xx_scrm_CLKDIV_7_4 ((omap44xx_scrm_clkdiv_status4_t)0x7)
#define omap44xx_scrm_CLKDIV_8_4 ((omap44xx_scrm_clkdiv_status4_t)0x8)
#define omap44xx_scrm_CLKDIV_9_4 ((omap44xx_scrm_clkdiv_status4_t)0x9)
#define omap44xx_scrm_CLKDIV_10_4 ((omap44xx_scrm_clkdiv_status4_t)0xa)
#define omap44xx_scrm_CLKDIV_11_4 ((omap44xx_scrm_clkdiv_status4_t)0xb)
#define omap44xx_scrm_CLKDIV_12_4 ((omap44xx_scrm_clkdiv_status4_t)0xc)
#define omap44xx_scrm_CLKDIV_13_4 ((omap44xx_scrm_clkdiv_status4_t)0xd)
#define omap44xx_scrm_CLKDIV_14_4 ((omap44xx_scrm_clkdiv_status4_t)0xe)
#define omap44xx_scrm_CLKDIV_15_4 ((omap44xx_scrm_clkdiv_status4_t)0xf)

static inline char *omap44xx_scrm_clkdiv_status4_describe(omap44xx_scrm_clkdiv_status4_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_clkdiv_status4_describe(omap44xx_scrm_clkdiv_status4_t _e)
{
    switch (_e) {
    case omap44xx_scrm_CLKDIV_0_4:
        return("CLKDIV_0_4: The auxiliary clock #4 is divided by 1.");
    case omap44xx_scrm_CLKDIV_1_4:
        return("CLKDIV_1_4: The auxiliary clock #4 is divided by 2.");
    case omap44xx_scrm_CLKDIV_2_4:
        return("CLKDIV_2_4: The auxiliary clock #4 is divided by 3.");
    case omap44xx_scrm_CLKDIV_3_4:
        return("CLKDIV_3_4: The auxiliary clock #4 is divided by 4.");
    case omap44xx_scrm_CLKDIV_4_4:
        return("CLKDIV_4_4: The auxiliary clock #4 is divided by 5.");
    case omap44xx_scrm_CLKDIV_5_4:
        return("CLKDIV_5_4: The auxiliary clock #4 is divided by 6.");
    case omap44xx_scrm_CLKDIV_6_4:
        return("CLKDIV_6_4: The auxiliary clock #4 is divided by 7.");
    case omap44xx_scrm_CLKDIV_7_4:
        return("CLKDIV_7_4: The auxiliary clock #4 is divided by 8.");
    case omap44xx_scrm_CLKDIV_8_4:
        return("CLKDIV_8_4: The auxiliary clock #4 is divided by 9.");
    case omap44xx_scrm_CLKDIV_9_4:
        return("CLKDIV_9_4: The auxiliary clock #4 is divided by 10.");
    case omap44xx_scrm_CLKDIV_10_4:
        return("CLKDIV_10_4: The auxiliary clock #4 is divided by 11.");
    case omap44xx_scrm_CLKDIV_11_4:
        return("CLKDIV_11_4: The auxiliary clock #4 is divided by 12.");
    case omap44xx_scrm_CLKDIV_12_4:
        return("CLKDIV_12_4: The auxiliary clock #4 is divided by 13.");
    case omap44xx_scrm_CLKDIV_13_4:
        return("CLKDIV_13_4: The auxiliary clock #4 is divided by 14.");
    case omap44xx_scrm_CLKDIV_14_4:
        return("CLKDIV_14_4: The auxiliary clock #4 is divided by 15.");
    case omap44xx_scrm_CLKDIV_15_4:
        return("CLKDIV_15_4: The auxiliary clock #4 is divided by 16.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_clkdiv_status4_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status4_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clkdiv_status4_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status4_t _e)
{
    char *d = omap44xx_scrm_clkdiv_status4_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_clkdiv_status4_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.polarity_status4 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_polarity_status4_t;
#define omap44xx_scrm_POLARITY_0_14 ((omap44xx_scrm_polarity_status4_t)0x0)
#define omap44xx_scrm_POLARITY_1_14 ((omap44xx_scrm_polarity_status4_t)0x1)

static inline char *omap44xx_scrm_polarity_status4_describe(omap44xx_scrm_polarity_status4_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_polarity_status4_describe(omap44xx_scrm_polarity_status4_t _e)
{
    switch (_e) {
    case omap44xx_scrm_POLARITY_0_14:
        return("POLARITY_0_14: The auxiliary clock #4 is gated low.");
    case omap44xx_scrm_POLARITY_1_14:
        return("POLARITY_1_14: The auxiliary clock #4 is gated high.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_polarity_status4_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status4_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_polarity_status4_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status4_t _e)
{
    char *d = omap44xx_scrm_polarity_status4_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_polarity_status4_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.clkdiv_status5 ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_scrm_clkdiv_status5_t;
#define omap44xx_scrm_CLKDIV_0_5 ((omap44xx_scrm_clkdiv_status5_t)0x0)
#define omap44xx_scrm_CLKDIV_1_5 ((omap44xx_scrm_clkdiv_status5_t)0x1)
#define omap44xx_scrm_CLKDIV_2_5 ((omap44xx_scrm_clkdiv_status5_t)0x2)
#define omap44xx_scrm_CLKDIV_3_5 ((omap44xx_scrm_clkdiv_status5_t)0x3)
#define omap44xx_scrm_CLKDIV_4_5 ((omap44xx_scrm_clkdiv_status5_t)0x4)
#define omap44xx_scrm_CLKDIV_5_5 ((omap44xx_scrm_clkdiv_status5_t)0x5)
#define omap44xx_scrm_CLKDIV_6_5 ((omap44xx_scrm_clkdiv_status5_t)0x6)
#define omap44xx_scrm_CLKDIV_7_5 ((omap44xx_scrm_clkdiv_status5_t)0x7)
#define omap44xx_scrm_CLKDIV_8_5 ((omap44xx_scrm_clkdiv_status5_t)0x8)
#define omap44xx_scrm_CLKDIV_9_5 ((omap44xx_scrm_clkdiv_status5_t)0x9)
#define omap44xx_scrm_CLKDIV_10_5 ((omap44xx_scrm_clkdiv_status5_t)0xa)
#define omap44xx_scrm_CLKDIV_11_5 ((omap44xx_scrm_clkdiv_status5_t)0xb)
#define omap44xx_scrm_CLKDIV_12_5 ((omap44xx_scrm_clkdiv_status5_t)0xc)
#define omap44xx_scrm_CLKDIV_13_5 ((omap44xx_scrm_clkdiv_status5_t)0xd)
#define omap44xx_scrm_CLKDIV_14_5 ((omap44xx_scrm_clkdiv_status5_t)0xe)
#define omap44xx_scrm_CLKDIV_15_5 ((omap44xx_scrm_clkdiv_status5_t)0xf)

static inline char *omap44xx_scrm_clkdiv_status5_describe(omap44xx_scrm_clkdiv_status5_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_clkdiv_status5_describe(omap44xx_scrm_clkdiv_status5_t _e)
{
    switch (_e) {
    case omap44xx_scrm_CLKDIV_0_5:
        return("CLKDIV_0_5: The auxiliary clock #5 is divided by 1.");
    case omap44xx_scrm_CLKDIV_1_5:
        return("CLKDIV_1_5: The auxiliary clock #5 is divided by 2.");
    case omap44xx_scrm_CLKDIV_2_5:
        return("CLKDIV_2_5: The auxiliary clock #5 is divided by 3.");
    case omap44xx_scrm_CLKDIV_3_5:
        return("CLKDIV_3_5: The auxiliary clock #5 is divided by 4.");
    case omap44xx_scrm_CLKDIV_4_5:
        return("CLKDIV_4_5: The auxiliary clock #5 is divided by 5.");
    case omap44xx_scrm_CLKDIV_5_5:
        return("CLKDIV_5_5: The auxiliary clock #5 is divided by 6.");
    case omap44xx_scrm_CLKDIV_6_5:
        return("CLKDIV_6_5: The auxiliary clock #5 is divided by 7.");
    case omap44xx_scrm_CLKDIV_7_5:
        return("CLKDIV_7_5: The auxiliary clock #5 is divided by 8.");
    case omap44xx_scrm_CLKDIV_8_5:
        return("CLKDIV_8_5: The auxiliary clock #5 is divided by 9.");
    case omap44xx_scrm_CLKDIV_9_5:
        return("CLKDIV_9_5: The auxiliary clock #5 is divided by 10.");
    case omap44xx_scrm_CLKDIV_10_5:
        return("CLKDIV_10_5: The auxiliary clock #5 is divided by 11.");
    case omap44xx_scrm_CLKDIV_11_5:
        return("CLKDIV_11_5: The auxiliary clock #5 is divided by 12.");
    case omap44xx_scrm_CLKDIV_12_5:
        return("CLKDIV_12_5: The auxiliary clock #5 is divided by 13.");
    case omap44xx_scrm_CLKDIV_13_5:
        return("CLKDIV_13_5: The auxiliary clock #5 is divided by 14.");
    case omap44xx_scrm_CLKDIV_14_5:
        return("CLKDIV_14_5: The auxiliary clock #5 is divided by 15.");
    case omap44xx_scrm_CLKDIV_15_5:
        return("CLKDIV_15_5: The auxiliary clock #5 is divided by 16.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_clkdiv_status5_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status5_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clkdiv_status5_prtval(char *_s, size_t _size, omap44xx_scrm_clkdiv_status5_t _e)
{
    char *d = omap44xx_scrm_clkdiv_status5_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_clkdiv_status5_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.polarity_status5 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_polarity_status5_t;
#define omap44xx_scrm_POLARITY_0_15 ((omap44xx_scrm_polarity_status5_t)0x0)
#define omap44xx_scrm_POLARITY_1_15 ((omap44xx_scrm_polarity_status5_t)0x1)

static inline char *omap44xx_scrm_polarity_status5_describe(omap44xx_scrm_polarity_status5_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_polarity_status5_describe(omap44xx_scrm_polarity_status5_t _e)
{
    switch (_e) {
    case omap44xx_scrm_POLARITY_0_15:
        return("POLARITY_0_15: The auxiliary clock #5 is gated low.");
    case omap44xx_scrm_POLARITY_1_15:
        return("POLARITY_1_15: The auxiliary clock #5 is gated high.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_polarity_status5_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status5_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_polarity_status5_prtval(char *_s, size_t _size, omap44xx_scrm_polarity_status5_t _e)
{
    char *d = omap44xx_scrm_polarity_status5_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_polarity_status5_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.pwronrst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_pwronrst_status_t;
#define omap44xx_scrm_PWRONRST_0 ((omap44xx_scrm_pwronrst_status_t)0x0)
#define omap44xx_scrm_PWRONRST_1 ((omap44xx_scrm_pwronrst_status_t)0x1)

static inline char *omap44xx_scrm_pwronrst_status_describe(omap44xx_scrm_pwronrst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_pwronrst_status_describe(omap44xx_scrm_pwronrst_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_PWRONRST_0:
        return("PWRONRST_0: De-asserts the external power-on reset.");
    case omap44xx_scrm_PWRONRST_1:
        return("PWRONRST_1: Asserts the external power-on reset.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_pwronrst_status_prtval(char *_s, size_t _size, omap44xx_scrm_pwronrst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_pwronrst_status_prtval(char *_s, size_t _size, omap44xx_scrm_pwronrst_status_t _e)
{
    char *d = omap44xx_scrm_pwronrst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_pwronrst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.extwarmrstst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_extwarmrstst_status_t;
#define omap44xx_scrm_EXTWARMRSTST_0 ((omap44xx_scrm_extwarmrstst_status_t)0x0)
#define omap44xx_scrm_EXTWARMRSTST_1 ((omap44xx_scrm_extwarmrstst_status_t)0x1)

static inline char *omap44xx_scrm_extwarmrstst_status_describe(omap44xx_scrm_extwarmrstst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_extwarmrstst_status_describe(omap44xx_scrm_extwarmrstst_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_EXTWARMRSTST_0:
        return("EXTWARMRSTST_0: No external warm reset occurred.");
    case omap44xx_scrm_EXTWARMRSTST_1:
        return("EXTWARMRSTST_1: An external warm reset occurred.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_extwarmrstst_status_prtval(char *_s, size_t _size, omap44xx_scrm_extwarmrstst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extwarmrstst_status_prtval(char *_s, size_t _size, omap44xx_scrm_extwarmrstst_status_t _e)
{
    char *d = omap44xx_scrm_extwarmrstst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_extwarmrstst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.apewarmrstst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_apewarmrstst_status_t;
#define omap44xx_scrm_APEWARMRSTST_0 ((omap44xx_scrm_apewarmrstst_status_t)0x0)
#define omap44xx_scrm_APEWARMRSTST_1 ((omap44xx_scrm_apewarmrstst_status_t)0x1)

static inline char *omap44xx_scrm_apewarmrstst_status_describe(omap44xx_scrm_apewarmrstst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_apewarmrstst_status_describe(omap44xx_scrm_apewarmrstst_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_APEWARMRSTST_0:
        return("APEWARMRSTST_0: No APE warm reset occurred.");
    case omap44xx_scrm_APEWARMRSTST_1:
        return("APEWARMRSTST_1: An APE warm reset occurred.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_apewarmrstst_status_prtval(char *_s, size_t _size, omap44xx_scrm_apewarmrstst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_apewarmrstst_status_prtval(char *_s, size_t _size, omap44xx_scrm_apewarmrstst_status_t _e)
{
    char *d = omap44xx_scrm_apewarmrstst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_apewarmrstst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_scrm.c2cwarmrstst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_scrm_c2cwarmrstst_status_t;
#define omap44xx_scrm_C2CWARMRSTST_0 ((omap44xx_scrm_c2cwarmrstst_status_t)0x0)
#define omap44xx_scrm_C2CWARMRSTST_1 ((omap44xx_scrm_c2cwarmrstst_status_t)0x1)

static inline char *omap44xx_scrm_c2cwarmrstst_status_describe(omap44xx_scrm_c2cwarmrstst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_scrm_c2cwarmrstst_status_describe(omap44xx_scrm_c2cwarmrstst_status_t _e)
{
    switch (_e) {
    case omap44xx_scrm_C2CWARMRSTST_0:
        return("C2CWARMRSTST_0: No C2C warm reset occurred.");
    case omap44xx_scrm_C2CWARMRSTST_1:
        return("C2CWARMRSTST_1: A C2C warm reset occurred.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_scrm_c2cwarmrstst_status_prtval(char *_s, size_t _size, omap44xx_scrm_c2cwarmrstst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cwarmrstst_status_prtval(char *_s, size_t _size, omap44xx_scrm_c2cwarmrstst_status_t _e)
{
    char *d = omap44xx_scrm_c2cwarmrstst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_scrm_c2cwarmrstst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_scrm_revision_scrm_t
 * Description: Implicit type of This register contains the IP revision code for the SCRM. register
 * Fields:
 *   rev	(size 8, offset 0, init 0):	RO	Revision Number
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_revision_scrm_t;
#define omap44xx_scrm_revision_scrm_default 0x0
static inline uint8_t omap44xx_scrm_revision_scrm_rev_extract(omap44xx_scrm_revision_scrm_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_revision_scrm_rev_extract(omap44xx_scrm_revision_scrm_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_scrm_revision_scrm_t omap44xx_scrm_revision_scrm_rev_insert(omap44xx_scrm_revision_scrm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_revision_scrm_t omap44xx_scrm_revision_scrm_rev_insert(omap44xx_scrm_revision_scrm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_scrm_revision_scrm_t )(_fieldval)) << 0)));
}

static inline int omap44xx_scrm_revision_scrm_prtval(char *_s, size_t _size, omap44xx_scrm_revision_scrm_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_revision_scrm_prtval(char *_s, size_t _size, omap44xx_scrm_revision_scrm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev =\t%" PRIx8 "\t(Revision Number)\n", omap44xx_scrm_revision_scrm_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_clksetuptime_t
 * Description: Implicit type of This register holds the clock setup time counters of the system clock source supplier. register
 * Fields:
 *   setuptime	(size 12, offset 0, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to stabilize the clock source supplier.
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   downtime	(size 6, offset 16, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to gate the clock source supplier.
 *   _anon22	(size 10, offset 22, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_clksetuptime_t;
#define omap44xx_scrm_clksetuptime_default 0x0
static inline uint16_t omap44xx_scrm_clksetuptime_setuptime_extract(omap44xx_scrm_clksetuptime_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_scrm_clksetuptime_setuptime_extract(omap44xx_scrm_clksetuptime_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_setuptime_insert(omap44xx_scrm_clksetuptime_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_setuptime_insert(omap44xx_scrm_clksetuptime_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((omap44xx_scrm_clksetuptime_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_scrm_clksetuptime_downtime_extract(omap44xx_scrm_clksetuptime_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_clksetuptime_downtime_extract(omap44xx_scrm_clksetuptime_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_downtime_insert(omap44xx_scrm_clksetuptime_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_downtime_insert(omap44xx_scrm_clksetuptime_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((omap44xx_scrm_clksetuptime_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_clksetuptime_prtval(char *_s, size_t _size, omap44xx_scrm_clksetuptime_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clksetuptime_prtval(char *_s, size_t _size, omap44xx_scrm_clksetuptime_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " setuptime =\t%" PRIx16 "\t(Holds the number of 32 kHz clock cycles it takes to stabilize the clock source supplier.)\n", omap44xx_scrm_clksetuptime_setuptime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " downtime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles it takes to gate the clock source supplier.)\n", omap44xx_scrm_clksetuptime_downtime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_pmicsetuptime_t
 * Description: Implicit type of This register holds the setup time counters for the sleep mode of the clock-source generator power supply (the power supply in external connected PMIC or LDO). register
 * Fields:
 *   sleeptime	(size 6, offset 0, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to enter the clock source generator power supply in sleep mode. SCRM activates Sleep-time counter by deactivation of power request.
 *   _anon6	(size 10, offset 6, init 0):	MBZ	_
 *   wakeuptime	(size 6, offset 16, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to exit the clock-source generator power supply from sleep mode. SCRM starts Wakeup-time counter by activation of power request.
 *   _anon22	(size 10, offset 22, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_pmicsetuptime_t;
#define omap44xx_scrm_pmicsetuptime_default 0x0
static inline uint8_t omap44xx_scrm_pmicsetuptime_sleeptime_extract(omap44xx_scrm_pmicsetuptime_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_pmicsetuptime_sleeptime_extract(omap44xx_scrm_pmicsetuptime_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_sleeptime_insert(omap44xx_scrm_pmicsetuptime_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_sleeptime_insert(omap44xx_scrm_pmicsetuptime_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((omap44xx_scrm_pmicsetuptime_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_scrm_pmicsetuptime_wakeuptime_extract(omap44xx_scrm_pmicsetuptime_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_pmicsetuptime_wakeuptime_extract(omap44xx_scrm_pmicsetuptime_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_wakeuptime_insert(omap44xx_scrm_pmicsetuptime_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_wakeuptime_insert(omap44xx_scrm_pmicsetuptime_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((omap44xx_scrm_pmicsetuptime_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_pmicsetuptime_prtval(char *_s, size_t _size, omap44xx_scrm_pmicsetuptime_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_pmicsetuptime_prtval(char *_s, size_t _size, omap44xx_scrm_pmicsetuptime_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sleeptime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles it takes to enter the clock source generator power supply in sleep mode. SCRM activates Sleep-time counter by deactivation of power request.)\n", omap44xx_scrm_pmicsetuptime_sleeptime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wakeuptime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles it takes to exit the clock-source generator power supply from sleep mode. SCRM starts Wakeup-time counter by activation of power request.)\n", omap44xx_scrm_pmicsetuptime_wakeuptime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_altclksrc_t
 * Description: Implicit type of This register controls the alternate system clock source supplier. register
 * Fields:
 *   mode	(size 2, offset 0, init 0):	RW	This bit field defines the functional mode of the alternate system clock supplier.
 *   enable_int	(size 1, offset 2, init 0):	RW	This bit allows to enable and disable the alternate system clock version used to generate the auxiliary clocks. This bit is intended to be used in order to gate this clock path while the source is stabilizing and also to gate this clock path while switching the auxiliary clock paths on / from this possible source.
 *   enable_ext	(size 1, offset 3, init 0):	RW	This bit allows to enable and disable the output alternate system clock version. This bit is intended to be used in order to gate this clock path while the source is stabilizing.
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_altclksrc_t;
#define omap44xx_scrm_altclksrc_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_altclksrc_mode_extract(omap44xx_scrm_altclksrc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_altclksrc_mode_extract(omap44xx_scrm_altclksrc_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_mode_insert(omap44xx_scrm_altclksrc_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_mode_insert(omap44xx_scrm_altclksrc_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_scrm_altclksrc_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_int_extract(omap44xx_scrm_altclksrc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_int_extract(omap44xx_scrm_altclksrc_t _regval)
{
    return((omap44xx_scrm_enable_ext_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_enable_int_insert(omap44xx_scrm_altclksrc_t _regval, omap44xx_scrm_enable_ext_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_enable_int_insert(omap44xx_scrm_altclksrc_t _regval, omap44xx_scrm_enable_ext_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_scrm_altclksrc_t )(_fieldval)) << 2)));
}

static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_ext_extract(omap44xx_scrm_altclksrc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_ext_extract(omap44xx_scrm_altclksrc_t _regval)
{
    return((omap44xx_scrm_enable_ext_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_enable_ext_insert(omap44xx_scrm_altclksrc_t _regval, omap44xx_scrm_enable_ext_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_enable_ext_insert(omap44xx_scrm_altclksrc_t _regval, omap44xx_scrm_enable_ext_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_scrm_altclksrc_t )(_fieldval)) << 3)));
}

static inline int omap44xx_scrm_altclksrc_prtval(char *_s, size_t _size, omap44xx_scrm_altclksrc_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_altclksrc_prtval(char *_s, size_t _size, omap44xx_scrm_altclksrc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_altclksrc_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit field defines the functional mode of the alternate system clock supplier.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable_int =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_enable_ext_status_prtval(_s + _r, _avail, omap44xx_scrm_altclksrc_enable_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the alternate system clock version used to generate the auxiliary clocks. This bit is intended to be used in order to gate this clock path while the source is stabilizing and also to gate this clock path while switching the auxiliary clock paths on / from this possible source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable_ext =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_enable_ext_status_prtval(_s + _r, _avail, omap44xx_scrm_altclksrc_enable_ext_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the output alternate system clock version. This bit is intended to be used in order to gate this clock path while the source is stabilizing.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_c2cclkm_t
 * Description: Implicit type of This register controls the clocks of the external C2C interface. register
 * Fields:
 *   clk_32khz	(size 1, offset 0, init 0):	RW	This bit allows to enable and disable the 32 kHz clock version of the external C2C interface.
 *   sysclk	(size 1, offset 1, init 0):	RW	This bit allows to enable and disable the system clock version of the external C2C interface.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_c2cclkm_t;
#define omap44xx_scrm_c2cclkm_default 0x0
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_clk_32khz_extract(omap44xx_scrm_c2cclkm_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_clk_32khz_extract(omap44xx_scrm_c2cclkm_t _regval)
{
    return((omap44xx_scrm_sysclk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_clk_32khz_insert(omap44xx_scrm_c2cclkm_t _regval, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_clk_32khz_insert(omap44xx_scrm_c2cclkm_t _regval, omap44xx_scrm_sysclk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_c2cclkm_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_sysclk_extract(omap44xx_scrm_c2cclkm_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_sysclk_extract(omap44xx_scrm_c2cclkm_t _regval)
{
    return((omap44xx_scrm_sysclk_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_sysclk_insert(omap44xx_scrm_c2cclkm_t _regval, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_sysclk_insert(omap44xx_scrm_c2cclkm_t _regval, omap44xx_scrm_sysclk_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_c2cclkm_t )(_fieldval)) << 1)));
}

static inline int omap44xx_scrm_c2cclkm_prtval(char *_s, size_t _size, omap44xx_scrm_c2cclkm_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cclkm_prtval(char *_s, size_t _size, omap44xx_scrm_c2cclkm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clk_32khz =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkm_clk_32khz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the 32 kHz clock version of the external C2C interface.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkm_sysclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the system clock version of the external C2C interface.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_extclkreq_t
 * Description: Implicit type of This register holds qualifiers for the external clock request. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the external clock request.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_extclkreq_t;
#define omap44xx_scrm_extclkreq_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extclkreq_polarity_extract(omap44xx_scrm_extclkreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extclkreq_polarity_extract(omap44xx_scrm_extclkreq_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_extclkreq_t omap44xx_scrm_extclkreq_polarity_insert(omap44xx_scrm_extclkreq_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_extclkreq_t omap44xx_scrm_extclkreq_polarity_insert(omap44xx_scrm_extclkreq_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_extclkreq_t )(_fieldval)) << 0)));
}

static inline int omap44xx_scrm_extclkreq_prtval(char *_s, size_t _size, omap44xx_scrm_extclkreq_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extclkreq_prtval(char *_s, size_t _size, omap44xx_scrm_extclkreq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_extclkreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the external clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_accclkreq_t
 * Description: Implicit type of This register holds qualifiers for the accurate clock request. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the accurate clock request.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_accclkreq_t;
#define omap44xx_scrm_accclkreq_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_accclkreq_polarity_extract(omap44xx_scrm_accclkreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_accclkreq_polarity_extract(omap44xx_scrm_accclkreq_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_accclkreq_t omap44xx_scrm_accclkreq_polarity_insert(omap44xx_scrm_accclkreq_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_accclkreq_t omap44xx_scrm_accclkreq_polarity_insert(omap44xx_scrm_accclkreq_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_accclkreq_t )(_fieldval)) << 0)));
}

static inline int omap44xx_scrm_accclkreq_prtval(char *_s, size_t _size, omap44xx_scrm_accclkreq_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_accclkreq_prtval(char *_s, size_t _size, omap44xx_scrm_accclkreq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_accclkreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_pwrreq_t
 * Description: Implicit type of This register holds qualifiers for the external power request. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the external power request.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_pwrreq_t;
#define omap44xx_scrm_pwrreq_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_pwrreq_polarity_extract(omap44xx_scrm_pwrreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_pwrreq_polarity_extract(omap44xx_scrm_pwrreq_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_pwrreq_t omap44xx_scrm_pwrreq_polarity_insert(omap44xx_scrm_pwrreq_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_pwrreq_t omap44xx_scrm_pwrreq_polarity_insert(omap44xx_scrm_pwrreq_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_pwrreq_t )(_fieldval)) << 0)));
}

static inline int omap44xx_scrm_pwrreq_prtval(char *_s, size_t _size, omap44xx_scrm_pwrreq_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_pwrreq_prtval(char *_s, size_t _size, omap44xx_scrm_pwrreq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_pwrreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the external power request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclkreq0_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock request #0. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #0.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #0 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #0 on another auxiliary clock output than auxiliary clock #0.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclkreq0_t;
#define omap44xx_scrm_auxclkreq0_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_polarity_extract(omap44xx_scrm_auxclkreq0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_polarity_extract(omap44xx_scrm_auxclkreq0_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_polarity_insert(omap44xx_scrm_auxclkreq0_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_polarity_insert(omap44xx_scrm_auxclkreq0_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclkreq0_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_accuracy_extract(omap44xx_scrm_auxclkreq0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_accuracy_extract(omap44xx_scrm_auxclkreq0_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_accuracy_insert(omap44xx_scrm_auxclkreq0_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_accuracy_insert(omap44xx_scrm_auxclkreq0_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_auxclkreq0_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq0_mapping_extract(omap44xx_scrm_auxclkreq0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq0_mapping_extract(omap44xx_scrm_auxclkreq0_t _regval)
{
    return((omap44xx_scrm_mapping_status_t )((_regval & 0x1c) >> 2));
}

static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_mapping_insert(omap44xx_scrm_auxclkreq0_t _regval, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_mapping_insert(omap44xx_scrm_auxclkreq0_t _regval, omap44xx_scrm_mapping_status_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((omap44xx_scrm_auxclkreq0_t )(_fieldval)) << 2)));
}

static inline int omap44xx_scrm_auxclkreq0_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq0_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq0_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq0_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #0 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq0_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #0 on another auxiliary clock output than auxiliary clock #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclkreq1_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock request #1. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #1.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #1 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #1 on another auxiliary clock output than auxiliary clock #1.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclkreq1_t;
#define omap44xx_scrm_auxclkreq1_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_polarity_extract(omap44xx_scrm_auxclkreq1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_polarity_extract(omap44xx_scrm_auxclkreq1_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_polarity_insert(omap44xx_scrm_auxclkreq1_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_polarity_insert(omap44xx_scrm_auxclkreq1_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclkreq1_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_accuracy_extract(omap44xx_scrm_auxclkreq1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_accuracy_extract(omap44xx_scrm_auxclkreq1_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_accuracy_insert(omap44xx_scrm_auxclkreq1_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_accuracy_insert(omap44xx_scrm_auxclkreq1_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_auxclkreq1_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq1_mapping_extract(omap44xx_scrm_auxclkreq1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq1_mapping_extract(omap44xx_scrm_auxclkreq1_t _regval)
{
    return((omap44xx_scrm_mapping_status_t )((_regval & 0x1c) >> 2));
}

static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_mapping_insert(omap44xx_scrm_auxclkreq1_t _regval, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_mapping_insert(omap44xx_scrm_auxclkreq1_t _regval, omap44xx_scrm_mapping_status_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((omap44xx_scrm_auxclkreq1_t )(_fieldval)) << 2)));
}

static inline int omap44xx_scrm_auxclkreq1_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq1_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq1_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq1_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #1 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq1_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #1 on another auxiliary clock output than auxiliary clock #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclkreq2_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock request #2. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #2.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #2 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #2 on another auxiliary clock output than auxiliary clock #2.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclkreq2_t;
#define omap44xx_scrm_auxclkreq2_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_polarity_extract(omap44xx_scrm_auxclkreq2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_polarity_extract(omap44xx_scrm_auxclkreq2_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_polarity_insert(omap44xx_scrm_auxclkreq2_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_polarity_insert(omap44xx_scrm_auxclkreq2_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclkreq2_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_accuracy_extract(omap44xx_scrm_auxclkreq2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_accuracy_extract(omap44xx_scrm_auxclkreq2_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_accuracy_insert(omap44xx_scrm_auxclkreq2_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_accuracy_insert(omap44xx_scrm_auxclkreq2_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_auxclkreq2_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq2_mapping_extract(omap44xx_scrm_auxclkreq2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq2_mapping_extract(omap44xx_scrm_auxclkreq2_t _regval)
{
    return((omap44xx_scrm_mapping_status_t )((_regval & 0x1c) >> 2));
}

static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_mapping_insert(omap44xx_scrm_auxclkreq2_t _regval, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_mapping_insert(omap44xx_scrm_auxclkreq2_t _regval, omap44xx_scrm_mapping_status_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((omap44xx_scrm_auxclkreq2_t )(_fieldval)) << 2)));
}

static inline int omap44xx_scrm_auxclkreq2_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq2_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq2_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq2_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #2 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq2_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #2 on another auxiliary clock output than auxiliary clock #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclkreq3_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock request #3. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #3.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #3 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #3 on another auxiliary clock output than auxiliary clock #3.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclkreq3_t;
#define omap44xx_scrm_auxclkreq3_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_polarity_extract(omap44xx_scrm_auxclkreq3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_polarity_extract(omap44xx_scrm_auxclkreq3_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_polarity_insert(omap44xx_scrm_auxclkreq3_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_polarity_insert(omap44xx_scrm_auxclkreq3_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclkreq3_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_accuracy_extract(omap44xx_scrm_auxclkreq3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_accuracy_extract(omap44xx_scrm_auxclkreq3_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_accuracy_insert(omap44xx_scrm_auxclkreq3_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_accuracy_insert(omap44xx_scrm_auxclkreq3_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_auxclkreq3_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq3_mapping_extract(omap44xx_scrm_auxclkreq3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq3_mapping_extract(omap44xx_scrm_auxclkreq3_t _regval)
{
    return((omap44xx_scrm_mapping_status_t )((_regval & 0x1c) >> 2));
}

static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_mapping_insert(omap44xx_scrm_auxclkreq3_t _regval, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_mapping_insert(omap44xx_scrm_auxclkreq3_t _regval, omap44xx_scrm_mapping_status_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((omap44xx_scrm_auxclkreq3_t )(_fieldval)) << 2)));
}

static inline int omap44xx_scrm_auxclkreq3_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq3_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq3_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq3_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq3_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #3 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq3_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #3 on another auxiliary clock output than auxiliary clock #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclkreq4_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock request #4. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #4.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #4 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #4 on another auxiliary clock output than auxiliary clock #4.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclkreq4_t;
#define omap44xx_scrm_auxclkreq4_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_polarity_extract(omap44xx_scrm_auxclkreq4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_polarity_extract(omap44xx_scrm_auxclkreq4_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_polarity_insert(omap44xx_scrm_auxclkreq4_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_polarity_insert(omap44xx_scrm_auxclkreq4_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclkreq4_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_accuracy_extract(omap44xx_scrm_auxclkreq4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_accuracy_extract(omap44xx_scrm_auxclkreq4_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_accuracy_insert(omap44xx_scrm_auxclkreq4_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_accuracy_insert(omap44xx_scrm_auxclkreq4_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_auxclkreq4_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq4_mapping_extract(omap44xx_scrm_auxclkreq4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq4_mapping_extract(omap44xx_scrm_auxclkreq4_t _regval)
{
    return((omap44xx_scrm_mapping_status_t )((_regval & 0x1c) >> 2));
}

static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_mapping_insert(omap44xx_scrm_auxclkreq4_t _regval, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_mapping_insert(omap44xx_scrm_auxclkreq4_t _regval, omap44xx_scrm_mapping_status_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((omap44xx_scrm_auxclkreq4_t )(_fieldval)) << 2)));
}

static inline int omap44xx_scrm_auxclkreq4_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq4_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq4_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq4_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq4_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq4_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #4 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq4_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #4 on another auxiliary clock output than auxiliary clock #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclkreq5_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock request #5. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #5.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #5 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #5 on another auxiliary clock output than auxiliary clock #5.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclkreq5_t;
#define omap44xx_scrm_auxclkreq5_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_polarity_extract(omap44xx_scrm_auxclkreq5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_polarity_extract(omap44xx_scrm_auxclkreq5_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_polarity_insert(omap44xx_scrm_auxclkreq5_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_polarity_insert(omap44xx_scrm_auxclkreq5_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclkreq5_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_accuracy_extract(omap44xx_scrm_auxclkreq5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_accuracy_extract(omap44xx_scrm_auxclkreq5_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_accuracy_insert(omap44xx_scrm_auxclkreq5_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_accuracy_insert(omap44xx_scrm_auxclkreq5_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_auxclkreq5_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq5_mapping_extract(omap44xx_scrm_auxclkreq5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq5_mapping_extract(omap44xx_scrm_auxclkreq5_t _regval)
{
    return((omap44xx_scrm_mapping_status_t )((_regval & 0x1c) >> 2));
}

static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_mapping_insert(omap44xx_scrm_auxclkreq5_t _regval, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_mapping_insert(omap44xx_scrm_auxclkreq5_t _regval, omap44xx_scrm_mapping_status_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((omap44xx_scrm_auxclkreq5_t )(_fieldval)) << 2)));
}

static inline int omap44xx_scrm_auxclkreq5_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq5_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq5_prtval(char *_s, size_t _size, omap44xx_scrm_auxclkreq5_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq5_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq5_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #5 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq5_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #5 on another auxiliary clock output than auxiliary clock #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_c2cclkreq_t
 * Description: Implicit type of This register holds qualifiers for the external C2C interface clock request. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the external C2C interface clock request.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the external C2C interface clock request as an accurate clock request.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_c2cclkreq_t;
#define omap44xx_scrm_c2cclkreq_default 0x0
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_polarity_extract(omap44xx_scrm_c2cclkreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_polarity_extract(omap44xx_scrm_c2cclkreq_t _regval)
{
    return((omap44xx_scrm_sysclk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_polarity_insert(omap44xx_scrm_c2cclkreq_t _regval, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_polarity_insert(omap44xx_scrm_c2cclkreq_t _regval, omap44xx_scrm_sysclk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_c2cclkreq_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_accuracy_extract(omap44xx_scrm_c2cclkreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_accuracy_extract(omap44xx_scrm_c2cclkreq_t _regval)
{
    return((omap44xx_scrm_sysclk_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_accuracy_insert(omap44xx_scrm_c2cclkreq_t _regval, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_accuracy_insert(omap44xx_scrm_c2cclkreq_t _regval, omap44xx_scrm_sysclk_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_c2cclkreq_t )(_fieldval)) << 1)));
}

static inline int omap44xx_scrm_c2cclkreq_prtval(char *_s, size_t _size, omap44xx_scrm_c2cclkreq_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cclkreq_prtval(char *_s, size_t _size, omap44xx_scrm_c2cclkreq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the external C2C interface clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkreq_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the external C2C interface clock request as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclk0_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock #0. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #0 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #0.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #0 by software.
 *   disableclk	(size 1, offset 9, init 0):	RW	This bit allows to gate the auxiliary clock #0 without condition. This is bit is intended to be used only when the SOC is not clock provider.
 *   _anon10	(size 6, offset 10, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #0.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclk0_t;
#define omap44xx_scrm_auxclk0_default 0x0
static inline omap44xx_scrm_polarity_status_t omap44xx_scrm_auxclk0_polarity_extract(omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status_t omap44xx_scrm_auxclk0_polarity_extract(omap44xx_scrm_auxclk0_t _regval)
{
    return((omap44xx_scrm_polarity_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_polarity_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_polarity_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_polarity_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_polarity_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk0_srcselect_extract(omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk0_srcselect_extract(omap44xx_scrm_auxclk0_t _regval)
{
    return((omap44xx_scrm_srcselect_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_srcselect_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_srcselect_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_srcselect_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk0_enable_extract(omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk0_enable_extract(omap44xx_scrm_auxclk0_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_enable_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_enable_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 8)));
}

static inline omap44xx_scrm_disableclk_status_t omap44xx_scrm_auxclk0_disableclk_extract(omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_disableclk_status_t omap44xx_scrm_auxclk0_disableclk_extract(omap44xx_scrm_auxclk0_t _regval)
{
    return((omap44xx_scrm_disableclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_disableclk_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_disableclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_disableclk_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_disableclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 9)));
}

static inline omap44xx_scrm_clkdiv_status_t omap44xx_scrm_auxclk0_clkdiv_extract(omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status_t omap44xx_scrm_auxclk0_clkdiv_extract(omap44xx_scrm_auxclk0_t _regval)
{
    return((omap44xx_scrm_clkdiv_status_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_clkdiv_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_clkdiv_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_clkdiv_insert(omap44xx_scrm_auxclk0_t _regval, omap44xx_scrm_clkdiv_status_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_auxclk0_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk0_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #0 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #0 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " disableclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_disableclk_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_disableclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to gate the auxiliary clock #0 without condition. This is bit is intended to be used only when the SOC is not clock provider.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclk1_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock #1. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #1 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #1.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #1 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #1.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclk1_t;
#define omap44xx_scrm_auxclk1_default 0x0
static inline omap44xx_scrm_polarity_status1_t omap44xx_scrm_auxclk1_polarity_extract(omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status1_t omap44xx_scrm_auxclk1_polarity_extract(omap44xx_scrm_auxclk1_t _regval)
{
    return((omap44xx_scrm_polarity_status1_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_polarity_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_polarity_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_polarity_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_polarity_status1_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk1_srcselect_extract(omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk1_srcselect_extract(omap44xx_scrm_auxclk1_t _regval)
{
    return((omap44xx_scrm_srcselect_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_srcselect_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_srcselect_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_srcselect_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk1_enable_extract(omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk1_enable_extract(omap44xx_scrm_auxclk1_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_enable_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_enable_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 8)));
}

static inline omap44xx_scrm_clkdiv_status1_t omap44xx_scrm_auxclk1_clkdiv_extract(omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status1_t omap44xx_scrm_auxclk1_clkdiv_extract(omap44xx_scrm_auxclk1_t _regval)
{
    return((omap44xx_scrm_clkdiv_status1_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_clkdiv_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_clkdiv_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_clkdiv_insert(omap44xx_scrm_auxclk1_t _regval, omap44xx_scrm_clkdiv_status1_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_auxclk1_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk1_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status1_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #1 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #1 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status1_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclk2_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock #2. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #2 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #2.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #2 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #2.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclk2_t;
#define omap44xx_scrm_auxclk2_default 0x0
static inline omap44xx_scrm_polarity_status2_t omap44xx_scrm_auxclk2_polarity_extract(omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status2_t omap44xx_scrm_auxclk2_polarity_extract(omap44xx_scrm_auxclk2_t _regval)
{
    return((omap44xx_scrm_polarity_status2_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_polarity_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_polarity_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_polarity_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_polarity_status2_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk2_srcselect_extract(omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk2_srcselect_extract(omap44xx_scrm_auxclk2_t _regval)
{
    return((omap44xx_scrm_srcselect_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_srcselect_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_srcselect_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_srcselect_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk2_enable_extract(omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk2_enable_extract(omap44xx_scrm_auxclk2_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_enable_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_enable_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 8)));
}

static inline omap44xx_scrm_clkdiv_status2_t omap44xx_scrm_auxclk2_clkdiv_extract(omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status2_t omap44xx_scrm_auxclk2_clkdiv_extract(omap44xx_scrm_auxclk2_t _regval)
{
    return((omap44xx_scrm_clkdiv_status2_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_clkdiv_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_clkdiv_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_clkdiv_insert(omap44xx_scrm_auxclk2_t _regval, omap44xx_scrm_clkdiv_status2_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_auxclk2_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk2_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status2_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #2 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #2 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status2_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclk3_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock #3. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #3 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #3.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #3 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #3.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclk3_t;
#define omap44xx_scrm_auxclk3_default 0x0
static inline omap44xx_scrm_polarity_status3_t omap44xx_scrm_auxclk3_polarity_extract(omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status3_t omap44xx_scrm_auxclk3_polarity_extract(omap44xx_scrm_auxclk3_t _regval)
{
    return((omap44xx_scrm_polarity_status3_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_polarity_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_polarity_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_polarity_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_polarity_status3_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk3_srcselect_extract(omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk3_srcselect_extract(omap44xx_scrm_auxclk3_t _regval)
{
    return((omap44xx_scrm_srcselect_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_srcselect_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_srcselect_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_srcselect_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk3_enable_extract(omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk3_enable_extract(omap44xx_scrm_auxclk3_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_enable_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_enable_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 8)));
}

static inline omap44xx_scrm_clkdiv_status3_t omap44xx_scrm_auxclk3_clkdiv_extract(omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status3_t omap44xx_scrm_auxclk3_clkdiv_extract(omap44xx_scrm_auxclk3_t _regval)
{
    return((omap44xx_scrm_clkdiv_status3_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_clkdiv_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_clkdiv_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_clkdiv_insert(omap44xx_scrm_auxclk3_t _regval, omap44xx_scrm_clkdiv_status3_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_auxclk3_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk3_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status3_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #3 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #3 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status3_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclk4_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock #4. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #4 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #4.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #4 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #4.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclk4_t;
#define omap44xx_scrm_auxclk4_default 0x0
static inline omap44xx_scrm_polarity_status4_t omap44xx_scrm_auxclk4_polarity_extract(omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status4_t omap44xx_scrm_auxclk4_polarity_extract(omap44xx_scrm_auxclk4_t _regval)
{
    return((omap44xx_scrm_polarity_status4_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_polarity_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_polarity_status4_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_polarity_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_polarity_status4_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk4_srcselect_extract(omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk4_srcselect_extract(omap44xx_scrm_auxclk4_t _regval)
{
    return((omap44xx_scrm_srcselect_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_srcselect_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_srcselect_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_srcselect_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk4_enable_extract(omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk4_enable_extract(omap44xx_scrm_auxclk4_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_enable_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_enable_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 8)));
}

static inline omap44xx_scrm_clkdiv_status4_t omap44xx_scrm_auxclk4_clkdiv_extract(omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status4_t omap44xx_scrm_auxclk4_clkdiv_extract(omap44xx_scrm_auxclk4_t _regval)
{
    return((omap44xx_scrm_clkdiv_status4_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_clkdiv_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_clkdiv_status4_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_clkdiv_insert(omap44xx_scrm_auxclk4_t _regval, omap44xx_scrm_clkdiv_status4_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_auxclk4_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk4_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk4_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status4_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #4 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #4 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status4_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_auxclk5_t
 * Description: Implicit type of This register holds qualifiers for the auxiliary clock #5. register
 * Fields:
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #5 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #5.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #5 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #5.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_auxclk5_t;
#define omap44xx_scrm_auxclk5_default 0x0
static inline omap44xx_scrm_polarity_status5_t omap44xx_scrm_auxclk5_polarity_extract(omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status5_t omap44xx_scrm_auxclk5_polarity_extract(omap44xx_scrm_auxclk5_t _regval)
{
    return((omap44xx_scrm_polarity_status5_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_polarity_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_polarity_status5_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_polarity_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_polarity_status5_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk5_srcselect_extract(omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk5_srcselect_extract(omap44xx_scrm_auxclk5_t _regval)
{
    return((omap44xx_scrm_srcselect_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_srcselect_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_srcselect_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_srcselect_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 1)));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk5_enable_extract(omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk5_enable_extract(omap44xx_scrm_auxclk5_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_enable_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_enable_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 8)));
}

static inline omap44xx_scrm_clkdiv_status5_t omap44xx_scrm_auxclk5_clkdiv_extract(omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status5_t omap44xx_scrm_auxclk5_clkdiv_extract(omap44xx_scrm_auxclk5_t _regval)
{
    return((omap44xx_scrm_clkdiv_status5_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_clkdiv_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_clkdiv_status5_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_clkdiv_insert(omap44xx_scrm_auxclk5_t _regval, omap44xx_scrm_clkdiv_status5_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 16)));
}

static inline int omap44xx_scrm_auxclk5_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk5_prtval(char *_s, size_t _size, omap44xx_scrm_auxclk5_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status5_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #5 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #5 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status5_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_rsttime_reg_t
 * Description: Implicit type of This register holds the reset time counter which is used to extend the reset lines beyond the release of the pad reset. register
 * Fields:
 *   rsttime	(size 4, offset 0, init 0):	RW	Holds the number of 32 kHz clock cycles for which the reset duration is extended. Values 0,1 and 2 are not allowed. 0x0: Reserved. 0x1: Reserved. 0x2: Reserved.
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_rsttime_reg_t;
#define omap44xx_scrm_rsttime_reg_default 0x0
static inline uint8_t omap44xx_scrm_rsttime_reg_rsttime_extract(omap44xx_scrm_rsttime_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_rsttime_reg_rsttime_extract(omap44xx_scrm_rsttime_reg_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_scrm_rsttime_reg_t omap44xx_scrm_rsttime_reg_rsttime_insert(omap44xx_scrm_rsttime_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_rsttime_reg_t omap44xx_scrm_rsttime_reg_rsttime_insert(omap44xx_scrm_rsttime_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_scrm_rsttime_reg_t )(_fieldval)) << 0)));
}

static inline int omap44xx_scrm_rsttime_reg_prtval(char *_s, size_t _size, omap44xx_scrm_rsttime_reg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_rsttime_reg_prtval(char *_s, size_t _size, omap44xx_scrm_rsttime_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsttime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles for which the reset duration is extended. Values 0,1 and 2 are not allowed. 0x0: Reserved. 0x1: Reserved. 0x2: Reserved.)\n", omap44xx_scrm_rsttime_reg_rsttime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_c2crstctrl_t
 * Description: Implicit type of This register controls the release of the external C2C interface reset lines. register
 * Fields:
 *   coldrst	(size 1, offset 0, init 0):	RW	This bit allows to release the cold reset line of the external C2C interface.
 *   warmrst	(size 1, offset 1, init 0):	RW	This bit allows to release the warm reset line of the external C2C interface. [warm reset sensitive]
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_c2crstctrl_t;
#define omap44xx_scrm_c2crstctrl_default 0x0
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_coldrst_extract(omap44xx_scrm_c2crstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_coldrst_extract(omap44xx_scrm_c2crstctrl_t _regval)
{
    return((omap44xx_scrm_sysclk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_coldrst_insert(omap44xx_scrm_c2crstctrl_t _regval, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_coldrst_insert(omap44xx_scrm_c2crstctrl_t _regval, omap44xx_scrm_sysclk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_c2crstctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_warmrst_extract(omap44xx_scrm_c2crstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_warmrst_extract(omap44xx_scrm_c2crstctrl_t _regval)
{
    return((omap44xx_scrm_sysclk_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_warmrst_insert(omap44xx_scrm_c2crstctrl_t _regval, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_warmrst_insert(omap44xx_scrm_c2crstctrl_t _regval, omap44xx_scrm_sysclk_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_c2crstctrl_t )(_fieldval)) << 1)));
}

static inline int omap44xx_scrm_c2crstctrl_prtval(char *_s, size_t _size, omap44xx_scrm_c2crstctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2crstctrl_prtval(char *_s, size_t _size, omap44xx_scrm_c2crstctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " coldrst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2crstctrl_coldrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to release the cold reset line of the external C2C interface.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " warmrst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2crstctrl_warmrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to release the warm reset line of the external C2C interface. [warm reset sensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_extpwronrstctrl_t
 * Description: Implicit type of This register allows the software to perform an external power-on reset. register
 * Fields:
 *   enable	(size 1, offset 0, init 0):	RW	This bit must be set to 1 to allow the software to assert the external power-on reset.
 *   pwronrst	(size 1, offset 1, init 0):	RW	This bit controls the assertion and the de-assertion of the external power-on reset.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_extpwronrstctrl_t;
#define omap44xx_scrm_extpwronrstctrl_default 0x0
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extpwronrstctrl_enable_extract(omap44xx_scrm_extpwronrstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extpwronrstctrl_enable_extract(omap44xx_scrm_extpwronrstctrl_t _regval)
{
    return((omap44xx_scrm_mode_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_enable_insert(omap44xx_scrm_extpwronrstctrl_t _regval, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_enable_insert(omap44xx_scrm_extpwronrstctrl_t _regval, omap44xx_scrm_mode_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_extpwronrstctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_scrm_pwronrst_status_t omap44xx_scrm_extpwronrstctrl_pwronrst_extract(omap44xx_scrm_extpwronrstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_pwronrst_status_t omap44xx_scrm_extpwronrstctrl_pwronrst_extract(omap44xx_scrm_extpwronrstctrl_t _regval)
{
    return((omap44xx_scrm_pwronrst_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_pwronrst_insert(omap44xx_scrm_extpwronrstctrl_t _regval, omap44xx_scrm_pwronrst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_pwronrst_insert(omap44xx_scrm_extpwronrstctrl_t _regval, omap44xx_scrm_pwronrst_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_extpwronrstctrl_t )(_fieldval)) << 1)));
}

static inline int omap44xx_scrm_extpwronrstctrl_prtval(char *_s, size_t _size, omap44xx_scrm_extpwronrstctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extpwronrstctrl_prtval(char *_s, size_t _size, omap44xx_scrm_extpwronrstctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_extpwronrstctrl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit must be set to 1 to allow the software to assert the external power-on reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwronrst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_pwronrst_status_prtval(_s + _r, _avail, omap44xx_scrm_extpwronrstctrl_pwronrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit controls the assertion and the de-assertion of the external power-on reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_extwarmrstst_reg_t
 * Description: Implicit type of This register logs the source of warm reset output. Each bit is set upon release of the warm reset output and must be cleared by software. register
 * Fields:
 *   extwarmrstst	(size 1, offset 0, init 0):	RWC	This bit logs the external warm reset source.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_extwarmrstst_reg_t;
#define omap44xx_scrm_extwarmrstst_reg_default 0x0
static inline omap44xx_scrm_extwarmrstst_status_t omap44xx_scrm_extwarmrstst_reg_extwarmrstst_extract(omap44xx_scrm_extwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_extwarmrstst_status_t omap44xx_scrm_extwarmrstst_reg_extwarmrstst_extract(omap44xx_scrm_extwarmrstst_reg_t _regval)
{
    return((omap44xx_scrm_extwarmrstst_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_scrm_extwarmrstst_reg_t omap44xx_scrm_extwarmrstst_reg_extwarmrstst_insert(omap44xx_scrm_extwarmrstst_reg_t _regval, omap44xx_scrm_extwarmrstst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_extwarmrstst_reg_t omap44xx_scrm_extwarmrstst_reg_extwarmrstst_insert(omap44xx_scrm_extwarmrstst_reg_t _regval, omap44xx_scrm_extwarmrstst_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_scrm_extwarmrstst_reg_t )(_fieldval)) << 0)));
}

static inline int omap44xx_scrm_extwarmrstst_reg_prtval(char *_s, size_t _size, omap44xx_scrm_extwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extwarmrstst_reg_prtval(char *_s, size_t _size, omap44xx_scrm_extwarmrstst_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " extwarmrstst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_extwarmrstst_status_prtval(_s + _r, _avail, omap44xx_scrm_extwarmrstst_reg_extwarmrstst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit logs the external warm reset source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_apewarmrstst_reg_t
 * Description: Implicit type of This register logs the source of warm reset on the APE. Each bit is set upon release of the APE warm reset and must be cleared by software. register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   apewarmrstst	(size 1, offset 1, init 0):	RWC	This bit logs the APE warm reset source.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_apewarmrstst_reg_t;
#define omap44xx_scrm_apewarmrstst_reg_default 0x0
static inline omap44xx_scrm_apewarmrstst_status_t omap44xx_scrm_apewarmrstst_reg_apewarmrstst_extract(omap44xx_scrm_apewarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_apewarmrstst_status_t omap44xx_scrm_apewarmrstst_reg_apewarmrstst_extract(omap44xx_scrm_apewarmrstst_reg_t _regval)
{
    return((omap44xx_scrm_apewarmrstst_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_scrm_apewarmrstst_reg_t omap44xx_scrm_apewarmrstst_reg_apewarmrstst_insert(omap44xx_scrm_apewarmrstst_reg_t _regval, omap44xx_scrm_apewarmrstst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_apewarmrstst_reg_t omap44xx_scrm_apewarmrstst_reg_apewarmrstst_insert(omap44xx_scrm_apewarmrstst_reg_t _regval, omap44xx_scrm_apewarmrstst_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_scrm_apewarmrstst_reg_t )(_fieldval)) << 1)));
}

static inline int omap44xx_scrm_apewarmrstst_reg_prtval(char *_s, size_t _size, omap44xx_scrm_apewarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_apewarmrstst_reg_prtval(char *_s, size_t _size, omap44xx_scrm_apewarmrstst_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apewarmrstst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_apewarmrstst_status_prtval(_s + _r, _avail, omap44xx_scrm_apewarmrstst_reg_apewarmrstst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit logs the APE warm reset source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_scrm_c2cwarmrstst_reg_t
 * Description: Implicit type of This register logs the source of warm reset on the external C2C interface. Each bit is set upon release of the external C2C interface warm reset and must be cleared by software. register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   c2cwarmrstst	(size 1, offset 3, init 0):	RWC	This bit logs the C2C warm reset source.
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_scrm_c2cwarmrstst_reg_t;
#define omap44xx_scrm_c2cwarmrstst_reg_default 0x0
static inline omap44xx_scrm_c2cwarmrstst_status_t omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_extract(omap44xx_scrm_c2cwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cwarmrstst_status_t omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_extract(omap44xx_scrm_c2cwarmrstst_reg_t _regval)
{
    return((omap44xx_scrm_c2cwarmrstst_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_scrm_c2cwarmrstst_reg_t omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_insert(omap44xx_scrm_c2cwarmrstst_reg_t _regval, omap44xx_scrm_c2cwarmrstst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cwarmrstst_reg_t omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_insert(omap44xx_scrm_c2cwarmrstst_reg_t _regval, omap44xx_scrm_c2cwarmrstst_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_scrm_c2cwarmrstst_reg_t )(_fieldval)) << 3)));
}

static inline int omap44xx_scrm_c2cwarmrstst_reg_prtval(char *_s, size_t _size, omap44xx_scrm_c2cwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cwarmrstst_reg_prtval(char *_s, size_t _size, omap44xx_scrm_c2cwarmrstst_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c2cwarmrstst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_c2cwarmrstst_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit logs the C2C warm reset source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_scrm_initials {
    omap44xx_scrm_revision_scrm_initial = 0x0,
    omap44xx_scrm_clksetuptime_initial = 0x0,
    omap44xx_scrm_pmicsetuptime_initial = 0x0,
    omap44xx_scrm_altclksrc_initial = 0x0,
    omap44xx_scrm_c2cclkm_initial = 0x0,
    omap44xx_scrm_extclkreq_initial = 0x0,
    omap44xx_scrm_accclkreq_initial = 0x0,
    omap44xx_scrm_pwrreq_initial = 0x0,
    omap44xx_scrm_auxclkreq0_initial = 0x0,
    omap44xx_scrm_auxclkreq1_initial = 0x0,
    omap44xx_scrm_auxclkreq2_initial = 0x0,
    omap44xx_scrm_auxclkreq3_initial = 0x0,
    omap44xx_scrm_auxclkreq4_initial = 0x0,
    omap44xx_scrm_auxclkreq5_initial = 0x0,
    omap44xx_scrm_c2cclkreq_initial = 0x0,
    omap44xx_scrm_auxclk0_initial = 0x0,
    omap44xx_scrm_auxclk1_initial = 0x0,
    omap44xx_scrm_auxclk2_initial = 0x0,
    omap44xx_scrm_auxclk3_initial = 0x0,
    omap44xx_scrm_auxclk4_initial = 0x0,
    omap44xx_scrm_auxclk5_initial = 0x0,
    omap44xx_scrm_rsttime_reg_initial = 0x0,
    omap44xx_scrm_c2crstctrl_initial = 0x0,
    omap44xx_scrm_extpwronrstctrl_initial = 0x0,
    omap44xx_scrm_extwarmrstst_reg_initial = 0x0,
    omap44xx_scrm_apewarmrstst_reg_initial = 0x0,
    omap44xx_scrm_c2cwarmrstst_reg_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_scrm_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_scrm_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register revision_scrm: This register contains the IP revision code for the SCRM.
 * Type: omap44xx_scrm.revision_scrm (Implicit type of This register contains the IP revision code for the SCRM. register)
 *   rev	(size 8, offset 0, init 0):	RO	Revision Number
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_scrm_revision_scrm_t omap44xx_scrm_revision_scrm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_revision_scrm_t omap44xx_scrm_revision_scrm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_scrm_revision_scrm_t omap44xx_scrm_revision_scrm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_revision_scrm_t omap44xx_scrm_revision_scrm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_scrm_revision_scrm_rawwr(__DN(t) *_dev, omap44xx_scrm_revision_scrm_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_revision_scrm_rawwr(__DN(t) *_dev, omap44xx_scrm_revision_scrm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register revision_scrm is not writeable
static inline int omap44xx_scrm_revision_scrm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_revision_scrm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_revision_scrm_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register revision_scrm (This register contains the IP revision code for the SCRM.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev =\t%" PRIx8 "\t(Revision Number)\n", omap44xx_scrm_revision_scrm_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_scrm_revision_scrm_rev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_revision_scrm_rev_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_revision_scrm_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_scrm_revision_scrm_rev_extract(_regval));
}

/*
 * Register clksetuptime: This register holds the clock setup time counters of the system clock source supplier.
 * Type: omap44xx_scrm.clksetuptime (Implicit type of This register holds the clock setup time counters of the system clock source supplier. register)
 *   setuptime	(size 12, offset 0, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to stabilize the clock source supplier.
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   downtime	(size 6, offset 16, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to gate the clock source supplier.
 *   _anon22	(size 10, offset 22, init 0):	MBZ	_
 */
static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clksetuptime_t omap44xx_scrm_clksetuptime_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline void omap44xx_scrm_clksetuptime_rawwr(__DN(t) *_dev, omap44xx_scrm_clksetuptime_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_clksetuptime_rawwr(__DN(t) *_dev, omap44xx_scrm_clksetuptime_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline void omap44xx_scrm_clksetuptime_wr(__DN(t) *_dev, omap44xx_scrm_clksetuptime_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_clksetuptime_wr(__DN(t) *_dev, omap44xx_scrm_clksetuptime_t _regval)
{
    _regval = (_regval & 0x3f0fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline int omap44xx_scrm_clksetuptime_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_clksetuptime_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_clksetuptime_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register clksetuptime (This register holds the clock setup time counters of the system clock source supplier.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " setuptime =\t%" PRIx16 "\t(Holds the number of 32 kHz clock cycles it takes to stabilize the clock source supplier.)\n", omap44xx_scrm_clksetuptime_setuptime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " downtime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles it takes to gate the clock source supplier.)\n", omap44xx_scrm_clksetuptime_downtime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_scrm_clksetuptime_setuptime_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_scrm_clksetuptime_setuptime_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_clksetuptime_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(omap44xx_scrm_clksetuptime_setuptime_extract(_regval));
}

static inline uint8_t omap44xx_scrm_clksetuptime_downtime_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_clksetuptime_downtime_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_clksetuptime_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(omap44xx_scrm_clksetuptime_downtime_extract(_regval));
}

static inline void omap44xx_scrm_clksetuptime_setuptime_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_clksetuptime_setuptime_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_scrm_clksetuptime_t _regval = 0xfff & (((omap44xx_scrm_clksetuptime_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3f0000 & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x3f0fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_clksetuptime_downtime_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_clksetuptime_downtime_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_scrm_clksetuptime_t _regval = 0x3f0000 & (((omap44xx_scrm_clksetuptime_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x3f0fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

/*
 * Register pmicsetuptime: This register holds the setup time counters for the sleep mode of the clock-source generator power supply (the power supply in external connected PMIC or LDO).
 * Type: omap44xx_scrm.pmicsetuptime (Implicit type of This register holds the setup time counters for the sleep mode of the clock-source generator power supply (the power supply in external connected PMIC or LDO). register)
 *   sleeptime	(size 6, offset 0, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to enter the clock source generator power supply in sleep mode. SCRM activates Sleep-time counter by deactivation of power request.
 *   _anon6	(size 10, offset 6, init 0):	MBZ	_
 *   wakeuptime	(size 6, offset 16, init 0):	RW	Holds the number of 32 kHz clock cycles it takes to exit the clock-source generator power supply from sleep mode. SCRM starts Wakeup-time counter by activation of power request.
 *   _anon22	(size 10, offset 22, init 0):	MBZ	_
 */
static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x104));
}

static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_pmicsetuptime_t omap44xx_scrm_pmicsetuptime_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x104));
}

static inline void omap44xx_scrm_pmicsetuptime_rawwr(__DN(t) *_dev, omap44xx_scrm_pmicsetuptime_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pmicsetuptime_rawwr(__DN(t) *_dev, omap44xx_scrm_pmicsetuptime_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
}

static inline void omap44xx_scrm_pmicsetuptime_wr(__DN(t) *_dev, omap44xx_scrm_pmicsetuptime_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pmicsetuptime_wr(__DN(t) *_dev, omap44xx_scrm_pmicsetuptime_t _regval)
{
    _regval = (_regval & 0x3f003f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
}

static inline int omap44xx_scrm_pmicsetuptime_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_pmicsetuptime_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_pmicsetuptime_t _regval = mackerel_read_addr_32(_dev->base, 0x104);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pmicsetuptime (This register holds the setup time counters for the sleep mode of the clock-source generator power supply (the power supply in external connected PMIC or LDO).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sleeptime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles it takes to enter the clock source generator power supply in sleep mode. SCRM activates Sleep-time counter by deactivation of power request.)\n", omap44xx_scrm_pmicsetuptime_sleeptime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wakeuptime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles it takes to exit the clock-source generator power supply from sleep mode. SCRM starts Wakeup-time counter by activation of power request.)\n", omap44xx_scrm_pmicsetuptime_wakeuptime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_scrm_pmicsetuptime_sleeptime_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_pmicsetuptime_sleeptime_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_pmicsetuptime_t _regval = mackerel_read_addr_32(_dev->base, 0x104);
    return(omap44xx_scrm_pmicsetuptime_sleeptime_extract(_regval));
}

static inline uint8_t omap44xx_scrm_pmicsetuptime_wakeuptime_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_pmicsetuptime_wakeuptime_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_pmicsetuptime_t _regval = mackerel_read_addr_32(_dev->base, 0x104);
    return(omap44xx_scrm_pmicsetuptime_wakeuptime_extract(_regval));
}

static inline void omap44xx_scrm_pmicsetuptime_sleeptime_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pmicsetuptime_sleeptime_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_scrm_pmicsetuptime_t _regval = 0x3f & (((omap44xx_scrm_pmicsetuptime_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3f0000 & mackerel_read_addr_32(_dev->base, 0x104)));
    // No read of register shadow required
    _regval = (_regval & 0x3f003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_pmicsetuptime_wakeuptime_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pmicsetuptime_wakeuptime_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_scrm_pmicsetuptime_t _regval = 0x3f0000 & (((omap44xx_scrm_pmicsetuptime_t )(_fieldval)) << 16);
    _regval = (_regval | (0x3f & mackerel_read_addr_32(_dev->base, 0x104)));
    // No read of register shadow required
    _regval = (_regval & 0x3f003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
    // No shadow register to write to
}

/*
 * Register altclksrc: This register controls the alternate system clock source supplier.
 * Type: omap44xx_scrm.altclksrc (Implicit type of This register controls the alternate system clock source supplier. register)
 *   mode	(size 2, offset 0, init 0):	RW	This bit field defines the functional mode of the alternate system clock supplier.
 *   enable_int	(size 1, offset 2, init 0):	RW	This bit allows to enable and disable the alternate system clock version used to generate the auxiliary clocks. This bit is intended to be used in order to gate this clock path while the source is stabilizing and also to gate this clock path while switching the auxiliary clock paths on / from this possible source.
 *   enable_ext	(size 1, offset 3, init 0):	RW	This bit allows to enable and disable the output alternate system clock version. This bit is intended to be used in order to gate this clock path while the source is stabilizing.
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110));
}

static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_altclksrc_t omap44xx_scrm_altclksrc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110));
}

static inline void omap44xx_scrm_altclksrc_rawwr(__DN(t) *_dev, omap44xx_scrm_altclksrc_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_altclksrc_rawwr(__DN(t) *_dev, omap44xx_scrm_altclksrc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
}

static inline void omap44xx_scrm_altclksrc_wr(__DN(t) *_dev, omap44xx_scrm_altclksrc_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_altclksrc_wr(__DN(t) *_dev, omap44xx_scrm_altclksrc_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
}

static inline int omap44xx_scrm_altclksrc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_altclksrc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_altclksrc_t _regval = mackerel_read_addr_32(_dev->base, 0x110);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register altclksrc (This register controls the alternate system clock source supplier.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_altclksrc_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit field defines the functional mode of the alternate system clock supplier.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable_int =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_enable_ext_status_prtval(_s + _r, _avail, omap44xx_scrm_altclksrc_enable_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the alternate system clock version used to generate the auxiliary clocks. This bit is intended to be used in order to gate this clock path while the source is stabilizing and also to gate this clock path while switching the auxiliary clock paths on / from this possible source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable_ext =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_enable_ext_status_prtval(_s + _r, _avail, omap44xx_scrm_altclksrc_enable_ext_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the output alternate system clock version. This bit is intended to be used in order to gate this clock path while the source is stabilizing.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_altclksrc_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_altclksrc_mode_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_altclksrc_t _regval = mackerel_read_addr_32(_dev->base, 0x110);
    return(omap44xx_scrm_altclksrc_mode_extract(_regval));
}

static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_int_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_int_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_altclksrc_t _regval = mackerel_read_addr_32(_dev->base, 0x110);
    return(omap44xx_scrm_altclksrc_enable_int_extract(_regval));
}

static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_ext_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_enable_ext_status_t omap44xx_scrm_altclksrc_enable_ext_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_altclksrc_t _regval = mackerel_read_addr_32(_dev->base, 0x110);
    return(omap44xx_scrm_altclksrc_enable_ext_extract(_regval));
}

static inline void omap44xx_scrm_altclksrc_mode_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_altclksrc_mode_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_altclksrc_t _regval = 0x3 & (((omap44xx_scrm_altclksrc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xc & mackerel_read_addr_32(_dev->base, 0x110)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_altclksrc_enable_int_wrf(__DN(t) *_dev, omap44xx_scrm_enable_ext_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_altclksrc_enable_int_wrf(__DN(t) *_dev, omap44xx_scrm_enable_ext_status_t _fieldval)
{
    omap44xx_scrm_altclksrc_t _regval = 0x4 & (((omap44xx_scrm_altclksrc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xb & mackerel_read_addr_32(_dev->base, 0x110)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_altclksrc_enable_ext_wrf(__DN(t) *_dev, omap44xx_scrm_enable_ext_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_altclksrc_enable_ext_wrf(__DN(t) *_dev, omap44xx_scrm_enable_ext_status_t _fieldval)
{
    omap44xx_scrm_altclksrc_t _regval = 0x8 & (((omap44xx_scrm_altclksrc_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7 & mackerel_read_addr_32(_dev->base, 0x110)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
    // No shadow register to write to
}

/*
 * Register c2cclkm: This register controls the clocks of the external C2C interface.
 * Type: omap44xx_scrm.c2cclkm (Implicit type of This register controls the clocks of the external C2C interface. register)
 *   clk_32khz	(size 1, offset 0, init 0):	RW	This bit allows to enable and disable the 32 kHz clock version of the external C2C interface.
 *   sysclk	(size 1, offset 1, init 0):	RW	This bit allows to enable and disable the system clock version of the external C2C interface.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11c));
}

static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkm_t omap44xx_scrm_c2cclkm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11c));
}

static inline void omap44xx_scrm_c2cclkm_rawwr(__DN(t) *_dev, omap44xx_scrm_c2cclkm_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkm_rawwr(__DN(t) *_dev, omap44xx_scrm_c2cclkm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
}

static inline void omap44xx_scrm_c2cclkm_wr(__DN(t) *_dev, omap44xx_scrm_c2cclkm_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkm_wr(__DN(t) *_dev, omap44xx_scrm_c2cclkm_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
}

static inline int omap44xx_scrm_c2cclkm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cclkm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_c2cclkm_t _regval = mackerel_read_addr_32(_dev->base, 0x11c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register c2cclkm (This register controls the clocks of the external C2C interface.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clk_32khz =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkm_clk_32khz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the 32 kHz clock version of the external C2C interface.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkm_sysclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable and disable the system clock version of the external C2C interface.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_clk_32khz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_clk_32khz_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2cclkm_t _regval = mackerel_read_addr_32(_dev->base, 0x11c);
    return(omap44xx_scrm_c2cclkm_clk_32khz_extract(_regval));
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_sysclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkm_sysclk_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2cclkm_t _regval = mackerel_read_addr_32(_dev->base, 0x11c);
    return(omap44xx_scrm_c2cclkm_sysclk_extract(_regval));
}

static inline void omap44xx_scrm_c2cclkm_clk_32khz_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkm_clk_32khz_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval)
{
    omap44xx_scrm_c2cclkm_t _regval = 0x1 & (((omap44xx_scrm_c2cclkm_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x11c)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_c2cclkm_sysclk_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkm_sysclk_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval)
{
    omap44xx_scrm_c2cclkm_t _regval = 0x2 & (((omap44xx_scrm_c2cclkm_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x11c)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
    // No shadow register to write to
}

/*
 * Register extclkreq: This register holds qualifiers for the external clock request.
 * Type: omap44xx_scrm.extclkreq (Implicit type of This register holds qualifiers for the external clock request. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the external clock request.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_scrm_extclkreq_t omap44xx_scrm_extclkreq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extclkreq_t omap44xx_scrm_extclkreq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline omap44xx_scrm_extclkreq_t omap44xx_scrm_extclkreq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extclkreq_t omap44xx_scrm_extclkreq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline void omap44xx_scrm_extclkreq_rawwr(__DN(t) *_dev, omap44xx_scrm_extclkreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extclkreq_rawwr(__DN(t) *_dev, omap44xx_scrm_extclkreq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

static inline void omap44xx_scrm_extclkreq_wr(__DN(t) *_dev, omap44xx_scrm_extclkreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extclkreq_wr(__DN(t) *_dev, omap44xx_scrm_extclkreq_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

static inline int omap44xx_scrm_extclkreq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extclkreq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_extclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register extclkreq (This register holds qualifiers for the external clock request.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_extclkreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the external clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extclkreq_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extclkreq_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_extclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(omap44xx_scrm_extclkreq_polarity_extract(_regval));
}

static inline void omap44xx_scrm_extclkreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extclkreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_extclkreq_t _regval = 0x1 & (((omap44xx_scrm_extclkreq_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

/*
 * Register accclkreq: This register holds qualifiers for the accurate clock request.
 * Type: omap44xx_scrm.accclkreq (Implicit type of This register holds qualifiers for the accurate clock request. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the accurate clock request.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_scrm_accclkreq_t omap44xx_scrm_accclkreq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_accclkreq_t omap44xx_scrm_accclkreq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x204));
}

static inline omap44xx_scrm_accclkreq_t omap44xx_scrm_accclkreq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_accclkreq_t omap44xx_scrm_accclkreq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x204));
}

static inline void omap44xx_scrm_accclkreq_rawwr(__DN(t) *_dev, omap44xx_scrm_accclkreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_accclkreq_rawwr(__DN(t) *_dev, omap44xx_scrm_accclkreq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x204, _regval);
}

static inline void omap44xx_scrm_accclkreq_wr(__DN(t) *_dev, omap44xx_scrm_accclkreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_accclkreq_wr(__DN(t) *_dev, omap44xx_scrm_accclkreq_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x204, _regval);
}

static inline int omap44xx_scrm_accclkreq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_accclkreq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_accclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register accclkreq (This register holds qualifiers for the accurate clock request.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_accclkreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_accclkreq_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_accclkreq_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_accclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    return(omap44xx_scrm_accclkreq_polarity_extract(_regval));
}

static inline void omap44xx_scrm_accclkreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_accclkreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_accclkreq_t _regval = 0x1 & (((omap44xx_scrm_accclkreq_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x204, _regval);
    // No shadow register to write to
}

/*
 * Register pwrreq: This register holds qualifiers for the external power request.
 * Type: omap44xx_scrm.pwrreq (Implicit type of This register holds qualifiers for the external power request. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the external power request.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_scrm_pwrreq_t omap44xx_scrm_pwrreq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_pwrreq_t omap44xx_scrm_pwrreq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x208));
}

static inline omap44xx_scrm_pwrreq_t omap44xx_scrm_pwrreq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_pwrreq_t omap44xx_scrm_pwrreq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x208));
}

static inline void omap44xx_scrm_pwrreq_rawwr(__DN(t) *_dev, omap44xx_scrm_pwrreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pwrreq_rawwr(__DN(t) *_dev, omap44xx_scrm_pwrreq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x208, _regval);
}

static inline void omap44xx_scrm_pwrreq_wr(__DN(t) *_dev, omap44xx_scrm_pwrreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pwrreq_wr(__DN(t) *_dev, omap44xx_scrm_pwrreq_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x208, _regval);
}

static inline int omap44xx_scrm_pwrreq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_pwrreq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_pwrreq_t _regval = mackerel_read_addr_32(_dev->base, 0x208);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pwrreq (This register holds qualifiers for the external power request.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_pwrreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the external power request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_pwrreq_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_pwrreq_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_pwrreq_t _regval = mackerel_read_addr_32(_dev->base, 0x208);
    return(omap44xx_scrm_pwrreq_polarity_extract(_regval));
}

static inline void omap44xx_scrm_pwrreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_pwrreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_pwrreq_t _regval = 0x1 & (((omap44xx_scrm_pwrreq_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x208, _regval);
    // No shadow register to write to
}

/*
 * Register auxclkreq0: This register holds qualifiers for the auxiliary clock request #0.
 * Type: omap44xx_scrm.auxclkreq0 (Implicit type of This register holds qualifiers for the auxiliary clock request #0. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #0.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #0 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #0 on another auxiliary clock output than auxiliary clock #0.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x210));
}

static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq0_t omap44xx_scrm_auxclkreq0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x210));
}

static inline void omap44xx_scrm_auxclkreq0_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq0_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
}

static inline void omap44xx_scrm_auxclkreq0_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq0_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq0_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
}

static inline int omap44xx_scrm_auxclkreq0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclkreq0_t _regval = mackerel_read_addr_32(_dev->base, 0x210);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclkreq0 (This register holds qualifiers for the auxiliary clock request #0.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq0_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq0_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #0 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq0_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #0 on another auxiliary clock output than auxiliary clock #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq0_t _regval = mackerel_read_addr_32(_dev->base, 0x210);
    return(omap44xx_scrm_auxclkreq0_polarity_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq0_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq0_t _regval = mackerel_read_addr_32(_dev->base, 0x210);
    return(omap44xx_scrm_auxclkreq0_accuracy_extract(_regval));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq0_mapping_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq0_mapping_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq0_t _regval = mackerel_read_addr_32(_dev->base, 0x210);
    return(omap44xx_scrm_auxclkreq0_mapping_extract(_regval));
}

static inline void omap44xx_scrm_auxclkreq0_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq0_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq0_t _regval = 0x1 & (((omap44xx_scrm_auxclkreq0_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x210)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq0_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq0_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq0_t _regval = 0x2 & (((omap44xx_scrm_auxclkreq0_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x210)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq0_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq0_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq0_t _regval = 0x1c & (((omap44xx_scrm_auxclkreq0_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x210)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
    // No shadow register to write to
}

/*
 * Register auxclkreq1: This register holds qualifiers for the auxiliary clock request #1.
 * Type: omap44xx_scrm.auxclkreq1 (Implicit type of This register holds qualifiers for the auxiliary clock request #1. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #1.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #1 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #1 on another auxiliary clock output than auxiliary clock #1.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x214));
}

static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq1_t omap44xx_scrm_auxclkreq1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x214));
}

static inline void omap44xx_scrm_auxclkreq1_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq1_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
}

static inline void omap44xx_scrm_auxclkreq1_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq1_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq1_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
}

static inline int omap44xx_scrm_auxclkreq1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclkreq1_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclkreq1 (This register holds qualifiers for the auxiliary clock request #1.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq1_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq1_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #1 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq1_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #1 on another auxiliary clock output than auxiliary clock #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq1_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    return(omap44xx_scrm_auxclkreq1_polarity_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq1_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq1_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    return(omap44xx_scrm_auxclkreq1_accuracy_extract(_regval));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq1_mapping_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq1_mapping_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq1_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    return(omap44xx_scrm_auxclkreq1_mapping_extract(_regval));
}

static inline void omap44xx_scrm_auxclkreq1_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq1_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq1_t _regval = 0x1 & (((omap44xx_scrm_auxclkreq1_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x214)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq1_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq1_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq1_t _regval = 0x2 & (((omap44xx_scrm_auxclkreq1_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x214)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq1_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq1_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq1_t _regval = 0x1c & (((omap44xx_scrm_auxclkreq1_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x214)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
    // No shadow register to write to
}

/*
 * Register auxclkreq2: This register holds qualifiers for the auxiliary clock request #2.
 * Type: omap44xx_scrm.auxclkreq2 (Implicit type of This register holds qualifiers for the auxiliary clock request #2. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #2.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #2 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #2 on another auxiliary clock output than auxiliary clock #2.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x218));
}

static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq2_t omap44xx_scrm_auxclkreq2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x218));
}

static inline void omap44xx_scrm_auxclkreq2_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq2_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
}

static inline void omap44xx_scrm_auxclkreq2_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq2_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq2_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
}

static inline int omap44xx_scrm_auxclkreq2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclkreq2_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclkreq2 (This register holds qualifiers for the auxiliary clock request #2.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq2_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq2_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #2 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq2_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #2 on another auxiliary clock output than auxiliary clock #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq2_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    return(omap44xx_scrm_auxclkreq2_polarity_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq2_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq2_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    return(omap44xx_scrm_auxclkreq2_accuracy_extract(_regval));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq2_mapping_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq2_mapping_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq2_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    return(omap44xx_scrm_auxclkreq2_mapping_extract(_regval));
}

static inline void omap44xx_scrm_auxclkreq2_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq2_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq2_t _regval = 0x1 & (((omap44xx_scrm_auxclkreq2_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x218)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq2_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq2_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq2_t _regval = 0x2 & (((omap44xx_scrm_auxclkreq2_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x218)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq2_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq2_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq2_t _regval = 0x1c & (((omap44xx_scrm_auxclkreq2_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x218)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
    // No shadow register to write to
}

/*
 * Register auxclkreq3: This register holds qualifiers for the auxiliary clock request #3.
 * Type: omap44xx_scrm.auxclkreq3 (Implicit type of This register holds qualifiers for the auxiliary clock request #3. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #3.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #3 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #3 on another auxiliary clock output than auxiliary clock #3.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x21c));
}

static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq3_t omap44xx_scrm_auxclkreq3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x21c));
}

static inline void omap44xx_scrm_auxclkreq3_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq3_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
}

static inline void omap44xx_scrm_auxclkreq3_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq3_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq3_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
}

static inline int omap44xx_scrm_auxclkreq3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclkreq3_t _regval = mackerel_read_addr_32(_dev->base, 0x21c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclkreq3 (This register holds qualifiers for the auxiliary clock request #3.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq3_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq3_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #3 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq3_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #3 on another auxiliary clock output than auxiliary clock #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq3_t _regval = mackerel_read_addr_32(_dev->base, 0x21c);
    return(omap44xx_scrm_auxclkreq3_polarity_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq3_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq3_t _regval = mackerel_read_addr_32(_dev->base, 0x21c);
    return(omap44xx_scrm_auxclkreq3_accuracy_extract(_regval));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq3_mapping_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq3_mapping_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq3_t _regval = mackerel_read_addr_32(_dev->base, 0x21c);
    return(omap44xx_scrm_auxclkreq3_mapping_extract(_regval));
}

static inline void omap44xx_scrm_auxclkreq3_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq3_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq3_t _regval = 0x1 & (((omap44xx_scrm_auxclkreq3_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x21c)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq3_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq3_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq3_t _regval = 0x2 & (((omap44xx_scrm_auxclkreq3_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x21c)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq3_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq3_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq3_t _regval = 0x1c & (((omap44xx_scrm_auxclkreq3_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x21c)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
    // No shadow register to write to
}

/*
 * Register auxclkreq4: This register holds qualifiers for the auxiliary clock request #4.
 * Type: omap44xx_scrm.auxclkreq4 (Implicit type of This register holds qualifiers for the auxiliary clock request #4. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #4.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #4 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #4 on another auxiliary clock output than auxiliary clock #4.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x220));
}

static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq4_t omap44xx_scrm_auxclkreq4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x220));
}

static inline void omap44xx_scrm_auxclkreq4_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq4_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq4_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq4_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
}

static inline void omap44xx_scrm_auxclkreq4_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq4_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq4_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq4_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
}

static inline int omap44xx_scrm_auxclkreq4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclkreq4_t _regval = mackerel_read_addr_32(_dev->base, 0x220);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclkreq4 (This register holds qualifiers for the auxiliary clock request #4.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq4_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq4_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #4 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq4_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #4 on another auxiliary clock output than auxiliary clock #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq4_t _regval = mackerel_read_addr_32(_dev->base, 0x220);
    return(omap44xx_scrm_auxclkreq4_polarity_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq4_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq4_t _regval = mackerel_read_addr_32(_dev->base, 0x220);
    return(omap44xx_scrm_auxclkreq4_accuracy_extract(_regval));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq4_mapping_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq4_mapping_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq4_t _regval = mackerel_read_addr_32(_dev->base, 0x220);
    return(omap44xx_scrm_auxclkreq4_mapping_extract(_regval));
}

static inline void omap44xx_scrm_auxclkreq4_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq4_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq4_t _regval = 0x1 & (((omap44xx_scrm_auxclkreq4_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x220)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq4_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq4_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq4_t _regval = 0x2 & (((omap44xx_scrm_auxclkreq4_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x220)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq4_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq4_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq4_t _regval = 0x1c & (((omap44xx_scrm_auxclkreq4_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x220)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
    // No shadow register to write to
}

/*
 * Register auxclkreq5: This register holds qualifiers for the auxiliary clock request #5.
 * Type: omap44xx_scrm.auxclkreq5 (Implicit type of This register holds qualifiers for the auxiliary clock request #5. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the auxiliary clock request #5.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the auxiliary clock request #5 as an accurate clock request.
 *   mapping	(size 3, offset 2, init 0):	RW	This field allows re-mapping the auxiliary clock request #5 on another auxiliary clock output than auxiliary clock #5.
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x224));
}

static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclkreq5_t omap44xx_scrm_auxclkreq5_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x224));
}

static inline void omap44xx_scrm_auxclkreq5_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq5_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq5_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclkreq5_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
}

static inline void omap44xx_scrm_auxclkreq5_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq5_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq5_wr(__DN(t) *_dev, omap44xx_scrm_auxclkreq5_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
}

static inline int omap44xx_scrm_auxclkreq5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclkreq5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclkreq5_t _regval = mackerel_read_addr_32(_dev->base, 0x224);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclkreq5 (This register holds qualifiers for the auxiliary clock request #5.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq5_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the auxiliary clock request #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq5_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the auxiliary clock request #5 as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mapping =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mapping_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclkreq5_mapping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows re-mapping the auxiliary clock request #5 on another auxiliary clock output than auxiliary clock #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq5_t _regval = mackerel_read_addr_32(_dev->base, 0x224);
    return(omap44xx_scrm_auxclkreq5_polarity_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclkreq5_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq5_t _regval = mackerel_read_addr_32(_dev->base, 0x224);
    return(omap44xx_scrm_auxclkreq5_accuracy_extract(_regval));
}

static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq5_mapping_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mapping_status_t omap44xx_scrm_auxclkreq5_mapping_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclkreq5_t _regval = mackerel_read_addr_32(_dev->base, 0x224);
    return(omap44xx_scrm_auxclkreq5_mapping_extract(_regval));
}

static inline void omap44xx_scrm_auxclkreq5_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq5_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq5_t _regval = 0x1 & (((omap44xx_scrm_auxclkreq5_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x224)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq5_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq5_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq5_t _regval = 0x2 & (((omap44xx_scrm_auxclkreq5_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x224)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclkreq5_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclkreq5_mapping_wrf(__DN(t) *_dev, omap44xx_scrm_mapping_status_t _fieldval)
{
    omap44xx_scrm_auxclkreq5_t _regval = 0x1c & (((omap44xx_scrm_auxclkreq5_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x224)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
    // No shadow register to write to
}

/*
 * Register c2cclkreq: This register holds qualifiers for the external C2C interface clock request.
 * Type: omap44xx_scrm.c2cclkreq (Implicit type of This register holds qualifiers for the external C2C interface clock request. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the active level of the external C2C interface clock request.
 *   accuracy	(size 1, offset 1, init 0):	RW	This bit qualifies the external C2C interface clock request as an accurate clock request.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x234));
}

static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cclkreq_t omap44xx_scrm_c2cclkreq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x234));
}

static inline void omap44xx_scrm_c2cclkreq_rawwr(__DN(t) *_dev, omap44xx_scrm_c2cclkreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkreq_rawwr(__DN(t) *_dev, omap44xx_scrm_c2cclkreq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x234, _regval);
}

static inline void omap44xx_scrm_c2cclkreq_wr(__DN(t) *_dev, omap44xx_scrm_c2cclkreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkreq_wr(__DN(t) *_dev, omap44xx_scrm_c2cclkreq_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x234, _regval);
}

static inline int omap44xx_scrm_c2cclkreq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cclkreq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_c2cclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x234);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register c2cclkreq (This register holds qualifiers for the external C2C interface clock request.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkreq_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the active level of the external C2C interface clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accuracy =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cclkreq_accuracy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit qualifies the external C2C interface clock request as an accurate clock request.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2cclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x234);
    return(omap44xx_scrm_c2cclkreq_polarity_extract(_regval));
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_accuracy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2cclkreq_accuracy_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2cclkreq_t _regval = mackerel_read_addr_32(_dev->base, 0x234);
    return(omap44xx_scrm_c2cclkreq_accuracy_extract(_regval));
}

static inline void omap44xx_scrm_c2cclkreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkreq_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval)
{
    omap44xx_scrm_c2cclkreq_t _regval = 0x1 & (((omap44xx_scrm_c2cclkreq_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x234)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x234, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_c2cclkreq_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cclkreq_accuracy_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval)
{
    omap44xx_scrm_c2cclkreq_t _regval = 0x2 & (((omap44xx_scrm_c2cclkreq_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x234)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x234, _regval);
    // No shadow register to write to
}

/*
 * Register auxclk0: This register holds qualifiers for the auxiliary clock #0.
 * Type: omap44xx_scrm.auxclk0 (Implicit type of This register holds qualifiers for the auxiliary clock #0. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #0 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #0.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #0 by software.
 *   disableclk	(size 1, offset 9, init 0):	RW	This bit allows to gate the auxiliary clock #0 without condition. This is bit is intended to be used only when the SOC is not clock provider.
 *   _anon10	(size 6, offset 10, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #0.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x310));
}

static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk0_t omap44xx_scrm_auxclk0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x310));
}

static inline void omap44xx_scrm_auxclk0_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
}

static inline void omap44xx_scrm_auxclk0_wr(__DN(t) *_dev, omap44xx_scrm_auxclk0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_wr(__DN(t) *_dev, omap44xx_scrm_auxclk0_t _regval)
{
    _regval = (_regval & 0xf0307);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
}

static inline int omap44xx_scrm_auxclk0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclk0_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclk0 (This register holds qualifiers for the auxiliary clock #0.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #0 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #0 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " disableclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_disableclk_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_disableclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to gate the auxiliary clock #0 without condition. This is bit is intended to be used only when the SOC is not clock provider.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk0_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline omap44xx_scrm_polarity_status_t omap44xx_scrm_auxclk0_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status_t omap44xx_scrm_auxclk0_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk0_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    return(omap44xx_scrm_auxclk0_polarity_extract(_regval));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk0_srcselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk0_srcselect_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk0_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    return(omap44xx_scrm_auxclk0_srcselect_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk0_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk0_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk0_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    return(omap44xx_scrm_auxclk0_enable_extract(_regval));
}

static inline omap44xx_scrm_disableclk_status_t omap44xx_scrm_auxclk0_disableclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_disableclk_status_t omap44xx_scrm_auxclk0_disableclk_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk0_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    return(omap44xx_scrm_auxclk0_disableclk_extract(_regval));
}

static inline omap44xx_scrm_clkdiv_status_t omap44xx_scrm_auxclk0_clkdiv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status_t omap44xx_scrm_auxclk0_clkdiv_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk0_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    return(omap44xx_scrm_auxclk0_clkdiv_extract(_regval));
}

static inline void omap44xx_scrm_auxclk0_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status_t _fieldval)
{
    omap44xx_scrm_auxclk0_t _regval = 0x1 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0306 & mackerel_read_addr_32(_dev->base, 0x310)));
    // No read of register shadow required
    _regval = (_regval & 0xf0307);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk0_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval)
{
    omap44xx_scrm_auxclk0_t _regval = 0x6 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf0301 & mackerel_read_addr_32(_dev->base, 0x310)));
    // No read of register shadow required
    _regval = (_regval & 0xf0307);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk0_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclk0_t _regval = 0x100 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0207 & mackerel_read_addr_32(_dev->base, 0x310)));
    // No read of register shadow required
    _regval = (_regval & 0xf0307);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk0_disableclk_wrf(__DN(t) *_dev, omap44xx_scrm_disableclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_disableclk_wrf(__DN(t) *_dev, omap44xx_scrm_disableclk_status_t _fieldval)
{
    omap44xx_scrm_auxclk0_t _regval = 0x200 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 9);
    _regval = (_regval | (0xf0107 & mackerel_read_addr_32(_dev->base, 0x310)));
    // No read of register shadow required
    _regval = (_regval & 0xf0307);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk0_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk0_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status_t _fieldval)
{
    omap44xx_scrm_auxclk0_t _regval = 0xf0000 & (((omap44xx_scrm_auxclk0_t )(_fieldval)) << 16);
    _regval = (_regval | (0x307 & mackerel_read_addr_32(_dev->base, 0x310)));
    // No read of register shadow required
    _regval = (_regval & 0xf0307);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
    // No shadow register to write to
}

/*
 * Register auxclk1: This register holds qualifiers for the auxiliary clock #1.
 * Type: omap44xx_scrm.auxclk1 (Implicit type of This register holds qualifiers for the auxiliary clock #1. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #1 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #1.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #1 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #1.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x314));
}

static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk1_t omap44xx_scrm_auxclk1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x314));
}

static inline void omap44xx_scrm_auxclk1_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk1_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
}

static inline void omap44xx_scrm_auxclk1_wr(__DN(t) *_dev, omap44xx_scrm_auxclk1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk1_wr(__DN(t) *_dev, omap44xx_scrm_auxclk1_t _regval)
{
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
}

static inline int omap44xx_scrm_auxclk1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclk1_t _regval = mackerel_read_addr_32(_dev->base, 0x314);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclk1 (This register holds qualifiers for the auxiliary clock #1.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status1_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #1 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #1 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status1_prtval(_s + _r, _avail, omap44xx_scrm_auxclk1_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline omap44xx_scrm_polarity_status1_t omap44xx_scrm_auxclk1_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status1_t omap44xx_scrm_auxclk1_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk1_t _regval = mackerel_read_addr_32(_dev->base, 0x314);
    return(omap44xx_scrm_auxclk1_polarity_extract(_regval));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk1_srcselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk1_srcselect_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk1_t _regval = mackerel_read_addr_32(_dev->base, 0x314);
    return(omap44xx_scrm_auxclk1_srcselect_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk1_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk1_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk1_t _regval = mackerel_read_addr_32(_dev->base, 0x314);
    return(omap44xx_scrm_auxclk1_enable_extract(_regval));
}

static inline omap44xx_scrm_clkdiv_status1_t omap44xx_scrm_auxclk1_clkdiv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status1_t omap44xx_scrm_auxclk1_clkdiv_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk1_t _regval = mackerel_read_addr_32(_dev->base, 0x314);
    return(omap44xx_scrm_auxclk1_clkdiv_extract(_regval));
}

static inline void omap44xx_scrm_auxclk1_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk1_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status1_t _fieldval)
{
    omap44xx_scrm_auxclk1_t _regval = 0x1 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0106 & mackerel_read_addr_32(_dev->base, 0x314)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk1_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk1_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval)
{
    omap44xx_scrm_auxclk1_t _regval = 0x6 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf0101 & mackerel_read_addr_32(_dev->base, 0x314)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk1_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk1_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclk1_t _regval = 0x100 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0007 & mackerel_read_addr_32(_dev->base, 0x314)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk1_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk1_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status1_t _fieldval)
{
    omap44xx_scrm_auxclk1_t _regval = 0xf0000 & (((omap44xx_scrm_auxclk1_t )(_fieldval)) << 16);
    _regval = (_regval | (0x107 & mackerel_read_addr_32(_dev->base, 0x314)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
    // No shadow register to write to
}

/*
 * Register auxclk2: This register holds qualifiers for the auxiliary clock #2.
 * Type: omap44xx_scrm.auxclk2 (Implicit type of This register holds qualifiers for the auxiliary clock #2. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #2 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #2.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #2 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #2.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x318));
}

static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk2_t omap44xx_scrm_auxclk2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x318));
}

static inline void omap44xx_scrm_auxclk2_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk2_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
}

static inline void omap44xx_scrm_auxclk2_wr(__DN(t) *_dev, omap44xx_scrm_auxclk2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk2_wr(__DN(t) *_dev, omap44xx_scrm_auxclk2_t _regval)
{
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
}

static inline int omap44xx_scrm_auxclk2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclk2_t _regval = mackerel_read_addr_32(_dev->base, 0x318);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclk2 (This register holds qualifiers for the auxiliary clock #2.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status2_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #2 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #2 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status2_prtval(_s + _r, _avail, omap44xx_scrm_auxclk2_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #2.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline omap44xx_scrm_polarity_status2_t omap44xx_scrm_auxclk2_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status2_t omap44xx_scrm_auxclk2_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk2_t _regval = mackerel_read_addr_32(_dev->base, 0x318);
    return(omap44xx_scrm_auxclk2_polarity_extract(_regval));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk2_srcselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk2_srcselect_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk2_t _regval = mackerel_read_addr_32(_dev->base, 0x318);
    return(omap44xx_scrm_auxclk2_srcselect_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk2_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk2_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk2_t _regval = mackerel_read_addr_32(_dev->base, 0x318);
    return(omap44xx_scrm_auxclk2_enable_extract(_regval));
}

static inline omap44xx_scrm_clkdiv_status2_t omap44xx_scrm_auxclk2_clkdiv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status2_t omap44xx_scrm_auxclk2_clkdiv_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk2_t _regval = mackerel_read_addr_32(_dev->base, 0x318);
    return(omap44xx_scrm_auxclk2_clkdiv_extract(_regval));
}

static inline void omap44xx_scrm_auxclk2_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk2_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status2_t _fieldval)
{
    omap44xx_scrm_auxclk2_t _regval = 0x1 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0106 & mackerel_read_addr_32(_dev->base, 0x318)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk2_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk2_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval)
{
    omap44xx_scrm_auxclk2_t _regval = 0x6 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf0101 & mackerel_read_addr_32(_dev->base, 0x318)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk2_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk2_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclk2_t _regval = 0x100 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0007 & mackerel_read_addr_32(_dev->base, 0x318)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk2_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk2_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status2_t _fieldval)
{
    omap44xx_scrm_auxclk2_t _regval = 0xf0000 & (((omap44xx_scrm_auxclk2_t )(_fieldval)) << 16);
    _regval = (_regval | (0x107 & mackerel_read_addr_32(_dev->base, 0x318)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
    // No shadow register to write to
}

/*
 * Register auxclk3: This register holds qualifiers for the auxiliary clock #3.
 * Type: omap44xx_scrm.auxclk3 (Implicit type of This register holds qualifiers for the auxiliary clock #3. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #3 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #3.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #3 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #3.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x31c));
}

static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk3_t omap44xx_scrm_auxclk3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x31c));
}

static inline void omap44xx_scrm_auxclk3_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk3_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
}

static inline void omap44xx_scrm_auxclk3_wr(__DN(t) *_dev, omap44xx_scrm_auxclk3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk3_wr(__DN(t) *_dev, omap44xx_scrm_auxclk3_t _regval)
{
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
}

static inline int omap44xx_scrm_auxclk3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclk3_t _regval = mackerel_read_addr_32(_dev->base, 0x31c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclk3 (This register holds qualifiers for the auxiliary clock #3.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status3_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #3 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #3 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status3_prtval(_s + _r, _avail, omap44xx_scrm_auxclk3_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #3.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline omap44xx_scrm_polarity_status3_t omap44xx_scrm_auxclk3_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status3_t omap44xx_scrm_auxclk3_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk3_t _regval = mackerel_read_addr_32(_dev->base, 0x31c);
    return(omap44xx_scrm_auxclk3_polarity_extract(_regval));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk3_srcselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk3_srcselect_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk3_t _regval = mackerel_read_addr_32(_dev->base, 0x31c);
    return(omap44xx_scrm_auxclk3_srcselect_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk3_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk3_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk3_t _regval = mackerel_read_addr_32(_dev->base, 0x31c);
    return(omap44xx_scrm_auxclk3_enable_extract(_regval));
}

static inline omap44xx_scrm_clkdiv_status3_t omap44xx_scrm_auxclk3_clkdiv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status3_t omap44xx_scrm_auxclk3_clkdiv_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk3_t _regval = mackerel_read_addr_32(_dev->base, 0x31c);
    return(omap44xx_scrm_auxclk3_clkdiv_extract(_regval));
}

static inline void omap44xx_scrm_auxclk3_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk3_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status3_t _fieldval)
{
    omap44xx_scrm_auxclk3_t _regval = 0x1 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0106 & mackerel_read_addr_32(_dev->base, 0x31c)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk3_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk3_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval)
{
    omap44xx_scrm_auxclk3_t _regval = 0x6 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf0101 & mackerel_read_addr_32(_dev->base, 0x31c)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk3_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk3_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclk3_t _regval = 0x100 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0007 & mackerel_read_addr_32(_dev->base, 0x31c)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk3_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk3_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status3_t _fieldval)
{
    omap44xx_scrm_auxclk3_t _regval = 0xf0000 & (((omap44xx_scrm_auxclk3_t )(_fieldval)) << 16);
    _regval = (_regval | (0x107 & mackerel_read_addr_32(_dev->base, 0x31c)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
    // No shadow register to write to
}

/*
 * Register auxclk4: This register holds qualifiers for the auxiliary clock #4.
 * Type: omap44xx_scrm.auxclk4 (Implicit type of This register holds qualifiers for the auxiliary clock #4. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #4 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #4.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #4 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #4.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x320));
}

static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk4_t omap44xx_scrm_auxclk4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x320));
}

static inline void omap44xx_scrm_auxclk4_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk4_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk4_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
}

static inline void omap44xx_scrm_auxclk4_wr(__DN(t) *_dev, omap44xx_scrm_auxclk4_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk4_wr(__DN(t) *_dev, omap44xx_scrm_auxclk4_t _regval)
{
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
}

static inline int omap44xx_scrm_auxclk4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclk4_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclk4 (This register holds qualifiers for the auxiliary clock #4.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status4_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #4 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #4 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status4_prtval(_s + _r, _avail, omap44xx_scrm_auxclk4_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #4.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline omap44xx_scrm_polarity_status4_t omap44xx_scrm_auxclk4_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status4_t omap44xx_scrm_auxclk4_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk4_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(omap44xx_scrm_auxclk4_polarity_extract(_regval));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk4_srcselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk4_srcselect_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk4_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(omap44xx_scrm_auxclk4_srcselect_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk4_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk4_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk4_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(omap44xx_scrm_auxclk4_enable_extract(_regval));
}

static inline omap44xx_scrm_clkdiv_status4_t omap44xx_scrm_auxclk4_clkdiv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status4_t omap44xx_scrm_auxclk4_clkdiv_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk4_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(omap44xx_scrm_auxclk4_clkdiv_extract(_regval));
}

static inline void omap44xx_scrm_auxclk4_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status4_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk4_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status4_t _fieldval)
{
    omap44xx_scrm_auxclk4_t _regval = 0x1 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0106 & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk4_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk4_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval)
{
    omap44xx_scrm_auxclk4_t _regval = 0x6 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf0101 & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk4_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk4_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclk4_t _regval = 0x100 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0007 & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk4_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status4_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk4_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status4_t _fieldval)
{
    omap44xx_scrm_auxclk4_t _regval = 0xf0000 & (((omap44xx_scrm_auxclk4_t )(_fieldval)) << 16);
    _regval = (_regval | (0x107 & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

/*
 * Register auxclk5: This register holds qualifiers for the auxiliary clock #5.
 * Type: omap44xx_scrm.auxclk5 (Implicit type of This register holds qualifiers for the auxiliary clock #5. register)
 *   polarity	(size 1, offset 0, init 0):	RW	This bit defines the output level when the auxiliary clock #5 is gated.
 *   srcselect	(size 2, offset 1, init 0):	RW	This field allows selecting the clock source of the auxiliary clock #5.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   enable	(size 1, offset 8, init 0):	RW	This bit allows to request the auxiliary clock #5 by software.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   clkdiv	(size 4, offset 16, init 0):	RW	This field holds the divider value for the auxiliary clock #5.
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x324));
}

static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_auxclk5_t omap44xx_scrm_auxclk5_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x324));
}

static inline void omap44xx_scrm_auxclk5_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk5_rawwr(__DN(t) *_dev, omap44xx_scrm_auxclk5_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
}

static inline void omap44xx_scrm_auxclk5_wr(__DN(t) *_dev, omap44xx_scrm_auxclk5_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk5_wr(__DN(t) *_dev, omap44xx_scrm_auxclk5_t _regval)
{
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
}

static inline int omap44xx_scrm_auxclk5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_auxclk5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_auxclk5_t _regval = mackerel_read_addr_32(_dev->base, 0x324);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register auxclk5 (This register holds qualifiers for the auxiliary clock #5.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_polarity_status5_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit defines the output level when the auxiliary clock #5 is gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srcselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_srcselect_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_srcselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field allows selecting the clock source of the auxiliary clock #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to request the auxiliary clock #5 by software.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkdiv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clkdiv_status5_prtval(_s + _r, _avail, omap44xx_scrm_auxclk5_clkdiv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field holds the divider value for the auxiliary clock #5.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline omap44xx_scrm_polarity_status5_t omap44xx_scrm_auxclk5_polarity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_polarity_status5_t omap44xx_scrm_auxclk5_polarity_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk5_t _regval = mackerel_read_addr_32(_dev->base, 0x324);
    return(omap44xx_scrm_auxclk5_polarity_extract(_regval));
}

static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk5_srcselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_srcselect_status_t omap44xx_scrm_auxclk5_srcselect_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk5_t _regval = mackerel_read_addr_32(_dev->base, 0x324);
    return(omap44xx_scrm_auxclk5_srcselect_extract(_regval));
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk5_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_auxclk5_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk5_t _regval = mackerel_read_addr_32(_dev->base, 0x324);
    return(omap44xx_scrm_auxclk5_enable_extract(_regval));
}

static inline omap44xx_scrm_clkdiv_status5_t omap44xx_scrm_auxclk5_clkdiv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_clkdiv_status5_t omap44xx_scrm_auxclk5_clkdiv_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_auxclk5_t _regval = mackerel_read_addr_32(_dev->base, 0x324);
    return(omap44xx_scrm_auxclk5_clkdiv_extract(_regval));
}

static inline void omap44xx_scrm_auxclk5_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status5_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk5_polarity_wrf(__DN(t) *_dev, omap44xx_scrm_polarity_status5_t _fieldval)
{
    omap44xx_scrm_auxclk5_t _regval = 0x1 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0106 & mackerel_read_addr_32(_dev->base, 0x324)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk5_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk5_srcselect_wrf(__DN(t) *_dev, omap44xx_scrm_srcselect_status_t _fieldval)
{
    omap44xx_scrm_auxclk5_t _regval = 0x6 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf0101 & mackerel_read_addr_32(_dev->base, 0x324)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk5_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk5_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_auxclk5_t _regval = 0x100 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0007 & mackerel_read_addr_32(_dev->base, 0x324)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_auxclk5_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status5_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_auxclk5_clkdiv_wrf(__DN(t) *_dev, omap44xx_scrm_clkdiv_status5_t _fieldval)
{
    omap44xx_scrm_auxclk5_t _regval = 0xf0000 & (((omap44xx_scrm_auxclk5_t )(_fieldval)) << 16);
    _regval = (_regval | (0x107 & mackerel_read_addr_32(_dev->base, 0x324)));
    // No read of register shadow required
    _regval = (_regval & 0xf0107);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
    // No shadow register to write to
}

/*
 * Register rsttime_reg: This register holds the reset time counter which is used to extend the reset lines beyond the release of the pad reset.
 * Type: omap44xx_scrm.rsttime_reg (Implicit type of This register holds the reset time counter which is used to extend the reset lines beyond the release of the pad reset. register)
 *   rsttime	(size 4, offset 0, init 0):	RW	Holds the number of 32 kHz clock cycles for which the reset duration is extended. Values 0,1 and 2 are not allowed. 0x0: Reserved. 0x1: Reserved. 0x2: Reserved.
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
static inline omap44xx_scrm_rsttime_reg_t omap44xx_scrm_rsttime_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_rsttime_reg_t omap44xx_scrm_rsttime_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline omap44xx_scrm_rsttime_reg_t omap44xx_scrm_rsttime_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_rsttime_reg_t omap44xx_scrm_rsttime_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline void omap44xx_scrm_rsttime_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_rsttime_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_rsttime_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_rsttime_reg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline void omap44xx_scrm_rsttime_reg_wr(__DN(t) *_dev, omap44xx_scrm_rsttime_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_rsttime_reg_wr(__DN(t) *_dev, omap44xx_scrm_rsttime_reg_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline int omap44xx_scrm_rsttime_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_rsttime_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_rsttime_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rsttime_reg (This register holds the reset time counter which is used to extend the reset lines beyond the release of the pad reset.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsttime =\t%" PRIx8 "\t(Holds the number of 32 kHz clock cycles for which the reset duration is extended. Values 0,1 and 2 are not allowed. 0x0: Reserved. 0x1: Reserved. 0x2: Reserved.)\n", omap44xx_scrm_rsttime_reg_rsttime_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_scrm_rsttime_reg_rsttime_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_scrm_rsttime_reg_rsttime_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_rsttime_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(omap44xx_scrm_rsttime_reg_rsttime_extract(_regval));
}

static inline void omap44xx_scrm_rsttime_reg_rsttime_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_rsttime_reg_rsttime_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_scrm_rsttime_reg_t _regval = 0xf & (((omap44xx_scrm_rsttime_reg_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

/*
 * Register c2crstctrl: This register controls the release of the external C2C interface reset lines.
 * Type: omap44xx_scrm.c2crstctrl (Implicit type of This register controls the release of the external C2C interface reset lines. register)
 *   coldrst	(size 1, offset 0, init 0):	RW	This bit allows to release the cold reset line of the external C2C interface.
 *   warmrst	(size 1, offset 1, init 0):	RW	This bit allows to release the warm reset line of the external C2C interface. [warm reset sensitive]
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x41c));
}

static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2crstctrl_t omap44xx_scrm_c2crstctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x41c));
}

static inline void omap44xx_scrm_c2crstctrl_rawwr(__DN(t) *_dev, omap44xx_scrm_c2crstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2crstctrl_rawwr(__DN(t) *_dev, omap44xx_scrm_c2crstctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x41c, _regval);
}

static inline void omap44xx_scrm_c2crstctrl_wr(__DN(t) *_dev, omap44xx_scrm_c2crstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2crstctrl_wr(__DN(t) *_dev, omap44xx_scrm_c2crstctrl_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x41c, _regval);
}

static inline int omap44xx_scrm_c2crstctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2crstctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_c2crstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x41c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register c2crstctrl (This register controls the release of the external C2C interface reset lines.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " coldrst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2crstctrl_coldrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to release the cold reset line of the external C2C interface.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " warmrst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_sysclk_status_prtval(_s + _r, _avail, omap44xx_scrm_c2crstctrl_warmrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to release the warm reset line of the external C2C interface. [warm reset sensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_coldrst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_coldrst_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2crstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x41c);
    return(omap44xx_scrm_c2crstctrl_coldrst_extract(_regval));
}

static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_warmrst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_sysclk_status_t omap44xx_scrm_c2crstctrl_warmrst_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2crstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x41c);
    return(omap44xx_scrm_c2crstctrl_warmrst_extract(_regval));
}

static inline void omap44xx_scrm_c2crstctrl_coldrst_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2crstctrl_coldrst_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval)
{
    omap44xx_scrm_c2crstctrl_t _regval = 0x1 & (((omap44xx_scrm_c2crstctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x41c)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x41c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_c2crstctrl_warmrst_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2crstctrl_warmrst_wrf(__DN(t) *_dev, omap44xx_scrm_sysclk_status_t _fieldval)
{
    omap44xx_scrm_c2crstctrl_t _regval = 0x2 & (((omap44xx_scrm_c2crstctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x41c)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x41c, _regval);
    // No shadow register to write to
}

/*
 * Register extpwronrstctrl: This register allows the software to perform an external power-on reset.
 * Type: omap44xx_scrm.extpwronrstctrl (Implicit type of This register allows the software to perform an external power-on reset. register)
 *   enable	(size 1, offset 0, init 0):	RW	This bit must be set to 1 to allow the software to assert the external power-on reset.
 *   pwronrst	(size 1, offset 1, init 0):	RW	This bit controls the assertion and the de-assertion of the external power-on reset.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420));
}

static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extpwronrstctrl_t omap44xx_scrm_extpwronrstctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420));
}

static inline void omap44xx_scrm_extpwronrstctrl_rawwr(__DN(t) *_dev, omap44xx_scrm_extpwronrstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extpwronrstctrl_rawwr(__DN(t) *_dev, omap44xx_scrm_extpwronrstctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
}

static inline void omap44xx_scrm_extpwronrstctrl_wr(__DN(t) *_dev, omap44xx_scrm_extpwronrstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extpwronrstctrl_wr(__DN(t) *_dev, omap44xx_scrm_extpwronrstctrl_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
}

static inline int omap44xx_scrm_extpwronrstctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extpwronrstctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_extpwronrstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x420);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register extpwronrstctrl (This register allows the software to perform an external power-on reset.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_mode_status_prtval(_s + _r, _avail, omap44xx_scrm_extpwronrstctrl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit must be set to 1 to allow the software to assert the external power-on reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwronrst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_pwronrst_status_prtval(_s + _r, _avail, omap44xx_scrm_extpwronrstctrl_pwronrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit controls the assertion and the de-assertion of the external power-on reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extpwronrstctrl_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_mode_status_t omap44xx_scrm_extpwronrstctrl_enable_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_extpwronrstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x420);
    return(omap44xx_scrm_extpwronrstctrl_enable_extract(_regval));
}

static inline omap44xx_scrm_pwronrst_status_t omap44xx_scrm_extpwronrstctrl_pwronrst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_pwronrst_status_t omap44xx_scrm_extpwronrstctrl_pwronrst_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_extpwronrstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x420);
    return(omap44xx_scrm_extpwronrstctrl_pwronrst_extract(_regval));
}

static inline void omap44xx_scrm_extpwronrstctrl_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extpwronrstctrl_enable_wrf(__DN(t) *_dev, omap44xx_scrm_mode_status_t _fieldval)
{
    omap44xx_scrm_extpwronrstctrl_t _regval = 0x1 & (((omap44xx_scrm_extpwronrstctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x420)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
    // No shadow register to write to
}

static inline void omap44xx_scrm_extpwronrstctrl_pwronrst_wrf(__DN(t) *_dev, omap44xx_scrm_pwronrst_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extpwronrstctrl_pwronrst_wrf(__DN(t) *_dev, omap44xx_scrm_pwronrst_status_t _fieldval)
{
    omap44xx_scrm_extpwronrstctrl_t _regval = 0x2 & (((omap44xx_scrm_extpwronrstctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x420)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
    // No shadow register to write to
}

/*
 * Register extwarmrstst_reg: This register logs the source of warm reset output. Each bit is set upon release of the warm reset output and must be cleared by software.
 * Type: omap44xx_scrm.extwarmrstst_reg (Implicit type of This register logs the source of warm reset output. Each bit is set upon release of the warm reset output and must be cleared by software. register)
 *   extwarmrstst	(size 1, offset 0, init 0):	RWC	This bit logs the external warm reset source.
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_scrm_extwarmrstst_reg_t omap44xx_scrm_extwarmrstst_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extwarmrstst_reg_t omap44xx_scrm_extwarmrstst_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x510));
}

static inline omap44xx_scrm_extwarmrstst_reg_t omap44xx_scrm_extwarmrstst_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extwarmrstst_reg_t omap44xx_scrm_extwarmrstst_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x510));
}

static inline void omap44xx_scrm_extwarmrstst_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_extwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extwarmrstst_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_extwarmrstst_reg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x510, _regval);
}

static inline void omap44xx_scrm_extwarmrstst_reg_wr(__DN(t) *_dev, omap44xx_scrm_extwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extwarmrstst_reg_wr(__DN(t) *_dev, omap44xx_scrm_extwarmrstst_reg_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x510, _regval);
}

static inline int omap44xx_scrm_extwarmrstst_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_extwarmrstst_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_extwarmrstst_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x510);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register extwarmrstst_reg (This register logs the source of warm reset output. Each bit is set upon release of the warm reset output and must be cleared by software.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " extwarmrstst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_extwarmrstst_status_prtval(_s + _r, _avail, omap44xx_scrm_extwarmrstst_reg_extwarmrstst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit logs the external warm reset source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_scrm_extwarmrstst_status_t omap44xx_scrm_extwarmrstst_reg_extwarmrstst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_extwarmrstst_status_t omap44xx_scrm_extwarmrstst_reg_extwarmrstst_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_extwarmrstst_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x510);
    return(omap44xx_scrm_extwarmrstst_reg_extwarmrstst_extract(_regval));
}

static inline void omap44xx_scrm_extwarmrstst_reg_extwarmrstst_wrf(__DN(t) *_dev, omap44xx_scrm_extwarmrstst_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_extwarmrstst_reg_extwarmrstst_wrf(__DN(t) *_dev, omap44xx_scrm_extwarmrstst_status_t _fieldval)
{
    omap44xx_scrm_extwarmrstst_reg_t _regval = 0x1 & (((omap44xx_scrm_extwarmrstst_reg_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x510, _regval);
    // No shadow register to write to
}

/*
 * Register apewarmrstst_reg: This register logs the source of warm reset on the APE. Each bit is set upon release of the APE warm reset and must be cleared by software.
 * Type: omap44xx_scrm.apewarmrstst_reg (Implicit type of This register logs the source of warm reset on the APE. Each bit is set upon release of the APE warm reset and must be cleared by software. register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   apewarmrstst	(size 1, offset 1, init 0):	RWC	This bit logs the APE warm reset source.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_scrm_apewarmrstst_reg_t omap44xx_scrm_apewarmrstst_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_apewarmrstst_reg_t omap44xx_scrm_apewarmrstst_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x514));
}

static inline omap44xx_scrm_apewarmrstst_reg_t omap44xx_scrm_apewarmrstst_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_apewarmrstst_reg_t omap44xx_scrm_apewarmrstst_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x514));
}

static inline void omap44xx_scrm_apewarmrstst_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_apewarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_apewarmrstst_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_apewarmrstst_reg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x514, _regval);
}

static inline void omap44xx_scrm_apewarmrstst_reg_wr(__DN(t) *_dev, omap44xx_scrm_apewarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_apewarmrstst_reg_wr(__DN(t) *_dev, omap44xx_scrm_apewarmrstst_reg_t _regval)
{
    _regval = (_regval & 0x2);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x514, _regval);
}

static inline int omap44xx_scrm_apewarmrstst_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_apewarmrstst_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_apewarmrstst_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x514);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register apewarmrstst_reg (This register logs the source of warm reset on the APE. Each bit is set upon release of the APE warm reset and must be cleared by software.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apewarmrstst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_apewarmrstst_status_prtval(_s + _r, _avail, omap44xx_scrm_apewarmrstst_reg_apewarmrstst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit logs the APE warm reset source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_scrm_apewarmrstst_status_t omap44xx_scrm_apewarmrstst_reg_apewarmrstst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_apewarmrstst_status_t omap44xx_scrm_apewarmrstst_reg_apewarmrstst_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_apewarmrstst_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x514);
    return(omap44xx_scrm_apewarmrstst_reg_apewarmrstst_extract(_regval));
}

static inline void omap44xx_scrm_apewarmrstst_reg_apewarmrstst_wrf(__DN(t) *_dev, omap44xx_scrm_apewarmrstst_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_apewarmrstst_reg_apewarmrstst_wrf(__DN(t) *_dev, omap44xx_scrm_apewarmrstst_status_t _fieldval)
{
    omap44xx_scrm_apewarmrstst_reg_t _regval = 0x2 & (((omap44xx_scrm_apewarmrstst_reg_t )(_fieldval)) << 1);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x2);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x514, _regval);
    // No shadow register to write to
}

/*
 * Register c2cwarmrstst_reg: This register logs the source of warm reset on the external C2C interface. Each bit is set upon release of the external C2C interface warm reset and must be cleared by software.
 * Type: omap44xx_scrm.c2cwarmrstst_reg (Implicit type of This register logs the source of warm reset on the external C2C interface. Each bit is set upon release of the external C2C interface warm reset and must be cleared by software. register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   c2cwarmrstst	(size 1, offset 3, init 0):	RWC	This bit logs the C2C warm reset source.
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
static inline omap44xx_scrm_c2cwarmrstst_reg_t omap44xx_scrm_c2cwarmrstst_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cwarmrstst_reg_t omap44xx_scrm_c2cwarmrstst_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51c));
}

static inline omap44xx_scrm_c2cwarmrstst_reg_t omap44xx_scrm_c2cwarmrstst_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cwarmrstst_reg_t omap44xx_scrm_c2cwarmrstst_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51c));
}

static inline void omap44xx_scrm_c2cwarmrstst_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_c2cwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cwarmrstst_reg_rawwr(__DN(t) *_dev, omap44xx_scrm_c2cwarmrstst_reg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x51c, _regval);
}

static inline void omap44xx_scrm_c2cwarmrstst_reg_wr(__DN(t) *_dev, omap44xx_scrm_c2cwarmrstst_reg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cwarmrstst_reg_wr(__DN(t) *_dev, omap44xx_scrm_c2cwarmrstst_reg_t _regval)
{
    _regval = (_regval & 0x8);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x51c, _regval);
}

static inline int omap44xx_scrm_c2cwarmrstst_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_c2cwarmrstst_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_scrm_c2cwarmrstst_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x51c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register c2cwarmrstst_reg (This register logs the source of warm reset on the external C2C interface. Each bit is set upon release of the external C2C interface warm reset and must be cleared by software.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c2cwarmrstst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_c2cwarmrstst_status_prtval(_s + _r, _avail, omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit logs the C2C warm reset source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline omap44xx_scrm_c2cwarmrstst_status_t omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_scrm_c2cwarmrstst_status_t omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_rdf(__DN(t) *_dev)
{
    omap44xx_scrm_c2cwarmrstst_reg_t _regval = mackerel_read_addr_32(_dev->base, 0x51c);
    return(omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_extract(_regval));
}

static inline void omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_wrf(__DN(t) *_dev, omap44xx_scrm_c2cwarmrstst_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_scrm_c2cwarmrstst_reg_c2cwarmrstst_wrf(__DN(t) *_dev, omap44xx_scrm_c2cwarmrstst_status_t _fieldval)
{
    omap44xx_scrm_c2cwarmrstst_reg_t _regval = 0x8 & (((omap44xx_scrm_c2cwarmrstst_reg_t )(_fieldval)) << 3);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x51c, _regval);
    // No shadow register to write to
}

static inline int omap44xx_scrm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_scrm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_scrm ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_revision_scrm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_clksetuptime_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_pmicsetuptime_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_altclksrc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_c2cclkm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_extclkreq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_accclkreq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_pwrreq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclkreq0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclkreq1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclkreq2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclkreq3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclkreq4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclkreq5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_c2cclkreq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclk0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclk1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclk2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclk3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclk4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_auxclk5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_rsttime_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_c2crstctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_extpwronrstctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_extwarmrstst_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_apewarmrstst_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_scrm_c2cwarmrstst_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_scrm\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_scrm_DEV_H
