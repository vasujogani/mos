#ifndef __omap44xx_l4per_cm2_DEV_H
#define __omap44xx_l4per_cm2_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_l4per_cm2 ## _ ## x
/*
 * Constants defn: omap44xx_l4per_cm2.clkactivity_per_abe_24m_fclk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t;
#define omap44xx_l4per_cm2_CLKACTIVITY_PER_ABE_24M_FCLK_0_r ((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t)0x0)
#define omap44xx_l4per_cm2_CLKACTIVITY_PER_ABE_24M_FCLK_1_r ((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t)0x1)

static inline char *omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_describe(omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_describe(omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_CLKACTIVITY_PER_ABE_24M_FCLK_0_r:
        return("CLKACTIVITY_PER_ABE_24M_FCLK_0_r: Corresponding clock is definitely gated");
    case omap44xx_l4per_cm2_CLKACTIVITY_PER_ABE_24M_FCLK_1_r:
        return("CLKACTIVITY_PER_ABE_24M_FCLK_1_r: Corresponding clock is running or gating/ungating transition is ongoing");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _e)
{
    char *d = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.clktrctrl_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_clktrctrl_status_t;
#define omap44xx_l4per_cm2_CLKTRCTRL_0 ((omap44xx_l4per_cm2_clktrctrl_status_t)0x0)
#define omap44xx_l4per_cm2_CLKTRCTRL_1 ((omap44xx_l4per_cm2_clktrctrl_status_t)0x1)
#define omap44xx_l4per_cm2_CLKTRCTRL_2 ((omap44xx_l4per_cm2_clktrctrl_status_t)0x2)
#define omap44xx_l4per_cm2_CLKTRCTRL_3 ((omap44xx_l4per_cm2_clktrctrl_status_t)0x3)

static inline char *omap44xx_l4per_cm2_clktrctrl_status_describe(omap44xx_l4per_cm2_clktrctrl_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_clktrctrl_status_describe(omap44xx_l4per_cm2_clktrctrl_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_CLKTRCTRL_0:
        return("CLKTRCTRL_0: NO_SLEEP: Sleep transition cannot be initiated. Wakeup transition may however occur.");
    case omap44xx_l4per_cm2_CLKTRCTRL_1:
        return("CLKTRCTRL_1: SW_SLEEP: Start a software forced sleep transition on the domain.");
    case omap44xx_l4per_cm2_CLKTRCTRL_2:
        return("CLKTRCTRL_2: SW_WKUP: Start a software forced wake-up transition on the domain.");
    case omap44xx_l4per_cm2_CLKTRCTRL_3:
        return("CLKTRCTRL_3: HW_AUTO: Automatic transition is enabled. Sleep and wakeup transition are based upon hardware conditions.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_clktrctrl_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clktrctrl_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_clktrctrl_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clktrctrl_status_t _e)
{
    char *d = omap44xx_l4per_cm2_clktrctrl_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_clktrctrl_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.l4sec_dyndep_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_l4sec_dyndep_status_t;
#define omap44xx_l4per_cm2_L4SEC_DYNDEP_1_r ((omap44xx_l4per_cm2_l4sec_dyndep_status_t)0x1)

static inline char *omap44xx_l4per_cm2_l4sec_dyndep_status_describe(omap44xx_l4per_cm2_l4sec_dyndep_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_l4sec_dyndep_status_describe(omap44xx_l4per_cm2_l4sec_dyndep_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_L4SEC_DYNDEP_1_r:
        return("L4SEC_DYNDEP_1_r: Dependency is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_l4sec_dyndep_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_l4sec_dyndep_status_t _e)
{
    char *d = omap44xx_l4per_cm2_l4sec_dyndep_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_l4sec_dyndep_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.clksel_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_clksel_status_t;
#define omap44xx_l4per_cm2_CLKSEL_0 ((omap44xx_l4per_cm2_clksel_status_t)0x0)
#define omap44xx_l4per_cm2_CLKSEL_1 ((omap44xx_l4per_cm2_clksel_status_t)0x1)

static inline char *omap44xx_l4per_cm2_clksel_status_describe(omap44xx_l4per_cm2_clksel_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_clksel_status_describe(omap44xx_l4per_cm2_clksel_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_CLKSEL_0:
        return("CLKSEL_0: Selects the SYS_CLK as the source");
    case omap44xx_l4per_cm2_CLKSEL_1:
        return("CLKSEL_1: Selects the 32KHz as the source");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_clksel_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clksel_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_clksel_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clksel_status_t _e)
{
    char *d = omap44xx_l4per_cm2_clksel_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_clksel_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.idlest_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_idlest_status_t;
#define omap44xx_l4per_cm2_IDLEST_0_r ((omap44xx_l4per_cm2_idlest_status_t)0x0)
#define omap44xx_l4per_cm2_IDLEST_1_r ((omap44xx_l4per_cm2_idlest_status_t)0x1)
#define omap44xx_l4per_cm2_IDLEST_2_r ((omap44xx_l4per_cm2_idlest_status_t)0x2)
#define omap44xx_l4per_cm2_IDLEST_3_r ((omap44xx_l4per_cm2_idlest_status_t)0x3)

static inline char *omap44xx_l4per_cm2_idlest_status_describe(omap44xx_l4per_cm2_idlest_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_idlest_status_describe(omap44xx_l4per_cm2_idlest_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_IDLEST_0_r:
        return("IDLEST_0_r: Module is fully functional, including INTRCONN");
    case omap44xx_l4per_cm2_IDLEST_1_r:
        return("IDLEST_1_r: Module is performing transition: wakeup, or sleep, or sleep abortion");
    case omap44xx_l4per_cm2_IDLEST_2_r:
        return("IDLEST_2_r: Module is in idle mode (only INTRCONN part). It is functional if using separate functional clock");
    case omap44xx_l4per_cm2_IDLEST_3_r:
        return("IDLEST_3_r: Module is disabled and cannot be accessed");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_idlest_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_idlest_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_idlest_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_idlest_status_t _e)
{
    char *d = omap44xx_l4per_cm2_idlest_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_idlest_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.modulemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_modulemode_status_t;
#define omap44xx_l4per_cm2_MODULEMODE_0 ((omap44xx_l4per_cm2_modulemode_status_t)0x0)
#define omap44xx_l4per_cm2_MODULEMODE_1_r ((omap44xx_l4per_cm2_modulemode_status_t)0x1)
#define omap44xx_l4per_cm2_MODULEMODE_2 ((omap44xx_l4per_cm2_modulemode_status_t)0x2)
#define omap44xx_l4per_cm2_MODULEMODE_3_r ((omap44xx_l4per_cm2_modulemode_status_t)0x3)

static inline char *omap44xx_l4per_cm2_modulemode_status_describe(omap44xx_l4per_cm2_modulemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_modulemode_status_describe(omap44xx_l4per_cm2_modulemode_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_MODULEMODE_0:
        return("MODULEMODE_0: Module is disable by software. Any INTRCONN access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l4per_cm2_MODULEMODE_1_r:
        return("MODULEMODE_1_r: Reserved");
    case omap44xx_l4per_cm2_MODULEMODE_2:
        return("MODULEMODE_2: Module is explicitly enabled. Interface clock (if not used for functions) may be gated according to the clock domain state. Functional clocks are guarantied to stay present. As long as in this configuration, power domain sleep transition cannot happen.");
    case omap44xx_l4per_cm2_MODULEMODE_3_r:
        return("MODULEMODE_3_r: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_modulemode_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_modulemode_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status_t _e)
{
    char *d = omap44xx_l4per_cm2_modulemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_modulemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.modulemode_status1 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_modulemode_status1_t;
#define omap44xx_l4per_cm2_MODULEMODE_1_r_6 ((omap44xx_l4per_cm2_modulemode_status1_t)0x1)

static inline char *omap44xx_l4per_cm2_modulemode_status1_describe(omap44xx_l4per_cm2_modulemode_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_modulemode_status1_describe(omap44xx_l4per_cm2_modulemode_status1_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_MODULEMODE_1_r_6:
        return("MODULEMODE_1_r_6: Module is managed automatically by hardware according to clock domain transition. A clock domain sleep transition put module into idle. A wakeup domain transition put it back into function. If CLKTRCTRL=3, any INTRCONN access to module is always granted. Module clocks may be gated according to the clock domain state.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_modulemode_status1_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_modulemode_status1_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status1_t _e)
{
    char *d = omap44xx_l4per_cm2_modulemode_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_modulemode_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.optfclken_dbclk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_optfclken_dbclk_status_t;
#define omap44xx_l4per_cm2_OPTFCLKEN_DBCLK_0 ((omap44xx_l4per_cm2_optfclken_dbclk_status_t)0x0)
#define omap44xx_l4per_cm2_OPTFCLKEN_DBCLK_1 ((omap44xx_l4per_cm2_optfclken_dbclk_status_t)0x1)

static inline char *omap44xx_l4per_cm2_optfclken_dbclk_status_describe(omap44xx_l4per_cm2_optfclken_dbclk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_optfclken_dbclk_status_describe(omap44xx_l4per_cm2_optfclken_dbclk_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_OPTFCLKEN_DBCLK_0:
        return("OPTFCLKEN_DBCLK_0: Optional functional clock is disabled");
    case omap44xx_l4per_cm2_OPTFCLKEN_DBCLK_1:
        return("OPTFCLKEN_DBCLK_1: Optional functional clock is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_optfclken_dbclk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_optfclken_dbclk_status_t _e)
{
    char *d = omap44xx_l4per_cm2_optfclken_dbclk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_optfclken_dbclk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.modulemode_status2 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_modulemode_status2_t;
#define omap44xx_l4per_cm2_MODULEMODE_0_6 ((omap44xx_l4per_cm2_modulemode_status2_t)0x0)
#define omap44xx_l4per_cm2_MODULEMODE_1 ((omap44xx_l4per_cm2_modulemode_status2_t)0x1)
#define omap44xx_l4per_cm2_MODULEMODE_2_r ((omap44xx_l4per_cm2_modulemode_status2_t)0x2)
#define omap44xx_l4per_cm2_MODULEMODE_3_r_6 ((omap44xx_l4per_cm2_modulemode_status2_t)0x3)

static inline char *omap44xx_l4per_cm2_modulemode_status2_describe(omap44xx_l4per_cm2_modulemode_status2_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_modulemode_status2_describe(omap44xx_l4per_cm2_modulemode_status2_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_MODULEMODE_0_6:
        return("MODULEMODE_0_6: Module is disable by software. Any INTRCONN access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l4per_cm2_MODULEMODE_1:
        return("MODULEMODE_1: Module is managed automatically by hardware according to clock domain transition. A clock domain sleep transition put module into idle. A wakeup domain transition put it back into function. If CLKTRCTRL=3, any INTRCONN access to module is always granted. Module clocks may be gated according to the clock domain state.");
    case omap44xx_l4per_cm2_MODULEMODE_2_r:
        return("MODULEMODE_2_r: Reserved");
    case omap44xx_l4per_cm2_MODULEMODE_3_r_6:
        return("MODULEMODE_3_r_6: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_modulemode_status2_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status2_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_modulemode_status2_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status2_t _e)
{
    char *d = omap44xx_l4per_cm2_modulemode_status2_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_modulemode_status2_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.clksel_internal_source_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_clksel_internal_source_status_t;
#define omap44xx_l4per_cm2_CLKSEL_INTERNAL_SOURCE_0 ((omap44xx_l4per_cm2_clksel_internal_source_status_t)0x0)
#define omap44xx_l4per_cm2_CLKSEL_INTERNAL_SOURCE_1 ((omap44xx_l4per_cm2_clksel_internal_source_status_t)0x1)

static inline char *omap44xx_l4per_cm2_clksel_internal_source_status_describe(omap44xx_l4per_cm2_clksel_internal_source_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_clksel_internal_source_status_describe(omap44xx_l4per_cm2_clksel_internal_source_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_CLKSEL_INTERNAL_SOURCE_0:
        return("CLKSEL_INTERNAL_SOURCE_0: 96MHz clock derived from DPLL_PER is selected");
    case omap44xx_l4per_cm2_CLKSEL_INTERNAL_SOURCE_1:
        return("CLKSEL_INTERNAL_SOURCE_1: 98MHz clock derived from DPLL_ABE is selected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_clksel_internal_source_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clksel_internal_source_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_clksel_internal_source_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clksel_internal_source_status_t _e)
{
    char *d = omap44xx_l4per_cm2_clksel_internal_source_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_clksel_internal_source_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.clksel_source_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_clksel_source_status_t;
#define omap44xx_l4per_cm2_CLKSEL_SOURCE_0 ((omap44xx_l4per_cm2_clksel_source_status_t)0x0)
#define omap44xx_l4per_cm2_CLKSEL_SOURCE_1 ((omap44xx_l4per_cm2_clksel_source_status_t)0x1)

static inline char *omap44xx_l4per_cm2_clksel_source_status_describe(omap44xx_l4per_cm2_clksel_source_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_clksel_source_status_describe(omap44xx_l4per_cm2_clksel_source_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_CLKSEL_SOURCE_0:
        return("CLKSEL_SOURCE_0: Functional clock is sourced from an internal clock");
    case omap44xx_l4per_cm2_CLKSEL_SOURCE_1:
        return("CLKSEL_SOURCE_1: Functional clock is sourced from CLKS pad");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_clksel_source_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clksel_source_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_clksel_source_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_clksel_source_status_t _e)
{
    char *d = omap44xx_l4per_cm2_clksel_source_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_clksel_source_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.l4per_statdep_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_l4per_statdep_status_t;
#define omap44xx_l4per_cm2_L4PER_STATDEP_0 ((omap44xx_l4per_cm2_l4per_statdep_status_t)0x0)
#define omap44xx_l4per_cm2_L4PER_STATDEP_1 ((omap44xx_l4per_cm2_l4per_statdep_status_t)0x1)

static inline char *omap44xx_l4per_cm2_l4per_statdep_status_describe(omap44xx_l4per_cm2_l4per_statdep_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_l4per_statdep_status_describe(omap44xx_l4per_cm2_l4per_statdep_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_L4PER_STATDEP_0:
        return("L4PER_STATDEP_0: Dependency is disabled");
    case omap44xx_l4per_cm2_L4PER_STATDEP_1:
        return("L4PER_STATDEP_1: Dependency is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_l4per_statdep_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_l4per_statdep_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_l4per_statdep_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_l4per_statdep_status_t _e)
{
    char *d = omap44xx_l4per_cm2_l4per_statdep_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_l4per_statdep_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.idlest_status1 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_idlest_status1_t;
#define omap44xx_l4per_cm2_IDLEST_0_r_31 ((omap44xx_l4per_cm2_idlest_status1_t)0x0)
#define omap44xx_l4per_cm2_IDLEST_1_r_31 ((omap44xx_l4per_cm2_idlest_status1_t)0x1)
#define omap44xx_l4per_cm2_IDLEST_2_r_31 ((omap44xx_l4per_cm2_idlest_status1_t)0x2)
#define omap44xx_l4per_cm2_IDLEST_3_r_31 ((omap44xx_l4per_cm2_idlest_status1_t)0x3)

static inline char *omap44xx_l4per_cm2_idlest_status1_describe(omap44xx_l4per_cm2_idlest_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_idlest_status1_describe(omap44xx_l4per_cm2_idlest_status1_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_IDLEST_0_r_31:
        return("IDLEST_0_r_31: Module is fully functional, including OCP");
    case omap44xx_l4per_cm2_IDLEST_1_r_31:
        return("IDLEST_1_r_31: Module is performing transition: wakeup, or sleep, or sleep abortion");
    case omap44xx_l4per_cm2_IDLEST_2_r_31:
        return("IDLEST_2_r_31: Module is in Idle mode (only OCP part). It is functional if using separate functional clock");
    case omap44xx_l4per_cm2_IDLEST_3_r_31:
        return("IDLEST_3_r_31: Module is disabled and cannot be accessed");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_idlest_status1_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_idlest_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_idlest_status1_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_idlest_status1_t _e)
{
    char *d = omap44xx_l4per_cm2_idlest_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_idlest_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.modulemode_status3 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_modulemode_status3_t;
#define omap44xx_l4per_cm2_MODULEMODE_0_29 ((omap44xx_l4per_cm2_modulemode_status3_t)0x0)
#define omap44xx_l4per_cm2_MODULEMODE_1_r_26 ((omap44xx_l4per_cm2_modulemode_status3_t)0x1)
#define omap44xx_l4per_cm2_MODULEMODE_2_24 ((omap44xx_l4per_cm2_modulemode_status3_t)0x2)
#define omap44xx_l4per_cm2_MODULEMODE_3_r_29 ((omap44xx_l4per_cm2_modulemode_status3_t)0x3)

static inline char *omap44xx_l4per_cm2_modulemode_status3_describe(omap44xx_l4per_cm2_modulemode_status3_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_modulemode_status3_describe(omap44xx_l4per_cm2_modulemode_status3_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_MODULEMODE_0_29:
        return("MODULEMODE_0_29: Module is disabled by SW. Any OCP access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l4per_cm2_MODULEMODE_1_r_26:
        return("MODULEMODE_1_r_26: Reserved");
    case omap44xx_l4per_cm2_MODULEMODE_2_24:
        return("MODULEMODE_2_24: Module is explicitly enabled. Interface clock (if not used for functions) may be gated according to the clock domain state. Functional clocks are guaranteed to stay present. As long as in this configuration, power domain sleep transition cannot happen.");
    case omap44xx_l4per_cm2_MODULEMODE_3_r_29:
        return("MODULEMODE_3_r_29: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_modulemode_status3_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status3_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_modulemode_status3_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status3_t _e)
{
    char *d = omap44xx_l4per_cm2_modulemode_status3_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_modulemode_status3_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.modulemode_status4 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l4per_cm2_modulemode_status4_t;
#define omap44xx_l4per_cm2_MODULEMODE_0_33 ((omap44xx_l4per_cm2_modulemode_status4_t)0x0)
#define omap44xx_l4per_cm2_MODULEMODE_1_5 ((omap44xx_l4per_cm2_modulemode_status4_t)0x1)
#define omap44xx_l4per_cm2_MODULEMODE_2_r_5 ((omap44xx_l4per_cm2_modulemode_status4_t)0x2)
#define omap44xx_l4per_cm2_MODULEMODE_3_r_33 ((omap44xx_l4per_cm2_modulemode_status4_t)0x3)

static inline char *omap44xx_l4per_cm2_modulemode_status4_describe(omap44xx_l4per_cm2_modulemode_status4_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_modulemode_status4_describe(omap44xx_l4per_cm2_modulemode_status4_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_MODULEMODE_0_33:
        return("MODULEMODE_0_33: Module is disabled by SW. Any OCP access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l4per_cm2_MODULEMODE_1_5:
        return("MODULEMODE_1_5: Module is managed automatically by HW according to clock domain transition. A clock domain sleep transition put module into idle. A wakeup domain transition put it back into function. If CLKTRCTRL=3, any OCP access to module is always granted. Module clocks may be gated according to the clock domain state.");
    case omap44xx_l4per_cm2_MODULEMODE_2_r_5:
        return("MODULEMODE_2_r_5: Reserved");
    case omap44xx_l4per_cm2_MODULEMODE_3_r_33:
        return("MODULEMODE_3_r_33: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_modulemode_status4_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status4_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_modulemode_status4_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_modulemode_status4_t _e)
{
    char *d = omap44xx_l4per_cm2_modulemode_status4_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_modulemode_status4_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l4per_cm2.stbyst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l4per_cm2_stbyst_status_t;
#define omap44xx_l4per_cm2_STBYST_0_r ((omap44xx_l4per_cm2_stbyst_status_t)0x0)
#define omap44xx_l4per_cm2_STBYST_1_r ((omap44xx_l4per_cm2_stbyst_status_t)0x1)

static inline char *omap44xx_l4per_cm2_stbyst_status_describe(omap44xx_l4per_cm2_stbyst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l4per_cm2_stbyst_status_describe(omap44xx_l4per_cm2_stbyst_status_t _e)
{
    switch (_e) {
    case omap44xx_l4per_cm2_STBYST_0_r:
        return("STBYST_0_r: Module is functional (not in standby)");
    case omap44xx_l4per_cm2_STBYST_1_r:
        return("STBYST_1_r: Module is in standby");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l4per_cm2_stbyst_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_stbyst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_stbyst_status_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_stbyst_status_t _e)
{
    char *d = omap44xx_l4per_cm2_stbyst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l4per_cm2_stbyst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_clkstctrl_t
 * Description: Implicit type of This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain. register
 * Fields:
 *   clktrctrl	(size 2, offset 0, init 0):	RW	Controls the clock state transition of the L4PER clock domain.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   clkactivity_l4_per_iclk	(size 1, offset 8, init 0):	RO	This field indicates the state of the L4_PER_GICLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt10_fclk	(size 1, offset 9, init 0):	RO	This field indicates the state of the DMT10_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt11_fclk	(size 1, offset 10, init 0):	RO	This field indicates the state of the DMT11_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt2_fclk	(size 1, offset 11, init 0):	RO	This field indicates the state of the DMT2_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt3_fclk	(size 1, offset 12, init 0):	RO	This field indicates the state of the DMT3_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt4_fclk	(size 1, offset 13, init 0):	RO	This field indicates the state of the DMT4_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt9_fclk	(size 1, offset 14, init 0):	RO	This field indicates the state of the DMT9_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_12m_fclk	(size 1, offset 15, init 0):	RO	This field indicates the state of the FUNC_12M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_24mc_fclk	(size 1, offset 16, init 0):	RO	This field indicates the state of the PER_24MC_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_32k_fclk	(size 1, offset 17, init 0):	RO	This field indicates the state of the PER_32K_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_48m_fclk	(size 1, offset 18, init 0):	RO	This field indicates the state of the PER_48M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_96m_fclk	(size 1, offset 19, init 0):	RO	This field indicates the state of the PER_96M_FCLK clock in the domain. [warm reset insensitive]
 *   _anon20	(size 2, offset 20, init 0):	MBZ	_
 *   clkactivity_per_mcbsp4_fclk	(size 1, offset 22, init 0):	RO	This field indicates the state of the PER_MCBSP4_FCLK clock in the domain. [warm reset insensitive]
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   _anon24	(size 1, offset 24, init 0):	MBZ	_
 *   clkactivity_per_abe_24m_fclk	(size 1, offset 25, init 0):	RO	This field indicates the state of the PER_ABE_24M_FCLK clock in the domain. [warm reset insensitive]
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_clkstctrl_default 0x0
static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clktrctrl_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 9)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 10)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 11)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 12)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 13)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 14)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 15)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 17)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 19)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x400000) >> 22));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 22)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x2000000) >> 25));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 25)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_clkstctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_clkstctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clktrctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clktrctrl_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls the clock state transition of the L4PER clock domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_l4_per_iclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L4_PER_GICLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt10_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT10_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt11_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT11_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt3_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT3_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt4_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT4_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt9_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT9_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_12m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the FUNC_12M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_24mc_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_24MC_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_32k_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_32K_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_48m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_48M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_96m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_96M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_mcbsp4_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_MCBSP4_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_abe_24m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_ABE_24M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_dynamicdep_t
 * Description: Implicit type of This register controls the dynamic domain dependencies from L4PER domain towards 'target' domains. It is relevant only for domain having INTERCONN master port(s). register
 * Fields:
 *   _anon0	(size 7, offset 0, init 0):	MBZ	_
 *   l3_init_dyndep	(size 1, offset 7, init 0):	RO	Dynamic dependency towards L3INIT clock domain
 *   dss_dyndep	(size 1, offset 8, init 0):	RO	Dynamic dependency towards DSS clock domain
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   l4sec_dyndep	(size 1, offset 14, init 0):	RO	Dynamic dependency towards L4SEC clock domain
 *   _anon15	(size 9, offset 15, init 0):	MBZ	_
 *   windowsize	(size 4, offset 24, init 0):	RW	Size of sliding window used to monitor INTRCONN interface activity for determination of auto-sleep feature. Time unit defined byCM_DYN_DEP_PRESCAL register.
 *   _anon28	(size 4, offset 28, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_t;
#define omap44xx_l4per_cm2_cm_l4per_dynamicdep_default 0x0
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4sec_dyndep_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_l4per_cm2_cm_l4per_dynamicdep_t )(_fieldval)) << 7)));
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4sec_dyndep_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_dynamicdep_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4sec_dyndep_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_l4per_cm2_cm_l4per_dynamicdep_t )(_fieldval)) << 14)));
}

static inline uint8_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_extract(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    return((uint8_t )((_regval & 0xf000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_insert(omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((omap44xx_l4per_cm2_cm_l4per_dynamicdep_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_dynamicdep_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_dynamicdep_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_init_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3INIT clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dss_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards DSS clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4sec_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L4SEC clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " windowsize =\t%" PRIx8 "\t(Size of sliding window used to monitor INTRCONN interface activity for determination of auto-sleep feature. Time unit defined byCM_DYN_DEP_PRESCAL register.)\n", omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t
 * Description: Implicit type of This register manages the DMTIMER10 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t
 * Description: Implicit type of This register manages the DMTIMER11 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t
 * Description: Implicit type of This register manages the DMTIMER2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t
 * Description: Implicit type of This register manages the DMTIMER3 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t
 * Description: Implicit type of This register manages the DMTIMER4 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t
 * Description: Implicit type of This register manages the DMTIMER9 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_extract(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_insert(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t
 * Description: Implicit type of This register manages the ELM clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RO	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status1_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status1_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t
 * Description: Implicit type of This register manages the GPIO2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t
 * Description: Implicit type of This register manages the GPIO3 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t
 * Description: Implicit type of This register manages the GPIO4 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t
 * Description: Implicit type of This register manages the GPIO5 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t
 * Description: Implicit type of This register manages the GPIO6 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_extract(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_insert(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t
 * Description: Implicit type of This register manages the HDQ1W clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t
 * Description: Implicit type of This register manages the i-th I2C clocks. register array
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t
 * Description: Implicit type of This register manages the L4PER clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RO	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status1_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status1_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t
 * Description: Implicit type of This register manages the MCBSP4 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel_source	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock between, internal source and CLKS pad. The switching between the clocks is not guaranteed to be glitchless.
 *   clksel_internal_source	(size 1, offset 25, init 0):	RW	Selects the internal clock to be used as the functional clock in case CLKSEL_SOURCE selects the internal clock source as the functional clock source.
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_clksel_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_source_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_source_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_source_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 24)));
}

static inline omap44xx_l4per_cm2_clksel_internal_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_internal_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_extract(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clksel_internal_source_status_t )((_regval & 0x2000000) >> 25));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_internal_source_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_insert(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval, omap44xx_l4per_cm2_clksel_internal_source_status_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 25)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_source =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_source_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock between, internal source and CLKS pad. The switching between the clocks is not guaranteed to be glitchless.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_internal_source =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_internal_source_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the internal clock to be used as the functional clock in case CLKSEL_SOURCE selects the internal clock source as the functional clock source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t
 * Description: Implicit type of This register manages the MCSPI1 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t
 * Description: Implicit type of This register manages the MCSPI2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t
 * Description: Implicit type of This register manages the MCSPI3 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t
 * Description: Implicit type of This register manages the MCSPI4 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t
 * Description: Implicit type of This register manages the MMCSD3 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t
 * Description: Implicit type of This register manages the MMCSD4 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t
 * Description: Implicit type of This register manages the SLIMBUS2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_per24mc_fclk	(size 1, offset 8, init 0):	RW	Optional functional clock control for PER_24MC_FCLK clock.
 *   optfclken_perabe24m_fclk	(size 1, offset 9, init 0):	RW	Optional functional clock control for PER_ABE_24M_FCLK clock.
 *   optfclken_slimbus_clk	(size 1, offset 10, init 0):	RW	Optional functional clock control.
 *   _anon11	(size 5, offset 11, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 9)));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_optfclken_dbclk_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 10)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_per24mc_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control for PER_24MC_FCLK clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_perabe24m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control for PER_ABE_24M_FCLK clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_slimbus_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t
 * Description: Implicit type of This register manages the UART1 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t
 * Description: Implicit type of This register manages the UART2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t
 * Description: Implicit type of This register manages the UART3 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t
 * Description: Implicit type of This register manages the UART4 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t
 * Description: Implicit type of This register manages the MMCSD5 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t
 * Description: Implicit type of This register enables the domain power state transition. It controls the hardware-supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds one status bit per clock input of the domain. register
 * Fields:
 *   clktrctrl	(size 2, offset 0, init 0):	RW	Controls the clock state transition of the L4SEC clock domain.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   clkactivity_l3_secure_giclk	(size 1, offset 8, init 0):	RO	This field indicates the state of the L3_SECURE_GICLK clock in the domain.
 *   clkactivity_l4_secure_giclk	(size 1, offset 9, init 0):	RO	This field indicates the state of the L4_SECURE_GICLK clock in the domain.
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_clkstctrl_default 0x0
static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_extract(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_extract(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clktrctrl_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_insert(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_insert(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_extract(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_extract(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_insert(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_insert(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_extract(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_extract(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval)
{
    return((omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_insert(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_insert(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval, omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t )(_fieldval)) << 9)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_clkstctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_clkstctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clktrctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clktrctrl_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls the clock state transition of the L4SEC clock domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_l3_secure_giclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L3_SECURE_GICLK clock in the domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_l4_secure_giclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L4_SECURE_GICLK clock in the domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_staticdep_t
 * Description: Implicit type of This register controls the static domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having system initiator(s). register
 * Fields:
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   memif_statdep	(size 1, offset 4, init 0):	RW	Static dependency towards MEMIF clock domain
 *   l3_1_statdep	(size 1, offset 5, init 0):	RW	Static dependency towards L3_1 clock domain
 *   l3_2_statdep	(size 1, offset 6, init 0):	RO	Static dependency towards L3_2 clock domain
 *   _anon7	(size 6, offset 7, init 0):	MBZ	_
 *   l4per_statdep	(size 1, offset 13, init 0):	RW	Static dependency towards L4PER clock domain
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_staticdep_t;
#define omap44xx_l4per_cm2_cm_l4sec_staticdep_default 0x0
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4per_statdep_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 4)));
}

static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4per_statdep_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 5)));
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4sec_dyndep_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4sec_dyndep_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 6)));
}

static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_extract(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4per_statdep_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_insert(omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 13)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_staticdep_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_staticdep_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " memif_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards MEMIF clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_1_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_1 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4per_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4PER clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t
 * Description: Implicit type of This register controls the dynamic domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having OCP master port(s). register
 * Fields:
 *   _anon0	(size 6, offset 0, init 0):	MBZ	_
 *   l3_2_dyndep	(size 1, offset 6, init 0):	RO	Dynamic dependency towards L3_2 clock domain
 *   _anon7	(size 25, offset 7, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t;
#define omap44xx_l4per_cm2_cm_l4sec_dynamicdep_default 0x0
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_extract(omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_extract(omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval)
{
    return((omap44xx_l4per_cm2_l4per_statdep_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_insert(omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_insert(omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t )(_fieldval)) << 6)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_dynamicdep_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_dynamicdep_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t
 * Description: Implicit type of This register manages the AES1 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status3_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t
 * Description: Implicit type of This register manages the AES2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status3_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t
 * Description: Implicit type of This register manages the DES3DES clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status3_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t
 * Description: Implicit type of This register manages the PKA clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status3_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t
 * Description: Implicit type of This register manages the RNG clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status4_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status4_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status4_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status4_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t
 * Description: Implicit type of This register manages the SHA2MD5 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status3_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t
 * Description: Implicit type of This register manages the CryptoDMA clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RO	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t;
#define omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_default 0x0
static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_extract(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_modulemode_status4_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status4_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_insert(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval, omap44xx_l4per_cm2_modulemode_status4_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_extract(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_idlest_status1_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_insert(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval, omap44xx_l4per_cm2_idlest_status1_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l4per_cm2_stbyst_status_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_extract(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_stbyst_status_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_extract(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval)
{
    return((omap44xx_l4per_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_insert(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval, omap44xx_l4per_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_insert(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval, omap44xx_l4per_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t )(_fieldval)) << 18)));
}

static inline int omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_prtval(char *_s, size_t _size, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status4_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_l4per_cm2_initials {
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_clkstctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_staticdep_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_dynamicdep_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_initial = 0x0,
    omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_l4per_cm2_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register cm_l4per_clkstctrl: This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain.
 * Type: omap44xx_l4per_cm2.cm_l4per_clkstctrl (Implicit type of This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain. register)
 *   clktrctrl	(size 2, offset 0, init 0):	RW	Controls the clock state transition of the L4PER clock domain.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   clkactivity_l4_per_iclk	(size 1, offset 8, init 0):	RO	This field indicates the state of the L4_PER_GICLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt10_fclk	(size 1, offset 9, init 0):	RO	This field indicates the state of the DMT10_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt11_fclk	(size 1, offset 10, init 0):	RO	This field indicates the state of the DMT11_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt2_fclk	(size 1, offset 11, init 0):	RO	This field indicates the state of the DMT2_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt3_fclk	(size 1, offset 12, init 0):	RO	This field indicates the state of the DMT3_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt4_fclk	(size 1, offset 13, init 0):	RO	This field indicates the state of the DMT4_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_gpt9_fclk	(size 1, offset 14, init 0):	RO	This field indicates the state of the DMT9_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_12m_fclk	(size 1, offset 15, init 0):	RO	This field indicates the state of the FUNC_12M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_24mc_fclk	(size 1, offset 16, init 0):	RO	This field indicates the state of the PER_24MC_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_32k_fclk	(size 1, offset 17, init 0):	RO	This field indicates the state of the PER_32K_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_48m_fclk	(size 1, offset 18, init 0):	RO	This field indicates the state of the PER_48M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_per_96m_fclk	(size 1, offset 19, init 0):	RO	This field indicates the state of the PER_96M_FCLK clock in the domain. [warm reset insensitive]
 *   _anon20	(size 2, offset 20, init 0):	MBZ	_
 *   clkactivity_per_mcbsp4_fclk	(size 1, offset 22, init 0):	RO	This field indicates the state of the PER_MCBSP4_FCLK clock in the domain. [warm reset insensitive]
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   _anon24	(size 1, offset 24, init 0):	MBZ	_
 *   clkactivity_per_abe_24m_fclk	(size 1, offset 25, init 0):	RO	This field indicates the state of the PER_ABE_24M_FCLK clock in the domain. [warm reset insensitive]
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_clkstctrl_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_l4per_cm2_cm_l4per_clkstctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_clkstctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_clkstctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_clkstctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval)
{
    _regval = (_regval & 0x24fff03);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_clkstctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_clkstctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_clkstctrl (This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clktrctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clktrctrl_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls the clock state transition of the L4PER clock domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_l4_per_iclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L4_PER_GICLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt10_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT10_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt11_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT11_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt3_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT3_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt4_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT4_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_gpt9_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the DMT9_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_12m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the FUNC_12M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_24mc_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_24MC_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_32k_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_32K_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_48m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_48M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_96m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_96M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_mcbsp4_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_MCBSP4_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_per_abe_24m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the PER_ABE_24M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_l4_per_iclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt10_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt11_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt2_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt3_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt4_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_gpt9_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_12m_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_24mc_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_32k_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_48m_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_96m_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_mcbsp4_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l4per_cm2_cm_l4per_clkstctrl_clkactivity_per_abe_24m_fclk_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_clkstctrl_clktrctrl_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_clkstctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_clkstctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x24fff03);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_dynamicdep: This register controls the dynamic domain dependencies from L4PER domain towards 'target' domains. It is relevant only for domain having INTERCONN master port(s).
 * Type: omap44xx_l4per_cm2.cm_l4per_dynamicdep (Implicit type of This register controls the dynamic domain dependencies from L4PER domain towards 'target' domains. It is relevant only for domain having INTERCONN master port(s). register)
 *   _anon0	(size 7, offset 0, init 0):	MBZ	_
 *   l3_init_dyndep	(size 1, offset 7, init 0):	RO	Dynamic dependency towards L3INIT clock domain
 *   dss_dyndep	(size 1, offset 8, init 0):	RO	Dynamic dependency towards DSS clock domain
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   l4sec_dyndep	(size 1, offset 14, init 0):	RO	Dynamic dependency towards L4SEC clock domain
 *   _anon15	(size 9, offset 15, init 0):	MBZ	_
 *   windowsize	(size 4, offset 24, init 0):	RW	Size of sliding window used to monitor INTRCONN interface activity for determination of auto-sleep feature. Time unit defined byCM_DYN_DEP_PRESCAL register.
 *   _anon28	(size 4, offset 28, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_dynamicdep_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_l4per_cm2_cm_l4per_dynamicdep_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_dynamicdep_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_dynamicdep_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_dynamicdep_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval)
{
    _regval = (_regval & 0xf004180);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_dynamicdep_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_dynamicdep_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_dynamicdep (This register controls the dynamic domain dependencies from L4PER domain towards 'target' domains. It is relevant only for domain having INTERCONN master port(s).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_init_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3INIT clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dss_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards DSS clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4sec_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L4SEC clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " windowsize =\t%" PRIx8 "\t(Size of sliding window used to monitor INTRCONN interface activity for determination of auto-sleep feature. Time unit defined byCM_DYN_DEP_PRESCAL register.)\n", omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_l4per_cm2_cm_l4per_dynamicdep_l3_init_dyndep_extract(_regval));
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_l4per_cm2_cm_l4per_dynamicdep_dss_dyndep_extract(_regval));
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_l4per_cm2_cm_l4per_dynamicdep_l4sec_dyndep_extract(_regval));
}

static inline uint8_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_dynamicdep_windowsize_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_dynamicdep_t _regval = 0xf000000 & (((omap44xx_l4per_cm2_cm_l4per_dynamicdep_t )(_fieldval)) << 24);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf004180);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gptimer10_clkctrl: This register manages the DMTIMER10 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gptimer10_clkctrl (Implicit type of This register manages the DMTIMER10 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval)
{
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gptimer10_clkctrl (This register manages the DMTIMER10 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gptimer11_clkctrl: This register manages the DMTIMER11 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gptimer11_clkctrl (Implicit type of This register manages the DMTIMER11 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval)
{
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gptimer11_clkctrl (This register manages the DMTIMER11 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gptimer2_clkctrl: This register manages the DMTIMER2 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gptimer2_clkctrl (Implicit type of This register manages the DMTIMER2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval)
{
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gptimer2_clkctrl (This register manages the DMTIMER2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gptimer3_clkctrl: This register manages the DMTIMER3 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gptimer3_clkctrl (Implicit type of This register manages the DMTIMER3 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval)
{
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gptimer3_clkctrl (This register manages the DMTIMER3 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gptimer4_clkctrl: This register manages the DMTIMER4 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gptimer4_clkctrl (Implicit type of This register manages the DMTIMER4 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval)
{
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gptimer4_clkctrl (This register manages the DMTIMER4 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gptimer9_clkctrl: This register manages the DMTIMER9 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gptimer9_clkctrl (Implicit type of This register manages the DMTIMER9 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Select the source of the functional clock
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval)
{
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gptimer9_clkctrl (This register manages the DMTIMER9 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the source of the functional clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_status_t omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0x1030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_elm_clkctrl: This register manages the ELM clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_elm_clkctrl (Implicit type of This register manages the ELM clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RO	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline void omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

// Register cm_l4per_elm_clkctrl is not writeable
static inline int omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_elm_clkctrl (This register manages the ELM clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_idlest_extract(_regval));
}

/*
 * Register cm_l4per_gpio2_clkctrl: This register manages the GPIO2 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gpio2_clkctrl (Implicit type of This register manages the GPIO2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval)
{
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gpio2_clkctrl (This register manages the GPIO2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t _regval = 0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gpio3_clkctrl: This register manages the GPIO3 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gpio3_clkctrl (Implicit type of This register manages the GPIO3 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval)
{
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gpio3_clkctrl (This register manages the GPIO3 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t _regval = 0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gpio4_clkctrl: This register manages the GPIO4 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gpio4_clkctrl (Implicit type of This register manages the GPIO4 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval)
{
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gpio4_clkctrl (This register manages the GPIO4 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t _regval = 0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gpio5_clkctrl: This register manages the GPIO5 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gpio5_clkctrl (Implicit type of This register manages the GPIO5 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x78));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x78));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x78, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval)
{
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x78, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x78);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gpio5_clkctrl (This register manages the GPIO5 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x78);
    return(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x78);
    return(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x78);
    return(omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t _regval = 0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_gpio6_clkctrl: This register manages the GPIO6 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_gpio6_clkctrl (Implicit type of This register manages the GPIO6 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_dbclk	(size 1, offset 8, init 0):	RW	Optional functional clock control.
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval)
{
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_gpio6_clkctrl (This register manages the GPIO6 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_dbclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status2_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_optfclken_dbclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t _regval = 0x100 & (((omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_hdq1w_clkctrl: This register manages the HDQ1W clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_hdq1w_clkctrl (Implicit type of This register manages the HDQ1W clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x88));
}

static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x88));
}

static inline void omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_hdq1w_clkctrl (This register manages the HDQ1W clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

/*
 * Register array cm_l4per_i2c_clkctrl: This register manages the i-th I2C clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_i2c_clkctrl (Implicit type of This register manages the i-th I2C clocks. register array)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static const size_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_length = 4;
static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0 + (_i * 8)));
}

static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0 + (_i * 8)));
}

static inline void omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_rawwr(__DN(t) *_dev, int _i, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_rawwr(__DN(t) *_dev, int _i, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa0 + (_i * 8), _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_wr(__DN(t) *_dev, int _i, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_wr(__DN(t) *_dev, int _i, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa0 + (_i * 8), _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xa0 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "cm_l4per_i2c_clkctrl", _i, "This register manages the i-th I2C clocks.");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline int omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_rdf(__DN(t) *_dev, int _i)
{
    omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xa0 + (_i * 8));
    return(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_rdf(__DN(t) *_dev, int _i)
{
    omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xa0 + (_i * 8));
    return(omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_wrf(__DN(t) *_dev, int _i, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_modulemode_wrf(__DN(t) *_dev, int _i, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_l4per_clkctrl: This register manages the L4PER clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_l4per_clkctrl (Implicit type of This register manages the L4PER clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RO	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc0));
}

static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc0));
}

static inline void omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc0, _regval);
}

// Register cm_l4per_l4per_clkctrl is not writeable
static inline int omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_l4per_clkctrl (This register manages the L4PER clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status1_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_idlest_extract(_regval));
}

/*
 * Register cm_l4per_mcbsp4_clkctrl: This register manages the MCBSP4 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mcbsp4_clkctrl (Implicit type of This register manages the MCBSP4 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 6, offset 18, init 0):	MBZ	_
 *   clksel_source	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock between, internal source and CLKS pad. The switching between the clocks is not guaranteed to be glitchless.
 *   clksel_internal_source	(size 1, offset 25, init 0):	RW	Selects the internal clock to be used as the functional clock in case CLKSEL_SOURCE selects the internal clock source as the functional clock source.
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval)
{
    _regval = (_regval & 0x3030003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mcbsp4_clkctrl (This register manages the MCBSP4 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_source =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_source_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock between, internal source and CLKS pad. The switching between the clocks is not guaranteed to be glitchless.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_internal_source =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clksel_internal_source_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the internal clock to be used as the functional clock in case CLKSEL_SOURCE selects the internal clock source as the functional clock source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_extract(_regval));
}

static inline omap44xx_l4per_cm2_clksel_internal_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clksel_internal_source_status_t omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3000000 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x3030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_source_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_source_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_source_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = 0x1000000 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x2000003 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x3030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_internal_source_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_clksel_internal_source_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clksel_internal_source_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t _regval = 0x2000000 & (((omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_t )(_fieldval)) << 25);
    _regval = (_regval | (0x1000003 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x3030003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mcspi1_clkctrl: This register manages the MCSPI1 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mcspi1_clkctrl (Implicit type of This register manages the MCSPI1 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mcspi1_clkctrl (This register manages the MCSPI1 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mcspi2_clkctrl: This register manages the MCSPI2 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mcspi2_clkctrl (Implicit type of This register manages the MCSPI2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf8));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf8));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf8, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xf8, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mcspi2_clkctrl (This register manages the MCSPI2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf8);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf8);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mcspi3_clkctrl: This register manages the MCSPI3 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mcspi3_clkctrl (Implicit type of This register manages the MCSPI3 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mcspi3_clkctrl (This register manages the MCSPI3 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mcspi4_clkctrl: This register manages the MCSPI4 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mcspi4_clkctrl (Implicit type of This register manages the MCSPI4 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mcspi4_clkctrl (This register manages the MCSPI4 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    return(omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mmcsd3_clkctrl: This register manages the MMCSD3 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mmcsd3_clkctrl (Implicit type of This register manages the MMCSD3 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x120));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x120));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x120);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mmcsd3_clkctrl (This register manages the MMCSD3 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x120);
    return(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x120);
    return(omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mmcsd4_clkctrl: This register manages the MMCSD4 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mmcsd4_clkctrl (Implicit type of This register manages the MMCSD4 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x128));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x128));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x128);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mmcsd4_clkctrl (This register manages the MMCSD4 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x128);
    return(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x128);
    return(omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_slimbus2_clkctrl: This register manages the SLIMBUS2 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_slimbus2_clkctrl (Implicit type of This register manages the SLIMBUS2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_per24mc_fclk	(size 1, offset 8, init 0):	RW	Optional functional clock control for PER_24MC_FCLK clock.
 *   optfclken_perabe24m_fclk	(size 1, offset 9, init 0):	RW	Optional functional clock control for PER_ABE_24M_FCLK clock.
 *   optfclken_slimbus_clk	(size 1, offset 10, init 0):	RW	Optional functional clock control.
 *   _anon11	(size 5, offset 11, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x138));
}

static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x138));
}

static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval)
{
    _regval = (_regval & 0x30703);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_slimbus2_clkctrl (This register manages the SLIMBUS2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_per24mc_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control for PER_24MC_FCLK clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_perabe24m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control for PER_ABE_24M_FCLK clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_slimbus_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_optfclken_dbclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Optional functional clock control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    return(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    return(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    return(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_optfclken_dbclk_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    return(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    return(omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x700 & mackerel_read_addr_32(_dev->base, 0x138)));
    // No read of register shadow required
    _regval = (_regval & 0x30703);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_per24mc_fclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = 0x100 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x603 & mackerel_read_addr_32(_dev->base, 0x138)));
    // No read of register shadow required
    _regval = (_regval & 0x30703);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_perabe24m_fclk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = 0x200 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0x503 & mackerel_read_addr_32(_dev->base, 0x138)));
    // No read of register shadow required
    _regval = (_regval & 0x30703);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_optfclken_slimbus_clk_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_optfclken_dbclk_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t _regval = 0x400 & (((omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_t )(_fieldval)) << 10);
    _regval = (_regval | (0x303 & mackerel_read_addr_32(_dev->base, 0x138)));
    // No read of register shadow required
    _regval = (_regval & 0x30703);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_uart1_clkctrl: This register manages the UART1 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_uart1_clkctrl (Implicit type of This register manages the UART1 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_uart1_clkctrl (This register manages the UART1 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    return(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    return(omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_uart2_clkctrl: This register manages the UART2 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_uart2_clkctrl (Implicit type of This register manages the UART2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_uart2_clkctrl (This register manages the UART2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    return(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    return(omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_uart3_clkctrl: This register manages the UART3 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_uart3_clkctrl (Implicit type of This register manages the UART3 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x150));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x150));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x150);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_uart3_clkctrl (This register manages the UART3 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x150);
    return(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x150);
    return(omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_uart4_clkctrl: This register manages the UART4 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_uart4_clkctrl (Implicit type of This register manages the UART4 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x158));
}

static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x158));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x158, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x158, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x158);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_uart4_clkctrl (This register manages the UART4 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x158);
    return(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x158);
    return(omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x158, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4per_mmcsd5_clkctrl: This register manages the MMCSD5 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4per_mmcsd5_clkctrl (Implicit type of This register manages the MMCSD5 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4per_mmcsd5_clkctrl (This register manages the MMCSD5 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status_t omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_clkstctrl: This register enables the domain power state transition. It controls the hardware-supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds one status bit per clock input of the domain.
 * Type: omap44xx_l4per_cm2.cm_l4sec_clkstctrl (Implicit type of This register enables the domain power state transition. It controls the hardware-supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds one status bit per clock input of the domain. register)
 *   clktrctrl	(size 2, offset 0, init 0):	RW	Controls the clock state transition of the L4SEC clock domain.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   clkactivity_l3_secure_giclk	(size 1, offset 8, init 0):	RO	This field indicates the state of the L3_SECURE_GICLK clock in the domain.
 *   clkactivity_l4_secure_giclk	(size 1, offset 9, init 0):	RO	This field indicates the state of the L4_SECURE_GICLK clock in the domain.
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_clkstctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_clkstctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_clkstctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_clkstctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval)
{
    _regval = (_regval & 0x303);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_clkstctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_clkstctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_clkstctrl (This register enables the domain power state transition. It controls the hardware-supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds one status bit per clock input of the domain.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clktrctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clktrctrl_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls the clock state transition of the L4SEC clock domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_l3_secure_giclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L3_SECURE_GICLK clock in the domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_l4_secure_giclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L4_SECURE_GICLK clock in the domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clktrctrl_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l3_secure_giclk_extract(_regval));
}

static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_clkactivity_per_abe_24m_fclk_status_t omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clkactivity_l4_secure_giclk_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_clkstctrl_clktrctrl_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_clktrctrl_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_clkstctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x303);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_staticdep: This register controls the static domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having system initiator(s).
 * Type: omap44xx_l4per_cm2.cm_l4sec_staticdep (Implicit type of This register controls the static domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having system initiator(s). register)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   memif_statdep	(size 1, offset 4, init 0):	RW	Static dependency towards MEMIF clock domain
 *   l3_1_statdep	(size 1, offset 5, init 0):	RW	Static dependency towards L3_1 clock domain
 *   l3_2_statdep	(size 1, offset 6, init 0):	RO	Static dependency towards L3_2 clock domain
 *   _anon7	(size 6, offset 7, init 0):	MBZ	_
 *   l4per_statdep	(size 1, offset 13, init 0):	RW	Static dependency towards L4PER clock domain
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x184));
}

static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_staticdep_t omap44xx_l4per_cm2_cm_l4sec_staticdep_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x184));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval)
{
    _regval = (_regval & 0x2070);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_staticdep_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_staticdep_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_staticdep (This register controls the static domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having system initiator(s).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " memif_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards MEMIF clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_1_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_1 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4sec_dyndep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4per_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4PER clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    return(omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_extract(_regval));
}

static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    return(omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_extract(_regval));
}

static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4sec_dyndep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    return(omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_2_statdep_extract(_regval));
}

static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    return(omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_memif_statdep_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = 0x10 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 4);
    _regval = (_regval | (0x2020 & mackerel_read_addr_32(_dev->base, 0x184)));
    // No read of register shadow required
    _regval = (_regval & 0x2070);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_l3_1_statdep_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = 0x20 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 5);
    _regval = (_regval | (0x2010 & mackerel_read_addr_32(_dev->base, 0x184)));
    // No read of register shadow required
    _regval = (_regval & 0x2070);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_staticdep_l4per_statdep_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_l4per_statdep_status_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_staticdep_t _regval = 0x2000 & (((omap44xx_l4per_cm2_cm_l4sec_staticdep_t )(_fieldval)) << 13);
    _regval = (_regval | (0x30 & mackerel_read_addr_32(_dev->base, 0x184)));
    // No read of register shadow required
    _regval = (_regval & 0x2070);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_dynamicdep: This register controls the dynamic domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having OCP master port(s).
 * Type: omap44xx_l4per_cm2.cm_l4sec_dynamicdep (Implicit type of This register controls the dynamic domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having OCP master port(s). register)
 *   _anon0	(size 6, offset 0, init 0):	MBZ	_
 *   l3_2_dyndep	(size 1, offset 6, init 0):	RO	Dynamic dependency towards L3_2 clock domain
 *   _anon7	(size 25, offset 7, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x188));
}

static inline omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x188));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_dynamicdep_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_dynamicdep_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x188, _regval);
}

// Register cm_l4sec_dynamicdep is not writeable
static inline int omap44xx_l4per_cm2_cm_l4sec_dynamicdep_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_dynamicdep_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x188);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_dynamicdep (This register controls the dynamic domain dependencies from L4SEC domain towards 'target' domains. It is relevant only for domain having OCP master port(s).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_l4per_statdep_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_l4per_statdep_status_t omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x188);
    return(omap44xx_l4per_cm2_cm_l4sec_dynamicdep_l3_2_dyndep_extract(_regval));
}

/*
 * Register cm_l4sec_aes1_clkctrl: This register manages the AES1 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_aes1_clkctrl (Implicit type of This register manages the AES1 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a0));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1a0, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1a0, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_aes1_clkctrl (This register manages the AES1 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1a0);
    return(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1a0);
    return(omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1a0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_aes2_clkctrl: This register manages the AES2 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_aes2_clkctrl (Implicit type of This register manages the AES2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a8));
}

static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a8));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1a8, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1a8, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_aes2_clkctrl (This register manages the AES2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1a8);
    return(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1a8);
    return(omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1a8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_des3des_clkctrl: This register manages the DES3DES clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_des3des_clkctrl (Implicit type of This register manages the DES3DES clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b0));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1b0, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1b0, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_des3des_clkctrl (This register manages the DES3DES clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1b0);
    return(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1b0);
    return(omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1b0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_pka_clkctrl: This register manages the PKA clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_pka_clkctrl (Implicit type of This register manages the PKA clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b8));
}

static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b8));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1b8, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1b8, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_pka_clkctrl (This register manages the PKA clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1b8);
    return(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1b8);
    return(omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1b8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_rng_clkctrl: This register manages the RNG clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_rng_clkctrl (Implicit type of This register manages the RNG clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c0));
}

static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c0));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c0, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c0, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_rng_clkctrl (This register manages the RNG clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status4_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1c0);
    return(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1c0);
    return(omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status4_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status4_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_sha2md5_clkctrl: This register manages the SHA2MD5 clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_sha2md5_clkctrl (Implicit type of This register manages the SHA2MD5 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c8));
}

static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c8));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c8, _regval);
}

static inline void omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_wr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval)
{
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c8, _regval);
}

static inline int omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_sha2md5_clkctrl (This register manages the SHA2MD5 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status3_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status3_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1c8);
    return(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1c8);
    return(omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l4per_cm2_modulemode_status3_t _fieldval)
{
    omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t _regval = 0x3 & (((omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x30003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l4sec_cryptodma_clkctrl: This register manages the CryptoDMA clocks.
 * Type: omap44xx_l4per_cm2.cm_l4sec_cryptodma_clkctrl (Implicit type of This register manages the CryptoDMA clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RO	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d8));
}

static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d8));
}

static inline void omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1d8, _regval);
}

// Register cm_l4sec_cryptodma_clkctrl is not writeable
static inline int omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l4sec_cryptodma_clkctrl (This register manages the CryptoDMA clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_modulemode_status4_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_idlest_status1_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_modulemode_status4_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1d8);
    return(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_idlest_status1_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1d8);
    return(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l4per_cm2_stbyst_status_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l4per_cm2_stbyst_status_t omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x1d8);
    return(omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_stbyst_extract(_regval));
}

static inline int omap44xx_l4per_cm2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l4per_cm2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_l4per_cm2 ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_clkstctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_dynamicdep_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gptimer10_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gptimer11_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gptimer2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gptimer3_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gptimer4_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gptimer9_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_elm_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gpio2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gpio3_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gpio4_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gpio5_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_gpio6_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_hdq1w_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_i2c_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_l4per_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mcbsp4_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mcspi1_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mcspi2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mcspi3_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mcspi4_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mmcsd3_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mmcsd4_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_slimbus2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_uart1_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_uart2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_uart3_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_uart4_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4per_mmcsd5_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_clkstctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_staticdep_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_dynamicdep_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_aes1_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_aes2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_des3des_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_pka_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_rng_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_sha2md5_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l4per_cm2_cm_l4sec_cryptodma_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_l4per_cm2\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_l4per_cm2_DEV_H
