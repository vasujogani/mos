#ifndef __omap44xx_l3init_cm2_DEV_H
#define __omap44xx_l3init_cm2_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_l3init_cm2 ## _ ## x
/*
 * Constants defn: omap44xx_l3init_cm2.clkactivity_init_60m_p2_fclk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t;
#define omap44xx_l3init_cm2_CLKACTIVITY_INIT_60M_P2_FCLK_0_r ((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t)0x0)
#define omap44xx_l3init_cm2_CLKACTIVITY_INIT_60M_P2_FCLK_1_r ((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t)0x1)

static inline char *omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_describe(omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_describe(omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_CLKACTIVITY_INIT_60M_P2_FCLK_0_r:
        return("CLKACTIVITY_INIT_60M_P2_FCLK_0_r: Corresponding clock is definitely gated");
    case omap44xx_l3init_cm2_CLKACTIVITY_INIT_60M_P2_FCLK_1_r:
        return("CLKACTIVITY_INIT_60M_P2_FCLK_1_r: Corresponding clock is running or gating/ungating transition is ongoing");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _e)
{
    char *d = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.clktrctrl_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l3init_cm2_clktrctrl_status_t;
#define omap44xx_l3init_cm2_CLKTRCTRL_0 ((omap44xx_l3init_cm2_clktrctrl_status_t)0x0)
#define omap44xx_l3init_cm2_CLKTRCTRL_1 ((omap44xx_l3init_cm2_clktrctrl_status_t)0x1)
#define omap44xx_l3init_cm2_CLKTRCTRL_2 ((omap44xx_l3init_cm2_clktrctrl_status_t)0x2)
#define omap44xx_l3init_cm2_CLKTRCTRL_3 ((omap44xx_l3init_cm2_clktrctrl_status_t)0x3)

static inline char *omap44xx_l3init_cm2_clktrctrl_status_describe(omap44xx_l3init_cm2_clktrctrl_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_clktrctrl_status_describe(omap44xx_l3init_cm2_clktrctrl_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_CLKTRCTRL_0:
        return("CLKTRCTRL_0: NO_SLEEP: Sleep transition cannot be initiated. Wakeup transition may however occur.");
    case omap44xx_l3init_cm2_CLKTRCTRL_1:
        return("CLKTRCTRL_1: SW_SLEEP: Start a software forced sleep transition on the domain.");
    case omap44xx_l3init_cm2_CLKTRCTRL_2:
        return("CLKTRCTRL_2: SW_WKUP: Start a software forced wake-up transition on the domain.");
    case omap44xx_l3init_cm2_CLKTRCTRL_3:
        return("CLKTRCTRL_3: HW_AUTO: Automatic transition is enabled. Sleep and wakeup transition are based upon hardware conditions.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_clktrctrl_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clktrctrl_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_clktrctrl_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clktrctrl_status_t _e)
{
    char *d = omap44xx_l3init_cm2_clktrctrl_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_clktrctrl_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.l4wkup_statdep_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_l4wkup_statdep_status_t;
#define omap44xx_l3init_cm2_L4WKUP_STATDEP_0 ((omap44xx_l3init_cm2_l4wkup_statdep_status_t)0x0)
#define omap44xx_l3init_cm2_L4WKUP_STATDEP_1 ((omap44xx_l3init_cm2_l4wkup_statdep_status_t)0x1)

static inline char *omap44xx_l3init_cm2_l4wkup_statdep_status_describe(omap44xx_l3init_cm2_l4wkup_statdep_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_l4wkup_statdep_status_describe(omap44xx_l3init_cm2_l4wkup_statdep_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_L4WKUP_STATDEP_0:
        return("L4WKUP_STATDEP_0: Dependency is disabled");
    case omap44xx_l3init_cm2_L4WKUP_STATDEP_1:
        return("L4WKUP_STATDEP_1: Dependency is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_l4wkup_statdep_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_l4wkup_statdep_status_t _e)
{
    char *d = omap44xx_l3init_cm2_l4wkup_statdep_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_l4wkup_statdep_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.clksel_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_clksel_status_t;
#define omap44xx_l3init_cm2_CLKSEL_0 ((omap44xx_l3init_cm2_clksel_status_t)0x0)
#define omap44xx_l3init_cm2_CLKSEL_1 ((omap44xx_l3init_cm2_clksel_status_t)0x1)

static inline char *omap44xx_l3init_cm2_clksel_status_describe(omap44xx_l3init_cm2_clksel_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_clksel_status_describe(omap44xx_l3init_cm2_clksel_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_CLKSEL_0:
        return("CLKSEL_0: 64MHz clock derived from DPLL_PER is selected");
    case omap44xx_l3init_cm2_CLKSEL_1:
        return("CLKSEL_1: 96MHz clock derived from DPLL_PER is selected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_clksel_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_clksel_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_status_t _e)
{
    char *d = omap44xx_l3init_cm2_clksel_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_clksel_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.stbyst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_stbyst_status_t;
#define omap44xx_l3init_cm2_STBYST_0_r ((omap44xx_l3init_cm2_stbyst_status_t)0x0)
#define omap44xx_l3init_cm2_STBYST_1_r ((omap44xx_l3init_cm2_stbyst_status_t)0x1)

static inline char *omap44xx_l3init_cm2_stbyst_status_describe(omap44xx_l3init_cm2_stbyst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_stbyst_status_describe(omap44xx_l3init_cm2_stbyst_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_STBYST_0_r:
        return("STBYST_0_r: Module is functional (not in standby)");
    case omap44xx_l3init_cm2_STBYST_1_r:
        return("STBYST_1_r: Module is in standby");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_stbyst_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_stbyst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_stbyst_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_stbyst_status_t _e)
{
    char *d = omap44xx_l3init_cm2_stbyst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_stbyst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.idlest_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l3init_cm2_idlest_status_t;
#define omap44xx_l3init_cm2_IDLEST_0_r ((omap44xx_l3init_cm2_idlest_status_t)0x0)
#define omap44xx_l3init_cm2_IDLEST_1_r ((omap44xx_l3init_cm2_idlest_status_t)0x1)
#define omap44xx_l3init_cm2_IDLEST_2_r ((omap44xx_l3init_cm2_idlest_status_t)0x2)
#define omap44xx_l3init_cm2_IDLEST_3_r ((omap44xx_l3init_cm2_idlest_status_t)0x3)

static inline char *omap44xx_l3init_cm2_idlest_status_describe(omap44xx_l3init_cm2_idlest_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_idlest_status_describe(omap44xx_l3init_cm2_idlest_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_IDLEST_0_r:
        return("IDLEST_0_r: Module is fully functional, including INTRCONN");
    case omap44xx_l3init_cm2_IDLEST_1_r:
        return("IDLEST_1_r: Module is performing transition: wakeup, or sleep, or sleep abortion");
    case omap44xx_l3init_cm2_IDLEST_2_r:
        return("IDLEST_2_r: Module is in idle mode (only INTRCONN part). It is functional if using separate functional clock");
    case omap44xx_l3init_cm2_IDLEST_3_r:
        return("IDLEST_3_r: Module is disabled and cannot be accessed");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_idlest_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_idlest_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_idlest_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_idlest_status_t _e)
{
    char *d = omap44xx_l3init_cm2_idlest_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_idlest_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.modulemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l3init_cm2_modulemode_status_t;
#define omap44xx_l3init_cm2_MODULEMODE_0 ((omap44xx_l3init_cm2_modulemode_status_t)0x0)
#define omap44xx_l3init_cm2_MODULEMODE_1_r ((omap44xx_l3init_cm2_modulemode_status_t)0x1)
#define omap44xx_l3init_cm2_MODULEMODE_2 ((omap44xx_l3init_cm2_modulemode_status_t)0x2)
#define omap44xx_l3init_cm2_MODULEMODE_3_r ((omap44xx_l3init_cm2_modulemode_status_t)0x3)

static inline char *omap44xx_l3init_cm2_modulemode_status_describe(omap44xx_l3init_cm2_modulemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_modulemode_status_describe(omap44xx_l3init_cm2_modulemode_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_MODULEMODE_0:
        return("MODULEMODE_0: Module is disable by software. Any INTRCONN access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l3init_cm2_MODULEMODE_1_r:
        return("MODULEMODE_1_r: Reserved");
    case omap44xx_l3init_cm2_MODULEMODE_2:
        return("MODULEMODE_2: Module is explicitly enabled. Interface clock (if not used for functions) may be gated according to the clock domain state. Functional clocks are guarantied to stay present. As long as in this configuration, power domain sleep transition cannot happen.");
    case omap44xx_l3init_cm2_MODULEMODE_3_r:
        return("MODULEMODE_3_r: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_modulemode_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_modulemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_modulemode_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_modulemode_status_t _e)
{
    char *d = omap44xx_l3init_cm2_modulemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_modulemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.clksel_status1 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l3init_cm2_clksel_status1_t;
#define omap44xx_l3init_cm2_CLKSEL_0_2 ((omap44xx_l3init_cm2_clksel_status1_t)0x0)
#define omap44xx_l3init_cm2_CLKSEL_1_2 ((omap44xx_l3init_cm2_clksel_status1_t)0x1)
#define omap44xx_l3init_cm2_CLKSEL_2 ((omap44xx_l3init_cm2_clksel_status1_t)0x2)
#define omap44xx_l3init_cm2_CLKSEL_3 ((omap44xx_l3init_cm2_clksel_status1_t)0x3)

static inline char *omap44xx_l3init_cm2_clksel_status1_describe(omap44xx_l3init_cm2_clksel_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_clksel_status1_describe(omap44xx_l3init_cm2_clksel_status1_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_CLKSEL_0_2:
        return("CLKSEL_0_2: HSI_FCLK is divide by 1 of 192-MHz clock, to be used for OPP100");
    case omap44xx_l3init_cm2_CLKSEL_1_2:
        return("CLKSEL_1_2: HSI_FCLK is divide by 2 of 192-MHz clock, to be used for OPP50");
    case omap44xx_l3init_cm2_CLKSEL_2:
        return("CLKSEL_2: HSI_FCLK is divide by 4 of 192-MHz clock");
    case omap44xx_l3init_cm2_CLKSEL_3:
        return("CLKSEL_3: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_clksel_status1_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_clksel_status1_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_status1_t _e)
{
    char *d = omap44xx_l3init_cm2_clksel_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_clksel_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.modulemode_status1 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l3init_cm2_modulemode_status1_t;
#define omap44xx_l3init_cm2_MODULEMODE_0_2 ((omap44xx_l3init_cm2_modulemode_status1_t)0x0)
#define omap44xx_l3init_cm2_MODULEMODE_1 ((omap44xx_l3init_cm2_modulemode_status1_t)0x1)
#define omap44xx_l3init_cm2_MODULEMODE_3_r_2 ((omap44xx_l3init_cm2_modulemode_status1_t)0x3)

static inline char *omap44xx_l3init_cm2_modulemode_status1_describe(omap44xx_l3init_cm2_modulemode_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_modulemode_status1_describe(omap44xx_l3init_cm2_modulemode_status1_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_MODULEMODE_0_2:
        return("MODULEMODE_0_2: Module is disable by software. Any INTRCONN access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l3init_cm2_MODULEMODE_1:
        return("MODULEMODE_1: Module is managed automatically by hardware according to clock domain");
    case omap44xx_l3init_cm2_MODULEMODE_3_r_2:
        return("MODULEMODE_3_r_2: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_modulemode_status1_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_modulemode_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_modulemode_status1_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_modulemode_status1_t _e)
{
    char *d = omap44xx_l3init_cm2_modulemode_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_modulemode_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.clksel_utmi_p2_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_clksel_utmi_p2_status_t;
#define omap44xx_l3init_cm2_CLKSEL_UTMI_P2_0 ((omap44xx_l3init_cm2_clksel_utmi_p2_status_t)0x0)
#define omap44xx_l3init_cm2_CLKSEL_UTMI_P2_1 ((omap44xx_l3init_cm2_clksel_utmi_p2_status_t)0x1)

static inline char *omap44xx_l3init_cm2_clksel_utmi_p2_status_describe(omap44xx_l3init_cm2_clksel_utmi_p2_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_clksel_utmi_p2_status_describe(omap44xx_l3init_cm2_clksel_utmi_p2_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_CLKSEL_UTMI_P2_0:
        return("CLKSEL_UTMI_P2_0: The functional clock is provided by the internal clock source");
    case omap44xx_l3init_cm2_CLKSEL_UTMI_P2_1:
        return("CLKSEL_UTMI_P2_1: The functional clock is provided by an external PHY through an I/O pad.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_clksel_utmi_p2_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_clksel_utmi_p2_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _e)
{
    char *d = omap44xx_l3init_cm2_clksel_utmi_p2_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_clksel_utmi_p2_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.optfclken_func48mclk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_optfclken_func48mclk_status_t;
#define omap44xx_l3init_cm2_OPTFCLKEN_FUNC48MCLK_0 ((omap44xx_l3init_cm2_optfclken_func48mclk_status_t)0x0)
#define omap44xx_l3init_cm2_OPTFCLKEN_FUNC48MCLK_1 ((omap44xx_l3init_cm2_optfclken_func48mclk_status_t)0x1)

static inline char *omap44xx_l3init_cm2_optfclken_func48mclk_status_describe(omap44xx_l3init_cm2_optfclken_func48mclk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_optfclken_func48mclk_status_describe(omap44xx_l3init_cm2_optfclken_func48mclk_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_OPTFCLKEN_FUNC48MCLK_0:
        return("OPTFCLKEN_FUNC48MCLK_0: Optional functional clock is disabled");
    case omap44xx_l3init_cm2_OPTFCLKEN_FUNC48MCLK_1:
        return("OPTFCLKEN_FUNC48MCLK_1: Optional functional clock is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _e)
{
    char *d = omap44xx_l3init_cm2_optfclken_func48mclk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_optfclken_func48mclk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.sar_mode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_sar_mode_status_t;
#define omap44xx_l3init_cm2_SAR_MODE_0 ((omap44xx_l3init_cm2_sar_mode_status_t)0x0)
#define omap44xx_l3init_cm2_SAR_MODE_1 ((omap44xx_l3init_cm2_sar_mode_status_t)0x1)

static inline char *omap44xx_l3init_cm2_sar_mode_status_describe(omap44xx_l3init_cm2_sar_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_sar_mode_status_describe(omap44xx_l3init_cm2_sar_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_SAR_MODE_0:
        return("SAR_MODE_0: SAR mode is disabled");
    case omap44xx_l3init_cm2_SAR_MODE_1:
        return("SAR_MODE_1: SAR mode is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_sar_mode_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_sar_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_sar_mode_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_sar_mode_status_t _e)
{
    char *d = omap44xx_l3init_cm2_sar_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_sar_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.clksel_60m_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_l3init_cm2_clksel_60m_status_t;
#define omap44xx_l3init_cm2_CLKSEL_60M_0 ((omap44xx_l3init_cm2_clksel_60m_status_t)0x0)
#define omap44xx_l3init_cm2_CLKSEL_60M_1 ((omap44xx_l3init_cm2_clksel_60m_status_t)0x1)

static inline char *omap44xx_l3init_cm2_clksel_60m_status_describe(omap44xx_l3init_cm2_clksel_60m_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_clksel_60m_status_describe(omap44xx_l3init_cm2_clksel_60m_status_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_CLKSEL_60M_0:
        return("CLKSEL_60M_0: The 60MHz clock is sourced from on die UTMI PHY");
    case omap44xx_l3init_cm2_CLKSEL_60M_1:
        return("CLKSEL_60M_1: The 60MHz clock is sourced from the external ULPI PHY");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_clksel_60m_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_60m_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_clksel_60m_status_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_clksel_60m_status_t _e)
{
    char *d = omap44xx_l3init_cm2_clksel_60m_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_clksel_60m_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_l3init_cm2.modulemode_status2 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_l3init_cm2_modulemode_status2_t;
#define omap44xx_l3init_cm2_MODULEMODE_0_4 ((omap44xx_l3init_cm2_modulemode_status2_t)0x0)
#define omap44xx_l3init_cm2_MODULEMODE_1_1 ((omap44xx_l3init_cm2_modulemode_status2_t)0x1)
#define omap44xx_l3init_cm2_MODULEMODE_2_r ((omap44xx_l3init_cm2_modulemode_status2_t)0x2)
#define omap44xx_l3init_cm2_MODULEMODE_3_r_4 ((omap44xx_l3init_cm2_modulemode_status2_t)0x3)

static inline char *omap44xx_l3init_cm2_modulemode_status2_describe(omap44xx_l3init_cm2_modulemode_status2_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_l3init_cm2_modulemode_status2_describe(omap44xx_l3init_cm2_modulemode_status2_t _e)
{
    switch (_e) {
    case omap44xx_l3init_cm2_MODULEMODE_0_4:
        return("MODULEMODE_0_4: Module is disable by software. Any INTRCONN access to module results in an error, except if resulting from a module wakeup (asynchronous wakeup).");
    case omap44xx_l3init_cm2_MODULEMODE_1_1:
        return("MODULEMODE_1_1: Module is managed automatically by hardware according to clock domain transition. A clock domain sleep transition put module into idle. A wakeup domain transition put it back into function. If CLKTRCTRL=3, any INTRCONN access to module is always granted. Module clocks may be gated according to the clock domain state.");
    case omap44xx_l3init_cm2_MODULEMODE_2_r:
        return("MODULEMODE_2_r: Reserved");
    case omap44xx_l3init_cm2_MODULEMODE_3_r_4:
        return("MODULEMODE_3_r_4: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_l3init_cm2_modulemode_status2_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_modulemode_status2_t _e) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_modulemode_status2_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_modulemode_status2_t _e)
{
    char *d = omap44xx_l3init_cm2_modulemode_status2_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_l3init_cm2_modulemode_status2_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_clkstctrl_t
 * Description: Implicit type of This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain. register
 * Fields:
 *   clktrctrl	(size 2, offset 0, init 0):	RW	Controls the clock state transition of the L3INIT clock domain.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   clkactivity_init_l3_iclk	(size 1, offset 8, init 0):	RO	This field indicates the state of the L3_INIT_ICLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_l4_iclk	(size 1, offset 9, init 0):	RO	This field indicates the state of the L4_INIT_ICLK clock in the domain. [warm reset insensitive]
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   clkactivity_init_48m_fclk	(size 1, offset 12, init 0):	RO	This field indicates the state of the INIT_48M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_48mc_fclk	(size 1, offset 13, init 0):	RO	This field indicates the state of the INIT_48MC_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_usb_dpll_clk	(size 1, offset 14, init 0):	RO	This field indicates the state of the USB_DPLL_CLK clock in the domain. [warm reset insensitive]
 *   clkactivity_usb_dpll_hs_clk	(size 1, offset 15, init 0):	RO	This field indicates the state of the USB_DPLL_HS_CLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_hsi_fclk	(size 1, offset 16, init 0):	RO	This field indicates the state of the INIT_HSI_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_hsmmc1_fclk	(size 1, offset 17, init 0):	RO	This field indicates the state of the INIT_HSMMC1_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_hsmmc2_fclk	(size 1, offset 18, init 0):	RO	This field indicates the state of the INIT_HSMMC2_FCLK clock in the domain. [warm reset insensitive]
 *   _anon19	(size 1, offset 19, init 0):	MBZ	_
 *   clkactivity_hsic_p1_480m_fclk	(size 1, offset 20, init 0):	RO	This field indicates the state of the HSIC_P1_480M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_hsic_p2_480m_fclk	(size 1, offset 21, init 0):	RO	This field indicates the state of the HSIC_P2_480M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_tll_ch0_fclk	(size 1, offset 22, init 0):	RO	This field indicates the state of the TLL_CH0_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_tll_ch1_fclk	(size 1, offset 23, init 0):	RO	This field indicates the state of the TLL_CH1_FCLK clock in the domain. [warm reset insensitive]
 *   _anon24	(size 1, offset 24, init 0):	MBZ	_
 *   clkactivity_utmi_root_fclk	(size 1, offset 25, init 0):	RO	This field indicates the state of the UTMI_ROOT_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_hsic_p1_fclk	(size 1, offset 26, init 0):	RO	This field indicates the state of the HSIC_P1_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_hsic_p2_fclk	(size 1, offset 27, init 0):	RO	This field indicates the state of the HSIC_P2_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_60m_p1_fclk	(size 1, offset 28, init 0):	RO	This field indicates the state of the INIT_60M_P1_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_60m_p2_fclk	(size 1, offset 29, init 0):	RO	This field indicates the state of the INIT_60M_P2_FCLK clock in the domain. [warm reset insensitive]
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_clkstctrl_default 0x0
static inline omap44xx_l3init_cm2_clktrctrl_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clktrctrl_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clktrctrl_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clktrctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clktrctrl_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 9)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 12)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 13)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 14)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 15)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 17)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 20)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x200000) >> 21));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 21)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x400000) >> 22));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 22)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x800000) >> 23));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 23)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x2000000) >> 25));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 25)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x4000000) >> 26));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 26)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x8000000) >> 27));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 27)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 28)));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_extract(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_insert(omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval, omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 29)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_clkstctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_clkstctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clktrctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clktrctrl_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls the clock state transition of the L3INIT clock domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_l3_iclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L3_INIT_ICLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_l4_iclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L4_INIT_ICLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_48m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_48M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_48mc_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_48MC_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_usb_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the USB_DPLL_CLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_usb_dpll_hs_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the USB_DPLL_HS_CLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_hsi_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_HSI_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_hsmmc1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_HSMMC1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_hsmmc2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_HSMMC2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p1_480m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P1_480M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p2_480m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P2_480M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_tll_ch0_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the TLL_CH0_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_tll_ch1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the TLL_CH1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_utmi_root_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the UTMI_ROOT_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_60m_p1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_60M_P1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_60m_p2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_60M_P2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_staticdep_t
 * Description: Implicit type of This register controls the static domain dependencies from L3INIT domain towards 'target' domains. It is relevant only for domain having system initiator(s). register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   ivahd_statdep	(size 1, offset 2, init 0):	RW	Static dependency towards IVAHD clock domain
 *   abe_statdep	(size 1, offset 3, init 0):	RW	Static dependency towards ABE clock domain
 *   memif_statdep	(size 1, offset 4, init 0):	RW	Static dependency towards MEMIF clock domain
 *   l3_1_statdep	(size 1, offset 5, init 0):	RO	Static dependency towards L3_1 clock domain
 *   l3_2_statdep	(size 1, offset 6, init 0):	RO	Static dependency towards L3_2 clock domain
 *   _anon7	(size 5, offset 7, init 0):	MBZ	_
 *   l4cfg_statdep	(size 1, offset 12, init 0):	RW	Static dependency towards L4CFG clock domain
 *   l4per_statdep	(size 1, offset 13, init 0):	RW	Static dependency towards L4PER clock domain
 *   l4sec_statdep	(size 1, offset 14, init 0):	RW	Static dependency towards L4SEC clock domain
 *   l4wkup_statdep	(size 1, offset 15, init 0):	RW	Static dependency towards L4WKUP clock domain
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_staticdep_t;
#define omap44xx_l3init_cm2_cm_l3init_staticdep_default 0x0
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 2)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 3)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 4)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 5)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 6)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 12)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 13)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 14)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_extract(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_insert(omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 15)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_staticdep_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_staticdep_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ivahd_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards IVAHD clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abe_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards ABE clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " memif_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards MEMIF clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_1_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_1 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4cfg_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4CFG clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4per_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4PER clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4sec_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4SEC clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4wkup_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4WKUP clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_dynamicdep_t
 * Description: Implicit type of This register controls the dynamic domain depedencies from L3INIT domain towards 'target' domains. It is relevant only for domain having INTRCONN master port(s). register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   l3_1_dyndep	(size 1, offset 5, init 0):	RO	Dynamic dependency towards L3_1 clock domain
 *   l3_2_dyndep	(size 1, offset 6, init 0):	RO	Dynamic dependency towards L3_2 clock domain
 *   _anon7	(size 25, offset 7, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_t;
#define omap44xx_l3init_cm2_cm_l3init_dynamicdep_default 0x0
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_extract(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_extract(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_insert(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_insert(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_l3init_cm2_cm_l3init_dynamicdep_t )(_fieldval)) << 5)));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_extract(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_extract(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval)
{
    return((omap44xx_l3init_cm2_l4wkup_statdep_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_insert(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_insert(omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_l3init_cm2_cm_l3init_dynamicdep_t )(_fieldval)) << 6)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_dynamicdep_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_dynamicdep_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_1_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3_1 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t
 * Description: Implicit type of This register manages the MMC1 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock.
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t
 * Description: Implicit type of This register manages the MMC2 clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock.
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_extract(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clksel_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_insert(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t
 * Description: Implicit type of This register manages the HSI clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.Read 0x: Reserved .
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel	(size 2, offset 24, init 0):	RW	Selects the functional clock source.
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status1_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status1_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l3init_cm2_clksel_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_extract(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clksel_status1_t )((_regval & 0x3000000) >> 24));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_insert(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_status1_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status1_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.Read 0x: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_status1_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the functional clock source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t
 * Description: Implicit type of This register manages the USB_HOST_HS clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   sar_mode	(size 1, offset 4, init 0):	RW	SAR mode control for the module. Shall not be modify except if module is disabled.
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   optfclken_utmi_p1_clk	(size 1, offset 8, init 0):	RW	USB-HOST optional clock control: UTMI_P1_CLK when CLKSEL_UTMI_P1 is 0
 *   optfclken_utmi_p2_clk	(size 1, offset 9, init 0):	RW	USB-HOST optional clock control: UTMI_P2_CLK when CLKSEL_UTMI_P2 is 0
 *   optfclken_utmi_p3_clk	(size 1, offset 10, init 0):	RW	USB-HOST optional clock control: UTMI_P3_CLK
 *   optfclken_hsic60m_p1_clk	(size 1, offset 11, init 0):	RW	USB-HOST optional clock control: HSIC60M_P1_CLK
 *   optfclken_hsic60m_p2_clk	(size 1, offset 12, init 0):	RW	USB-HOST optional clock control: HSIC60M_P2_CLK
 *   optfclken_hsic480m_p1_clk	(size 1, offset 13, init 0):	RW	USB-HOST optional clock control: HSIC480M_P1_CLK
 *   optfclken_hsic480m_p2_clk	(size 1, offset 14, init 0):	RW	USB-HOST optional clock control: HSIC480M_P2_CLK
 *   optfclken_func48mclk	(size 1, offset 15, init 0):	RW	USB-HOST optional clock control: FUNC48MCLK
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel_utmi_p1	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock for UTMI Por1 on USB Host
 *   clksel_utmi_p2	(size 1, offset 25, init 0):	RW	Selects the source of the functional clock for UTMI Port2 on USB Host
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_sar_mode_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_sar_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_sar_mode_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 4)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 9)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 10)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 11)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 12)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 13)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 14)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 15)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clksel_utmi_p2_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 24)));
}

static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_extract(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clksel_utmi_p2_status_t )((_regval & 0x2000000) >> 25));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_insert(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 25)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_sar_mode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SAR mode control for the module. Shall not be modify except if module is disabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_utmi_p1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: UTMI_P1_CLK when CLKSEL_UTMI_P1 is 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_utmi_p2_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: UTMI_P2_CLK when CLKSEL_UTMI_P2 is 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_utmi_p3_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: UTMI_P3_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic60m_p1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC60M_P1_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic60m_p2_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC60M_P2_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic480m_p1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC480M_P1_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic480m_p2_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC480M_P2_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_func48mclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: FUNC48MCLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_utmi_p1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_utmi_p2_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock for UTMI Por1 on USB Host)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_utmi_p2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_utmi_p2_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock for UTMI Port2 on USB Host)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t
 * Description: Implicit type of This register manages the USB_OTG_HS clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_xclk	(size 1, offset 8, init 0):	RW	USB_OTG optional clock control: XCLK (60MHz clock)
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel_60m	(size 1, offset 24, init 0):	RW	Selects the source of the 60MHz functional clock.
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 18)));
}

static inline omap44xx_l3init_cm2_clksel_60m_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_60m_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_extract(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_clksel_60m_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_60m_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_insert(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval, omap44xx_l3init_cm2_clksel_60m_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 24)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_xclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB_OTG optional clock control: XCLK (60MHz clock))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_60m =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_60m_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the 60MHz functional clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t
 * Description: Implicit type of This register manages the USB_TLL clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   sar_mode	(size 1, offset 4, init 0):	RW	SAR mode control for the module. Shall not be modify except if module is disabled.
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   optfclken_usb_ch0_clk	(size 1, offset 8, init 0):	RW	USB-HOST optional clock control: USB_CH0_CLK
 *   optfclken_usb_ch1_clk	(size 1, offset 9, init 0):	RW	USB-HOST optional clock control: USB_CH1_CLK
 *   _anon10	(size 6, offset 10, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_sar_mode_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_sar_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_sar_mode_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 4)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 9)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_sar_mode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SAR mode control for the module. Shall not be modify except if module is disabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_usb_ch0_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: USB_CH0_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_usb_ch1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: USB_CH1_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t
 * Description: Implicit type of This register manages the USB_HOST_FS clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t )(_fieldval)) << 16)));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_extract(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_stbyst_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_insert(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval, omap44xx_l3init_cm2_stbyst_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t )(_fieldval)) << 18)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t
 * Description: Implicit type of This register manages the USBPHY clocks. register
 * Fields:
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_phy_48m	(size 1, offset 8, init 0):	RW	USBPHY optional clock control: PHY_48M
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t;
#define omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_default 0x0
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_extract(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_modulemode_status2_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_insert(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval, omap44xx_l3init_cm2_modulemode_status2_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t )(_fieldval)) << 0)));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_extract(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_extract(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_optfclken_func48mclk_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_insert(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_insert(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t )(_fieldval)) << 8)));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_extract(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval)
{
    return((omap44xx_l3init_cm2_idlest_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_insert(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval, omap44xx_l3init_cm2_idlest_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_prtval(char *_s, size_t _size, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_phy_48m =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USBPHY optional clock control: PHY_48M)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_l3init_cm2_initials {
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_staticdep_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_dynamicdep_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_initial = 0x0,
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_l3init_cm2_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register cm_l3init_clkstctrl: This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain.
 * Type: omap44xx_l3init_cm2.cm_l3init_clkstctrl (Implicit type of This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain. register)
 *   clktrctrl	(size 2, offset 0, init 0):	RW	Controls the clock state transition of the L3INIT clock domain.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   clkactivity_init_l3_iclk	(size 1, offset 8, init 0):	RO	This field indicates the state of the L3_INIT_ICLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_l4_iclk	(size 1, offset 9, init 0):	RO	This field indicates the state of the L4_INIT_ICLK clock in the domain. [warm reset insensitive]
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   clkactivity_init_48m_fclk	(size 1, offset 12, init 0):	RO	This field indicates the state of the INIT_48M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_48mc_fclk	(size 1, offset 13, init 0):	RO	This field indicates the state of the INIT_48MC_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_usb_dpll_clk	(size 1, offset 14, init 0):	RO	This field indicates the state of the USB_DPLL_CLK clock in the domain. [warm reset insensitive]
 *   clkactivity_usb_dpll_hs_clk	(size 1, offset 15, init 0):	RO	This field indicates the state of the USB_DPLL_HS_CLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_hsi_fclk	(size 1, offset 16, init 0):	RO	This field indicates the state of the INIT_HSI_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_hsmmc1_fclk	(size 1, offset 17, init 0):	RO	This field indicates the state of the INIT_HSMMC1_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_hsmmc2_fclk	(size 1, offset 18, init 0):	RO	This field indicates the state of the INIT_HSMMC2_FCLK clock in the domain. [warm reset insensitive]
 *   _anon19	(size 1, offset 19, init 0):	MBZ	_
 *   clkactivity_hsic_p1_480m_fclk	(size 1, offset 20, init 0):	RO	This field indicates the state of the HSIC_P1_480M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_hsic_p2_480m_fclk	(size 1, offset 21, init 0):	RO	This field indicates the state of the HSIC_P2_480M_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_tll_ch0_fclk	(size 1, offset 22, init 0):	RO	This field indicates the state of the TLL_CH0_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_tll_ch1_fclk	(size 1, offset 23, init 0):	RO	This field indicates the state of the TLL_CH1_FCLK clock in the domain. [warm reset insensitive]
 *   _anon24	(size 1, offset 24, init 0):	MBZ	_
 *   clkactivity_utmi_root_fclk	(size 1, offset 25, init 0):	RO	This field indicates the state of the UTMI_ROOT_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_hsic_p1_fclk	(size 1, offset 26, init 0):	RO	This field indicates the state of the HSIC_P1_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_hsic_p2_fclk	(size 1, offset 27, init 0):	RO	This field indicates the state of the HSIC_P2_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_60m_p1_fclk	(size 1, offset 28, init 0):	RO	This field indicates the state of the INIT_60M_P1_FCLK clock in the domain. [warm reset insensitive]
 *   clkactivity_init_60m_p2_fclk	(size 1, offset 29, init 0):	RO	This field indicates the state of the INIT_60M_P2_FCLK clock in the domain. [warm reset insensitive]
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_clkstctrl_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_l3init_cm2_cm_l3init_clkstctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_clkstctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_clkstctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_clkstctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval)
{
    _regval = (_regval & 0x3ef7f303);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_clkstctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_clkstctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_clkstctrl (This register enables the domain power state transition. It controls the hardware supervised domain power state transition between ON-ACTIVE and ON-INACTIVE states. It also holds 1 status bit per clock input of the domain.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clktrctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clktrctrl_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls the clock state transition of the L3INIT clock domain.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_l3_iclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L3_INIT_ICLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_l4_iclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the L4_INIT_ICLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_48m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_48M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_48mc_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_48MC_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_usb_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the USB_DPLL_CLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_usb_dpll_hs_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the USB_DPLL_HS_CLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_hsi_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_HSI_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_hsmmc1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_HSMMC1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_hsmmc2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_HSMMC2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p1_480m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P1_480M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p2_480m_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P2_480M_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_tll_ch0_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the TLL_CH0_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_tll_ch1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the TLL_CH1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_utmi_root_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the UTMI_ROOT_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_hsic_p2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the HSIC_P2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_60m_p1_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_60M_P1_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clkactivity_init_60m_p2_fclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This field indicates the state of the INIT_60M_P2_FCLK clock in the domain. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_clktrctrl_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clktrctrl_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l3_iclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_l4_iclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48m_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_48mc_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_usb_dpll_hs_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsi_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc1_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_hsmmc2_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_480m_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_480m_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch0_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_tll_ch1_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_utmi_root_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p1_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_hsic_p2_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p1_fclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clkactivity_init_60m_p2_fclk_status_t omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_l3init_cm2_cm_l3init_clkstctrl_clkactivity_init_60m_p2_fclk_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clktrctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_clkstctrl_clktrctrl_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clktrctrl_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_clkstctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_clkstctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ef7f303);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_staticdep: This register controls the static domain dependencies from L3INIT domain towards 'target' domains. It is relevant only for domain having system initiator(s).
 * Type: omap44xx_l3init_cm2.cm_l3init_staticdep (Implicit type of This register controls the static domain dependencies from L3INIT domain towards 'target' domains. It is relevant only for domain having system initiator(s). register)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   ivahd_statdep	(size 1, offset 2, init 0):	RW	Static dependency towards IVAHD clock domain
 *   abe_statdep	(size 1, offset 3, init 0):	RW	Static dependency towards ABE clock domain
 *   memif_statdep	(size 1, offset 4, init 0):	RW	Static dependency towards MEMIF clock domain
 *   l3_1_statdep	(size 1, offset 5, init 0):	RO	Static dependency towards L3_1 clock domain
 *   l3_2_statdep	(size 1, offset 6, init 0):	RO	Static dependency towards L3_2 clock domain
 *   _anon7	(size 5, offset 7, init 0):	MBZ	_
 *   l4cfg_statdep	(size 1, offset 12, init 0):	RW	Static dependency towards L4CFG clock domain
 *   l4per_statdep	(size 1, offset 13, init 0):	RW	Static dependency towards L4PER clock domain
 *   l4sec_statdep	(size 1, offset 14, init 0):	RW	Static dependency towards L4SEC clock domain
 *   l4wkup_statdep	(size 1, offset 15, init 0):	RW	Static dependency towards L4WKUP clock domain
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_staticdep_t omap44xx_l3init_cm2_cm_l3init_staticdep_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval)
{
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_staticdep_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_staticdep_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_staticdep (This register controls the static domain dependencies from L3INIT domain towards 'target' domains. It is relevant only for domain having system initiator(s).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ivahd_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards IVAHD clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abe_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards ABE clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " memif_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards MEMIF clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_1_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_1 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4cfg_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4CFG clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4per_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4PER clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4sec_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4SEC clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4wkup_statdep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Static dependency towards L4WKUP clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_l3_1_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_l3_2_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_ivahd_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x4 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 2);
    _regval = (_regval | (0xf018 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_abe_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x8 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf014 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_memif_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x10 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf00c & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4cfg_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x1000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 12);
    _regval = (_regval | (0xe01c & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4per_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x2000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 13);
    _regval = (_regval | (0xd01c & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4sec_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x4000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 14);
    _regval = (_regval | (0xb01c & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_staticdep_l4wkup_statdep_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_l4wkup_statdep_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_staticdep_t _regval = 0x8000 & (((omap44xx_l3init_cm2_cm_l3init_staticdep_t )(_fieldval)) << 15);
    _regval = (_regval | (0x701c & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xf07c);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_dynamicdep: This register controls the dynamic domain depedencies from L3INIT domain towards 'target' domains. It is relevant only for domain having INTRCONN master port(s).
 * Type: omap44xx_l3init_cm2.cm_l3init_dynamicdep (Implicit type of This register controls the dynamic domain depedencies from L3INIT domain towards 'target' domains. It is relevant only for domain having INTRCONN master port(s). register)
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   l3_1_dyndep	(size 1, offset 5, init 0):	RO	Dynamic dependency towards L3_1 clock domain
 *   l3_2_dyndep	(size 1, offset 6, init 0):	RO	Dynamic dependency towards L3_2 clock domain
 *   _anon7	(size 25, offset 7, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_dynamicdep_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_l3init_cm2_cm_l3init_dynamicdep_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_dynamicdep_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

// Register cm_l3init_dynamicdep is not writeable
static inline int omap44xx_l3init_cm2_cm_l3init_dynamicdep_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_dynamicdep_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_dynamicdep (This register controls the dynamic domain depedencies from L3INIT domain towards 'target' domains. It is relevant only for domain having INTRCONN master port(s).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_1_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3_1 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l3_2_dyndep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_l4wkup_statdep_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Dynamic dependency towards L3_2 clock domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_1_dyndep_extract(_regval));
}

static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_l4wkup_statdep_status_t omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_dynamicdep_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_l3init_cm2_cm_l3init_dynamicdep_l3_2_dyndep_extract(_regval));
}

/*
 * Register cm_l3init_hsmmc1_clkctrl: This register manages the MMC1 clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_hsmmc1_clkctrl (Implicit type of This register manages the MMC1 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock.
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval)
{
    _regval = (_regval & 0x1070003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_hsmmc1_clkctrl (This register manages the MMC1 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_stbyst_extract(_regval));
}

static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0x1070003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t _regval = 0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0x1070003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_hsmmc2_clkctrl: This register manages the MMC2 clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_hsmmc2_clkctrl (Implicit type of This register manages the MMC2 clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock.
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval)
{
    _regval = (_regval & 0x1070003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_hsmmc2_clkctrl (This register manages the MMC2 clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_stbyst_extract(_regval));
}

static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_status_t omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000000 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0x1070003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t _regval = 0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0x1070003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_hsi_clkctrl: This register manages the HSI clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_hsi_clkctrl (Implicit type of This register manages the HSI clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.Read 0x: Reserved .
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel	(size 2, offset 24, init 0):	RW	Selects the functional clock source.
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval)
{
    _regval = (_regval & 0x3070003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_hsi_clkctrl (This register manages the HSI clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status1_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.Read 0x: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_status1_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the functional clock source.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_stbyst_extract(_regval));
}

static inline omap44xx_l3init_cm2_clksel_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_status1_t omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status1_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3000000 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x3070003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_clksel_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_status1_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t _regval = 0x3000000 & (((omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x3070003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_hsusbhost_clkctrl: This register manages the USB_HOST_HS clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_hsusbhost_clkctrl (Implicit type of This register manages the USB_HOST_HS clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   sar_mode	(size 1, offset 4, init 0):	RW	SAR mode control for the module. Shall not be modify except if module is disabled.
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   optfclken_utmi_p1_clk	(size 1, offset 8, init 0):	RW	USB-HOST optional clock control: UTMI_P1_CLK when CLKSEL_UTMI_P1 is 0
 *   optfclken_utmi_p2_clk	(size 1, offset 9, init 0):	RW	USB-HOST optional clock control: UTMI_P2_CLK when CLKSEL_UTMI_P2 is 0
 *   optfclken_utmi_p3_clk	(size 1, offset 10, init 0):	RW	USB-HOST optional clock control: UTMI_P3_CLK
 *   optfclken_hsic60m_p1_clk	(size 1, offset 11, init 0):	RW	USB-HOST optional clock control: HSIC60M_P1_CLK
 *   optfclken_hsic60m_p2_clk	(size 1, offset 12, init 0):	RW	USB-HOST optional clock control: HSIC60M_P2_CLK
 *   optfclken_hsic480m_p1_clk	(size 1, offset 13, init 0):	RW	USB-HOST optional clock control: HSIC480M_P1_CLK
 *   optfclken_hsic480m_p2_clk	(size 1, offset 14, init 0):	RW	USB-HOST optional clock control: HSIC480M_P2_CLK
 *   optfclken_func48mclk	(size 1, offset 15, init 0):	RW	USB-HOST optional clock control: FUNC48MCLK
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel_utmi_p1	(size 1, offset 24, init 0):	RW	Selects the source of the functional clock for UTMI Por1 on USB Host
 *   clksel_utmi_p2	(size 1, offset 25, init 0):	RW	Selects the source of the functional clock for UTMI Port2 on USB Host
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval)
{
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_hsusbhost_clkctrl (This register manages the USB_HOST_HS clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_sar_mode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SAR mode control for the module. Shall not be modify except if module is disabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_utmi_p1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: UTMI_P1_CLK when CLKSEL_UTMI_P1 is 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_utmi_p2_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: UTMI_P2_CLK when CLKSEL_UTMI_P2 is 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_utmi_p3_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: UTMI_P3_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic60m_p1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC60M_P1_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic60m_p2_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC60M_P2_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic480m_p1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC480M_P1_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_hsic480m_p2_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: HSIC480M_P2_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_func48mclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: FUNC48MCLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_utmi_p1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_utmi_p2_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock for UTMI Por1 on USB Host)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_utmi_p2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_utmi_p2_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the functional clock for UTMI Port2 on USB Host)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_stbyst_extract(_regval));
}

static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_extract(_regval));
}

static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_utmi_p2_status_t omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x300ff10 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_sar_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_sar_mode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_sar_mode_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x10 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0x300ff03 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x100 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x300fe13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p2_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x200 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0x300fd13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_utmi_p3_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x400 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 10);
    _regval = (_regval | (0x300fb13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x800 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0x300f713 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic60m_p2_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x1000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 12);
    _regval = (_regval | (0x300ef13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x2000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 13);
    _regval = (_regval | (0x300df13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_hsic480m_p2_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x4000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 14);
    _regval = (_regval | (0x300bf13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_optfclken_func48mclk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x8000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 15);
    _regval = (_regval | (0x3007f13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p1_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x200ff13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_clksel_utmi_p2_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_utmi_p2_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t _regval = 0x2000000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_t )(_fieldval)) << 25);
    _regval = (_regval | (0x100ff13 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x307ff13);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_hsusbotg_clkctrl: This register manages the USB_OTG_HS clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_hsusbotg_clkctrl (Implicit type of This register manages the USB_OTG_HS clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_xclk	(size 1, offset 8, init 0):	RW	USB_OTG optional clock control: XCLK (60MHz clock)
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   clksel_60m	(size 1, offset 24, init 0):	RW	Selects the source of the 60MHz functional clock.
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval)
{
    _regval = (_regval & 0x1070103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_hsusbotg_clkctrl (This register manages the USB_OTG_HS clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_xclk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB_OTG optional clock control: XCLK (60MHz clock))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_60m =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_clksel_60m_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the 60MHz functional clock.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_stbyst_extract(_regval));
}

static inline omap44xx_l3init_cm2_clksel_60m_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_clksel_60m_status_t omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000100 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x1070103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_optfclken_xclk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = 0x100 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1000003 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x1070103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_60m_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_clksel_60m_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_clksel_60m_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t _regval = 0x1000000 & (((omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x103 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x1070103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_hsusbtll_clkctrl: This register manages the USB_TLL clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_hsusbtll_clkctrl (Implicit type of This register manages the USB_TLL clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   sar_mode	(size 1, offset 4, init 0):	RW	SAR mode control for the module. Shall not be modify except if module is disabled.
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   optfclken_usb_ch0_clk	(size 1, offset 8, init 0):	RW	USB-HOST optional clock control: USB_CH0_CLK
 *   optfclken_usb_ch1_clk	(size 1, offset 9, init 0):	RW	USB-HOST optional clock control: USB_CH1_CLK
 *   _anon10	(size 6, offset 10, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval)
{
    _regval = (_regval & 0x30313);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_hsusbtll_clkctrl (This register manages the USB_TLL clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_sar_mode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SAR mode control for the module. Shall not be modify except if module is disabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_usb_ch0_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: USB_CH0_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_usb_ch1_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB-HOST optional clock control: USB_CH1_CLK)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_sar_mode_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x310 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0x30313);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_sar_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_sar_mode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_sar_mode_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = 0x10 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0x303 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0x30313);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch0_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = 0x100 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x213 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0x30313);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_optfclken_usb_ch1_clk_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t _regval = 0x200 & (((omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0x113 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0x30313);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_fsusb_clkctrl: This register manages the USB_HOST_FS clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_fsusb_clkctrl (Implicit type of This register manages the USB_HOST_FS clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 14, offset 2, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   stbyst	(size 1, offset 18, init 0):	RO	Module standby status. [warm reset insensitive]
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline void omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval)
{
    _regval = (_regval & 0x70003);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_fsusb_clkctrl (This register manages the USB_HOST_FS clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stbyst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_stbyst_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module standby status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_idlest_extract(_regval));
}

static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_stbyst_status_t omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_stbyst_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x70003);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_l3init_usbphy_clkctrl: This register manages the USBPHY clocks.
 * Type: omap44xx_l3init_cm2.cm_l3init_usbphy_clkctrl (Implicit type of This register manages the USBPHY clocks. register)
 *   modulemode	(size 2, offset 0, init 0):	RW	Control the way mandatory clocks are managed.
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   optfclken_phy_48m	(size 1, offset 8, init 0):	RW	USBPHY optional clock control: PHY_48M
 *   _anon9	(size 7, offset 9, init 0):	MBZ	_
 *   idlest	(size 2, offset 16, init 0):	RO	Module idle status. [warm reset insensitive]
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_rawwr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_wr(__DN(t) *_dev, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval)
{
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline int omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_l3init_usbphy_clkctrl (This register manages the USBPHY clocks.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modulemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_modulemode_status2_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the way mandatory clocks are managed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " optfclken_phy_48m =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_optfclken_func48mclk_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USBPHY optional clock control: PHY_48M)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlest =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_idlest_status_prtval(_s + _r, _avail, omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module idle status. [warm reset insensitive])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_modulemode_status2_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_extract(_regval));
}

static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_optfclken_func48mclk_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_extract(_regval));
}

static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_l3init_cm2_idlest_status_t omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_rdf(__DN(t) *_dev)
{
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_idlest_extract(_regval));
}

static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_modulemode_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_modulemode_status2_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval = 0x3 & (((omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_optfclken_phy_48m_wrf(__DN(t) *_dev, omap44xx_l3init_cm2_optfclken_func48mclk_status_t _fieldval)
{
    omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t _regval = 0x100 & (((omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x30103);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline int omap44xx_l3init_cm2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_l3init_cm2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_l3init_cm2 ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_clkstctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_staticdep_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_dynamicdep_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_hsmmc1_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_hsmmc2_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_hsi_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_hsusbhost_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_hsusbotg_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_hsusbtll_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_fsusb_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_l3init_cm2_cm_l3init_usbphy_clkctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_l3init_cm2\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_l3init_cm2_DEV_H
