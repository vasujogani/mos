#ifndef __omap44xx_hsusbhost_DEV_H
#define __omap44xx_hsusbhost_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_hsusbhost ## _ ## x
/*
 * Constants defn: omap44xx_hsusbhost.standbymode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_hsusbhost_standbymode_status_t;
#define omap44xx_hsusbhost_STANDBYMODE_0 ((omap44xx_hsusbhost_standbymode_status_t)0x0)
#define omap44xx_hsusbhost_STANDBYMODE_1 ((omap44xx_hsusbhost_standbymode_status_t)0x1)
#define omap44xx_hsusbhost_STANDBYMODE_2 ((omap44xx_hsusbhost_standbymode_status_t)0x2)
#define omap44xx_hsusbhost_STANDBYMODE_3 ((omap44xx_hsusbhost_standbymode_status_t)0x3)

static inline char *omap44xx_hsusbhost_standbymode_status_describe(omap44xx_hsusbhost_standbymode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_standbymode_status_describe(omap44xx_hsusbhost_standbymode_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_STANDBYMODE_0:
        return("STANDBYMODE_0: Force-standby mode. Mstandby asserted unconditionally. Asynchronous (master) wake-up disabled.");
    case omap44xx_hsusbhost_STANDBYMODE_1:
        return("STANDBYMODE_1: No-standby mode. Mstandby never asserted. Asynchronous (master) wakeup disabled.");
    case omap44xx_hsusbhost_STANDBYMODE_2:
        return("STANDBYMODE_2: Smart-standby mode. Mstandby asserted when initiator activity stops. Asynchronous (master) wake-up disabled.");
    case omap44xx_hsusbhost_STANDBYMODE_3:
        return("STANDBYMODE_3: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_standbymode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_standbymode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_standbymode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_standbymode_status_t _e)
{
    char *d = omap44xx_hsusbhost_standbymode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_standbymode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.idlemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_hsusbhost_idlemode_status_t;
#define omap44xx_hsusbhost_IDLEMODE_0 ((omap44xx_hsusbhost_idlemode_status_t)0x0)
#define omap44xx_hsusbhost_IDLEMODE_1 ((omap44xx_hsusbhost_idlemode_status_t)0x1)
#define omap44xx_hsusbhost_IDLEMODE_2 ((omap44xx_hsusbhost_idlemode_status_t)0x2)
#define omap44xx_hsusbhost_IDLEMODE_3 ((omap44xx_hsusbhost_idlemode_status_t)0x3)

static inline char *omap44xx_hsusbhost_idlemode_status_describe(omap44xx_hsusbhost_idlemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_idlemode_status_describe(omap44xx_hsusbhost_idlemode_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_IDLEMODE_0:
        return("IDLEMODE_0: Force-Idle mode. Sidleack asserted after Idlereq assertion. Asynchronous (slave) wake-up disabled.");
    case omap44xx_hsusbhost_IDLEMODE_1:
        return("IDLEMODE_1: No-idle mode. Sidleack never asserted. Asynchronous (slave) wakeup disabled.");
    case omap44xx_hsusbhost_IDLEMODE_2:
        return("IDLEMODE_2: Smart-idle mode. Sidleack asserted upon Idlereq assertion, after target activity is over. Asynchronous (slave) wake-up disabled.");
    case omap44xx_hsusbhost_IDLEMODE_3:
        return("IDLEMODE_3: Smart-idle wake-up mode. Like smart mode with asynchronous (slave) wakeup enabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_idlemode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_idlemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_idlemode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_idlemode_status_t _e)
{
    char *d = omap44xx_hsusbhost_idlemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_idlemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.softreset_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_softreset_status_t;
#define omap44xx_hsusbhost_SOFTRESET_0 ((omap44xx_hsusbhost_softreset_status_t)0x0)
#define omap44xx_hsusbhost_SOFTRESET_1 ((omap44xx_hsusbhost_softreset_status_t)0x1)

static inline char *omap44xx_hsusbhost_softreset_status_describe(omap44xx_hsusbhost_softreset_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_softreset_status_describe(omap44xx_hsusbhost_softreset_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_SOFTRESET_0:
        return("SOFTRESET_0: No reset pending");
    case omap44xx_hsusbhost_SOFTRESET_1:
        return("SOFTRESET_1: Starts softreset sequence / Reset is pending.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_softreset_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_softreset_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_softreset_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_softreset_status_t _e)
{
    char *d = omap44xx_hsusbhost_softreset_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_softreset_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.ehci_resetdone_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_ehci_resetdone_status_t;
#define omap44xx_hsusbhost_EHCI_RESETDONE_0_r ((omap44xx_hsusbhost_ehci_resetdone_status_t)0x0)
#define omap44xx_hsusbhost_EHCI_RESETDONE_1_r ((omap44xx_hsusbhost_ehci_resetdone_status_t)0x1)

static inline char *omap44xx_hsusbhost_ehci_resetdone_status_describe(omap44xx_hsusbhost_ehci_resetdone_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_ehci_resetdone_status_describe(omap44xx_hsusbhost_ehci_resetdone_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_EHCI_RESETDONE_0_r:
        return("EHCI_RESETDONE_0_r: Under reset");
    case omap44xx_hsusbhost_EHCI_RESETDONE_1_r:
        return("EHCI_RESETDONE_1_r: Out of reset");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_ehci_resetdone_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ehci_resetdone_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_ehci_resetdone_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ehci_resetdone_status_t _e)
{
    char *d = omap44xx_hsusbhost_ehci_resetdone_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_ehci_resetdone_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.p2_mode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_hsusbhost_p2_mode_status_t;
#define omap44xx_hsusbhost_P2_MODE_0 ((omap44xx_hsusbhost_p2_mode_status_t)0x0)
#define omap44xx_hsusbhost_P2_MODE_1 ((omap44xx_hsusbhost_p2_mode_status_t)0x1)
#define omap44xx_hsusbhost_P2_MODE_2 ((omap44xx_hsusbhost_p2_mode_status_t)0x2)
#define omap44xx_hsusbhost_P2_MODE_3 ((omap44xx_hsusbhost_p2_mode_status_t)0x3)

static inline char *omap44xx_hsusbhost_p2_mode_status_describe(omap44xx_hsusbhost_p2_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_p2_mode_status_describe(omap44xx_hsusbhost_p2_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_P2_MODE_0:
        return("P2_MODE_0: To external ULPI PHY, HS only");
    case omap44xx_hsusbhost_P2_MODE_1:
        return("P2_MODE_1: To UTMI PHY (or ULPI TLL), FS/LS capable");
    case omap44xx_hsusbhost_P2_MODE_2:
        return("P2_MODE_2: Forbidden");
    case omap44xx_hsusbhost_P2_MODE_3:
        return("P2_MODE_3: To HSIC digital front-end (DFE), HS only");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_p2_mode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_p2_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_p2_mode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_p2_mode_status_t _e)
{
    char *d = omap44xx_hsusbhost_p2_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_p2_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.p2_connect_status_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_p2_connect_status_status_t;
#define omap44xx_hsusbhost_P2_CONNECT_STATUS_0_r ((omap44xx_hsusbhost_p2_connect_status_status_t)0x0)
#define omap44xx_hsusbhost_P2_CONNECT_STATUS_1_r ((omap44xx_hsusbhost_p2_connect_status_status_t)0x1)

static inline char *omap44xx_hsusbhost_p2_connect_status_status_describe(omap44xx_hsusbhost_p2_connect_status_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_p2_connect_status_status_describe(omap44xx_hsusbhost_p2_connect_status_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_P2_CONNECT_STATUS_0_r:
        return("P2_CONNECT_STATUS_0_r: Disconnected");
    case omap44xx_hsusbhost_P2_CONNECT_STATUS_1_r:
        return("P2_CONNECT_STATUS_1_r: Peripheral connected and active on port");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_p2_connect_status_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_p2_connect_status_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_p2_connect_status_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_p2_connect_status_status_t _e)
{
    char *d = omap44xx_hsusbhost_p2_connect_status_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_p2_connect_status_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.ena_incr_align_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_ena_incr_align_status_t;
#define omap44xx_hsusbhost_ENA_INCR_ALIGN_0 ((omap44xx_hsusbhost_ena_incr_align_status_t)0x0)
#define omap44xx_hsusbhost_ENA_INCR_ALIGN_1 ((omap44xx_hsusbhost_ena_incr_align_status_t)0x1)

static inline char *omap44xx_hsusbhost_ena_incr_align_status_describe(omap44xx_hsusbhost_ena_incr_align_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_ena_incr_align_status_describe(omap44xx_hsusbhost_ena_incr_align_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_ENA_INCR_ALIGN_0:
        return("ENA_INCR_ALIGN_0: Disable burst type");
    case omap44xx_hsusbhost_ENA_INCR_ALIGN_1:
        return("ENA_INCR_ALIGN_1: Enable burst type");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_ena_incr_align_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ena_incr_align_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_ena_incr_align_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ena_incr_align_status_t _e)
{
    char *d = omap44xx_hsusbhost_ena_incr_align_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_ena_incr_align_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.autoppd_on_overcur_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_autoppd_on_overcur_en_status_t;
#define omap44xx_hsusbhost_AUTOPPD_ON_OVERCUR_EN_0 ((omap44xx_hsusbhost_autoppd_on_overcur_en_status_t)0x0)
#define omap44xx_hsusbhost_AUTOPPD_ON_OVERCUR_EN_1 ((omap44xx_hsusbhost_autoppd_on_overcur_en_status_t)0x1)

static inline char *omap44xx_hsusbhost_autoppd_on_overcur_en_status_describe(omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_autoppd_on_overcur_en_status_describe(omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_AUTOPPD_ON_OVERCUR_EN_0:
        return("AUTOPPD_ON_OVERCUR_EN_0: Port remains on upon overcurrent.");
    case omap44xx_hsusbhost_AUTOPPD_ON_OVERCUR_EN_1:
        return("AUTOPPD_ON_OVERCUR_EN_1: Port is powered down automatically upon overcurrent.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_autoppd_on_overcur_en_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_autoppd_on_overcur_en_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _e)
{
    char *d = omap44xx_hsusbhost_autoppd_on_overcur_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_autoppd_on_overcur_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.ohci_ccs_2_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_ohci_ccs_2_status_t;
#define omap44xx_hsusbhost_OHCI_CCS_2_0_r ((omap44xx_hsusbhost_ohci_ccs_2_status_t)0x0)
#define omap44xx_hsusbhost_OHCI_CCS_2_1_r ((omap44xx_hsusbhost_ohci_ccs_2_status_t)0x1)

static inline char *omap44xx_hsusbhost_ohci_ccs_2_status_describe(omap44xx_hsusbhost_ohci_ccs_2_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_ohci_ccs_2_status_describe(omap44xx_hsusbhost_ohci_ccs_2_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_OHCI_CCS_2_0_r:
        return("OHCI_CCS_2_0_r: No peripheral connected");
    case omap44xx_hsusbhost_OHCI_CCS_2_1_r:
        return("OHCI_CCS_2_1_r: Peripheral connected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_ohci_ccs_2_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ohci_ccs_2_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_ohci_ccs_2_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ohci_ccs_2_status_t _e)
{
    char *d = omap44xx_hsusbhost_ohci_ccs_2_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_ohci_ccs_2_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.ohci_globalsuspend_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_ohci_globalsuspend_status_t;
#define omap44xx_hsusbhost_OHCI_GLOBALSUSPEND_0_r ((omap44xx_hsusbhost_ohci_globalsuspend_status_t)0x0)
#define omap44xx_hsusbhost_OHCI_GLOBALSUSPEND_1_r ((omap44xx_hsusbhost_ohci_globalsuspend_status_t)0x1)

static inline char *omap44xx_hsusbhost_ohci_globalsuspend_status_describe(omap44xx_hsusbhost_ohci_globalsuspend_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_ohci_globalsuspend_status_describe(omap44xx_hsusbhost_ohci_globalsuspend_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_OHCI_GLOBALSUSPEND_0_r:
        return("OHCI_GLOBALSUSPEND_0_r: Host is not suspended.");
    case omap44xx_hsusbhost_OHCI_GLOBALSUSPEND_1_r:
        return("OHCI_GLOBALSUSPEND_1_r: Host is suspended.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_ohci_globalsuspend_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ohci_globalsuspend_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_ohci_globalsuspend_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ohci_globalsuspend_status_t _e)
{
    char *d = omap44xx_hsusbhost_ohci_globalsuspend_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_ohci_globalsuspend_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_hsusbhost.ehci_simulation_mode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_hsusbhost_ehci_simulation_mode_status_t;
#define omap44xx_hsusbhost_EHCI_SIMULATION_MODE_0 ((omap44xx_hsusbhost_ehci_simulation_mode_status_t)0x0)
#define omap44xx_hsusbhost_EHCI_SIMULATION_MODE_1 ((omap44xx_hsusbhost_ehci_simulation_mode_status_t)0x1)

static inline char *omap44xx_hsusbhost_ehci_simulation_mode_status_describe(omap44xx_hsusbhost_ehci_simulation_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_hsusbhost_ehci_simulation_mode_status_describe(omap44xx_hsusbhost_ehci_simulation_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_hsusbhost_EHCI_SIMULATION_MODE_0:
        return("EHCI_SIMULATION_MODE_0: Functional mode");
    case omap44xx_hsusbhost_EHCI_SIMULATION_MODE_1:
        return("EHCI_SIMULATION_MODE_1: PHY set to nondriving");
    default:
        return(NULL);
    }
}

static inline int omap44xx_hsusbhost_ehci_simulation_mode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ehci_simulation_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_ehci_simulation_mode_status_prtval(char *_s, size_t _size, omap44xx_hsusbhost_ehci_simulation_mode_status_t _e)
{
    char *d = omap44xx_hsusbhost_ehci_simulation_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_hsusbhost_ehci_simulation_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_hsusbhost_uhh_hwinfo_t
 * Description: Implicit type of Information on host hardware configuration register
 * Fields:
 *   sar_cntx_size	(size 10, offset 0, init 0):	RO	Save-and-restore context size, in 32-bit words; that is, number of 32-bit registers with significant context information, mapped from offset 0x100 upward.
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_hsusbhost_uhh_hwinfo_t;
#define omap44xx_hsusbhost_uhh_hwinfo_default 0x0
static inline uint16_t omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_extract(omap44xx_hsusbhost_uhh_hwinfo_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_extract(omap44xx_hsusbhost_uhh_hwinfo_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline omap44xx_hsusbhost_uhh_hwinfo_t omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_insert(omap44xx_hsusbhost_uhh_hwinfo_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hwinfo_t omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_insert(omap44xx_hsusbhost_uhh_hwinfo_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((omap44xx_hsusbhost_uhh_hwinfo_t )(_fieldval)) << 0)));
}

static inline int omap44xx_hsusbhost_uhh_hwinfo_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_hwinfo_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_hwinfo_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_hwinfo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_cntx_size =\t%" PRIx16 "\t(Save-and-restore context size, in 32-bit words; that is, number of 32-bit registers with significant context information, mapped from offset 0x100 upward.)\n", omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_hsusbhost_uhh_sysconfig_t
 * Description: Implicit type of OCP standard system configuration register register
 * Fields:
 *   softreset	(size 1, offset 0, init 0):	RW	Module software reset
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   idlemode	(size 2, offset 2, init 0):	RW	Sidlereq/Sidleack(1:0)/[Swakeup] target power management interface configuration.
 *   standbymode	(size 2, offset 4, init 0):	RW	Mstandby/Mwait/[Mwakeup] initiator power-management interface configuration
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_hsusbhost_uhh_sysconfig_t;
#define omap44xx_hsusbhost_uhh_sysconfig_default 0x0
static inline omap44xx_hsusbhost_softreset_status_t omap44xx_hsusbhost_uhh_sysconfig_softreset_extract(omap44xx_hsusbhost_uhh_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_softreset_status_t omap44xx_hsusbhost_uhh_sysconfig_softreset_extract(omap44xx_hsusbhost_uhh_sysconfig_t _regval)
{
    return((omap44xx_hsusbhost_softreset_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_softreset_insert(omap44xx_hsusbhost_uhh_sysconfig_t _regval, omap44xx_hsusbhost_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_softreset_insert(omap44xx_hsusbhost_uhh_sysconfig_t _regval, omap44xx_hsusbhost_softreset_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_hsusbhost_uhh_sysconfig_t )(_fieldval)) << 0)));
}

static inline omap44xx_hsusbhost_idlemode_status_t omap44xx_hsusbhost_uhh_sysconfig_idlemode_extract(omap44xx_hsusbhost_uhh_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_idlemode_status_t omap44xx_hsusbhost_uhh_sysconfig_idlemode_extract(omap44xx_hsusbhost_uhh_sysconfig_t _regval)
{
    return((omap44xx_hsusbhost_idlemode_status_t )((_regval & 0xc) >> 2));
}

static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_idlemode_insert(omap44xx_hsusbhost_uhh_sysconfig_t _regval, omap44xx_hsusbhost_idlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_idlemode_insert(omap44xx_hsusbhost_uhh_sysconfig_t _regval, omap44xx_hsusbhost_idlemode_status_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((omap44xx_hsusbhost_uhh_sysconfig_t )(_fieldval)) << 2)));
}

static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_sysconfig_standbymode_extract(omap44xx_hsusbhost_uhh_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_sysconfig_standbymode_extract(omap44xx_hsusbhost_uhh_sysconfig_t _regval)
{
    return((omap44xx_hsusbhost_standbymode_status_t )((_regval & 0x30) >> 4));
}

static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_standbymode_insert(omap44xx_hsusbhost_uhh_sysconfig_t _regval, omap44xx_hsusbhost_standbymode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_standbymode_insert(omap44xx_hsusbhost_uhh_sysconfig_t _regval, omap44xx_hsusbhost_standbymode_status_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((omap44xx_hsusbhost_uhh_sysconfig_t )(_fieldval)) << 4)));
}

static inline int omap44xx_hsusbhost_uhh_sysconfig_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_sysconfig_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sysconfig_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_sysconfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_softreset_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module software reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_idlemode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysconfig_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sidlereq/Sidleack(1:0)/[Swakeup] target power management interface configuration.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " standbymode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_standbymode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysconfig_standbymode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mstandby/Mwait/[Mwakeup] initiator power-management interface configuration)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_hsusbhost_uhh_sysstatus_t
 * Description: Implicit type of Module-specific system status register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   ohci_resetdone	(size 1, offset 1, init 0):	RO	Indicates when the OHCI FS/LS host is out of reset
 *   ehci_resetdone	(size 1, offset 2, init 0):	RO	Indicates when the EHCI HS host is out of reset
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_hsusbhost_uhh_sysstatus_t;
#define omap44xx_hsusbhost_uhh_sysstatus_default 0x0
static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_extract(omap44xx_hsusbhost_uhh_sysstatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_extract(omap44xx_hsusbhost_uhh_sysstatus_t _regval)
{
    return((omap44xx_hsusbhost_ehci_resetdone_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_insert(omap44xx_hsusbhost_uhh_sysstatus_t _regval, omap44xx_hsusbhost_ehci_resetdone_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_insert(omap44xx_hsusbhost_uhh_sysstatus_t _regval, omap44xx_hsusbhost_ehci_resetdone_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_hsusbhost_uhh_sysstatus_t )(_fieldval)) << 1)));
}

static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_extract(omap44xx_hsusbhost_uhh_sysstatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_extract(omap44xx_hsusbhost_uhh_sysstatus_t _regval)
{
    return((omap44xx_hsusbhost_ehci_resetdone_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_insert(omap44xx_hsusbhost_uhh_sysstatus_t _regval, omap44xx_hsusbhost_ehci_resetdone_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_insert(omap44xx_hsusbhost_uhh_sysstatus_t _regval, omap44xx_hsusbhost_ehci_resetdone_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_hsusbhost_uhh_sysstatus_t )(_fieldval)) << 2)));
}

static inline int omap44xx_hsusbhost_uhh_sysstatus_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_sysstatus_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sysstatus_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_sysstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ehci_resetdone_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates when the OHCI FS/LS host is out of reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ehci_resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ehci_resetdone_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates when the EHCI HS host is out of reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_hsusbhost_uhh_hostconfig_t
 * Description: Implicit type of Static configuration of the USB HS host register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   autoppd_on_overcur_en	(size 1, offset 1, init 0):	RW	Configure reaction upon port overcurrent condition. This function is not supported at the device level.
 *   ena_incr4	(size 1, offset 2, init 0):	RW	Control the use of INCR4-type bursts (in AHB sense)
 *   ena_incr8	(size 1, offset 3, init 0):	RW	Control the use of INCR8-type bursts (in AHB sense)
 *   ena_incr16	(size 1, offset 4, init 0):	RW	Control the use of INCR16-type bursts (in AHB sense)
 *   ena_incr_align	(size 1, offset 5, init 0):	RW	Force alignment of bursts to the respective burst-size boundaries
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   p1_connect_status	(size 1, offset 8, init 0):	RO	Connection status for port 1
 *   p2_connect_status	(size 1, offset 9, init 0):	RO	Connection status for port 2
 *   _anon10	(size 6, offset 10, init 0):	MBZ	_
 *   p1_mode	(size 2, offset 16, init 0):	RW	Port 1 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en
 *   p2_mode	(size 2, offset 18, init 0):	RW	Port 2 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en
 *   _anon20	(size 11, offset 20, init 0):	MBZ	_
 *   app_start_clk	(size 1, offset 31, init 0):	RW	When the OHCI clocks are suspended, the system must assert this signal to start the clocks (12 and 48 MHz).This must be deasserted after the clocks are started and before the host is suspended again. . (Host is suspended means HCFS = SUSPEND or all the OHCI ports are suspended.) .
 */
typedef uint32_t omap44xx_hsusbhost_uhh_hostconfig_t;
#define omap44xx_hsusbhost_uhh_hostconfig_default 0x0
static inline omap44xx_hsusbhost_autoppd_on_overcur_en_status_t omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_autoppd_on_overcur_en_status_t omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_autoppd_on_overcur_en_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 1)));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_ena_incr_align_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 2)));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_ena_incr_align_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 3)));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_ena_incr_align_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 4)));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_ena_incr_align_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 5)));
}

static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_p2_connect_status_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_connect_status_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_connect_status_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 8)));
}

static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_p2_connect_status_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_connect_status_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_connect_status_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 9)));
}

static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_mode_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_mode_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_p2_mode_status_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p1_mode_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p1_mode_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_mode_status_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 16)));
}

static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_mode_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_mode_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((omap44xx_hsusbhost_p2_mode_status_t )((_regval & 0xc0000) >> 18));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p2_mode_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_p2_mode_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, omap44xx_hsusbhost_p2_mode_status_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 18)));
}

static inline uint8_t omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_extract(omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_insert(omap44xx_hsusbhost_uhh_hostconfig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 31)));
}

static inline int omap44xx_hsusbhost_uhh_hostconfig_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_hostconfig_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoppd_on_overcur_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_autoppd_on_overcur_en_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Configure reaction upon port overcurrent condition. This function is not supported at the device level.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the use of INCR4-type bursts (in AHB sense))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr8 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the use of INCR8-type bursts (in AHB sense))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr16 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the use of INCR16-type bursts (in AHB sense))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr_align =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force alignment of bursts to the respective burst-size boundaries)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p1_connect_status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_connect_status_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connection status for port 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p2_connect_status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_connect_status_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connection status for port 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p1_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_mode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p1_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port 1 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p2_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_mode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p2_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port 2 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " app_start_clk =\t%" PRIx8 "\t(When the OHCI clocks are suspended, the system must assert this signal to start the clocks (12 and 48 MHz).This must be deasserted after the clocks are started and before the host is suspended again. . (Host is suspended means HCFS = SUSPEND or all the OHCI ports are suspended.) .)\n", omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_hsusbhost_uhh_debug_csr_t
 * Description: Implicit type of Debug control and status for the EHCI, OHCI hosts register
 * Fields:
 *   ehci_fladj	(size 6, offset 0, init 0):	RW	EHCI host frame length adjust. Modify only when EHCI Bit FieldUSBSTS.HCHalted = 1 Field value + 59,488 = 60,000 by default = Number of 60-MHz UTMI/ULPI clock cycles per 1 ms USB frame = Number of 480-MHz HS bits per 125 us HS USB microframe
 *   ehci_simulation_mode	(size 1, offset 6, init 0):	RW	Sets the PHY to nondriving mode (used only for simulation)
 *   ochi_cntsel	(size 1, offset 7, init 0):	RW	Selection of a shorter '1 ms' counter in OHCI host, to speed up long USB phases such as reset, resume, etc. (used only for simulation)
 *   _anon8	(size 8, offset 8, init 0):	MBZ	_
 *   ohci_globalsuspend	(size 1, offset 16, init 0):	RO	OHCI global suspend status, asserted 5 ms after the suspend order.
 *   ohci_ccs_1	(size 1, offset 17, init 0):	RO	Current connect status of port 1
 *   ohci_ccs_2	(size 1, offset 18, init 0):	RO	Current connect status of port 2
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_hsusbhost_uhh_debug_csr_t;
#define omap44xx_hsusbhost_uhh_debug_csr_default 0x0
static inline uint8_t omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 0)));
}

static inline omap44xx_hsusbhost_ehci_simulation_mode_status_t omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ehci_simulation_mode_status_t omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    return((omap44xx_hsusbhost_ehci_simulation_mode_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ehci_simulation_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ehci_simulation_mode_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 6)));
}

static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    return((omap44xx_hsusbhost_standbymode_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_standbymode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_standbymode_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 7)));
}

static inline omap44xx_hsusbhost_ohci_globalsuspend_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ohci_globalsuspend_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    return((omap44xx_hsusbhost_ohci_globalsuspend_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ohci_globalsuspend_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ohci_globalsuspend_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 16)));
}

static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    return((omap44xx_hsusbhost_ohci_ccs_2_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ohci_ccs_2_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ohci_ccs_2_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 17)));
}

static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_extract(omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    return((omap44xx_hsusbhost_ohci_ccs_2_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ohci_ccs_2_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_insert(omap44xx_hsusbhost_uhh_debug_csr_t _regval, omap44xx_hsusbhost_ohci_ccs_2_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 18)));
}

static inline int omap44xx_hsusbhost_uhh_debug_csr_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_debug_csr_prtval(char *_s, size_t _size, omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ehci_fladj =\t%" PRIx8 "\t(EHCI host frame length adjust. Modify only when EHCI Bit FieldUSBSTS.HCHalted = 1 Field value + 59,488 = 60,000 by default = Number of 60-MHz UTMI/ULPI clock cycles per 1 ms USB frame = Number of 480-MHz HS bits per 125 us HS USB microframe)\n", omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ehci_simulation_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ehci_simulation_mode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sets the PHY to nondriving mode (used only for simulation))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ochi_cntsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_standbymode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selection of a shorter '1 ms' counter in OHCI host, to speed up long USB phases such as reset, resume, etc. (used only for simulation))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_globalsuspend =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ohci_globalsuspend_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(OHCI global suspend status, asserted 5 ms after the suspend order.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_ccs_1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ohci_ccs_2_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect status of port 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_ccs_2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ohci_ccs_2_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect status of port 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_hsusbhost_initials {
    omap44xx_hsusbhost_uhh_revision_initial = 0x0,
    omap44xx_hsusbhost_uhh_hwinfo_initial = 0x0,
    omap44xx_hsusbhost_uhh_sysconfig_initial = 0x0,
    omap44xx_hsusbhost_uhh_sysstatus_initial = 0x0,
    omap44xx_hsusbhost_uhh_hostconfig_initial = 0x0,
    omap44xx_hsusbhost_uhh_debug_csr_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_0_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_1_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_2_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_3_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_4_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_5_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_6_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_7_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_8_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_9_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_10_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_11_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_12_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_13_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_14_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_15_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_16_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_17_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_18_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_19_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_20_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_21_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_22_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_23_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_24_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_25_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_26_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_27_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_28_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_29_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_30_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_31_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_32_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_33_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_34_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_35_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_36_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_37_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_38_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_39_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_40_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_41_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_42_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_43_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_44_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_45_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_46_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_47_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_48_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_49_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_50_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_51_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_52_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_53_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_54_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_55_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_56_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_57_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_58_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_59_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_60_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_61_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_62_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_63_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_64_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_65_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_66_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_67_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_68_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_69_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_70_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_71_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_72_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_73_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_74_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_75_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_76_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_77_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_78_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_79_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_80_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_81_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_82_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_83_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_84_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_85_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_86_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_87_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_88_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_89_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_90_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_91_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_92_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_93_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_94_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_95_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_96_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_97_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_98_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_99_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_100_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_101_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_102_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_103_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_104_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_105_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_106_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_107_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_108_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_109_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_110_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_111_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_112_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_113_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_114_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_115_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_116_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_117_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_118_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_119_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_120_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_121_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_122_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_123_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_124_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_125_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_126_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_127_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_128_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_129_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_130_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_131_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_132_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_133_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_134_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_135_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_136_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_137_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_138_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_139_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_140_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_141_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_142_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_143_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_144_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_145_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_146_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_147_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_148_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_149_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_150_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_151_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_152_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_153_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_154_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_155_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_156_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_157_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_158_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_159_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_160_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_161_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_162_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_163_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_164_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_165_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_166_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_167_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_168_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_169_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_170_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_171_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_172_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_173_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_174_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_175_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_176_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_177_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_178_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_179_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_180_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_181_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_182_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_183_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_184_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_185_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_186_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_187_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_188_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_189_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_190_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_191_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_192_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_193_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_194_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_195_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_196_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_197_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_198_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_199_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_200_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_201_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_202_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_203_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_204_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_205_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_206_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_207_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_208_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_209_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_210_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_211_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_212_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_213_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_214_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_215_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_216_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_217_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_218_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_219_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_220_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_221_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_222_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_223_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_224_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_225_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_226_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_227_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_228_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_229_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_230_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_231_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_232_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_233_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_234_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_235_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_236_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_237_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_238_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_239_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_240_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_241_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_242_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_243_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_244_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_245_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_246_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_247_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_248_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_249_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_250_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_251_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_252_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_253_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_254_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_255_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_256_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_257_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_258_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_259_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_260_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_261_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_262_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_263_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_264_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_265_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_266_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_267_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_268_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_269_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_270_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_271_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_272_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_273_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_274_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_275_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_276_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_277_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_278_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_279_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_280_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_281_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_282_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_283_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_284_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_285_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_286_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_287_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_288_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_289_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_290_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_291_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_292_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_293_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_294_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_295_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_296_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_297_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_298_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_299_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_300_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_301_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_302_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_303_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_304_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_305_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_306_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_307_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_308_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_309_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_310_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_311_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_312_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_313_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_314_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_315_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_316_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_317_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_318_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_319_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_320_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_321_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_322_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_323_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_324_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_325_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_326_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_327_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_328_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_329_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_330_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_331_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_332_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_333_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_334_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_335_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_336_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_337_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_338_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_339_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_340_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_341_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_342_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_343_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_344_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_345_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_346_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_347_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_348_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_349_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_350_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_351_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_352_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_353_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_354_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_355_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_356_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_357_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_358_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_359_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_360_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_361_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_362_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_363_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_364_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_365_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_366_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_367_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_368_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_369_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_370_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_371_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_372_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_373_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_374_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_375_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_376_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_377_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_378_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_379_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_380_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_381_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_382_initial = 0x0,
    omap44xx_hsusbhost_uhh_sar_cntx_i_383_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_hsusbhost_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register uhh_revision: USB high-speed host (UHH) revision identifier (X.Y.R) Used by software to track features, bugs, and compatibility
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_revision_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_revision_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_revision_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_revision_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_hsusbhost_uhh_revision_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_revision_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register uhh_revision is not writeable
static inline int omap44xx_hsusbhost_uhh_revision_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_revision_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_revision (USB high-speed host (UHH) revision identifier (X.Y.R) Used by software to track features, bugs, and compatibility): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_hwinfo: Information on host hardware configuration
 * Type: omap44xx_hsusbhost.uhh_hwinfo (Implicit type of Information on host hardware configuration register)
 *   sar_cntx_size	(size 10, offset 0, init 0):	RO	Save-and-restore context size, in 32-bit words; that is, number of 32-bit registers with significant context information, mapped from offset 0x100 upward.
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline omap44xx_hsusbhost_uhh_hwinfo_t omap44xx_hsusbhost_uhh_hwinfo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hwinfo_t omap44xx_hsusbhost_uhh_hwinfo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_hsusbhost_uhh_hwinfo_t omap44xx_hsusbhost_uhh_hwinfo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hwinfo_t omap44xx_hsusbhost_uhh_hwinfo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_hsusbhost_uhh_hwinfo_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_hwinfo_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hwinfo_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_hwinfo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

// Register uhh_hwinfo is not writeable
static inline int omap44xx_hsusbhost_uhh_hwinfo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_hwinfo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_hsusbhost_uhh_hwinfo_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_hwinfo (Information on host hardware configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_cntx_size =\t%" PRIx16 "\t(Save-and-restore context size, in 32-bit words; that is, number of 32-bit registers with significant context information, mapped from offset 0x100 upward.)\n", omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hwinfo_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_hsusbhost_uhh_hwinfo_sar_cntx_size_extract(_regval));
}

/*
 * Register uhh_sysconfig: OCP standard system configuration register
 * Type: omap44xx_hsusbhost.uhh_sysconfig (Implicit type of OCP standard system configuration register register)
 *   softreset	(size 1, offset 0, init 0):	RW	Module software reset
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   idlemode	(size 2, offset 2, init 0):	RW	Sidlereq/Sidleack(1:0)/[Swakeup] target power management interface configuration.
 *   standbymode	(size 2, offset 4, init 0):	RW	Mstandby/Mwait/[Mwakeup] initiator power-management interface configuration
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysconfig_t omap44xx_hsusbhost_uhh_sysconfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_hsusbhost_uhh_sysconfig_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sysconfig_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_sysconfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sysconfig_wr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sysconfig_wr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_sysconfig_t _regval)
{
    _regval = (_regval & 0x3d);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sysconfig (OCP standard system configuration register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_softreset_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module software reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_idlemode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysconfig_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sidlereq/Sidleack(1:0)/[Swakeup] target power management interface configuration.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " standbymode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_standbymode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysconfig_standbymode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mstandby/Mwait/[Mwakeup] initiator power-management interface configuration)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline omap44xx_hsusbhost_softreset_status_t omap44xx_hsusbhost_uhh_sysconfig_softreset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_softreset_status_t omap44xx_hsusbhost_uhh_sysconfig_softreset_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_hsusbhost_uhh_sysconfig_softreset_extract(_regval));
}

static inline omap44xx_hsusbhost_idlemode_status_t omap44xx_hsusbhost_uhh_sysconfig_idlemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_idlemode_status_t omap44xx_hsusbhost_uhh_sysconfig_idlemode_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_hsusbhost_uhh_sysconfig_idlemode_extract(_regval));
}

static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_sysconfig_standbymode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_sysconfig_standbymode_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_hsusbhost_uhh_sysconfig_standbymode_extract(_regval));
}

static inline void omap44xx_hsusbhost_uhh_sysconfig_softreset_wrf(__DN(t) *_dev, omap44xx_hsusbhost_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sysconfig_softreset_wrf(__DN(t) *_dev, omap44xx_hsusbhost_softreset_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = 0x1 & (((omap44xx_hsusbhost_uhh_sysconfig_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3c & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x3d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_sysconfig_idlemode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_idlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sysconfig_idlemode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_idlemode_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = 0xc & (((omap44xx_hsusbhost_uhh_sysconfig_t )(_fieldval)) << 2);
    _regval = (_regval | (0x31 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x3d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_sysconfig_standbymode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_standbymode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sysconfig_standbymode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_standbymode_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_sysconfig_t _regval = 0x30 & (((omap44xx_hsusbhost_uhh_sysconfig_t )(_fieldval)) << 4);
    _regval = (_regval | (0xd & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x3d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register uhh_sysstatus: Module-specific system status
 * Type: omap44xx_hsusbhost.uhh_sysstatus (Implicit type of Module-specific system status register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   ohci_resetdone	(size 1, offset 1, init 0):	RO	Indicates when the OHCI FS/LS host is out of reset
 *   ehci_resetdone	(size 1, offset 2, init 0):	RO	Indicates when the EHCI HS host is out of reset
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_sysstatus_t omap44xx_hsusbhost_uhh_sysstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_hsusbhost_uhh_sysstatus_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_sysstatus_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sysstatus_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_sysstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

// Register uhh_sysstatus is not writeable
static inline int omap44xx_hsusbhost_uhh_sysstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sysstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_hsusbhost_uhh_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sysstatus (Module-specific system status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ehci_resetdone_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates when the OHCI FS/LS host is out of reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ehci_resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ehci_resetdone_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates when the EHCI HS host is out of reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_hsusbhost_uhh_sysstatus_ohci_resetdone_extract(_regval));
}

static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ehci_resetdone_status_t omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_hsusbhost_uhh_sysstatus_ehci_resetdone_extract(_regval));
}

/*
 * Register uhh_hostconfig: Static configuration of the USB HS host
 * Type: omap44xx_hsusbhost.uhh_hostconfig (Implicit type of Static configuration of the USB HS host register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   autoppd_on_overcur_en	(size 1, offset 1, init 0):	RW	Configure reaction upon port overcurrent condition. This function is not supported at the device level.
 *   ena_incr4	(size 1, offset 2, init 0):	RW	Control the use of INCR4-type bursts (in AHB sense)
 *   ena_incr8	(size 1, offset 3, init 0):	RW	Control the use of INCR8-type bursts (in AHB sense)
 *   ena_incr16	(size 1, offset 4, init 0):	RW	Control the use of INCR16-type bursts (in AHB sense)
 *   ena_incr_align	(size 1, offset 5, init 0):	RW	Force alignment of bursts to the respective burst-size boundaries
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   p1_connect_status	(size 1, offset 8, init 0):	RO	Connection status for port 1
 *   p2_connect_status	(size 1, offset 9, init 0):	RO	Connection status for port 2
 *   _anon10	(size 6, offset 10, init 0):	MBZ	_
 *   p1_mode	(size 2, offset 16, init 0):	RW	Port 1 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en
 *   p2_mode	(size 2, offset 18, init 0):	RW	Port 2 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en
 *   _anon20	(size 11, offset 20, init 0):	MBZ	_
 *   app_start_clk	(size 1, offset 31, init 0):	RW	When the OHCI clocks are suspended, the system must assert this signal to start the clocks (12 and 48 MHz).This must be deasserted after the clocks are started and before the host is suspended again. . (Host is suspended means HCFS = SUSPEND or all the OHCI ports are suspended.) .
 */
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_hostconfig_t omap44xx_hsusbhost_uhh_hostconfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_wr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_hostconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_wr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_hostconfig_t _regval)
{
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_hsusbhost_uhh_hostconfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_hostconfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_hostconfig (Static configuration of the USB HS host): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoppd_on_overcur_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_autoppd_on_overcur_en_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Configure reaction upon port overcurrent condition. This function is not supported at the device level.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the use of INCR4-type bursts (in AHB sense))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr8 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the use of INCR8-type bursts (in AHB sense))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr16 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control the use of INCR16-type bursts (in AHB sense))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ena_incr_align =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ena_incr_align_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force alignment of bursts to the respective burst-size boundaries)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p1_connect_status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_connect_status_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connection status for port 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p2_connect_status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_connect_status_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connection status for port 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p1_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_mode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p1_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port 1 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p2_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_p2_mode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_hostconfig_p2_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port 2 interface configuration. Each bit corresponds to an internal 'strap' signal, and output: Bit 0 = ulpi_bypass Bit 1 = hsic_en)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " app_start_clk =\t%" PRIx8 "\t(When the OHCI clocks are suspended, the system must assert this signal to start the clocks (12 and 48 MHz).This must be deasserted after the clocks are started and before the host is suspended again. . (Host is suspended means HCFS = SUSPEND or all the OHCI ports are suspended.) .)\n", omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_hsusbhost_autoppd_on_overcur_en_status_t omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_autoppd_on_overcur_en_status_t omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_extract(_regval));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_extract(_regval));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_extract(_regval));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_extract(_regval));
}

static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ena_incr_align_status_t omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_extract(_regval));
}

static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_p1_connect_status_extract(_regval));
}

static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_connect_status_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_p2_connect_status_extract(_regval));
}

static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p1_mode_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_p1_mode_extract(_regval));
}

static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_p2_mode_status_t omap44xx_hsusbhost_uhh_hostconfig_p2_mode_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_p2_mode_extract(_regval));
}

static inline uint8_t omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_extract(_regval));
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_wrf(__DN(t) *_dev, omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_autoppd_on_overcur_en_wrf(__DN(t) *_dev, omap44xx_hsusbhost_autoppd_on_overcur_en_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x2 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 1);
    _regval = (_regval | (0x800f003c & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr4_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x4 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 2);
    _regval = (_regval | (0x800f003a & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr8_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x8 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 3);
    _regval = (_regval | (0x800f0036 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr16_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x10 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 4);
    _regval = (_regval | (0x800f002e & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_ena_incr_align_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ena_incr_align_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x20 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 5);
    _regval = (_regval | (0x800f001e & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_p1_mode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_p2_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_p1_mode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_p2_mode_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x30000 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 16);
    _regval = (_regval | (0x800c003e & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_p2_mode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_p2_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_p2_mode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_p2_mode_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0xc0000 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 18);
    _regval = (_regval | (0x8003003e & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_hostconfig_app_start_clk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_hsusbhost_uhh_hostconfig_t _regval = 0x80000000 & (((omap44xx_hsusbhost_uhh_hostconfig_t )(_fieldval)) << 31);
    _regval = (_regval | (0xf003e & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x800f033e);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register uhh_debug_csr: Debug control and status for the EHCI, OHCI hosts
 * Type: omap44xx_hsusbhost.uhh_debug_csr (Implicit type of Debug control and status for the EHCI, OHCI hosts register)
 *   ehci_fladj	(size 6, offset 0, init 0):	RW	EHCI host frame length adjust. Modify only when EHCI Bit FieldUSBSTS.HCHalted = 1 Field value + 59,488 = 60,000 by default = Number of 60-MHz UTMI/ULPI clock cycles per 1 ms USB frame = Number of 480-MHz HS bits per 125 us HS USB microframe
 *   ehci_simulation_mode	(size 1, offset 6, init 0):	RW	Sets the PHY to nondriving mode (used only for simulation)
 *   ochi_cntsel	(size 1, offset 7, init 0):	RW	Selection of a shorter '1 ms' counter in OHCI host, to speed up long USB phases such as reset, resume, etc. (used only for simulation)
 *   _anon8	(size 8, offset 8, init 0):	MBZ	_
 *   ohci_globalsuspend	(size 1, offset 16, init 0):	RO	OHCI global suspend status, asserted 5 ms after the suspend order.
 *   ohci_ccs_1	(size 1, offset 17, init 0):	RO	Current connect status of port 1
 *   ohci_ccs_2	(size 1, offset 18, init 0):	RO	Current connect status of port 2
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_uhh_debug_csr_t omap44xx_hsusbhost_uhh_debug_csr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void omap44xx_hsusbhost_uhh_debug_csr_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_debug_csr_rawwr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void omap44xx_hsusbhost_uhh_debug_csr_wr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_debug_csr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_debug_csr_wr(__DN(t) *_dev, omap44xx_hsusbhost_uhh_debug_csr_t _regval)
{
    _regval = (_regval & 0x700ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int omap44xx_hsusbhost_uhh_debug_csr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_debug_csr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_debug_csr (Debug control and status for the EHCI, OHCI hosts): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ehci_fladj =\t%" PRIx8 "\t(EHCI host frame length adjust. Modify only when EHCI Bit FieldUSBSTS.HCHalted = 1 Field value + 59,488 = 60,000 by default = Number of 60-MHz UTMI/ULPI clock cycles per 1 ms USB frame = Number of 480-MHz HS bits per 125 us HS USB microframe)\n", omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ehci_simulation_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ehci_simulation_mode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sets the PHY to nondriving mode (used only for simulation))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ochi_cntsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_standbymode_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selection of a shorter '1 ms' counter in OHCI host, to speed up long USB phases such as reset, resume, etc. (used only for simulation))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_globalsuspend =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ohci_globalsuspend_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(OHCI global suspend status, asserted 5 ms after the suspend order.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_ccs_1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ohci_ccs_2_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect status of port 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ohci_ccs_2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_ohci_ccs_2_status_prtval(_s + _r, _avail, omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect status of port 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_extract(_regval));
}

static inline omap44xx_hsusbhost_ehci_simulation_mode_status_t omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ehci_simulation_mode_status_t omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_extract(_regval));
}

static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_standbymode_status_t omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_extract(_regval));
}

static inline omap44xx_hsusbhost_ohci_globalsuspend_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ohci_globalsuspend_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_hsusbhost_uhh_debug_csr_ohci_globalsuspend_extract(_regval));
}

static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_1_extract(_regval));
}

static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_hsusbhost_ohci_ccs_2_status_t omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_rdf(__DN(t) *_dev)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_hsusbhost_uhh_debug_csr_ohci_ccs_2_extract(_regval));
}

static inline void omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_debug_csr_ehci_fladj_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = 0x3f & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xc0 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x700ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ehci_simulation_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_debug_csr_ehci_simulation_mode_wrf(__DN(t) *_dev, omap44xx_hsusbhost_ehci_simulation_mode_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = 0x40 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x700ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_wrf(__DN(t) *_dev, omap44xx_hsusbhost_standbymode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_debug_csr_ochi_cntsel_wrf(__DN(t) *_dev, omap44xx_hsusbhost_standbymode_status_t _fieldval)
{
    omap44xx_hsusbhost_uhh_debug_csr_t _regval = 0x80 & (((omap44xx_hsusbhost_uhh_debug_csr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x700ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register uhh_sar_cntx_i_0: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_0 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_1: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x104));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x104));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x104);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_1 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_2: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_2 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_3: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_3_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_3_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_3_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_3_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x10c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_3 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_4: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_4_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_4_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_4_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_4_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x110, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x110);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_4 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_5: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x114));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_5_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x114));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_5_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_5_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x114, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_5_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_5_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x114, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x114);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_5 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_6: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_6_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_6_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x118));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_6_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_6_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x118));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_6_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_6_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x118, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_6_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_6_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x118, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_6_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_6_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x118);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_6 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_7: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_7_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_7_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_7_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_7_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_7_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_7_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_7_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_7_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x11c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_7_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_7_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x11c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_7 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_8: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_8_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_8_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x120));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_8_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_8_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x120));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_8_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_8_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_8_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_8_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x120, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_8_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_8_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x120);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_8 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_9: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_9_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_9_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x124));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_9_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_9_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x124));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_9_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_9_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x124, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_9_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_9_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x124, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_9_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_9_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x124);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_9 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_10: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_10_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_10_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x128));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_10_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_10_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x128));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_10_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_10_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_10_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_10_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x128, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_10_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_10_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x128);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_10 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_11: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_11_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_11_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x12c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_11_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_11_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x12c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_11_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_11_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x12c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_11_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_11_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x12c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_11_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_11_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x12c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_11 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_12: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_12_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_12_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x130));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_12_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_12_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x130));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_12_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_12_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x130, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_12_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_12_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x130, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_12_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_12_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x130);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_12 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_13: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_13_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_13_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x134));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_13_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_13_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x134));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_13_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_13_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x134, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_13_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_13_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x134, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_13_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_13_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x134);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_13 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_14: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_14_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_14_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x138));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_14_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_14_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x138));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_14_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_14_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_14_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_14_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x138, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_14_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_14_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x138);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_14 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_15: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_15_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_15_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x13c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_15_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_15_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x13c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_15_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_15_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x13c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_15_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_15_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x13c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_15_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_15_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x13c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_15 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_16: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_16_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_16_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_16_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_16_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_16_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_16_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_16_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_16_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_16_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_16_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_16 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_17: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_17_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_17_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x144));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_17_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_17_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x144));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_17_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_17_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x144, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_17_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_17_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x144, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_17_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_17_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x144);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_17 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_18: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_18_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_18_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_18_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_18_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_18_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_18_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_18_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_18_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_18_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_18_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_18 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_19: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_19_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_19_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_19_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_19_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_19_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_19_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_19_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_19_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_19_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_19_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x14c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_19 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_20: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_20_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_20_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x150));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_20_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_20_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x150));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_20_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_20_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_20_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_20_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x150, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_20_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_20_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x150);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_20 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_21: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_21_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_21_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x154));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_21_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_21_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x154));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_21_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_21_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x154, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_21_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_21_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x154, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_21_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_21_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x154);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_21 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_22: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_22_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_22_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x158));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_22_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_22_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x158));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_22_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_22_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x158, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_22_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_22_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x158, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_22_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_22_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x158);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_22 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_23: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_23_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_23_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x15c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_23_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_23_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x15c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_23_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_23_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x15c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_23_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_23_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x15c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_23_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_23_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x15c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_23 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_24: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_24_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_24_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_24_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_24_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_24_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_24_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_24_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_24_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_24_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_24_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_24 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_25: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_25_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_25_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x164));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_25_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_25_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x164));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_25_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_25_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_25_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_25_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_25_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_25_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_25 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_26: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_26_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_26_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x168));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_26_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_26_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x168));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_26_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_26_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x168, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_26_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_26_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x168, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_26_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_26_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x168);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_26 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_27: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_27_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_27_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x16c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_27_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_27_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x16c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_27_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_27_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x16c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_27_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_27_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x16c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_27_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_27_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x16c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_27 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_28: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_28_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_28_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_28_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_28_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_28_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_28_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_28_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_28_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_28_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_28_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x170);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_28 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_29: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_29_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_29_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x174));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_29_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_29_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x174));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_29_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_29_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x174, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_29_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_29_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x174, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_29_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_29_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x174);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_29 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_30: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_30_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_30_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x178));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_30_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_30_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x178));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_30_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_30_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_30_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_30_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_30_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_30_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_30 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_31: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_31_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_31_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x17c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_31_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_31_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x17c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_31_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_31_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x17c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_31_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_31_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x17c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_31_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_31_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x17c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_31 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_32: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_32_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_32_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_32_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_32_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_32_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_32_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_32_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_32_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_32_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_32_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_32 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_33: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_33_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_33_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x184));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_33_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_33_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x184));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_33_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_33_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_33_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_33_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x184, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_33_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_33_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x184);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_33 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_34: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_34_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_34_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x188));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_34_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_34_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x188));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_34_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_34_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x188, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_34_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_34_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x188, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_34_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_34_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x188);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_34 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_35: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_35_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_35_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_35_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_35_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_35_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_35_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_35_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_35_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_35_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_35_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x18c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_35 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_36: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_36_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_36_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x190));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_36_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_36_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x190));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_36_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_36_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x190, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_36_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_36_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x190, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_36_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_36_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x190);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_36 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_37: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_37_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_37_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x194));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_37_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_37_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x194));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_37_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_37_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x194, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_37_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_37_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x194, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_37_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_37_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x194);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_37 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_38: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_38_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_38_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x198));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_38_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_38_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x198));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_38_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_38_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x198, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_38_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_38_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x198, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_38_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_38_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x198);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_38 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_39: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_39_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_39_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x19c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_39_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_39_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x19c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_39_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_39_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x19c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_39_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_39_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x19c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_39_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_39_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x19c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_39 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_40: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_40_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_40_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_40_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_40_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_40_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_40_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1a0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_40_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_40_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1a0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_40_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_40_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_40 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_41: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_41_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_41_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_41_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_41_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_41_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_41_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1a4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_41_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_41_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1a4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_41_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_41_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_41 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_42: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_42_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_42_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_42_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_42_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_42_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_42_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1a8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_42_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_42_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1a8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_42_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_42_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_42 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_43: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_43_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_43_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1ac));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_43_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_43_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1ac));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_43_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_43_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1ac, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_43_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_43_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1ac, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_43_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_43_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_43 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_44: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_44_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_44_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_44_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_44_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_44_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_44_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1b0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_44_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_44_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1b0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_44_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_44_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_44 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_45: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_45_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_45_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_45_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_45_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_45_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_45_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1b4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_45_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_45_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1b4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_45_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_45_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_45 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_46: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_46_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_46_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_46_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_46_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1b8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_46_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_46_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1b8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_46_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_46_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1b8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_46_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_46_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_46 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_47: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_47_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_47_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1bc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_47_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_47_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1bc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_47_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_47_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1bc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_47_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_47_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1bc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_47_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_47_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_47 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_48: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_48_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_48_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_48_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_48_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_48_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_48_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_48_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_48_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_48_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_48_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_48 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_49: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_49_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_49_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_49_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_49_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_49_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_49_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_49_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_49_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_49_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_49_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_49 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_50: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_50_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_50_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_50_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_50_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_50_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_50_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_50_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_50_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_50_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_50_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_50 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_51: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_51_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_51_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1cc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_51_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_51_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1cc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_51_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_51_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1cc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_51_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_51_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1cc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_51_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_51_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_51 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_52: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_52_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_52_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_52_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_52_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_52_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_52_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1d0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_52_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_52_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1d0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_52_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_52_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_52 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_53: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_53_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_53_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_53_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_53_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_53_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_53_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1d4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_53_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_53_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1d4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_53_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_53_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_53 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_54: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_54_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_54_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_54_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_54_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1d8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_54_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_54_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1d8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_54_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_54_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1d8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_54_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_54_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_54 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_55: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_55_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_55_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1dc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_55_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_55_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1dc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_55_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_55_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1dc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_55_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_55_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1dc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_55_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_55_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_55 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_56: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_56_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_56_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1e0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_56_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_56_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1e0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_56_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_56_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1e0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_56_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_56_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1e0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_56_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_56_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_56 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_57: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_57_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_57_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1e4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_57_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_57_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1e4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_57_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_57_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1e4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_57_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_57_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1e4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_57_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_57_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_57 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_58: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_58_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_58_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1e8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_58_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_58_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1e8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_58_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_58_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1e8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_58_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_58_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1e8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_58_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_58_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_58 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_59: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_59_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_59_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1ec));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_59_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_59_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1ec));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_59_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_59_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1ec, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_59_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_59_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1ec, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_59_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_59_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_59 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_60: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_60_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_60_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1f0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_60_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_60_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1f0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_60_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_60_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1f0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_60_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_60_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1f0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_60_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_60_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_60 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_61: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_61_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_61_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1f4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_61_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_61_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1f4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_61_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_61_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1f4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_61_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_61_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1f4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_61_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_61_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_61 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_62: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_62_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_62_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1f8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_62_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_62_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1f8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_62_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_62_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1f8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_62_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_62_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1f8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_62_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_62_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_62 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_63: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_63_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_63_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1fc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_63_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_63_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1fc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_63_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_63_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1fc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_63_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_63_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1fc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_63_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_63_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_63 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_64: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_64_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_64_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_64_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_64_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_64_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_64_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_64_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_64_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_64_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_64_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_64 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_65: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_65_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_65_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x204));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_65_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_65_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x204));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_65_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_65_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x204, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_65_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_65_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x204, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_65_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_65_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_65 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_66: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_66_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_66_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x208));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_66_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_66_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x208));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_66_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_66_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x208, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_66_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_66_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x208, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_66_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_66_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x208);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_66 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_67: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_67_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_67_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_67_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_67_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_67_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_67_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_67_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_67_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_67_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_67_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x20c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_67 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_68: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_68_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_68_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x210));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_68_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_68_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x210));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_68_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_68_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_68_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_68_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_68_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_68_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x210);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_68 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_69: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_69_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_69_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x214));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_69_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_69_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x214));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_69_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_69_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_69_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_69_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_69_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_69_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_69 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_70: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_70_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_70_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x218));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_70_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_70_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x218));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_70_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_70_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_70_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_70_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_70_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_70_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_70 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_71: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_71_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_71_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x21c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_71_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_71_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x21c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_71_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_71_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_71_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_71_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x21c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_71_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_71_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x21c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_71 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_72: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_72_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_72_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x220));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_72_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_72_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x220));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_72_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_72_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_72_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_72_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x220, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_72_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_72_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x220);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_72 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_73: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_73_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_73_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x224));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_73_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_73_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x224));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_73_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_73_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_73_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_73_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x224, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_73_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_73_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x224);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_73 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_74: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_74_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_74_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x228));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_74_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_74_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x228));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_74_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_74_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x228, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_74_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_74_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x228, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_74_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_74_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x228);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_74 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_75: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_75_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_75_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x22c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_75_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_75_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x22c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_75_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_75_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x22c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_75_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_75_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x22c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_75_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_75_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x22c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_75 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_76: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_76_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_76_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x230));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_76_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_76_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x230));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_76_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_76_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x230, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_76_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_76_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x230, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_76_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_76_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x230);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_76 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_77: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_77_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_77_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x234));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_77_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_77_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x234));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_77_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_77_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x234, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_77_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_77_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x234, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_77_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_77_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x234);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_77 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_78: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_78_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_78_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x238));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_78_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_78_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x238));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_78_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_78_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x238, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_78_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_78_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x238, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_78_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_78_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x238);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_78 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_79: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_79_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_79_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x23c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_79_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_79_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x23c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_79_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_79_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x23c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_79_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_79_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x23c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_79_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_79_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x23c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_79 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_80: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_80_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_80_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x240));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_80_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_80_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x240));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_80_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_80_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x240, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_80_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_80_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x240, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_80_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_80_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x240);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_80 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_81: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_81_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_81_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x244));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_81_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_81_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x244));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_81_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_81_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x244, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_81_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_81_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x244, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_81_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_81_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x244);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_81 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_82: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_82_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_82_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x248));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_82_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_82_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x248));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_82_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_82_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x248, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_82_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_82_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x248, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_82_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_82_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x248);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_82 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_83: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_83_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_83_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_83_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_83_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_83_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_83_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_83_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_83_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_83_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_83_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x24c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_83 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_84: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_84_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_84_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x250));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_84_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_84_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x250));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_84_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_84_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x250, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_84_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_84_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x250, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_84_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_84_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x250);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_84 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_85: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_85_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_85_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x254));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_85_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_85_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x254));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_85_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_85_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x254, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_85_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_85_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x254, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_85_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_85_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x254);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_85 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_86: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_86_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_86_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x258));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_86_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_86_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x258));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_86_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_86_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x258, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_86_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_86_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x258, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_86_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_86_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x258);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_86 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_87: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_87_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_87_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x25c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_87_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_87_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x25c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_87_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_87_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x25c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_87_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_87_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x25c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_87_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_87_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x25c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_87 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_88: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_88_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_88_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x260));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_88_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_88_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x260));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_88_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_88_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x260, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_88_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_88_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x260, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_88_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_88_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x260);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_88 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_89: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_89_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_89_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x264));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_89_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_89_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x264));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_89_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_89_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x264, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_89_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_89_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x264, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_89_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_89_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x264);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_89 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_90: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_90_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_90_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x268));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_90_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_90_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x268));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_90_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_90_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x268, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_90_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_90_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x268, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_90_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_90_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x268);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_90 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_91: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_91_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_91_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x26c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_91_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_91_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x26c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_91_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_91_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x26c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_91_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_91_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x26c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_91_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_91_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x26c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_91 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_92: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_92_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_92_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x270));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_92_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_92_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x270));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_92_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_92_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x270, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_92_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_92_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x270, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_92_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_92_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x270);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_92 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_93: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_93_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_93_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x274));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_93_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_93_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x274));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_93_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_93_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x274, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_93_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_93_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x274, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_93_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_93_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x274);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_93 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_94: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_94_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_94_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x278));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_94_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_94_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x278));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_94_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_94_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x278, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_94_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_94_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x278, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_94_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_94_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x278);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_94 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_95: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_95_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_95_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x27c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_95_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_95_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x27c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_95_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_95_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x27c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_95_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_95_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x27c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_95_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_95_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x27c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_95 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_96: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_96_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_96_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x280));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_96_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_96_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x280));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_96_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_96_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_96_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_96_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_96_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_96_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_96 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_97: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_97_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_97_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x284));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_97_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_97_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x284));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_97_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_97_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x284, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_97_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_97_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x284, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_97_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_97_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x284);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_97 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_98: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_98_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_98_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x288));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_98_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_98_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x288));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_98_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_98_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x288, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_98_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_98_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x288, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_98_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_98_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x288);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_98 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_99: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_99_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_99_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_99_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_99_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_99_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_99_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_99_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_99_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_99_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_99_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x28c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_99 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_100: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_100_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_100_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x290));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_100_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_100_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x290));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_100_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_100_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x290, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_100_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_100_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x290, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_100_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_100_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x290);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_100 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_101: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_101_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_101_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x294));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_101_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_101_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x294));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_101_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_101_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x294, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_101_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_101_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x294, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_101_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_101_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x294);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_101 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_102: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_102_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_102_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x298));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_102_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_102_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x298));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_102_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_102_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x298, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_102_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_102_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x298, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_102_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_102_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x298);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_102 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_103: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_103_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_103_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x29c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_103_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_103_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x29c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_103_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_103_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x29c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_103_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_103_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x29c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_103_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_103_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x29c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_103 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_104: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_104_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_104_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2a0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_104_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_104_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2a0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_104_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_104_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2a0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_104_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_104_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2a0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_104_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_104_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_104 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_105: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_105_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_105_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2a4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_105_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_105_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2a4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_105_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_105_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2a4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_105_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_105_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2a4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_105_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_105_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_105 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_106: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_106_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_106_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2a8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_106_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_106_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2a8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_106_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_106_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2a8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_106_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_106_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2a8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_106_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_106_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_106 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_107: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_107_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_107_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2ac));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_107_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_107_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2ac));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_107_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_107_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2ac, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_107_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_107_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2ac, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_107_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_107_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_107 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_108: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_108_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_108_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2b0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_108_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_108_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2b0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_108_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_108_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2b0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_108_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_108_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2b0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_108_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_108_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_108 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_109: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_109_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_109_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2b4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_109_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_109_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2b4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_109_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_109_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2b4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_109_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_109_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2b4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_109_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_109_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_109 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_110: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_110_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_110_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2b8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_110_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_110_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2b8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_110_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_110_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2b8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_110_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_110_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2b8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_110_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_110_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_110 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_111: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_111_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_111_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2bc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_111_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_111_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2bc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_111_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_111_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2bc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_111_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_111_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2bc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_111_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_111_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_111 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_112: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_112_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_112_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_112_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_112_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_112_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_112_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_112_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_112_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_112_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_112_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_112 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_113: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_113_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_113_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_113_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_113_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_113_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_113_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_113_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_113_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_113_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_113_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_113 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_114: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_114_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_114_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_114_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_114_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_114_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_114_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_114_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_114_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_114_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_114_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_114 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_115: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_115_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_115_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2cc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_115_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_115_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2cc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_115_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_115_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2cc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_115_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_115_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2cc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_115_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_115_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_115 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_116: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_116_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_116_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2d0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_116_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_116_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2d0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_116_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_116_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2d0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_116_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_116_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2d0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_116_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_116_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_116 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_117: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_117_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_117_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2d4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_117_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_117_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2d4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_117_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_117_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2d4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_117_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_117_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2d4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_117_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_117_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_117 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_118: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_118_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_118_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2d8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_118_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_118_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2d8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_118_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_118_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2d8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_118_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_118_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2d8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_118_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_118_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_118 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_119: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_119_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_119_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2dc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_119_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_119_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2dc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_119_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_119_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2dc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_119_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_119_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2dc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_119_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_119_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_119 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_120: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_120_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_120_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2e0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_120_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_120_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2e0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_120_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_120_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2e0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_120_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_120_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2e0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_120_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_120_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_120 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_121: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_121_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_121_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2e4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_121_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_121_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2e4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_121_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_121_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2e4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_121_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_121_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2e4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_121_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_121_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_121 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_122: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_122_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_122_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2e8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_122_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_122_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2e8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_122_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_122_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2e8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_122_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_122_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2e8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_122_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_122_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_122 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_123: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_123_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_123_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2ec));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_123_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_123_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2ec));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_123_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_123_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2ec, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_123_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_123_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2ec, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_123_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_123_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_123 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_124: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_124_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_124_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_124_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_124_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_124_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_124_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2f0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_124_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_124_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2f0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_124_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_124_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_124 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_125: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_125_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_125_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_125_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_125_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_125_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_125_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2f4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_125_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_125_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2f4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_125_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_125_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_125 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_126: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_126_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_126_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_126_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_126_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_126_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_126_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2f8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_126_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_126_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2f8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_126_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_126_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_126 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_127: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_127_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_127_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2fc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_127_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_127_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2fc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_127_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_127_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2fc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_127_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_127_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2fc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_127_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_127_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_127 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_128: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_128_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_128_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x300));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_128_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_128_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x300));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_128_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_128_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_128_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_128_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_128_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_128_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_128 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_129: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_129_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_129_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x304));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_129_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_129_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x304));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_129_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_129_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x304, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_129_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_129_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x304, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_129_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_129_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x304);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_129 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_130: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_130_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_130_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x308));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_130_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_130_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x308));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_130_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_130_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x308, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_130_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_130_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x308, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_130_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_130_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x308);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_130 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_131: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_131_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_131_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_131_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_131_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_131_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_131_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_131_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_131_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_131_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_131_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x30c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_131 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_132: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_132_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_132_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x310));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_132_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_132_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x310));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_132_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_132_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_132_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_132_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_132_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_132_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_132 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_133: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_133_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_133_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x314));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_133_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_133_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x314));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_133_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_133_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_133_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_133_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x314, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_133_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_133_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x314);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_133 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_134: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_134_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_134_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x318));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_134_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_134_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x318));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_134_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_134_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_134_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_134_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x318, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_134_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_134_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x318);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_134 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_135: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_135_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_135_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x31c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_135_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_135_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x31c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_135_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_135_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_135_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_135_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x31c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_135_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_135_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x31c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_135 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_136: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_136_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_136_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x320));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_136_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_136_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x320));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_136_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_136_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_136_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_136_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_136_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_136_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_136 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_137: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_137_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_137_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x324));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_137_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_137_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x324));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_137_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_137_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_137_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_137_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x324, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_137_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_137_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x324);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_137 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_138: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_138_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_138_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x328));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_138_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_138_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x328));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_138_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_138_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x328, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_138_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_138_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x328, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_138_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_138_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x328);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_138 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_139: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_139_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_139_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x32c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_139_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_139_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x32c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_139_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_139_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x32c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_139_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_139_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x32c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_139_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_139_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x32c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_139 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_140: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_140_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_140_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x330));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_140_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_140_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x330));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_140_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_140_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_140_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_140_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_140_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_140_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x330);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_140 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_141: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_141_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_141_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x334));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_141_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_141_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x334));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_141_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_141_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x334, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_141_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_141_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x334, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_141_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_141_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x334);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_141 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_142: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_142_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_142_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x338));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_142_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_142_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x338));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_142_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_142_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x338, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_142_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_142_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x338, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_142_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_142_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x338);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_142 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_143: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_143_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_143_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x33c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_143_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_143_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x33c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_143_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_143_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x33c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_143_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_143_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x33c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_143_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_143_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x33c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_143 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_144: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_144_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_144_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x340));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_144_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_144_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x340));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_144_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_144_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_144_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_144_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_144_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_144_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x340);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_144 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_145: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_145_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_145_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x344));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_145_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_145_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x344));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_145_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_145_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x344, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_145_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_145_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x344, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_145_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_145_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x344);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_145 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_146: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_146_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_146_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x348));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_146_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_146_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x348));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_146_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_146_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x348, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_146_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_146_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x348, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_146_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_146_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x348);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_146 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_147: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_147_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_147_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_147_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_147_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_147_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_147_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_147_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_147_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x34c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_147_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_147_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x34c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_147 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_148: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_148_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_148_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x350));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_148_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_148_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x350));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_148_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_148_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_148_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_148_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_148_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_148_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_148 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_149: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_149_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_149_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x354));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_149_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_149_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x354));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_149_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_149_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x354, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_149_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_149_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x354, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_149_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_149_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x354);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_149 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_150: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_150_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_150_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x358));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_150_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_150_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x358));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_150_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_150_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x358, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_150_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_150_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x358, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_150_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_150_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x358);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_150 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_151: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_151_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_151_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x35c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_151_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_151_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x35c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_151_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_151_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x35c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_151_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_151_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x35c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_151_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_151_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x35c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_151 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_152: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_152_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_152_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x360));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_152_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_152_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x360));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_152_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_152_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_152_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_152_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_152_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_152_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_152 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_153: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_153_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_153_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x364));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_153_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_153_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x364));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_153_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_153_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x364, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_153_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_153_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x364, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_153_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_153_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x364);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_153 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_154: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_154_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_154_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x368));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_154_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_154_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x368));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_154_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_154_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x368, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_154_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_154_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x368, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_154_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_154_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x368);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_154 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_155: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_155_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_155_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x36c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_155_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_155_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x36c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_155_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_155_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x36c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_155_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_155_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x36c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_155_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_155_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x36c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_155 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_156: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_156_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_156_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x370));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_156_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_156_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x370));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_156_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_156_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_156_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_156_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_156_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_156_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x370);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_156 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_157: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_157_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_157_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x374));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_157_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_157_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x374));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_157_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_157_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x374, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_157_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_157_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x374, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_157_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_157_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x374);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_157 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_158: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_158_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_158_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x378));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_158_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_158_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x378));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_158_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_158_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x378, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_158_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_158_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x378, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_158_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_158_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x378);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_158 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_159: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_159_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_159_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x37c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_159_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_159_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x37c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_159_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_159_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x37c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_159_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_159_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x37c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_159_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_159_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x37c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_159 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_160: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_160_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_160_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x380));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_160_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_160_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x380));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_160_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_160_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x380, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_160_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_160_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x380, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_160_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_160_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x380);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_160 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_161: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_161_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_161_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x384));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_161_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_161_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x384));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_161_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_161_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x384, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_161_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_161_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x384, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_161_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_161_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x384);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_161 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_162: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_162_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_162_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x388));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_162_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_162_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x388));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_162_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_162_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x388, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_162_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_162_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x388, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_162_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_162_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x388);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_162 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_163: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_163_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_163_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_163_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_163_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_163_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_163_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_163_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_163_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_163_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_163_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x38c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_163 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_164: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_164_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_164_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x390));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_164_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_164_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x390));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_164_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_164_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x390, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_164_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_164_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x390, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_164_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_164_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x390);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_164 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_165: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_165_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_165_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x394));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_165_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_165_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x394));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_165_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_165_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x394, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_165_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_165_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x394, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_165_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_165_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x394);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_165 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_166: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_166_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_166_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x398));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_166_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_166_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x398));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_166_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_166_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x398, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_166_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_166_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x398, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_166_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_166_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x398);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_166 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_167: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_167_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_167_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x39c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_167_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_167_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x39c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_167_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_167_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x39c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_167_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_167_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x39c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_167_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_167_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x39c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_167 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_168: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_168_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_168_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3a0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_168_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_168_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3a0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_168_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_168_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3a0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_168_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_168_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3a0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_168_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_168_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_168 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_169: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_169_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_169_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3a4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_169_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_169_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3a4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_169_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_169_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3a4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_169_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_169_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3a4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_169_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_169_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_169 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_170: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_170_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_170_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3a8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_170_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_170_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3a8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_170_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_170_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3a8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_170_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_170_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3a8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_170_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_170_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_170 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_171: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_171_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_171_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3ac));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_171_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_171_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3ac));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_171_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_171_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3ac, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_171_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_171_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3ac, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_171_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_171_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_171 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_172: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_172_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_172_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3b0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_172_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_172_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3b0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_172_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_172_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3b0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_172_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_172_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3b0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_172_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_172_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_172 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_173: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_173_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_173_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3b4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_173_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_173_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3b4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_173_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_173_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3b4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_173_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_173_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3b4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_173_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_173_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_173 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_174: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_174_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_174_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3b8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_174_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_174_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3b8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_174_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_174_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3b8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_174_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_174_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3b8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_174_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_174_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_174 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_175: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_175_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_175_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3bc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_175_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_175_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3bc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_175_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_175_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3bc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_175_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_175_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3bc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_175_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_175_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_175 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_176: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_176_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_176_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_176_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_176_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_176_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_176_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_176_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_176_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3c0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_176_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_176_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_176 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_177: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_177_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_177_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_177_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_177_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_177_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_177_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_177_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_177_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3c4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_177_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_177_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_177 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_178: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_178_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_178_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_178_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_178_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_178_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_178_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_178_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_178_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3c8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_178_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_178_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_178 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_179: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_179_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_179_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3cc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_179_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_179_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3cc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_179_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_179_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3cc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_179_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_179_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3cc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_179_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_179_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_179 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_180: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_180_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_180_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_180_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_180_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_180_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_180_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3d0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_180_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_180_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3d0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_180_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_180_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_180 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_181: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_181_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_181_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_181_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_181_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_181_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_181_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3d4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_181_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_181_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3d4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_181_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_181_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_181 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_182: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_182_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_182_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_182_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_182_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_182_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_182_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3d8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_182_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_182_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3d8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_182_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_182_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_182 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_183: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_183_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_183_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3dc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_183_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_183_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3dc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_183_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_183_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3dc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_183_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_183_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3dc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_183_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_183_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_183 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_184: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_184_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_184_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_184_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_184_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_184_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_184_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3e0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_184_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_184_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3e0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_184_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_184_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_184 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_185: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_185_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_185_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_185_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_185_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_185_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_185_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3e4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_185_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_185_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3e4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_185_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_185_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_185 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_186: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_186_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_186_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_186_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_186_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_186_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_186_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3e8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_186_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_186_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3e8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_186_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_186_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_186 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_187: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_187_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_187_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3ec));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_187_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_187_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3ec));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_187_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_187_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3ec, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_187_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_187_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3ec, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_187_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_187_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_187 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_188: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_188_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_188_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3f0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_188_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_188_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3f0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_188_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_188_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3f0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_188_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_188_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3f0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_188_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_188_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_188 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_189: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_189_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_189_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3f4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_189_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_189_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3f4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_189_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_189_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3f4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_189_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_189_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3f4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_189_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_189_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_189 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_190: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_190_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_190_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3f8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_190_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_190_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3f8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_190_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_190_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3f8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_190_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_190_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3f8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_190_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_190_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_190 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_191: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_191_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_191_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3fc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_191_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_191_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3fc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_191_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_191_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3fc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_191_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_191_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3fc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_191_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_191_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_191 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_192: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_192_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_192_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_192_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_192_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_192_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_192_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_192_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_192_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_192_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_192_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_192 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_193: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_193_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_193_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_193_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_193_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_193_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_193_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_193_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_193_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_193_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_193_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x404);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_193 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_194: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_194_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_194_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x408));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_194_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_194_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x408));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_194_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_194_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x408, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_194_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_194_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x408, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_194_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_194_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x408);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_194 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_195: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_195_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_195_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_195_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_195_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_195_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_195_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_195_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_195_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_195_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_195_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_195 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_196: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_196_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_196_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_196_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_196_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_196_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_196_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_196_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_196_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_196_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_196_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_196 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_197: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_197_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_197_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x414));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_197_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_197_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x414));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_197_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_197_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x414, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_197_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_197_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x414, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_197_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_197_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x414);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_197 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_198: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_198_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_198_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x418));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_198_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_198_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x418));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_198_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_198_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x418, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_198_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_198_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x418, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_198_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_198_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x418);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_198 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_199: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_199_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_199_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x41c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_199_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_199_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x41c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_199_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_199_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x41c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_199_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_199_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x41c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_199_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_199_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x41c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_199 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_200: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_200_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_200_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_200_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_200_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_200_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_200_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_200_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_200_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_200_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_200_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x420);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_200 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_201: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_201_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_201_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x424));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_201_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_201_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x424));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_201_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_201_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x424, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_201_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_201_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x424, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_201_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_201_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x424);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_201 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_202: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_202_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_202_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x428));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_202_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_202_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x428));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_202_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_202_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x428, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_202_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_202_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x428, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_202_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_202_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x428);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_202 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_203: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_203_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_203_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_203_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_203_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_203_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_203_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_203_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_203_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x42c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_203_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_203_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x42c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_203 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_204: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_204_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_204_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x430));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_204_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_204_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x430));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_204_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_204_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x430, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_204_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_204_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x430, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_204_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_204_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x430);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_204 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_205: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_205_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_205_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x434));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_205_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_205_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x434));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_205_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_205_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x434, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_205_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_205_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x434, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_205_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_205_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x434);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_205 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_206: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_206_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_206_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x438));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_206_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_206_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x438));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_206_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_206_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x438, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_206_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_206_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x438, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_206_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_206_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x438);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_206 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_207: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_207_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_207_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x43c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_207_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_207_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x43c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_207_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_207_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x43c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_207_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_207_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x43c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_207_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_207_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x43c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_207 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_208: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_208_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_208_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x440));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_208_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_208_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x440));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_208_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_208_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x440, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_208_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_208_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x440, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_208_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_208_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x440);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_208 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_209: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_209_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_209_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x444));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_209_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_209_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x444));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_209_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_209_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x444, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_209_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_209_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x444, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_209_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_209_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x444);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_209 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_210: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_210_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_210_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x448));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_210_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_210_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x448));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_210_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_210_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x448, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_210_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_210_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x448, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_210_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_210_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x448);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_210 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_211: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_211_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_211_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_211_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_211_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_211_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_211_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_211_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_211_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_211_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_211_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x44c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_211 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_212: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_212_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_212_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x450));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_212_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_212_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x450));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_212_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_212_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x450, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_212_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_212_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x450, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_212_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_212_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x450);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_212 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_213: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_213_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_213_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x454));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_213_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_213_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x454));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_213_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_213_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x454, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_213_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_213_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x454, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_213_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_213_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x454);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_213 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_214: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_214_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_214_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x458));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_214_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_214_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x458));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_214_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_214_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x458, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_214_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_214_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x458, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_214_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_214_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x458);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_214 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_215: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_215_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_215_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x45c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_215_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_215_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x45c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_215_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_215_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x45c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_215_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_215_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x45c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_215_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_215_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x45c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_215 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_216: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_216_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_216_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x460));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_216_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_216_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x460));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_216_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_216_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x460, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_216_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_216_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x460, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_216_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_216_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x460);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_216 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_217: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_217_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_217_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x464));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_217_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_217_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x464));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_217_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_217_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x464, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_217_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_217_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x464, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_217_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_217_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x464);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_217 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_218: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_218_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_218_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x468));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_218_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_218_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x468));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_218_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_218_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x468, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_218_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_218_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x468, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_218_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_218_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x468);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_218 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_219: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_219_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_219_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x46c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_219_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_219_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x46c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_219_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_219_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x46c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_219_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_219_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x46c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_219_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_219_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x46c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_219 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_220: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_220_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_220_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x470));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_220_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_220_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x470));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_220_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_220_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x470, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_220_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_220_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x470, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_220_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_220_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x470);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_220 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_221: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_221_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_221_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x474));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_221_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_221_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x474));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_221_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_221_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x474, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_221_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_221_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x474, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_221_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_221_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x474);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_221 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_222: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_222_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_222_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x478));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_222_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_222_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x478));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_222_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_222_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x478, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_222_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_222_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x478, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_222_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_222_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x478);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_222 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_223: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_223_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_223_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x47c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_223_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_223_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x47c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_223_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_223_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x47c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_223_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_223_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x47c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_223_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_223_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x47c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_223 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_224: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_224_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_224_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x480));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_224_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_224_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x480));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_224_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_224_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x480, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_224_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_224_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x480, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_224_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_224_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x480);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_224 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_225: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_225_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_225_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x484));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_225_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_225_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x484));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_225_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_225_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x484, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_225_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_225_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x484, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_225_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_225_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x484);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_225 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_226: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_226_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_226_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x488));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_226_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_226_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x488));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_226_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_226_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x488, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_226_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_226_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x488, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_226_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_226_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x488);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_226 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_227: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_227_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_227_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_227_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_227_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_227_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_227_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_227_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_227_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x48c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_227_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_227_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x48c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_227 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_228: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_228_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_228_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x490));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_228_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_228_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x490));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_228_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_228_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x490, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_228_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_228_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x490, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_228_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_228_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x490);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_228 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_229: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_229_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_229_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x494));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_229_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_229_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x494));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_229_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_229_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x494, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_229_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_229_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x494, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_229_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_229_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x494);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_229 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_230: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_230_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_230_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x498));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_230_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_230_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x498));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_230_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_230_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x498, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_230_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_230_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x498, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_230_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_230_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x498);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_230 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_231: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_231_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_231_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x49c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_231_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_231_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x49c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_231_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_231_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x49c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_231_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_231_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x49c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_231_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_231_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x49c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_231 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_232: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_232_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_232_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_232_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_232_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_232_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_232_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4a0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_232_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_232_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4a0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_232_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_232_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_232 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_233: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_233_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_233_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_233_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_233_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_233_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_233_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4a4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_233_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_233_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4a4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_233_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_233_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_233 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_234: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_234_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_234_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_234_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_234_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_234_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_234_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4a8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_234_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_234_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4a8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_234_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_234_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_234 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_235: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_235_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_235_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4ac));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_235_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_235_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4ac));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_235_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_235_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4ac, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_235_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_235_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4ac, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_235_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_235_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_235 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_236: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_236_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_236_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4b0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_236_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_236_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4b0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_236_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_236_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4b0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_236_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_236_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4b0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_236_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_236_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_236 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_237: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_237_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_237_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4b4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_237_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_237_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4b4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_237_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_237_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4b4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_237_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_237_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4b4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_237_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_237_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_237 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_238: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_238_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_238_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4b8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_238_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_238_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4b8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_238_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_238_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4b8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_238_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_238_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4b8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_238_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_238_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_238 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_239: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_239_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_239_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4bc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_239_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_239_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4bc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_239_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_239_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4bc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_239_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_239_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4bc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_239_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_239_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_239 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_240: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_240_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_240_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_240_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_240_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_240_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_240_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_240_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_240_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4c0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_240_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_240_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_240 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_241: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_241_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_241_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_241_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_241_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_241_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_241_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_241_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_241_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4c4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_241_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_241_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_241 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_242: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_242_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_242_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_242_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_242_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_242_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_242_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_242_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_242_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4c8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_242_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_242_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_242 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_243: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_243_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_243_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4cc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_243_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_243_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4cc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_243_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_243_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4cc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_243_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_243_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4cc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_243_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_243_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_243 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_244: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_244_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_244_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4d0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_244_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_244_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4d0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_244_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_244_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4d0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_244_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_244_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4d0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_244_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_244_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_244 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_245: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_245_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_245_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4d4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_245_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_245_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4d4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_245_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_245_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4d4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_245_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_245_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4d4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_245_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_245_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_245 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_246: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_246_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_246_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4d8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_246_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_246_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4d8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_246_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_246_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4d8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_246_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_246_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4d8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_246_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_246_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_246 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_247: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_247_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_247_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4dc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_247_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_247_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4dc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_247_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_247_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4dc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_247_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_247_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4dc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_247_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_247_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_247 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_248: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_248_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_248_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4e0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_248_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_248_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4e0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_248_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_248_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4e0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_248_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_248_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4e0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_248_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_248_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_248 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_249: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_249_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_249_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4e4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_249_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_249_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4e4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_249_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_249_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4e4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_249_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_249_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4e4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_249_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_249_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_249 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_250: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_250_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_250_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4e8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_250_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_250_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4e8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_250_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_250_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4e8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_250_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_250_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4e8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_250_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_250_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_250 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_251: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_251_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_251_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4ec));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_251_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_251_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4ec));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_251_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_251_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4ec, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_251_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_251_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4ec, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_251_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_251_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_251 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_252: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_252_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_252_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4f0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_252_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_252_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4f0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_252_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_252_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4f0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_252_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_252_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4f0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_252_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_252_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_252 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_253: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_253_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_253_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4f4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_253_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_253_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4f4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_253_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_253_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4f4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_253_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_253_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4f4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_253_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_253_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_253 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_254: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_254_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_254_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4f8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_254_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_254_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4f8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_254_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_254_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4f8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_254_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_254_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4f8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_254_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_254_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_254 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_255: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_255_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_255_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4fc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_255_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_255_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4fc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_255_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_255_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4fc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_255_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_255_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4fc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_255_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_255_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_255 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_256: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_256_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_256_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x500));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_256_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_256_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x500));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_256_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_256_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x500, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_256_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_256_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x500, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_256_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_256_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x500);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_256 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_257: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_257_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_257_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x504));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_257_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_257_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x504));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_257_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_257_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x504, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_257_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_257_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x504, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_257_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_257_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x504);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_257 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_258: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_258_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_258_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x508));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_258_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_258_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x508));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_258_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_258_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x508, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_258_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_258_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x508, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_258_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_258_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x508);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_258 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_259: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_259_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_259_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_259_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_259_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_259_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_259_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_259_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_259_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x50c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_259_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_259_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x50c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_259 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_260: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_260_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_260_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x510));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_260_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_260_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x510));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_260_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_260_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x510, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_260_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_260_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x510, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_260_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_260_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x510);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_260 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_261: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_261_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_261_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x514));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_261_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_261_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x514));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_261_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_261_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x514, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_261_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_261_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x514, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_261_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_261_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x514);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_261 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_262: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_262_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_262_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x518));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_262_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_262_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x518));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_262_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_262_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x518, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_262_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_262_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x518, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_262_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_262_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x518);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_262 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_263: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_263_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_263_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_263_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_263_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_263_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_263_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x51c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_263_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_263_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x51c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_263_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_263_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x51c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_263 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_264: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_264_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_264_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x520));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_264_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_264_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x520));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_264_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_264_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x520, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_264_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_264_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x520, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_264_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_264_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x520);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_264 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_265: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_265_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_265_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x524));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_265_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_265_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x524));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_265_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_265_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x524, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_265_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_265_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x524, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_265_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_265_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x524);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_265 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_266: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_266_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_266_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x528));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_266_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_266_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x528));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_266_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_266_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x528, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_266_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_266_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x528, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_266_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_266_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x528);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_266 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_267: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_267_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_267_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x52c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_267_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_267_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x52c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_267_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_267_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x52c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_267_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_267_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x52c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_267_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_267_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x52c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_267 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_268: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_268_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_268_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x530));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_268_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_268_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x530));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_268_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_268_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x530, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_268_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_268_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x530, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_268_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_268_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x530);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_268 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_269: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_269_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_269_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x534));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_269_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_269_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x534));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_269_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_269_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x534, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_269_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_269_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x534, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_269_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_269_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x534);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_269 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_270: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_270_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_270_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x538));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_270_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_270_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x538));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_270_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_270_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x538, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_270_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_270_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x538, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_270_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_270_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x538);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_270 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_271: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_271_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_271_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x53c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_271_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_271_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x53c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_271_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_271_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x53c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_271_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_271_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x53c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_271_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_271_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x53c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_271 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_272: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_272_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_272_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x540));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_272_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_272_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x540));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_272_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_272_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x540, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_272_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_272_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x540, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_272_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_272_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x540);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_272 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_273: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_273_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_273_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x544));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_273_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_273_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x544));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_273_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_273_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x544, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_273_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_273_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x544, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_273_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_273_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x544);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_273 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_274: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_274_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_274_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x548));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_274_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_274_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x548));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_274_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_274_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x548, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_274_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_274_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x548, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_274_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_274_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x548);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_274 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_275: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_275_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_275_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_275_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_275_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_275_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_275_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_275_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_275_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x54c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_275_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_275_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x54c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_275 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_276: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_276_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_276_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x550));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_276_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_276_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x550));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_276_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_276_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x550, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_276_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_276_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x550, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_276_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_276_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x550);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_276 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_277: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_277_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_277_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x554));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_277_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_277_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x554));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_277_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_277_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x554, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_277_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_277_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x554, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_277_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_277_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x554);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_277 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_278: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_278_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_278_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x558));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_278_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_278_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x558));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_278_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_278_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x558, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_278_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_278_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x558, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_278_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_278_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x558);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_278 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_279: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_279_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_279_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x55c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_279_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_279_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x55c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_279_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_279_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x55c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_279_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_279_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x55c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_279_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_279_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x55c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_279 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_280: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_280_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_280_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x560));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_280_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_280_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x560));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_280_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_280_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x560, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_280_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_280_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x560, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_280_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_280_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x560);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_280 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_281: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_281_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_281_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x564));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_281_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_281_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x564));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_281_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_281_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x564, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_281_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_281_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x564, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_281_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_281_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x564);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_281 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_282: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_282_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_282_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x568));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_282_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_282_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x568));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_282_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_282_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x568, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_282_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_282_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x568, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_282_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_282_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x568);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_282 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_283: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_283_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_283_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x56c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_283_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_283_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x56c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_283_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_283_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x56c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_283_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_283_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x56c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_283_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_283_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x56c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_283 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_284: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_284_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_284_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x570));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_284_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_284_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x570));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_284_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_284_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x570, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_284_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_284_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x570, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_284_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_284_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x570);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_284 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_285: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_285_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_285_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x574));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_285_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_285_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x574));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_285_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_285_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x574, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_285_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_285_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x574, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_285_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_285_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x574);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_285 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_286: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_286_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_286_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x578));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_286_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_286_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x578));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_286_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_286_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x578, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_286_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_286_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x578, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_286_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_286_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x578);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_286 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_287: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_287_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_287_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x57c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_287_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_287_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x57c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_287_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_287_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x57c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_287_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_287_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x57c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_287_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_287_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x57c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_287 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_288: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_288_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_288_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x580));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_288_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_288_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x580));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_288_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_288_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x580, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_288_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_288_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x580, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_288_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_288_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x580);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_288 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_289: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_289_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_289_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x584));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_289_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_289_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x584));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_289_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_289_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x584, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_289_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_289_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x584, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_289_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_289_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x584);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_289 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_290: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_290_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_290_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x588));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_290_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_290_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x588));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_290_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_290_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x588, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_290_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_290_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x588, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_290_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_290_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x588);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_290 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_291: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_291_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_291_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_291_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_291_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_291_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_291_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_291_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_291_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x58c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_291_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_291_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x58c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_291 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_292: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_292_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_292_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x590));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_292_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_292_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x590));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_292_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_292_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x590, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_292_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_292_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x590, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_292_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_292_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x590);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_292 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_293: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_293_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_293_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x594));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_293_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_293_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x594));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_293_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_293_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x594, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_293_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_293_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x594, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_293_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_293_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x594);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_293 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_294: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_294_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_294_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x598));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_294_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_294_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x598));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_294_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_294_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x598, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_294_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_294_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x598, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_294_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_294_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x598);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_294 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_295: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_295_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_295_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x59c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_295_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_295_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x59c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_295_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_295_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x59c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_295_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_295_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x59c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_295_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_295_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x59c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_295 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_296: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_296_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_296_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_296_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_296_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_296_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_296_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_296_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_296_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_296_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_296_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_296 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_297: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_297_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_297_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_297_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_297_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_297_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_297_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_297_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_297_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_297_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_297_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_297 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_298: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_298_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_298_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_298_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_298_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_298_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_298_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_298_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_298_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_298_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_298_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_298 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_299: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_299_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_299_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5ac));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_299_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_299_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5ac));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_299_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_299_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5ac, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_299_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_299_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5ac, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_299_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_299_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_299 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_300: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_300_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_300_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_300_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_300_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_300_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_300_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_300_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_300_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_300_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_300_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_300 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_301: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_301_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_301_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_301_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_301_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_301_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_301_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_301_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_301_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_301_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_301_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_301 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_302: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_302_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_302_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_302_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_302_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_302_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_302_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_302_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_302_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_302_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_302_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_302 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_303: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_303_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_303_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5bc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_303_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_303_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5bc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_303_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_303_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5bc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_303_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_303_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5bc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_303_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_303_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_303 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_304: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_304_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_304_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_304_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_304_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_304_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_304_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_304_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_304_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5c0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_304_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_304_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_304 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_305: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_305_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_305_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_305_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_305_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_305_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_305_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_305_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_305_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5c4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_305_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_305_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_305 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_306: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_306_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_306_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_306_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_306_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_306_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_306_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_306_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_306_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5c8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_306_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_306_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_306 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_307: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_307_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_307_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5cc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_307_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_307_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5cc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_307_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_307_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5cc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_307_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_307_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5cc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_307_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_307_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_307 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_308: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_308_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_308_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5d0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_308_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_308_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5d0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_308_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_308_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5d0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_308_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_308_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5d0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_308_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_308_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_308 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_309: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_309_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_309_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5d4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_309_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_309_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5d4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_309_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_309_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5d4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_309_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_309_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5d4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_309_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_309_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_309 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_310: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_310_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_310_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5d8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_310_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_310_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5d8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_310_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_310_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5d8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_310_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_310_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5d8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_310_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_310_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_310 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_311: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_311_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_311_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5dc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_311_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_311_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5dc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_311_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_311_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5dc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_311_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_311_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5dc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_311_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_311_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_311 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_312: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_312_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_312_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5e0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_312_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_312_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5e0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_312_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_312_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5e0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_312_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_312_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5e0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_312_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_312_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_312 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_313: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_313_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_313_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5e4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_313_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_313_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5e4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_313_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_313_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5e4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_313_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_313_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5e4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_313_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_313_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_313 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_314: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_314_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_314_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5e8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_314_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_314_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5e8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_314_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_314_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5e8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_314_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_314_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5e8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_314_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_314_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_314 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_315: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_315_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_315_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5ec));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_315_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_315_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5ec));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_315_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_315_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5ec, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_315_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_315_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5ec, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_315_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_315_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_315 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_316: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_316_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_316_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_316_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_316_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_316_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_316_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5f0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_316_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_316_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5f0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_316_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_316_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_316 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_317: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_317_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_317_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_317_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_317_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_317_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_317_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5f4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_317_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_317_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5f4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_317_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_317_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_317 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_318: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_318_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_318_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_318_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_318_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_318_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_318_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5f8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_318_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_318_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5f8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_318_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_318_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_318 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_319: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_319_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_319_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5fc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_319_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_319_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5fc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_319_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_319_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5fc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_319_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_319_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5fc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_319_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_319_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_319 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_320: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_320_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_320_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x600));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_320_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_320_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x600));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_320_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_320_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_320_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_320_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_320_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_320_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x600);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_320 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_321: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_321_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_321_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x604));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_321_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_321_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x604));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_321_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_321_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_321_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_321_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_321_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_321_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_321 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_322: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_322_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_322_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x608));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_322_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_322_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x608));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_322_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_322_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_322_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_322_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_322_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_322_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_322 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_323: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_323_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_323_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_323_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_323_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_323_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_323_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_323_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_323_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_323_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_323_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x60c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_323 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_324: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_324_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_324_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x610));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_324_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_324_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x610));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_324_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_324_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x610, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_324_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_324_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x610, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_324_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_324_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x610);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_324 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_325: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_325_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_325_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x614));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_325_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_325_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x614));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_325_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_325_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x614, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_325_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_325_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x614, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_325_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_325_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x614);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_325 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_326: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_326_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_326_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x618));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_326_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_326_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x618));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_326_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_326_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x618, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_326_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_326_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x618, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_326_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_326_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x618);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_326 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_327: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_327_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_327_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x61c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_327_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_327_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x61c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_327_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_327_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_327_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_327_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_327_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_327_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_327 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_328: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_328_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_328_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x620));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_328_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_328_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x620));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_328_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_328_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x620, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_328_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_328_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x620, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_328_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_328_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x620);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_328 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_329: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_329_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_329_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x624));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_329_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_329_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x624));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_329_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_329_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x624, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_329_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_329_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x624, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_329_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_329_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x624);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_329 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_330: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_330_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_330_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x628));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_330_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_330_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x628));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_330_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_330_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x628, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_330_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_330_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x628, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_330_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_330_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x628);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_330 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_331: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_331_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_331_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x62c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_331_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_331_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x62c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_331_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_331_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x62c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_331_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_331_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x62c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_331_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_331_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x62c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_331 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_332: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_332_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_332_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x630));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_332_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_332_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x630));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_332_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_332_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x630, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_332_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_332_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x630, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_332_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_332_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x630);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_332 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_333: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_333_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_333_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x634));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_333_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_333_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x634));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_333_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_333_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x634, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_333_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_333_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x634, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_333_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_333_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x634);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_333 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_334: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_334_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_334_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x638));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_334_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_334_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x638));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_334_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_334_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x638, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_334_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_334_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x638, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_334_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_334_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x638);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_334 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_335: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_335_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_335_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x63c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_335_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_335_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x63c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_335_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_335_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x63c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_335_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_335_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x63c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_335_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_335_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x63c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_335 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_336: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_336_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_336_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x640));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_336_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_336_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x640));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_336_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_336_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x640, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_336_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_336_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x640, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_336_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_336_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x640);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_336 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_337: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_337_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_337_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x644));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_337_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_337_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x644));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_337_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_337_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x644, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_337_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_337_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x644, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_337_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_337_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x644);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_337 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_338: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_338_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_338_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x648));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_338_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_338_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x648));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_338_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_338_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x648, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_338_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_338_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x648, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_338_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_338_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x648);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_338 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_339: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_339_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_339_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_339_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_339_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_339_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_339_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x64c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_339_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_339_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x64c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_339_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_339_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x64c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_339 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_340: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_340_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_340_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x650));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_340_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_340_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x650));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_340_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_340_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x650, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_340_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_340_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x650, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_340_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_340_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x650);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_340 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_341: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_341_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_341_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x654));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_341_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_341_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x654));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_341_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_341_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x654, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_341_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_341_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x654, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_341_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_341_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x654);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_341 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_342: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_342_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_342_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x658));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_342_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_342_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x658));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_342_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_342_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x658, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_342_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_342_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x658, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_342_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_342_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x658);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_342 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_343: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_343_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_343_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x65c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_343_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_343_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x65c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_343_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_343_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x65c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_343_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_343_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x65c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_343_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_343_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x65c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_343 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_344: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_344_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_344_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x660));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_344_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_344_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x660));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_344_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_344_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x660, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_344_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_344_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x660, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_344_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_344_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x660);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_344 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_345: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_345_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_345_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x664));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_345_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_345_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x664));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_345_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_345_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x664, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_345_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_345_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x664, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_345_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_345_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x664);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_345 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_346: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_346_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_346_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x668));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_346_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_346_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x668));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_346_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_346_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x668, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_346_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_346_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x668, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_346_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_346_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x668);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_346 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_347: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_347_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_347_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x66c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_347_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_347_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x66c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_347_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_347_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x66c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_347_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_347_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x66c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_347_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_347_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x66c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_347 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_348: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_348_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_348_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x670));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_348_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_348_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x670));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_348_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_348_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x670, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_348_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_348_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x670, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_348_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_348_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x670);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_348 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_349: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_349_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_349_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x674));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_349_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_349_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x674));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_349_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_349_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x674, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_349_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_349_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x674, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_349_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_349_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x674);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_349 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_350: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_350_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_350_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x678));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_350_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_350_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x678));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_350_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_350_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x678, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_350_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_350_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x678, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_350_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_350_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x678);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_350 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_351: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_351_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_351_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x67c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_351_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_351_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x67c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_351_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_351_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x67c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_351_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_351_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x67c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_351_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_351_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x67c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_351 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_352: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_352_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_352_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x680));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_352_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_352_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x680));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_352_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_352_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x680, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_352_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_352_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x680, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_352_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_352_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x680);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_352 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_353: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_353_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_353_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x684));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_353_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_353_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x684));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_353_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_353_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x684, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_353_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_353_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x684, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_353_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_353_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x684);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_353 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_354: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_354_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_354_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x688));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_354_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_354_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x688));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_354_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_354_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x688, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_354_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_354_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x688, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_354_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_354_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x688);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_354 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_355: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_355_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_355_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_355_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_355_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_355_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_355_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x68c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_355_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_355_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x68c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_355_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_355_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x68c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_355 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_356: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_356_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_356_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x690));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_356_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_356_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x690));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_356_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_356_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x690, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_356_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_356_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x690, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_356_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_356_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x690);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_356 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_357: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_357_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_357_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x694));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_357_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_357_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x694));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_357_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_357_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x694, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_357_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_357_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x694, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_357_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_357_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x694);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_357 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_358: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_358_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_358_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x698));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_358_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_358_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x698));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_358_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_358_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x698, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_358_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_358_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x698, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_358_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_358_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x698);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_358 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_359: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_359_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_359_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x69c));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_359_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_359_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x69c));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_359_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_359_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x69c, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_359_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_359_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x69c, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_359_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_359_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x69c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_359 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_360: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_360_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_360_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6a0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_360_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_360_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6a0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_360_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_360_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6a0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_360_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_360_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6a0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_360_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_360_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_360 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_361: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_361_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_361_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6a4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_361_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_361_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6a4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_361_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_361_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6a4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_361_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_361_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6a4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_361_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_361_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_361 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_362: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_362_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_362_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6a8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_362_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_362_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6a8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_362_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_362_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6a8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_362_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_362_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6a8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_362_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_362_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_362 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_363: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_363_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_363_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6ac));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_363_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_363_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6ac));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_363_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_363_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6ac, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_363_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_363_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6ac, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_363_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_363_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_363 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_364: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_364_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_364_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6b0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_364_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_364_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6b0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_364_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_364_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6b0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_364_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_364_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6b0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_364_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_364_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_364 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_365: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_365_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_365_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6b4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_365_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_365_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6b4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_365_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_365_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6b4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_365_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_365_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6b4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_365_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_365_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_365 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_366: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_366_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_366_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6b8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_366_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_366_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6b8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_366_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_366_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6b8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_366_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_366_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6b8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_366_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_366_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_366 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_367: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_367_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_367_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6bc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_367_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_367_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6bc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_367_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_367_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6bc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_367_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_367_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6bc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_367_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_367_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_367 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_368: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_368_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_368_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_368_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_368_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_368_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_368_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6c0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_368_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_368_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6c0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_368_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_368_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_368 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_369: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_369_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_369_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_369_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_369_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_369_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_369_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6c4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_369_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_369_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6c4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_369_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_369_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_369 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_370: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_370_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_370_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_370_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_370_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_370_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_370_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6c8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_370_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_370_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6c8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_370_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_370_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_370 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_371: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_371_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_371_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6cc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_371_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_371_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6cc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_371_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_371_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6cc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_371_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_371_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6cc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_371_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_371_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_371 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_372: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_372_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_372_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6d0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_372_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_372_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6d0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_372_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_372_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6d0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_372_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_372_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6d0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_372_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_372_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_372 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_373: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_373_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_373_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6d4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_373_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_373_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6d4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_373_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_373_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6d4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_373_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_373_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6d4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_373_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_373_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_373 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_374: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_374_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_374_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6d8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_374_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_374_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6d8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_374_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_374_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6d8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_374_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_374_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6d8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_374_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_374_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_374 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_375: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_375_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_375_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6dc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_375_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_375_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6dc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_375_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_375_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6dc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_375_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_375_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6dc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_375_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_375_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_375 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_376: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_376_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_376_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6e0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_376_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_376_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6e0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_376_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_376_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6e0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_376_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_376_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6e0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_376_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_376_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_376 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_377: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_377_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_377_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6e4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_377_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_377_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6e4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_377_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_377_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6e4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_377_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_377_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6e4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_377_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_377_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_377 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_378: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_378_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_378_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6e8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_378_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_378_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6e8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_378_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_378_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6e8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_378_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_378_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6e8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_378_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_378_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_378 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_379: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_379_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_379_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6ec));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_379_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_379_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6ec));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_379_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_379_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6ec, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_379_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_379_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6ec, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_379_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_379_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_379 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_380: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_380_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_380_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6f0));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_380_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_380_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6f0));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_380_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_380_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6f0, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_380_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_380_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6f0, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_380_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_380_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_380 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_381: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_381_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_381_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6f4));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_381_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_381_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6f4));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_381_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_381_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6f4, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_381_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_381_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6f4, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_381_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_381_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_381 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_382: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_382_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_382_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6f8));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_382_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_382_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6f8));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_382_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_382_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6f8, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_382_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_382_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6f8, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_382_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_382_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_382 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register uhh_sar_cntx_i_383: Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_hsusbhost.uint32 (primitive type)
 */
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_383_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_383_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6fc));
}

static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_383_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_hsusbhost_uhh_sar_cntx_i_383_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6fc));
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_383_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_383_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6fc, _regval);
}

static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_383_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_hsusbhost_uhh_sar_cntx_i_383_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6fc, _regval);
}

static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_383_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_uhh_sar_cntx_i_383_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uhh_sar_cntx_i_383 (Save and restore context array. Array size is indicated in. When in SAR mode, read out to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int omap44xx_hsusbhost_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_hsusbhost_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_hsusbhost ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_revision_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_hwinfo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sysconfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sysstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_hostconfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_debug_csr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_6_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_7_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_8_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_9_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_10_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_11_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_12_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_13_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_14_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_15_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_16_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_17_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_18_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_19_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_20_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_21_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_22_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_23_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_24_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_25_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_26_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_27_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_28_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_29_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_30_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_31_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_32_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_33_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_34_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_35_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_36_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_37_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_38_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_39_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_40_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_41_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_42_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_43_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_44_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_45_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_46_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_47_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_48_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_49_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_50_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_51_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_52_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_53_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_54_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_55_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_56_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_57_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_58_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_59_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_60_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_61_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_62_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_63_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_64_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_65_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_66_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_67_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_68_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_69_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_70_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_71_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_72_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_73_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_74_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_75_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_76_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_77_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_78_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_79_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_80_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_81_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_82_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_83_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_84_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_85_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_86_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_87_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_88_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_89_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_90_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_91_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_92_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_93_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_94_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_95_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_96_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_97_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_98_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_99_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_100_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_101_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_102_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_103_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_104_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_105_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_106_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_107_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_108_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_109_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_110_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_111_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_112_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_113_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_114_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_115_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_116_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_117_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_118_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_119_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_120_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_121_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_122_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_123_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_124_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_125_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_126_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_127_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_128_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_129_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_130_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_131_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_132_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_133_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_134_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_135_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_136_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_137_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_138_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_139_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_140_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_141_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_142_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_143_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_144_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_145_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_146_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_147_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_148_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_149_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_150_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_151_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_152_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_153_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_154_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_155_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_156_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_157_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_158_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_159_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_160_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_161_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_162_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_163_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_164_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_165_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_166_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_167_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_168_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_169_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_170_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_171_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_172_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_173_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_174_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_175_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_176_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_177_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_178_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_179_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_180_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_181_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_182_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_183_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_184_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_185_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_186_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_187_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_188_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_189_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_190_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_191_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_192_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_193_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_194_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_195_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_196_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_197_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_198_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_199_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_200_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_201_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_202_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_203_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_204_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_205_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_206_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_207_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_208_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_209_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_210_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_211_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_212_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_213_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_214_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_215_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_216_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_217_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_218_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_219_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_220_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_221_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_222_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_223_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_224_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_225_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_226_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_227_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_228_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_229_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_230_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_231_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_232_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_233_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_234_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_235_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_236_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_237_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_238_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_239_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_240_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_241_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_242_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_243_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_244_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_245_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_246_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_247_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_248_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_249_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_250_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_251_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_252_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_253_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_254_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_255_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_256_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_257_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_258_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_259_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_260_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_261_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_262_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_263_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_264_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_265_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_266_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_267_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_268_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_269_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_270_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_271_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_272_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_273_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_274_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_275_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_276_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_277_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_278_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_279_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_280_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_281_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_282_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_283_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_284_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_285_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_286_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_287_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_288_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_289_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_290_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_291_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_292_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_293_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_294_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_295_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_296_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_297_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_298_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_299_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_300_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_301_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_302_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_303_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_304_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_305_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_306_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_307_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_308_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_309_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_310_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_311_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_312_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_313_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_314_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_315_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_316_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_317_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_318_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_319_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_320_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_321_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_322_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_323_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_324_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_325_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_326_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_327_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_328_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_329_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_330_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_331_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_332_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_333_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_334_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_335_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_336_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_337_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_338_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_339_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_340_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_341_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_342_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_343_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_344_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_345_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_346_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_347_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_348_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_349_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_350_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_351_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_352_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_353_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_354_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_355_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_356_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_357_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_358_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_359_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_360_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_361_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_362_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_363_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_364_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_365_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_366_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_367_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_368_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_369_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_370_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_371_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_372_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_373_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_374_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_375_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_376_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_377_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_378_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_379_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_380_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_381_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_382_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_hsusbhost_uhh_sar_cntx_i_383_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_hsusbhost\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_hsusbhost_DEV_H
