#ifndef __omap44xx_id_DEV_H
#define __omap44xx_id_DEV_H 1
/*
 * DEVICE DEFINITION: OMAP44xx device identification
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_id ## _ ## x
/*
 * Constants defn: omap44xx_id.hkvals (Hawkeye field)
 *  - no width specified
 */
typedef uint16_t omap44xx_id_hkvals_t;
#define omap44xx_id_omap4430_1 ((omap44xx_id_hkvals_t)0xb852)
#define omap44xx_id_omap4430_2 ((omap44xx_id_hkvals_t)0xb95c)
#define omap44xx_id_omap4460 ((omap44xx_id_hkvals_t)0xb94e)

static inline char *omap44xx_id_hkvals_describe(omap44xx_id_hkvals_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_id_hkvals_describe(omap44xx_id_hkvals_t _e)
{
    switch (_e) {
    case omap44xx_id_omap4430_1:
        return("omap4430_1: OMAP4430 ES1.0 and ES2.0");
    case omap44xx_id_omap4430_2:
        return("omap4430_2: OMAP4430 ES2.1 and ES2.2");
    case omap44xx_id_omap4460:
        return("omap4460: OMAP4460 ES1.0 and ES1.1");
    default:
        return(NULL);
    }
}

static inline int omap44xx_id_hkvals_prtval(char *_s, size_t _size, omap44xx_id_hkvals_t _e) __attribute__ ((always_inline));
static inline int omap44xx_id_hkvals_prtval(char *_s, size_t _size, omap44xx_id_hkvals_t _e)
{
    char *d = omap44xx_id_hkvals_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_id_hkvals_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_id.mfcvals (Manufacturer code field)
 *  - no width specified
 */
typedef uint8_t omap44xx_id_mfcvals_t;
#define omap44xx_id_mfc_ti ((omap44xx_id_mfcvals_t)0x17)

static inline char *omap44xx_id_mfcvals_describe(omap44xx_id_mfcvals_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_id_mfcvals_describe(omap44xx_id_mfcvals_t _e)
{
    switch (_e) {
    case omap44xx_id_mfc_ti:
        return("mfc_ti: Texas Instruments");
    default:
        return(NULL);
    }
}

static inline int omap44xx_id_mfcvals_prtval(char *_s, size_t _size, omap44xx_id_mfcvals_t _e) __attribute__ ((always_inline));
static inline int omap44xx_id_mfcvals_prtval(char *_s, size_t _size, omap44xx_id_mfcvals_t _e)
{
    char *d = omap44xx_id_mfcvals_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_id_mfcvals_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_id.codevals (Silicon type)
 *  - width 32 bits
 */
typedef uint32_t omap44xx_id_codevals_t;
#define omap44xx_id_c3010 ((omap44xx_id_codevals_t)0xb85202f)
#define omap44xx_id_c3020 ((omap44xx_id_codevals_t)0x1b85202f)
#define omap44xx_id_c3021 ((omap44xx_id_codevals_t)0x3b95c02f)
#define omap44xx_id_c3022 ((omap44xx_id_codevals_t)0x4b95c02f)
#define omap44xx_id_c6010 ((omap44xx_id_codevals_t)0xb94e02f)
#define omap44xx_id_c6011 ((omap44xx_id_codevals_t)0x2b94e02f)

static inline char *omap44xx_id_codevals_describe(omap44xx_id_codevals_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_id_codevals_describe(omap44xx_id_codevals_t _e)
{
    switch (_e) {
    case omap44xx_id_c3010:
        return("c3010: TI OMAP4430 ES1.0");
    case omap44xx_id_c3020:
        return("c3020: TI OMAP4430 ES2.0");
    case omap44xx_id_c3021:
        return("c3021: TI OMAP4430 ES2.1");
    case omap44xx_id_c3022:
        return("c3022: TI OMAP4430 ES2.2");
    case omap44xx_id_c6010:
        return("c6010: TI OMAP4460 ES1.0");
    case omap44xx_id_c6011:
        return("c6011: TI OMAP4460 ES1.1");
    default:
        return(NULL);
    }
}

static inline int omap44xx_id_codevals_prtval(char *_s, size_t _size, omap44xx_id_codevals_t _e) __attribute__ ((always_inline));
static inline int omap44xx_id_codevals_prtval(char *_s, size_t _size, omap44xx_id_codevals_t _e)
{
    char *d = omap44xx_id_codevals_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_id_codevals_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_id.stp (Silicon type)
 *  - no width specified
 */
typedef uint8_t omap44xx_id_stp_t;
#define omap44xx_id_st0 ((omap44xx_id_stp_t)0x0)
#define omap44xx_id_st1 ((omap44xx_id_stp_t)0x1)
#define omap44xx_id_st2 ((omap44xx_id_stp_t)0x2)

static inline char *omap44xx_id_stp_describe(omap44xx_id_stp_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_id_stp_describe(omap44xx_id_stp_t _e)
{
    switch (_e) {
    case omap44xx_id_st0:
        return("st0: Default silicon type");
    case omap44xx_id_st1:
        return("st1: Standard performance (1.2 GHz)");
    case omap44xx_id_st2:
        return("st2: High performance (1.5 GHz)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_id_stp_prtval(char *_s, size_t _size, omap44xx_id_stp_t _e) __attribute__ ((always_inline));
static inline int omap44xx_id_stp_prtval(char *_s, size_t _size, omap44xx_id_stp_t _e)
{
    char *d = omap44xx_id_stp_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_id_stp_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_id_code_t
 * Description: Implicit type of ID code register
 * Fields:
 *   _anon0	(size 1, offset 0, init 1):	MB1	_
 *   mnfctr	(size 11, offset 1, init 0):	RO	Manufacturer ID
 *   hawkeye	(size 16, offset 12, init 0):	RO	Hawkeye
 *   version	(size 4, offset 28, init 0):	RO	Version
 */
typedef uint32_t omap44xx_id_code_t;
#define omap44xx_id_code_default 0x1
static inline omap44xx_id_mfcvals_t omap44xx_id_code_mnfctr_extract(omap44xx_id_code_t _regval) __attribute__ ((always_inline));
static inline omap44xx_id_mfcvals_t omap44xx_id_code_mnfctr_extract(omap44xx_id_code_t _regval)
{
    return((omap44xx_id_mfcvals_t )((_regval & 0xffe) >> 1));
}

static inline omap44xx_id_code_t omap44xx_id_code_mnfctr_insert(omap44xx_id_code_t _regval, omap44xx_id_mfcvals_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_id_code_t omap44xx_id_code_mnfctr_insert(omap44xx_id_code_t _regval, omap44xx_id_mfcvals_t _fieldval)
{
    return((_regval & 0xfffff001) | (0xffe & (((omap44xx_id_code_t )(_fieldval)) << 1)));
}

static inline omap44xx_id_hkvals_t omap44xx_id_code_hawkeye_extract(omap44xx_id_code_t _regval) __attribute__ ((always_inline));
static inline omap44xx_id_hkvals_t omap44xx_id_code_hawkeye_extract(omap44xx_id_code_t _regval)
{
    return((omap44xx_id_hkvals_t )((_regval & 0xffff000) >> 12));
}

static inline omap44xx_id_code_t omap44xx_id_code_hawkeye_insert(omap44xx_id_code_t _regval, omap44xx_id_hkvals_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_id_code_t omap44xx_id_code_hawkeye_insert(omap44xx_id_code_t _regval, omap44xx_id_hkvals_t _fieldval)
{
    return((_regval & 0xf0000fff) | (0xffff000 & (((omap44xx_id_code_t )(_fieldval)) << 12)));
}

static inline uint8_t omap44xx_id_code_version_extract(omap44xx_id_code_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_id_code_version_extract(omap44xx_id_code_t _regval)
{
    return((uint8_t )((_regval & 0xf0000000) >> 28));
}

static inline omap44xx_id_code_t omap44xx_id_code_version_insert(omap44xx_id_code_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_id_code_t omap44xx_id_code_version_insert(omap44xx_id_code_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff) | (0xf0000000 & (((omap44xx_id_code_t )(_fieldval)) << 28)));
}

static inline int omap44xx_id_code_prtval(char *_s, size_t _size, omap44xx_id_code_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_id_code_prtval(char *_s, size_t _size, omap44xx_id_code_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mnfctr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_mfcvals_prtval(_s + _r, _avail, omap44xx_id_code_mnfctr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Manufacturer ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hawkeye =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_hkvals_prtval(_s + _r, _avail, omap44xx_id_code_hawkeye_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Hawkeye)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " version =\t%" PRIx8 "\t(Version)\n", omap44xx_id_code_version_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_id_prod0_t
 * Description: Implicit type of STD FUSE PROD ID 0 register
 * Fields:
 *   dt	(size 8, offset 0, init 0):	RO	Device type
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_id_prod0_t;
#define omap44xx_id_prod0_default 0x0
static inline uint8_t omap44xx_id_prod0_dt_extract(omap44xx_id_prod0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_id_prod0_dt_extract(omap44xx_id_prod0_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_id_prod0_t omap44xx_id_prod0_dt_insert(omap44xx_id_prod0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_id_prod0_t omap44xx_id_prod0_dt_insert(omap44xx_id_prod0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_id_prod0_t )(_fieldval)) << 0)));
}

static inline int omap44xx_id_prod0_prtval(char *_s, size_t _size, omap44xx_id_prod0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_id_prod0_prtval(char *_s, size_t _size, omap44xx_id_prod0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dt =\t%" PRIx8 "\t(Device type)\n", omap44xx_id_prod0_dt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_id_prod1_t
 * Description: Implicit type of STD FUSE PROD ID 0 register
 * Fields:
 *   _anon0	(size 16, offset 0, init 0):	MBZ	_
 *   st	(size 2, offset 16, init 0):	RO	Silicon type
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_id_prod1_t;
#define omap44xx_id_prod1_default 0x0
static inline omap44xx_id_stp_t omap44xx_id_prod1_st_extract(omap44xx_id_prod1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_id_stp_t omap44xx_id_prod1_st_extract(omap44xx_id_prod1_t _regval)
{
    return((omap44xx_id_stp_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_id_prod1_t omap44xx_id_prod1_st_insert(omap44xx_id_prod1_t _regval, omap44xx_id_stp_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_id_prod1_t omap44xx_id_prod1_st_insert(omap44xx_id_prod1_t _regval, omap44xx_id_stp_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_id_prod1_t )(_fieldval)) << 16)));
}

static inline int omap44xx_id_prod1_prtval(char *_s, size_t _size, omap44xx_id_prod1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_id_prod1_prtval(char *_s, size_t _size, omap44xx_id_prod1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_stp_prtval(_s + _r, _avail, omap44xx_id_prod1_st_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Silicon type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_id_initials {
    omap44xx_id_code_initial = 0x0,
    omap44xx_id_id0_initial = 0x0,
    omap44xx_id_id1_initial = 0x0,
    omap44xx_id_id2_initial = 0x0,
    omap44xx_id_id3_initial = 0x0,
    omap44xx_id_prod0_initial = 0x0,
    omap44xx_id_prod1_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_id_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_id_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register code: ID code
 * Type: omap44xx_id.code (Implicit type of ID code register)
 *   _anon0	(size 1, offset 0, init 1):	MB1	_
 *   mnfctr	(size 11, offset 1, init 0):	RO	Manufacturer ID
 *   hawkeye	(size 16, offset 12, init 0):	RO	Hawkeye
 *   version	(size 4, offset 28, init 0):	RO	Version
 */
static inline omap44xx_id_code_t omap44xx_id_code_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_code_t omap44xx_id_code_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x204));
}

static inline omap44xx_id_code_t omap44xx_id_code_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_code_t omap44xx_id_code_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x204));
}

static inline void omap44xx_id_code_rawwr(__DN(t) *_dev, omap44xx_id_code_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_code_rawwr(__DN(t) *_dev, omap44xx_id_code_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x204, _regval);
}

// Register code is not writeable
static inline int omap44xx_id_code_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_code_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_id_code_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register code (ID code): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mnfctr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_mfcvals_prtval(_s + _r, _avail, omap44xx_id_code_mnfctr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Manufacturer ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hawkeye =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_hkvals_prtval(_s + _r, _avail, omap44xx_id_code_hawkeye_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Hawkeye)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " version =\t%" PRIx8 "\t(Version)\n", omap44xx_id_code_version_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_id_mfcvals_t omap44xx_id_code_mnfctr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_mfcvals_t omap44xx_id_code_mnfctr_rdf(__DN(t) *_dev)
{
    omap44xx_id_code_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    return(omap44xx_id_code_mnfctr_extract(_regval));
}

static inline omap44xx_id_hkvals_t omap44xx_id_code_hawkeye_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_hkvals_t omap44xx_id_code_hawkeye_rdf(__DN(t) *_dev)
{
    omap44xx_id_code_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    return(omap44xx_id_code_hawkeye_extract(_regval));
}

static inline uint8_t omap44xx_id_code_version_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_id_code_version_rdf(__DN(t) *_dev)
{
    omap44xx_id_code_t _regval = mackerel_read_addr_32(_dev->base, 0x204);
    return(omap44xx_id_code_version_extract(_regval));
}

/*
 * Register id0: STD FUSE die id 0
 * Type: omap44xx_id.uint32 (primitive type)
 */
static inline uint32_t omap44xx_id_id0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline uint32_t omap44xx_id_id0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline void omap44xx_id_id0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_id0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

// Register id0 is not writeable
static inline int omap44xx_id_id0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_id0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register id0 (STD FUSE die id 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register id1: STD FUSE die id 1
 * Type: omap44xx_id.uint32 (primitive type)
 */
static inline uint32_t omap44xx_id_id1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x208));
}

static inline uint32_t omap44xx_id_id1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x208));
}

static inline void omap44xx_id_id1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_id1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x208, _regval);
}

// Register id1 is not writeable
static inline int omap44xx_id_id1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_id1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x208);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register id1 (STD FUSE die id 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register id2: STD FUSE die id 2
 * Type: omap44xx_id.uint32 (primitive type)
 */
static inline uint32_t omap44xx_id_id2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20c));
}

static inline uint32_t omap44xx_id_id2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20c));
}

static inline void omap44xx_id_id2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_id2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20c, _regval);
}

// Register id2 is not writeable
static inline int omap44xx_id_id2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_id2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x20c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register id2 (STD FUSE die id 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register id3: STD FUSE die id 3
 * Type: omap44xx_id.uint32 (primitive type)
 */
static inline uint32_t omap44xx_id_id3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x210));
}

static inline uint32_t omap44xx_id_id3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_id_id3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x210));
}

static inline void omap44xx_id_id3_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_id3_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x210, _regval);
}

// Register id3 is not writeable
static inline int omap44xx_id_id3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_id3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x210);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register id3 (STD FUSE die id 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prod0: STD FUSE PROD ID 0
 * Type: omap44xx_id.prod0 (Implicit type of STD FUSE PROD ID 0 register)
 *   dt	(size 8, offset 0, init 0):	RO	Device type
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_id_prod0_t omap44xx_id_prod0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_prod0_t omap44xx_id_prod0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x214));
}

static inline omap44xx_id_prod0_t omap44xx_id_prod0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_prod0_t omap44xx_id_prod0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x214));
}

static inline void omap44xx_id_prod0_rawwr(__DN(t) *_dev, omap44xx_id_prod0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_prod0_rawwr(__DN(t) *_dev, omap44xx_id_prod0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x214, _regval);
}

// Register prod0 is not writeable
static inline int omap44xx_id_prod0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_prod0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_id_prod0_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prod0 (STD FUSE PROD ID 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dt =\t%" PRIx8 "\t(Device type)\n", omap44xx_id_prod0_dt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_id_prod0_dt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_id_prod0_dt_rdf(__DN(t) *_dev)
{
    omap44xx_id_prod0_t _regval = mackerel_read_addr_32(_dev->base, 0x214);
    return(omap44xx_id_prod0_dt_extract(_regval));
}

/*
 * Register prod1: STD FUSE PROD ID 0
 * Type: omap44xx_id.prod1 (Implicit type of STD FUSE PROD ID 0 register)
 *   _anon0	(size 16, offset 0, init 0):	MBZ	_
 *   st	(size 2, offset 16, init 0):	RO	Silicon type
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_id_prod1_t omap44xx_id_prod1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_prod1_t omap44xx_id_prod1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x218));
}

static inline omap44xx_id_prod1_t omap44xx_id_prod1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_prod1_t omap44xx_id_prod1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x218));
}

static inline void omap44xx_id_prod1_rawwr(__DN(t) *_dev, omap44xx_id_prod1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_id_prod1_rawwr(__DN(t) *_dev, omap44xx_id_prod1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x218, _regval);
}

// Register prod1 is not writeable
static inline int omap44xx_id_prod1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_prod1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_id_prod1_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prod1 (STD FUSE PROD ID 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_stp_prtval(_s + _r, _avail, omap44xx_id_prod1_st_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Silicon type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_id_stp_t omap44xx_id_prod1_st_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_id_stp_t omap44xx_id_prod1_st_rdf(__DN(t) *_dev)
{
    omap44xx_id_prod1_t _regval = mackerel_read_addr_32(_dev->base, 0x218);
    return(omap44xx_id_prod1_st_extract(_regval));
}

static inline int omap44xx_id_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_id_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_id (OMAP44xx device identification):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_code_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_id0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_id1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_id2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_id3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_prod0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_id_prod1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_id\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_id_DEV_H
