#ifndef __omap44xx_usbtllhs_config_DEV_H
#define __omap44xx_usbtllhs_config_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_usbtllhs_config ## _ ## x
/*
 * Constants defn: omap44xx_usbtllhs_config.clockactivity_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_clockactivity_status_t;
#define omap44xx_usbtllhs_config_CLOCKACTIVITY_0 ((omap44xx_usbtllhs_config_clockactivity_status_t)0x0)
#define omap44xx_usbtllhs_config_CLOCKACTIVITY_1 ((omap44xx_usbtllhs_config_clockactivity_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_clockactivity_status_describe(omap44xx_usbtllhs_config_clockactivity_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_clockactivity_status_describe(omap44xx_usbtllhs_config_clockactivity_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_CLOCKACTIVITY_0:
        return("CLOCKACTIVITY_0: OCP-derived internal clocks OFF during idle");
    case omap44xx_usbtllhs_config_CLOCKACTIVITY_1:
        return("CLOCKACTIVITY_1: OCP-derived internal clocks ON during idle");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_clockactivity_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_clockactivity_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_clockactivity_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_clockactivity_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_clockactivity_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_clockactivity_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.sidlemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_sidlemode_status_t;
#define omap44xx_usbtllhs_config_SIDLEMODE_0 ((omap44xx_usbtllhs_config_sidlemode_status_t)0x0)
#define omap44xx_usbtllhs_config_SIDLEMODE_1 ((omap44xx_usbtllhs_config_sidlemode_status_t)0x1)
#define omap44xx_usbtllhs_config_SIDLEMODE_2 ((omap44xx_usbtllhs_config_sidlemode_status_t)0x2)

static inline char *omap44xx_usbtllhs_config_sidlemode_status_describe(omap44xx_usbtllhs_config_sidlemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_sidlemode_status_describe(omap44xx_usbtllhs_config_sidlemode_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_SIDLEMODE_0:
        return("SIDLEMODE_0: Force-idle mode. Sidleack[1] asserted after Sidlereq assertion");
    case omap44xx_usbtllhs_config_SIDLEMODE_1:
        return("SIDLEMODE_1: No-idle mode. Sidleack[1] never asserted.");
    case omap44xx_usbtllhs_config_SIDLEMODE_2:
        return("SIDLEMODE_2: Smart-idle mode. Sidleack[1] asserted after Sidlereq assertion when no more activity on the OCP.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_sidlemode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_sidlemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_sidlemode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_sidlemode_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_sidlemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_sidlemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.enawakeup_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_enawakeup_status_t;
#define omap44xx_usbtllhs_config_ENAWAKEUP_0 ((omap44xx_usbtllhs_config_enawakeup_status_t)0x0)
#define omap44xx_usbtllhs_config_ENAWAKEUP_1 ((omap44xx_usbtllhs_config_enawakeup_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_enawakeup_status_describe(omap44xx_usbtllhs_config_enawakeup_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_enawakeup_status_describe(omap44xx_usbtllhs_config_enawakeup_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_ENAWAKEUP_0:
        return("ENAWAKEUP_0: Wake-up generation disabled");
    case omap44xx_usbtllhs_config_ENAWAKEUP_1:
        return("ENAWAKEUP_1: Wake-up generation enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_enawakeup_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_enawakeup_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_enawakeup_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_enawakeup_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_enawakeup_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_enawakeup_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.softreset_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_softreset_status_t;
#define omap44xx_usbtllhs_config_SOFTRESET_0_w ((omap44xx_usbtllhs_config_softreset_status_t)0x0)
#define omap44xx_usbtllhs_config_SOFTRESET_1_w ((omap44xx_usbtllhs_config_softreset_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_softreset_status_describe(omap44xx_usbtllhs_config_softreset_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_softreset_status_describe(omap44xx_usbtllhs_config_softreset_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_SOFTRESET_0_w:
        return("SOFTRESET_0_w: No effect");
    case omap44xx_usbtllhs_config_SOFTRESET_1_w:
        return("SOFTRESET_1_w: Starts softreset sequence.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_softreset_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_softreset_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_softreset_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_softreset_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_softreset_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_softreset_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.autoidle_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_autoidle_status_t;
#define omap44xx_usbtllhs_config_AUTOIDLE_0 ((omap44xx_usbtllhs_config_autoidle_status_t)0x0)
#define omap44xx_usbtllhs_config_AUTOIDLE_1 ((omap44xx_usbtllhs_config_autoidle_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_autoidle_status_describe(omap44xx_usbtllhs_config_autoidle_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_autoidle_status_describe(omap44xx_usbtllhs_config_autoidle_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_AUTOIDLE_0:
        return("AUTOIDLE_0: Clock always running");
    case omap44xx_usbtllhs_config_AUTOIDLE_1:
        return("AUTOIDLE_1: When no activity on OCP, clock is cut off.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_autoidle_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_autoidle_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_autoidle_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_autoidle_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_autoidle_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_autoidle_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.resetdone_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_resetdone_status_t;
#define omap44xx_usbtllhs_config_RESETDONE_0_r ((omap44xx_usbtllhs_config_resetdone_status_t)0x0)
#define omap44xx_usbtllhs_config_RESETDONE_1_r ((omap44xx_usbtllhs_config_resetdone_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_resetdone_status_describe(omap44xx_usbtllhs_config_resetdone_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_resetdone_status_describe(omap44xx_usbtllhs_config_resetdone_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_RESETDONE_0_r:
        return("RESETDONE_0_r: Reset is ongoing");
    case omap44xx_usbtllhs_config_RESETDONE_1_r:
        return("RESETDONE_1_r: Reset is done");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_resetdone_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_resetdone_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_resetdone_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_resetdone_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_resetdone_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_resetdone_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.access_error_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_access_error_status_t;
#define omap44xx_usbtllhs_config_ACCESS_ERROR_0 ((omap44xx_usbtllhs_config_access_error_status_t)0x0)
#define omap44xx_usbtllhs_config_ACCESS_ERROR_1 ((omap44xx_usbtllhs_config_access_error_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_access_error_status_describe(omap44xx_usbtllhs_config_access_error_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_access_error_status_describe(omap44xx_usbtllhs_config_access_error_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_ACCESS_ERROR_0:
        return("ACCESS_ERROR_0: No event pending");
    case omap44xx_usbtllhs_config_ACCESS_ERROR_1:
        return("ACCESS_ERROR_1: Event pending");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_access_error_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_access_error_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_access_error_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_access_error_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_access_error_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_access_error_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.access_error_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_access_error_en_status_t;
#define omap44xx_usbtllhs_config_ACCESS_ERROR_EN_0 ((omap44xx_usbtllhs_config_access_error_en_status_t)0x0)
#define omap44xx_usbtllhs_config_ACCESS_ERROR_EN_1 ((omap44xx_usbtllhs_config_access_error_en_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_access_error_en_status_describe(omap44xx_usbtllhs_config_access_error_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_access_error_en_status_describe(omap44xx_usbtllhs_config_access_error_en_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_ACCESS_ERROR_EN_0:
        return("ACCESS_ERROR_EN_0: IRQ event is masked");
    case omap44xx_usbtllhs_config_ACCESS_ERROR_EN_1:
        return("ACCESS_ERROR_EN_1: IRQ event is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_access_error_en_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_access_error_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_access_error_en_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_access_error_en_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_access_error_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_access_error_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.fclk_req_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_fclk_req_status_t;
#define omap44xx_usbtllhs_config_FCLK_REQ_0 ((omap44xx_usbtllhs_config_fclk_req_status_t)0x0)
#define omap44xx_usbtllhs_config_FCLK_REQ_1 ((omap44xx_usbtllhs_config_fclk_req_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_fclk_req_status_describe(omap44xx_usbtllhs_config_fclk_req_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_fclk_req_status_describe(omap44xx_usbtllhs_config_fclk_req_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_FCLK_REQ_0:
        return("FCLK_REQ_0: Func clock input is not requested by TLL");
    case omap44xx_usbtllhs_config_FCLK_REQ_1:
        return("FCLK_REQ_1: Func clock input is requested by TLL");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_fclk_req_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fclk_req_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_fclk_req_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fclk_req_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_fclk_req_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_fclk_req_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.fclk_is_on_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_fclk_is_on_status_t;
#define omap44xx_usbtllhs_config_FCLK_IS_ON_0 ((omap44xx_usbtllhs_config_fclk_is_on_status_t)0x0)
#define omap44xx_usbtllhs_config_FCLK_IS_ON_1 ((omap44xx_usbtllhs_config_fclk_is_on_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_fclk_is_on_status_describe(omap44xx_usbtllhs_config_fclk_is_on_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_fclk_is_on_status_describe(omap44xx_usbtllhs_config_fclk_is_on_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_FCLK_IS_ON_0:
        return("FCLK_IS_ON_0: Functional clock input is not guaranteed ON (can actually be ON, OFF, or unstable)");
    case omap44xx_usbtllhs_config_FCLK_IS_ON_1:
        return("FCLK_IS_ON_1: Functional clock input is guaranteed ON and stable");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_fclk_is_on_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fclk_is_on_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_fclk_is_on_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fclk_is_on_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_fclk_is_on_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_fclk_is_on_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.fslslinestate_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_fslslinestate_status_t;
#define omap44xx_usbtllhs_config_FSLSLINESTATE_0_r ((omap44xx_usbtllhs_config_fslslinestate_status_t)0x0)
#define omap44xx_usbtllhs_config_FSLSLINESTATE_1_r ((omap44xx_usbtllhs_config_fslslinestate_status_t)0x1)
#define omap44xx_usbtllhs_config_FSLSLINESTATE_2_r ((omap44xx_usbtllhs_config_fslslinestate_status_t)0x2)
#define omap44xx_usbtllhs_config_FSLSLINESTATE_3_r ((omap44xx_usbtllhs_config_fslslinestate_status_t)0x3)

static inline char *omap44xx_usbtllhs_config_fslslinestate_status_describe(omap44xx_usbtllhs_config_fslslinestate_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_fslslinestate_status_describe(omap44xx_usbtllhs_config_fslslinestate_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_FSLSLINESTATE_0_r:
        return("FSLSLINESTATE_0_r: Single-ended 0");
    case omap44xx_usbtllhs_config_FSLSLINESTATE_1_r:
        return("FSLSLINESTATE_1_r: Full-Speed J = differential 1");
    case omap44xx_usbtllhs_config_FSLSLINESTATE_2_r:
        return("FSLSLINESTATE_2_r: Full-Speed K = differential 0");
    case omap44xx_usbtllhs_config_FSLSLINESTATE_3_r:
        return("FSLSLINESTATE_3_r: Single-ended 1 (illegal in USB)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_fslslinestate_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fslslinestate_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_fslslinestate_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fslslinestate_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_fslslinestate_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_fslslinestate_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.fslsmode_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_fslsmode_status_t;
#define omap44xx_usbtllhs_config_FSLSMODE_0 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x0)
#define omap44xx_usbtllhs_config_FSLSMODE_1 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x1)
#define omap44xx_usbtllhs_config_FSLSMODE_2 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x2)
#define omap44xx_usbtllhs_config_FSLSMODE_3 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x3)
#define omap44xx_usbtllhs_config_FSLSMODE_4 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x4)
#define omap44xx_usbtllhs_config_FSLSMODE_5 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x5)
#define omap44xx_usbtllhs_config_FSLSMODE_6 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x6)
#define omap44xx_usbtllhs_config_FSLSMODE_7 ((omap44xx_usbtllhs_config_fslsmode_status_t)0x7)
#define omap44xx_usbtllhs_config_FSLSMODE_10 ((omap44xx_usbtllhs_config_fslsmode_status_t)0xa)
#define omap44xx_usbtllhs_config_FSLSMODE_11 ((omap44xx_usbtllhs_config_fslsmode_status_t)0xb)

static inline char *omap44xx_usbtllhs_config_fslsmode_status_describe(omap44xx_usbtllhs_config_fslsmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_fslsmode_status_describe(omap44xx_usbtllhs_config_fslsmode_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_FSLSMODE_0:
        return("FSLSMODE_0: 6-pin unidirectional PHY i/f mode. TX encoding is Dat/Se0 (default).");
    case omap44xx_usbtllhs_config_FSLSMODE_1:
        return("FSLSMODE_1: 6-pin unidirectional PHY i/f mode. TX encoding is Dp/Dm.");
    case omap44xx_usbtllhs_config_FSLSMODE_2:
        return("FSLSMODE_2: 3-pin bidirectional PHY i/f mode");
    case omap44xx_usbtllhs_config_FSLSMODE_3:
        return("FSLSMODE_3: 4-pin bidirectional PHY i/f mode");
    case omap44xx_usbtllhs_config_FSLSMODE_4:
        return("FSLSMODE_4: 6-pin unidirectional TLL mode. TX encoding is Dat/Se0.");
    case omap44xx_usbtllhs_config_FSLSMODE_5:
        return("FSLSMODE_5: 6-pin unidirectional TLL mode. TX encoding is Dp/Dm.");
    case omap44xx_usbtllhs_config_FSLSMODE_6:
        return("FSLSMODE_6: 3-pin bidirectional TLL mode");
    case omap44xx_usbtllhs_config_FSLSMODE_7:
        return("FSLSMODE_7: 4-pin bidirectional TLL mode");
    case omap44xx_usbtllhs_config_FSLSMODE_10:
        return("FSLSMODE_10: 2-pin bidirectional TLL mode. Encoding is Dat/Se0.");
    case omap44xx_usbtllhs_config_FSLSMODE_11:
        return("FSLSMODE_11: 2-pin bidirectional TLL mode. Encoding is Dp/Dm.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_fslsmode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fslsmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_fslsmode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_fslsmode_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_fslsmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_fslsmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.testtxse0_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_testtxse0_status_t;
#define omap44xx_usbtllhs_config_TESTTXSE0_0 ((omap44xx_usbtllhs_config_testtxse0_status_t)0x0)
#define omap44xx_usbtllhs_config_TESTTXSE0_1 ((omap44xx_usbtllhs_config_testtxse0_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_testtxse0_status_describe(omap44xx_usbtllhs_config_testtxse0_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_testtxse0_status_describe(omap44xx_usbtllhs_config_testtxse0_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TESTTXSE0_0:
        return("TESTTXSE0_0: drive differential value on TX according to TestTxDat");
    case omap44xx_usbtllhs_config_TESTTXSE0_1:
        return("TESTTXSE0_1: drive SE0 on TX");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_testtxse0_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testtxse0_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_testtxse0_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testtxse0_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_testtxse0_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_testtxse0_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.testtxdat_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_testtxdat_status_t;
#define omap44xx_usbtllhs_config_TESTTXDAT_0 ((omap44xx_usbtllhs_config_testtxdat_status_t)0x0)
#define omap44xx_usbtllhs_config_TESTTXDAT_1 ((omap44xx_usbtllhs_config_testtxdat_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_testtxdat_status_describe(omap44xx_usbtllhs_config_testtxdat_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_testtxdat_status_describe(omap44xx_usbtllhs_config_testtxdat_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TESTTXDAT_0:
        return("TESTTXDAT_0: Drive full-speed K = differential 0");
    case omap44xx_usbtllhs_config_TESTTXDAT_1:
        return("TESTTXDAT_1: Drive full-speed J = differential 1");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_testtxdat_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testtxdat_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_testtxdat_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testtxdat_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_testtxdat_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_testtxdat_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.testtxen_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_testtxen_status_t;
#define omap44xx_usbtllhs_config_TESTTXEN_0 ((omap44xx_usbtllhs_config_testtxen_status_t)0x0)
#define omap44xx_usbtllhs_config_TESTTXEN_1 ((omap44xx_usbtllhs_config_testtxen_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_testtxen_status_describe(omap44xx_usbtllhs_config_testtxen_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_testtxen_status_describe(omap44xx_usbtllhs_config_testtxen_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TESTTXEN_0:
        return("TESTTXEN_0: Drive Tx according to TestTxDat/Se0");
    case omap44xx_usbtllhs_config_TESTTXEN_1:
        return("TESTTXEN_1: Drive Tx Hiz (no drive: pullups determine line state)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_testtxen_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testtxen_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_testtxen_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testtxen_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_testtxen_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_testtxen_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.testen_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_testen_status_t;
#define omap44xx_usbtllhs_config_TESTEN_0 ((omap44xx_usbtllhs_config_testen_status_t)0x0)
#define omap44xx_usbtllhs_config_TESTEN_1 ((omap44xx_usbtllhs_config_testen_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_testen_status_describe(omap44xx_usbtllhs_config_testen_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_testen_status_describe(omap44xx_usbtllhs_config_testen_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TESTEN_0:
        return("TESTEN_0: No override. Tx is from local link controller");
    case omap44xx_usbtllhs_config_TESTEN_1:
        return("TESTEN_1: Override enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_testen_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testen_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_testen_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_testen_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_testen_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_testen_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.drvvbus_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_drvvbus_status_t;
#define omap44xx_usbtllhs_config_DRVVBUS_0 ((omap44xx_usbtllhs_config_drvvbus_status_t)0x0)
#define omap44xx_usbtllhs_config_DRVVBUS_1 ((omap44xx_usbtllhs_config_drvvbus_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_drvvbus_status_describe(omap44xx_usbtllhs_config_drvvbus_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_drvvbus_status_describe(omap44xx_usbtllhs_config_drvvbus_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_DRVVBUS_0:
        return("DRVVBUS_0: VBUS not driven");
    case omap44xx_usbtllhs_config_DRVVBUS_1:
        return("DRVVBUS_1: VBUS driven to 5 V");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_drvvbus_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_drvvbus_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_drvvbus_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_drvvbus_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_drvvbus_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_drvvbus_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.chrgvbus_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_chrgvbus_status_t;
#define omap44xx_usbtllhs_config_CHRGVBUS_0 ((omap44xx_usbtllhs_config_chrgvbus_status_t)0x0)
#define omap44xx_usbtllhs_config_CHRGVBUS_1 ((omap44xx_usbtllhs_config_chrgvbus_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_chrgvbus_status_describe(omap44xx_usbtllhs_config_chrgvbus_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_chrgvbus_status_describe(omap44xx_usbtllhs_config_chrgvbus_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_CHRGVBUS_0:
        return("CHRGVBUS_0: VBUS not charged, session not valid");
    case omap44xx_usbtllhs_config_CHRGVBUS_1:
        return("CHRGVBUS_1: VBUS charged, session valid");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_chrgvbus_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_chrgvbus_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_chrgvbus_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_chrgvbus_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_chrgvbus_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_chrgvbus_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.ulpinobitstuff_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_ulpinobitstuff_status_t;
#define omap44xx_usbtllhs_config_ULPINOBITSTUFF_0 ((omap44xx_usbtllhs_config_ulpinobitstuff_status_t)0x0)
#define omap44xx_usbtllhs_config_ULPINOBITSTUFF_1 ((omap44xx_usbtllhs_config_ulpinobitstuff_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_ulpinobitstuff_status_describe(omap44xx_usbtllhs_config_ulpinobitstuff_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_ulpinobitstuff_status_describe(omap44xx_usbtllhs_config_ulpinobitstuff_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_ULPINOBITSTUFF_0:
        return("ULPINOBITSTUFF_0: Bitstuff enabled, following USB standard");
    case omap44xx_usbtllhs_config_ULPINOBITSTUFF_1:
        return("ULPINOBITSTUFF_1: No bitstuff or associated delays (nonstandard)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_ulpinobitstuff_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_ulpinobitstuff_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_ulpinobitstuff_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_ulpinobitstuff_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.ulpiautoidle_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_ulpiautoidle_status_t;
#define omap44xx_usbtllhs_config_ULPIAUTOIDLE_0 ((omap44xx_usbtllhs_config_ulpiautoidle_status_t)0x0)
#define omap44xx_usbtllhs_config_ULPIAUTOIDLE_1 ((omap44xx_usbtllhs_config_ulpiautoidle_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_ulpiautoidle_status_describe(omap44xx_usbtllhs_config_ulpiautoidle_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_ulpiautoidle_status_describe(omap44xx_usbtllhs_config_ulpiautoidle_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_ULPIAUTOIDLE_0:
        return("ULPIAUTOIDLE_0: ULPI output clock always-on");
    case omap44xx_usbtllhs_config_ULPIAUTOIDLE_1:
        return("ULPIAUTOIDLE_1: ULPI output clock stops during asynchronous ULPI modes");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_ulpiautoidle_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_ulpiautoidle_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_ulpiautoidle_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_ulpiautoidle_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_ulpiautoidle_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_ulpiautoidle_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.utmiautoidle_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_utmiautoidle_status_t;
#define omap44xx_usbtllhs_config_UTMIAUTOIDLE_0 ((omap44xx_usbtllhs_config_utmiautoidle_status_t)0x0)
#define omap44xx_usbtllhs_config_UTMIAUTOIDLE_1 ((omap44xx_usbtllhs_config_utmiautoidle_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_utmiautoidle_status_describe(omap44xx_usbtllhs_config_utmiautoidle_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_utmiautoidle_status_describe(omap44xx_usbtllhs_config_utmiautoidle_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_UTMIAUTOIDLE_0:
        return("UTMIAUTOIDLE_0: UTMI clock output always on");
    case omap44xx_usbtllhs_config_UTMIAUTOIDLE_1:
        return("UTMIAUTOIDLE_1: UTMI clock output gated upon suspend");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_utmiautoidle_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_utmiautoidle_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_utmiautoidle_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_utmiautoidle_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_utmiautoidle_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_utmiautoidle_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.ulpioutclkmode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_ulpioutclkmode_status_t;
#define omap44xx_usbtllhs_config_ULPIOUTCLKMODE_1_r ((omap44xx_usbtllhs_config_ulpioutclkmode_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_ulpioutclkmode_status_describe(omap44xx_usbtllhs_config_ulpioutclkmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_ulpioutclkmode_status_describe(omap44xx_usbtllhs_config_ulpioutclkmode_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_ULPIOUTCLKMODE_1_r:
        return("ULPIOUTCLKMODE_1_r: ULPI clock provided by PHY side (i.e. TLL, from functional clock). ULPI clock is output");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_ulpioutclkmode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_ulpioutclkmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_ulpioutclkmode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_ulpioutclkmode_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_ulpioutclkmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_ulpioutclkmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.tllfullspeed_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_tllfullspeed_status_t;
#define omap44xx_usbtllhs_config_TLLFULLSPEED_0 ((omap44xx_usbtllhs_config_tllfullspeed_status_t)0x0)
#define omap44xx_usbtllhs_config_TLLFULLSPEED_1 ((omap44xx_usbtllhs_config_tllfullspeed_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_tllfullspeed_status_describe(omap44xx_usbtllhs_config_tllfullspeed_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_tllfullspeed_status_describe(omap44xx_usbtllhs_config_tllfullspeed_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TLLFULLSPEED_0:
        return("TLLFULLSPEED_0: Connect is Low-speed: D- pullup");
    case omap44xx_usbtllhs_config_TLLFULLSPEED_1:
        return("TLLFULLSPEED_1: Connect is Full-Speed: D+ pullup");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_tllfullspeed_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tllfullspeed_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tllfullspeed_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tllfullspeed_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_tllfullspeed_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_tllfullspeed_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.tllconnect_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_tllconnect_status_t;
#define omap44xx_usbtllhs_config_TLLCONNECT_0 ((omap44xx_usbtllhs_config_tllconnect_status_t)0x0)
#define omap44xx_usbtllhs_config_TLLCONNECT_1 ((omap44xx_usbtllhs_config_tllconnect_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_tllconnect_status_describe(omap44xx_usbtllhs_config_tllconnect_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_tllconnect_status_describe(omap44xx_usbtllhs_config_tllconnect_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TLLCONNECT_0:
        return("TLLCONNECT_0: Unconnected");
    case omap44xx_usbtllhs_config_TLLCONNECT_1:
        return("TLLCONNECT_1: Connected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_tllconnect_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tllconnect_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tllconnect_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tllconnect_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_tllconnect_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_tllconnect_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.tllattach_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_tllattach_status_t;
#define omap44xx_usbtllhs_config_TLLATTACH_0 ((omap44xx_usbtllhs_config_tllattach_status_t)0x0)
#define omap44xx_usbtllhs_config_TLLATTACH_1 ((omap44xx_usbtllhs_config_tllattach_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_tllattach_status_describe(omap44xx_usbtllhs_config_tllattach_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_tllattach_status_describe(omap44xx_usbtllhs_config_tllattach_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_TLLATTACH_0:
        return("TLLATTACH_0: Cable detach emulated on serial TLL");
    case omap44xx_usbtllhs_config_TLLATTACH_1:
        return("TLLATTACH_1: Cable attach emulated on serial TLL");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_tllattach_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tllattach_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tllattach_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tllattach_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_tllattach_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_tllattach_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.utmiisadev_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_utmiisadev_status_t;
#define omap44xx_usbtllhs_config_UTMIISADEV_0 ((omap44xx_usbtllhs_config_utmiisadev_status_t)0x0)
#define omap44xx_usbtllhs_config_UTMIISADEV_1 ((omap44xx_usbtllhs_config_utmiisadev_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_utmiisadev_status_describe(omap44xx_usbtllhs_config_utmiisadev_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_utmiisadev_status_describe(omap44xx_usbtllhs_config_utmiisadev_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_UTMIISADEV_0:
        return("UTMIISADEV_0: UTMI side is peripheral, ULPI side is host");
    case omap44xx_usbtllhs_config_UTMIISADEV_1:
        return("UTMIISADEV_1: UTMI side is host, ULPI side is peripheral");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_utmiisadev_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_utmiisadev_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_utmiisadev_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_utmiisadev_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_utmiisadev_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_utmiisadev_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.chanmode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_chanmode_status_t;
#define omap44xx_usbtllhs_config_CHANMODE_0 ((omap44xx_usbtllhs_config_chanmode_status_t)0x0)
#define omap44xx_usbtllhs_config_CHANMODE_1 ((omap44xx_usbtllhs_config_chanmode_status_t)0x1)
#define omap44xx_usbtllhs_config_CHANMODE_2 ((omap44xx_usbtllhs_config_chanmode_status_t)0x2)
#define omap44xx_usbtllhs_config_CHANMODE_3 ((omap44xx_usbtllhs_config_chanmode_status_t)0x3)

static inline char *omap44xx_usbtllhs_config_chanmode_status_describe(omap44xx_usbtllhs_config_chanmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_chanmode_status_describe(omap44xx_usbtllhs_config_chanmode_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_CHANMODE_0:
        return("CHANMODE_0: UTMI-to-ULPI TLL mode (HS capable): to ULPI controller");
    case omap44xx_usbtllhs_config_CHANMODE_1:
        return("CHANMODE_1: UTMI-to-serial (FS/LS) mode: to serial controller (TLL) or serial PHY");
    case omap44xx_usbtllhs_config_CHANMODE_2:
        return("CHANMODE_2: Transparent UTMI mode: to UTMI PHY");
    case omap44xx_usbtllhs_config_CHANMODE_3:
        return("CHANMODE_3: No mode selected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_chanmode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_chanmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_chanmode_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_chanmode_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_chanmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_chanmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_usbtllhs_config.chanen_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_usbtllhs_config_chanen_status_t;
#define omap44xx_usbtllhs_config_CHANEN_0 ((omap44xx_usbtllhs_config_chanen_status_t)0x0)
#define omap44xx_usbtllhs_config_CHANEN_1 ((omap44xx_usbtllhs_config_chanen_status_t)0x1)

static inline char *omap44xx_usbtllhs_config_chanen_status_describe(omap44xx_usbtllhs_config_chanen_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_usbtllhs_config_chanen_status_describe(omap44xx_usbtllhs_config_chanen_status_t _e)
{
    switch (_e) {
    case omap44xx_usbtllhs_config_CHANEN_0:
        return("CHANEN_0: Channel i disabled");
    case omap44xx_usbtllhs_config_CHANEN_1:
        return("CHANEN_1: Channel i enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_usbtllhs_config_chanen_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_chanen_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_chanen_status_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_chanen_status_t _e)
{
    char *d = omap44xx_usbtllhs_config_chanen_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_usbtllhs_config_chanen_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_usbtllhs_config_usbtll_hwinfo_t
 * Description: Implicit type of Information on hardware configuration of host register
 * Fields:
 *   sar_cntx_size	(size 8, offset 0, init 0):	RO	Save-and-Restore context size, in 32-bit words, i.e. number of 32-bit registers with significant context information, mapped from offset 0x400 upward.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_usbtll_hwinfo_t;
#define omap44xx_usbtllhs_config_usbtll_hwinfo_default 0x0
static inline uint8_t omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_extract(omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_extract(omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_usbtllhs_config_usbtll_hwinfo_t omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_insert(omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_hwinfo_t omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_insert(omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_usbtllhs_config_usbtll_hwinfo_t )(_fieldval)) << 0)));
}

static inline int omap44xx_usbtllhs_config_usbtll_hwinfo_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_hwinfo_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_cntx_size =\t%" PRIx8 "\t(Save-and-Restore context size, in 32-bit words, i.e. number of 32-bit registers with significant context information, mapped from offset 0x400 upward.)\n", omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_usbtll_sysconfig_t
 * Description: Implicit type of OCP standard system configuration register register
 * Fields:
 *   autoidle	(size 1, offset 0, init 0):	RW	Internal autogating control
 *   softreset	(size 1, offset 1, init 0):	WO	Module software reset
 *   enawakeup	(size 1, offset 2, init 0):	RW	Asynchronous wake-up generation control (Swakeup)
 *   sidlemode	(size 2, offset 3, init 0):	RW	Slave interface power management control. Idle Req/ack control
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   clockactivity	(size 1, offset 8, init 0):	RW	Enable autogating of OCP-derived internal clocks while module is idle.
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_usbtll_sysconfig_t;
#define omap44xx_usbtllhs_config_usbtll_sysconfig_default 0x0
static inline omap44xx_usbtllhs_config_autoidle_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_autoidle_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    return((omap44xx_usbtllhs_config_autoidle_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_autoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_autoidle_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 0)));
}

static inline omap44xx_usbtllhs_config_softreset_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_softreset_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    return((omap44xx_usbtllhs_config_softreset_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_softreset_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 1)));
}

static inline omap44xx_usbtllhs_config_enawakeup_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_enawakeup_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    return((omap44xx_usbtllhs_config_enawakeup_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_enawakeup_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_enawakeup_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 2)));
}

static inline omap44xx_usbtllhs_config_sidlemode_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_sidlemode_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    return((omap44xx_usbtllhs_config_sidlemode_status_t )((_regval & 0x18) >> 3));
}

static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_sidlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_sidlemode_status_t _fieldval)
{
    return((_regval & 0xffffffe7) | (0x18 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 3)));
}

static inline omap44xx_usbtllhs_config_clockactivity_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_clockactivity_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_extract(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    return((omap44xx_usbtllhs_config_clockactivity_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_clockactivity_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_insert(omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval, omap44xx_usbtllhs_config_clockactivity_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 8)));
}

static inline int omap44xx_usbtllhs_config_usbtll_sysconfig_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sysconfig_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_autoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal autogating control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_softreset_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module software reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enawakeup =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_enawakeup_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous wake-up generation control (Swakeup))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sidlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_sidlemode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Slave interface power management control. Idle Req/ack control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clockactivity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_clockactivity_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable autogating of OCP-derived internal clocks while module is idle.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_usbtll_sysstatus_t
 * Description: Implicit type of OCP standard system status register register
 * Fields:
 *   resetdone	(size 1, offset 0, init 0):	RO	Indicates when the module has entirely come out of reset
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_usbtll_sysstatus_t;
#define omap44xx_usbtllhs_config_usbtll_sysstatus_default 0x0
static inline omap44xx_usbtllhs_config_resetdone_status_t omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_extract(omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_resetdone_status_t omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_extract(omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval)
{
    return((omap44xx_usbtllhs_config_resetdone_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_usbtll_sysstatus_t omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_insert(omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval, omap44xx_usbtllhs_config_resetdone_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysstatus_t omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_insert(omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval, omap44xx_usbtllhs_config_resetdone_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_usbtll_sysstatus_t )(_fieldval)) << 0)));
}

static inline int omap44xx_usbtllhs_config_usbtll_sysstatus_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sysstatus_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_resetdone_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates when the module has entirely come out of reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_usbtll_irqstatus_t
 * Description: Implicit type of OCP standard IRQ status vector. Write 1 to clear a bit. register
 * Fields:
 *   fclk_start	(size 1, offset 0, init 0):	RW	Functional clock is requested for USB clocking
 *   fclk_end	(size 1, offset 1, init 0):	RW	Functional clock is no longer requested for USB clocking
 *   access_error	(size 1, offset 2, init 0):	RW	Access error to ULPI register over OCP: USB clock must run for that type of access to succeed.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_usbtll_irqstatus_t;
#define omap44xx_usbtllhs_config_usbtll_irqstatus_default 0x0
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_extract(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_extract(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval)
{
    return((omap44xx_usbtllhs_config_access_error_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_insert(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval, omap44xx_usbtllhs_config_access_error_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_insert(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval, omap44xx_usbtllhs_config_access_error_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_usbtll_irqstatus_t )(_fieldval)) << 0)));
}

static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_extract(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_extract(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval)
{
    return((omap44xx_usbtllhs_config_access_error_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_insert(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval, omap44xx_usbtllhs_config_access_error_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_insert(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval, omap44xx_usbtllhs_config_access_error_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_usbtllhs_config_usbtll_irqstatus_t )(_fieldval)) << 1)));
}

static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_extract(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_extract(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval)
{
    return((omap44xx_usbtllhs_config_access_error_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_insert(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval, omap44xx_usbtllhs_config_access_error_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_insert(omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval, omap44xx_usbtllhs_config_access_error_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_usbtllhs_config_usbtll_irqstatus_t )(_fieldval)) << 2)));
}

static inline int omap44xx_usbtllhs_config_usbtll_irqstatus_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_irqstatus_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_start =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional clock is requested for USB clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_end =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional clock is no longer requested for USB clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " access_error =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Access error to ULPI register over OCP: USB clock must run for that type of access to succeed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_usbtll_irqenable_t
 * Description: Implicit type of OCP standard IRQ enable vector register
 * Fields:
 *   fclk_start_en	(size 1, offset 0, init 0):	RW	IRQ event mask for FCLK_START interrupt (seeUSBTLL_IRQSTATUS[0])
 *   fclk_end_en	(size 1, offset 1, init 0):	RW	IRQ event mask for FCLK_END interrupt (seeUSBTLL_IRQSTATUS[1])
 *   access_error_en	(size 1, offset 2, init 0):	RW	Enable IRQ generation upon access error to ULPI register over L3 interconnect
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_usbtll_irqenable_t;
#define omap44xx_usbtllhs_config_usbtll_irqenable_default 0x0
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_extract(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_extract(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval)
{
    return((omap44xx_usbtllhs_config_access_error_en_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_insert(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_insert(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_usbtll_irqenable_t )(_fieldval)) << 0)));
}

static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_extract(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_extract(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval)
{
    return((omap44xx_usbtllhs_config_access_error_en_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_insert(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_insert(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_usbtllhs_config_usbtll_irqenable_t )(_fieldval)) << 1)));
}

static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_extract(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_extract(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval)
{
    return((omap44xx_usbtllhs_config_access_error_en_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_insert(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_insert(omap44xx_usbtllhs_config_usbtll_irqenable_t _regval, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_usbtllhs_config_usbtll_irqenable_t )(_fieldval)) << 2)));
}

static inline int omap44xx_usbtllhs_config_usbtll_irqenable_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_irqenable_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_irqenable_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_usbtll_irqenable_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_start_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_en_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IRQ event mask for FCLK_START interrupt (seeUSBTLL_IRQSTATUS[0]))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_end_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_en_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IRQ event mask for FCLK_END interrupt (seeUSBTLL_IRQSTATUS[1]))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " access_error_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_en_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable IRQ generation upon access error to ULPI register over L3 interconnect)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_tll_shared_conf_t
 * Description: Implicit type of Common control register for all TLL channels register
 * Fields:
 *   fclk_is_on	(size 1, offset 0, init 0):	RW	Status of the functional clock input, provided by the system to the TLL module. The TLL module will only use that clock if the current status indicated that it is ready. Combined with the Fclk_request to generate fclk_start/end IRQs.
 *   fclk_req	(size 1, offset 1, init 0):	RO	Functional clock request, ORed from all channels depending on their respective USB bus state. Combined with the Fclk_is_on status to generate fclk_start/end IRQs.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_tll_shared_conf_t;
#define omap44xx_usbtllhs_config_tll_shared_conf_default 0x0
static inline omap44xx_usbtllhs_config_fclk_is_on_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_extract(omap44xx_usbtllhs_config_tll_shared_conf_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fclk_is_on_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_extract(omap44xx_usbtllhs_config_tll_shared_conf_t _regval)
{
    return((omap44xx_usbtllhs_config_fclk_is_on_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_insert(omap44xx_usbtllhs_config_tll_shared_conf_t _regval, omap44xx_usbtllhs_config_fclk_is_on_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_insert(omap44xx_usbtllhs_config_tll_shared_conf_t _regval, omap44xx_usbtllhs_config_fclk_is_on_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_tll_shared_conf_t )(_fieldval)) << 0)));
}

static inline omap44xx_usbtllhs_config_fclk_req_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_extract(omap44xx_usbtllhs_config_tll_shared_conf_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fclk_req_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_extract(omap44xx_usbtllhs_config_tll_shared_conf_t _regval)
{
    return((omap44xx_usbtllhs_config_fclk_req_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_insert(omap44xx_usbtllhs_config_tll_shared_conf_t _regval, omap44xx_usbtllhs_config_fclk_req_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_insert(omap44xx_usbtllhs_config_tll_shared_conf_t _regval, omap44xx_usbtllhs_config_fclk_req_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_usbtllhs_config_tll_shared_conf_t )(_fieldval)) << 1)));
}

static inline int omap44xx_usbtllhs_config_tll_shared_conf_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tll_shared_conf_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tll_shared_conf_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tll_shared_conf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_is_on =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fclk_is_on_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Status of the functional clock input, provided by the system to the TLL module. The TLL module will only use that clock if the current status indicated that it is ready. Combined with the Fclk_request to generate fclk_start/end IRQs.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_req =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fclk_req_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional clock request, ORed from all channels depending on their respective USB bus state. Combined with the Fclk_is_on status to generate fclk_start/end IRQs.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_tll_channel_conf_i_0_t
 * Description: Implicit type of Control and Status register for channel i. register
 * Fields:
 *   chanen	(size 1, offset 0, init 0):	RW	Active-high channel enable. A disabled channel is unclocked and kept under reset.
 *   chanmode	(size 2, offset 1, init 0):	RW	Main channel mode selection
 *   utmiisadev	(size 1, offset 3, init 0):	RW	Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.
 *   tllattach	(size 1, offset 4, init 0):	RW	Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL)
 *   tllconnect	(size 1, offset 5, init 0):	RW	Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.
 *   tllfullspeed	(size 1, offset 6, init 0):	RW	Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.
 *   ulpioutclkmode	(size 1, offset 7, init 0):	RO	ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   utmiautoidle	(size 1, offset 9, init 0):	RW	For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0)
 *   ulpiautoidle	(size 1, offset 10, init 0):	RW	For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.
 *   ulpinobitstuff	(size 1, offset 11, init 0):	RW	Disable bitstuff emulation in ULPI TLL for ULPI ChanMode
 *   _anon12	(size 3, offset 12, init 0):	MBZ	_
 *   chrgvbus	(size 1, offset 15, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller
 *   drvvbus	(size 1, offset 16, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller
 *   testen	(size 1, offset 17, init 0):	RW	Enable manual test override for serial mode TX path (from local controller UTMI port)
 *   testtxen	(size 1, offset 18, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode)
 *   testtxdat	(size 1, offset 19, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0)
 *   testtxse0	(size 1, offset 20, init 0):	RW	Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz)
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fslsmode	(size 4, offset 24, init 0):	RW	Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.
 *   fslslinestate	(size 2, offset 28, init 0):	RO	Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_t;
#define omap44xx_usbtllhs_config_tll_channel_conf_i_0_default 0x0
static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_chanen_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_chanen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_chanen_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 0)));
}

static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_chanmode_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_chanmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_chanmode_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 1)));
}

static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_utmiisadev_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 3)));
}

static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_tllattach_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_tllattach_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_tllattach_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 4)));
}

static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_tllconnect_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 5)));
}

static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_tllfullspeed_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 6)));
}

static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_ulpioutclkmode_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_ulpioutclkmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_ulpioutclkmode_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 7)));
}

static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_utmiautoidle_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 9)));
}

static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_ulpiautoidle_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 10)));
}

static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_ulpinobitstuff_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 11)));
}

static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_chrgvbus_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 15)));
}

static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_drvvbus_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 16)));
}

static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_testen_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testen_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 17)));
}

static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_testtxen_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testtxen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testtxen_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 18)));
}

static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_testtxdat_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 19)));
}

static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_testtxse0_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 20)));
}

static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_fslsmode_status_t )((_regval & 0xf000000) >> 24));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 24)));
}

static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    return((omap44xx_usbtllhs_config_fslslinestate_status_t )((_regval & 0x30000000) >> 28));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_fslslinestate_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval, omap44xx_usbtllhs_config_fslslinestate_status_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 28)));
}

static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_0_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_0_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active-high channel enable. A disabled channel is unclocked and kept under reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Main channel mode selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiisadev =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiisadev_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllattach =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllattach_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllconnect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllconnect_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllfullspeed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllfullspeed_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpioutclkmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpioutclkmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpinobitstuff =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpinobitstuff_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Disable bitstuff emulation in ULPI TLL for ULPI ChanMode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chrgvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chrgvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drvvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_drvvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable manual test override for serial mode TX path (from local controller UTMI port))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxdat =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxdat_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxse0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxse0_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslsmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslsmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslslinestate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslslinestate_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_usbtllhs_config_tll_channel_conf_i_1_t
 * Description: Implicit type of Control and Status register for channel i. register
 * Fields:
 *   chanen	(size 1, offset 0, init 0):	RW	Active-high channel enable. A disabled channel is unclocked and kept under reset.
 *   chanmode	(size 2, offset 1, init 0):	RW	Main channel mode selection
 *   utmiisadev	(size 1, offset 3, init 0):	RW	Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.
 *   tllattach	(size 1, offset 4, init 0):	RW	Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL)
 *   tllconnect	(size 1, offset 5, init 0):	RW	Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.
 *   tllfullspeed	(size 1, offset 6, init 0):	RW	Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.
 *   ulpioutclkmode	(size 1, offset 7, init 0):	RO	ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   utmiautoidle	(size 1, offset 9, init 0):	RW	For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0)
 *   ulpiautoidle	(size 1, offset 10, init 0):	RW	For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.
 *   ulpinobitstuff	(size 1, offset 11, init 0):	RW	Disable bitstuff emulation in ULPI TLL for ULPI ChanMode
 *   _anon12	(size 3, offset 12, init 0):	MBZ	_
 *   chrgvbus	(size 1, offset 15, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller
 *   drvvbus	(size 1, offset 16, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller
 *   testen	(size 1, offset 17, init 0):	RW	Enable manual test override for serial mode TX path (from local controller UTMI port)
 *   testtxen	(size 1, offset 18, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode)
 *   testtxdat	(size 1, offset 19, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0)
 *   testtxse0	(size 1, offset 20, init 0):	RW	Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz)
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fslsmode	(size 4, offset 24, init 0):	RW	Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.
 *   fslslinestate	(size 2, offset 28, init 0):	RO	Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_t;
#define omap44xx_usbtllhs_config_tll_channel_conf_i_1_default 0x0
static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_chanen_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_chanen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_chanen_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 0)));
}

static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_chanmode_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_chanmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_chanmode_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 1)));
}

static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_utmiisadev_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 3)));
}

static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_tllattach_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_tllattach_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_tllattach_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 4)));
}

static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_tllconnect_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 5)));
}

static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_tllfullspeed_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 6)));
}

static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_ulpioutclkmode_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_ulpioutclkmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_ulpioutclkmode_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 7)));
}

static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_utmiautoidle_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 9)));
}

static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_ulpiautoidle_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 10)));
}

static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_ulpinobitstuff_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 11)));
}

static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_chrgvbus_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 15)));
}

static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_drvvbus_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 16)));
}

static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_testen_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testen_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 17)));
}

static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_testtxen_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testtxen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testtxen_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 18)));
}

static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_testtxdat_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 19)));
}

static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_testtxse0_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 20)));
}

static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_fslsmode_status_t )((_regval & 0xf000000) >> 24));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 24)));
}

static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_extract(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    return((omap44xx_usbtllhs_config_fslslinestate_status_t )((_regval & 0x30000000) >> 28));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_fslslinestate_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_insert(omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval, omap44xx_usbtllhs_config_fslslinestate_status_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 28)));
}

static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_1_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_1_prtval(char *_s, size_t _size, omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active-high channel enable. A disabled channel is unclocked and kept under reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Main channel mode selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiisadev =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiisadev_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllattach =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllattach_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllconnect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllconnect_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllfullspeed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllfullspeed_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpioutclkmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpioutclkmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpinobitstuff =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpinobitstuff_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Disable bitstuff emulation in ULPI TLL for ULPI ChanMode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chrgvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chrgvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drvvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_drvvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable manual test override for serial mode TX path (from local controller UTMI port))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxdat =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxdat_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxse0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxse0_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslsmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslsmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslslinestate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslslinestate_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    omap44xx_usbtllhs_config_usbtll_sysconfig_t usbtll_sysconfig_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_usbtllhs_config_initials {
    omap44xx_usbtllhs_config_usbtll_revision_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_hwinfo_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sysconfig_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sysstatus_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_irqstatus_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_irqenable_initial = 0x0,
    omap44xx_usbtllhs_config_tll_shared_conf_initial = 0x0,
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_initial = 0x0,
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_initial = 0x0,
    omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_usbtllhs_config_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register usbtll_revision: OCP standard revision number, BCD encoded
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_revision_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_revision_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_revision_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_revision_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_usbtllhs_config_usbtll_revision_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_revision_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register usbtll_revision is not writeable
static inline int omap44xx_usbtllhs_config_usbtll_revision_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_revision_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_revision (OCP standard revision number, BCD encoded): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_hwinfo: Information on hardware configuration of host
 * Type: omap44xx_usbtllhs_config.usbtll_hwinfo (Implicit type of Information on hardware configuration of host register)
 *   sar_cntx_size	(size 8, offset 0, init 0):	RO	Save-and-Restore context size, in 32-bit words, i.e. number of 32-bit registers with significant context information, mapped from offset 0x400 upward.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_usbtll_hwinfo_t omap44xx_usbtllhs_config_usbtll_hwinfo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_hwinfo_t omap44xx_usbtllhs_config_usbtll_hwinfo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_usbtllhs_config_usbtll_hwinfo_t omap44xx_usbtllhs_config_usbtll_hwinfo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_hwinfo_t omap44xx_usbtllhs_config_usbtll_hwinfo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_usbtllhs_config_usbtll_hwinfo_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_hwinfo_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

// Register usbtll_hwinfo is not writeable
static inline int omap44xx_usbtllhs_config_usbtll_hwinfo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_hwinfo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_hwinfo (Information on hardware configuration of host): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sar_cntx_size =\t%" PRIx8 "\t(Save-and-Restore context size, in 32-bit words, i.e. number of 32-bit registers with significant context information, mapped from offset 0x400 upward.)\n", omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_hwinfo_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_usbtllhs_config_usbtll_hwinfo_sar_cntx_size_extract(_regval));
}

/*
 * Register usbtll_sysconfig: OCP standard system configuration register
 * Type: omap44xx_usbtllhs_config.usbtll_sysconfig (Implicit type of OCP standard system configuration register register)
 *   autoidle	(size 1, offset 0, init 0):	RW	Internal autogating control
 *   softreset	(size 1, offset 1, init 0):	WO	Module software reset
 *   enawakeup	(size 1, offset 2, init 0):	RW	Asynchronous wake-up generation control (Swakeup)
 *   sidlemode	(size 2, offset 3, init 0):	RW	Slave interface power management control. Idle Req/ack control
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   clockactivity	(size 1, offset 8, init 0):	RW	Enable autogating of OCP-derived internal clocks while module is idle.
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysconfig_t omap44xx_usbtllhs_config_usbtll_sysconfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval)
{
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sysconfig (OCP standard system configuration register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_autoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal autogating control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_softreset_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module software reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enawakeup =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_enawakeup_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous wake-up generation control (Swakeup))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sidlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_sidlemode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Slave interface power management control. Idle Req/ack control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clockactivity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_clockactivity_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable autogating of OCP-derived internal clocks while module is idle.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_autoidle_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_autoidle_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_extract(_regval));
}

static inline omap44xx_usbtllhs_config_enawakeup_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_enawakeup_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_extract(_regval));
}

static inline omap44xx_usbtllhs_config_sidlemode_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_sidlemode_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_clockactivity_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_clockactivity_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_extract(_regval));
}

static inline omap44xx_usbtllhs_config_softreset_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_softreset_status_t omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_extract(_dev->usbtll_sysconfig_shadow));
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_autoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_autoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_autoidle_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = 0x1 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 0);
    _regval = (_regval | (0x11c & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbtll_sysconfig_shadow)));
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbtll_sysconfig_shadow = _regval;
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_softreset_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_softreset_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = 0x2 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 1);
    _regval = (_regval | (0x11d & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbtll_sysconfig_shadow = _regval;
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_enawakeup_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_enawakeup_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_enawakeup_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = 0x4 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 2);
    _regval = (_regval | (0x119 & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbtll_sysconfig_shadow)));
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbtll_sysconfig_shadow = _regval;
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_sidlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_sidlemode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_sidlemode_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = 0x18 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 3);
    _regval = (_regval | (0x105 & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbtll_sysconfig_shadow)));
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbtll_sysconfig_shadow = _regval;
}

static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_clockactivity_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysconfig_clockactivity_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_clockactivity_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_sysconfig_t _regval = 0x100 & (((omap44xx_usbtllhs_config_usbtll_sysconfig_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbtll_sysconfig_shadow)));
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbtll_sysconfig_shadow = _regval;
}

/*
 * Register usbtll_sysstatus: OCP standard system status register
 * Type: omap44xx_usbtllhs_config.usbtll_sysstatus (Implicit type of OCP standard system status register register)
 *   resetdone	(size 1, offset 0, init 0):	RO	Indicates when the module has entirely come out of reset
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_usbtll_sysstatus_t omap44xx_usbtllhs_config_usbtll_sysstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysstatus_t omap44xx_usbtllhs_config_usbtll_sysstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_usbtllhs_config_usbtll_sysstatus_t omap44xx_usbtllhs_config_usbtll_sysstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_sysstatus_t omap44xx_usbtllhs_config_usbtll_sysstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_usbtllhs_config_usbtll_sysstatus_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sysstatus_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

// Register usbtll_sysstatus is not writeable
static inline int omap44xx_usbtllhs_config_usbtll_sysstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sysstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sysstatus (OCP standard system status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_resetdone_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates when the module has entirely come out of reset)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_resetdone_status_t omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_resetdone_status_t omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_sysstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_usbtllhs_config_usbtll_sysstatus_resetdone_extract(_regval));
}

/*
 * Register usbtll_irqstatus: OCP standard IRQ status vector. Write 1 to clear a bit.
 * Type: omap44xx_usbtllhs_config.usbtll_irqstatus (Implicit type of OCP standard IRQ status vector. Write 1 to clear a bit. register)
 *   fclk_start	(size 1, offset 0, init 0):	RW	Functional clock is requested for USB clocking
 *   fclk_end	(size 1, offset 1, init 0):	RW	Functional clock is no longer requested for USB clocking
 *   access_error	(size 1, offset 2, init 0):	RW	Access error to ULPI register over OCP: USB clock must run for that type of access to succeed.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqstatus_t omap44xx_usbtllhs_config_usbtll_irqstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_irqstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_irqstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_irqstatus (OCP standard IRQ status vector. Write 1 to clear a bit.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_start =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional clock is requested for USB clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_end =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional clock is no longer requested for USB clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " access_error =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Access error to ULPI register over OCP: USB clock must run for that type of access to succeed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_extract(_regval));
}

static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_extract(_regval));
}

static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_status_t omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_extract(_regval));
}

static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_start_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = 0x1 & (((omap44xx_usbtllhs_config_usbtll_irqstatus_t )(_fieldval)) << 0);
    _regval = (_regval | (0x6 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_fclk_end_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = 0x2 & (((omap44xx_usbtllhs_config_usbtll_irqstatus_t )(_fieldval)) << 1);
    _regval = (_regval | (0x5 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqstatus_access_error_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_irqstatus_t _regval = 0x4 & (((omap44xx_usbtllhs_config_usbtll_irqstatus_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register usbtll_irqenable: OCP standard IRQ enable vector
 * Type: omap44xx_usbtllhs_config.usbtll_irqenable (Implicit type of OCP standard IRQ enable vector register)
 *   fclk_start_en	(size 1, offset 0, init 0):	RW	IRQ event mask for FCLK_START interrupt (seeUSBTLL_IRQSTATUS[0])
 *   fclk_end_en	(size 1, offset 1, init 0):	RW	IRQ event mask for FCLK_END interrupt (seeUSBTLL_IRQSTATUS[1])
 *   access_error_en	(size 1, offset 2, init 0):	RW	Enable IRQ generation upon access error to ULPI register over L3 interconnect
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_usbtll_irqenable_t omap44xx_usbtllhs_config_usbtll_irqenable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void omap44xx_usbtllhs_config_usbtll_irqenable_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqenable_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqenable_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqenable_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_irqenable_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqenable_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqenable_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_usbtll_irqenable_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_irqenable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_irqenable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_irqenable (OCP standard IRQ enable vector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_start_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_en_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IRQ event mask for FCLK_START interrupt (seeUSBTLL_IRQSTATUS[0]))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_end_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_en_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IRQ event mask for FCLK_END interrupt (seeUSBTLL_IRQSTATUS[1]))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " access_error_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_access_error_en_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable IRQ generation upon access error to ULPI register over L3 interconnect)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_extract(_regval));
}

static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_extract(_regval));
}

static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_access_error_en_status_t omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_extract(_regval));
}

static inline void omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqenable_fclk_start_en_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = 0x1 & (((omap44xx_usbtllhs_config_usbtll_irqenable_t )(_fieldval)) << 0);
    _regval = (_regval | (0x6 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqenable_fclk_end_en_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = 0x2 & (((omap44xx_usbtllhs_config_usbtll_irqenable_t )(_fieldval)) << 1);
    _regval = (_regval | (0x5 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_irqenable_access_error_en_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_access_error_en_status_t _fieldval)
{
    omap44xx_usbtllhs_config_usbtll_irqenable_t _regval = 0x4 & (((omap44xx_usbtllhs_config_usbtll_irqenable_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register tll_shared_conf: Common control register for all TLL channels
 * Type: omap44xx_usbtllhs_config.tll_shared_conf (Implicit type of Common control register for all TLL channels register)
 *   fclk_is_on	(size 1, offset 0, init 0):	RW	Status of the functional clock input, provided by the system to the TLL module. The TLL module will only use that clock if the current status indicated that it is ready. Combined with the Fclk_request to generate fclk_start/end IRQs.
 *   fclk_req	(size 1, offset 1, init 0):	RO	Functional clock request, ORed from all channels depending on their respective USB bus state. Combined with the Fclk_is_on status to generate fclk_start/end IRQs.
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_shared_conf_t omap44xx_usbtllhs_config_tll_shared_conf_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_usbtllhs_config_tll_shared_conf_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_shared_conf_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_shared_conf_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_shared_conf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_usbtllhs_config_tll_shared_conf_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_shared_conf_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_shared_conf_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_shared_conf_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_usbtllhs_config_tll_shared_conf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tll_shared_conf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_tll_shared_conf_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tll_shared_conf (Common control register for all TLL channels): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_is_on =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fclk_is_on_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Status of the functional clock input, provided by the system to the TLL module. The TLL module will only use that clock if the current status indicated that it is ready. Combined with the Fclk_request to generate fclk_start/end IRQs.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fclk_req =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fclk_req_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional clock request, ORed from all channels depending on their respective USB bus state. Combined with the Fclk_is_on status to generate fclk_start/end IRQs.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_fclk_is_on_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fclk_is_on_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_shared_conf_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_extract(_regval));
}

static inline omap44xx_usbtllhs_config_fclk_req_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fclk_req_status_t omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_shared_conf_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_usbtllhs_config_tll_shared_conf_fclk_req_extract(_regval));
}

static inline void omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_fclk_is_on_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_shared_conf_fclk_is_on_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_fclk_is_on_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_shared_conf_t _regval = 0x1 & (((omap44xx_usbtllhs_config_tll_shared_conf_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register tll_channel_conf_i_0: Control and Status register for channel i.
 * Type: omap44xx_usbtllhs_config.tll_channel_conf_i_0 (Implicit type of Control and Status register for channel i. register)
 *   chanen	(size 1, offset 0, init 0):	RW	Active-high channel enable. A disabled channel is unclocked and kept under reset.
 *   chanmode	(size 2, offset 1, init 0):	RW	Main channel mode selection
 *   utmiisadev	(size 1, offset 3, init 0):	RW	Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.
 *   tllattach	(size 1, offset 4, init 0):	RW	Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL)
 *   tllconnect	(size 1, offset 5, init 0):	RW	Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.
 *   tllfullspeed	(size 1, offset 6, init 0):	RW	Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.
 *   ulpioutclkmode	(size 1, offset 7, init 0):	RO	ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   utmiautoidle	(size 1, offset 9, init 0):	RW	For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0)
 *   ulpiautoidle	(size 1, offset 10, init 0):	RW	For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.
 *   ulpinobitstuff	(size 1, offset 11, init 0):	RW	Disable bitstuff emulation in ULPI TLL for ULPI ChanMode
 *   _anon12	(size 3, offset 12, init 0):	MBZ	_
 *   chrgvbus	(size 1, offset 15, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller
 *   drvvbus	(size 1, offset 16, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller
 *   testen	(size 1, offset 17, init 0):	RW	Enable manual test override for serial mode TX path (from local controller UTMI port)
 *   testtxen	(size 1, offset 18, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode)
 *   testtxdat	(size 1, offset 19, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0)
 *   testtxse0	(size 1, offset 20, init 0):	RW	Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz)
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fslsmode	(size 4, offset 24, init 0):	RW	Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.
 *   fslslinestate	(size 2, offset 28, init 0):	RO	Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_0_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval)
{
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tll_channel_conf_i_0 (Control and Status register for channel i.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active-high channel enable. A disabled channel is unclocked and kept under reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Main channel mode selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiisadev =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiisadev_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllattach =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllattach_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllconnect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllconnect_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllfullspeed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllfullspeed_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpioutclkmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpioutclkmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpinobitstuff =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpinobitstuff_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Disable bitstuff emulation in ULPI TLL for ULPI ChanMode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chrgvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chrgvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drvvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_drvvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable manual test override for serial mode TX path (from local controller UTMI port))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxdat =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxdat_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxse0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxse0_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslsmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslsmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslslinestate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslslinestate_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_extract(_regval));
}

static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_extract(_regval));
}

static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_extract(_regval));
}

static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_extract(_regval));
}

static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_extract(_regval));
}

static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpioutclkmode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_extract(_regval));
}

static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_extract(_regval));
}

static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_extract(_regval));
}

static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_extract(_regval));
}

static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_extract(_regval));
}

static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslslinestate_extract(_regval));
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanen_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x1 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf1f8e7e & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_chanmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanmode_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x6 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf1f8e79 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiisadev_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x8 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf1f8e77 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllattach_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllattach_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllattach_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x10 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf1f8e6f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllconnect_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x20 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 5);
    _regval = (_regval | (0xf1f8e5f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_tllfullspeed_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x40 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 6);
    _regval = (_regval | (0xf1f8e3f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_utmiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x200 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 9);
    _regval = (_regval | (0xf1f8c7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x400 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 10);
    _regval = (_regval | (0xf1f8a7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_ulpinobitstuff_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x800 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 11);
    _regval = (_regval | (0xf1f867f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_chrgvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x8000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 15);
    _regval = (_regval | (0xf1f0e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_drvvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x10000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf1e8e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testen_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x20000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 17);
    _regval = (_regval | (0xf1d8e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxen_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x40000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 18);
    _regval = (_regval | (0xf1b8e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxdat_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x80000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 19);
    _regval = (_regval | (0xf178e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_testtxse0_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0x100000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 20);
    _regval = (_regval | (0xf0f8e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_0_fslsmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_0_t _regval = 0xf000000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_0_t )(_fieldval)) << 24);
    _regval = (_regval | (0x1f8e7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register tll_channel_conf_i_1: Control and Status register for channel i.
 * Type: omap44xx_usbtllhs_config.tll_channel_conf_i_1 (Implicit type of Control and Status register for channel i. register)
 *   chanen	(size 1, offset 0, init 0):	RW	Active-high channel enable. A disabled channel is unclocked and kept under reset.
 *   chanmode	(size 2, offset 1, init 0):	RW	Main channel mode selection
 *   utmiisadev	(size 1, offset 3, init 0):	RW	Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.
 *   tllattach	(size 1, offset 4, init 0):	RW	Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL)
 *   tllconnect	(size 1, offset 5, init 0):	RW	Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.
 *   tllfullspeed	(size 1, offset 6, init 0):	RW	Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.
 *   ulpioutclkmode	(size 1, offset 7, init 0):	RO	ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   utmiautoidle	(size 1, offset 9, init 0):	RW	For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0)
 *   ulpiautoidle	(size 1, offset 10, init 0):	RW	For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.
 *   ulpinobitstuff	(size 1, offset 11, init 0):	RW	Disable bitstuff emulation in ULPI TLL for ULPI ChanMode
 *   _anon12	(size 3, offset 12, init 0):	MBZ	_
 *   chrgvbus	(size 1, offset 15, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller
 *   drvvbus	(size 1, offset 16, init 0):	RW	VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller
 *   testen	(size 1, offset 17, init 0):	RW	Enable manual test override for serial mode TX path (from local controller UTMI port)
 *   testtxen	(size 1, offset 18, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode)
 *   testtxdat	(size 1, offset 19, init 0):	RW	Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0)
 *   testtxse0	(size 1, offset 20, init 0):	RW	Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz)
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fslsmode	(size 4, offset 24, init 0):	RW	Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.
 *   fslslinestate	(size 2, offset 28, init 0):	RO	Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tll_channel_conf_i_1_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_rawwr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_wr(__DN(t) *_dev, omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval)
{
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_tll_channel_conf_i_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tll_channel_conf_i_1 (Control and Status register for channel i.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active-high channel enable. A disabled channel is unclocked and kept under reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chanmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Main channel mode selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiisadev =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiisadev_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the cable end 'seen' by UTMI side of TLL, i.e. the emulated USB cable's orientation. The host must always be on A-side, peripheral on B-side. Reset value depends on generic DEFUTMIISHOST.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllattach =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllattach_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulates cable attach/detach for all serial TLL modes: * ChanMode = serial, in TLL mode (FsLsMode) * ChanMode = ULPI, in serial mode (6pin/3pin TLL))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllconnect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllconnect_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Emulation of Full/Low-Speed connect (that is, D+ resp D- pullup) for serial TLL modes. Speed is determined by field TllSpeed.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tllfullspeed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tllfullspeed_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Sets PHY speed emulation in TLL (full/slow), which determines the line to pull up upon connect. The two connect source controls are: input m(N)_tllpuen, register field TllConnect.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpioutclkmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpioutclkmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ULPI clocking mode select for ULPI TLL ChanMode. Hardcoded, for legacy only.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " utmiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_utmiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the UTMI clock (output) to be stopped when UTMII goes to suspended mode (suspendm = 0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpiautoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpiautoidle_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(For ChanMode = ULPI TLL only. Allow the ULPI output clock to be stopped when ULPI goes into asynchronous mode (low-power, 3-pin serial, 6-pin serial). No effect in ULPI input clock mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ulpinobitstuff =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_ulpinobitstuff_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Disable bitstuff emulation in ULPI TLL for ULPI ChanMode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chrgvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_chrgvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS charge/pullup (OTG) * In PHY config, write 1 to reports 'session valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drvvbus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_drvvbus_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VBUS-drive for ChanMode = serial * In TLL config, write 1 to emulate serial-side VBUS drive * In PHY config, write 1 to report 'VBUS valid' status (of actual VBUS) to UTMI controller)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable manual test override for serial mode TX path (from local controller UTMI port))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxen_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxdat =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxdat_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Differential data transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz) or TestSe0 = 1 (TX = se0))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " testtxse0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_testtxse0_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force-Se0 transmit override value for serial mode test Don't care if TestEn = 0 (functional mode) or = TestTxen = 1 (TX = hiz))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslsmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslsmode_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple-mode serial interface's mode select. Only when main channel mode is serial. No effect in other main modes.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fslslinestate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_fslslinestate_status_prtval(_s + _r, _avail, omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line state for Full/low speed serial modes Bit 1 = D-/ Bit0 = D+)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_extract(_regval));
}

static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chanmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiisadev_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_extract(_regval));
}

static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllattach_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_extract(_regval));
}

static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllconnect_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_extract(_regval));
}

static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_tllfullspeed_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_extract(_regval));
}

static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpioutclkmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpioutclkmode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_utmiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_extract(_regval));
}

static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpiautoidle_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_extract(_regval));
}

static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_ulpinobitstuff_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_extract(_regval));
}

static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_chrgvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_extract(_regval));
}

static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_drvvbus_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxen_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxdat_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_extract(_regval));
}

static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_testtxse0_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_extract(_regval));
}

static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslsmode_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_extract(_regval));
}

static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_usbtllhs_config_fslslinestate_status_t omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_rdf(__DN(t) *_dev)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslslinestate_extract(_regval));
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanen_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x1 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf1f8e7e & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_chanmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chanmode_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x6 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf1f8e79 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiisadev_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiisadev_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x8 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf1f8e77 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllattach_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllattach_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllattach_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x10 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf1f8e6f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllconnect_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllconnect_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x20 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 5);
    _regval = (_regval | (0xf1f8e5f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_tllfullspeed_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_tllfullspeed_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x40 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 6);
    _regval = (_regval | (0xf1f8e3f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_utmiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_utmiautoidle_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x200 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 9);
    _regval = (_regval | (0xf1f8c7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpiautoidle_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpiautoidle_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x400 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 10);
    _regval = (_regval | (0xf1f8a7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_ulpinobitstuff_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_ulpinobitstuff_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x800 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 11);
    _regval = (_regval | (0xf1f867f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_chrgvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_chrgvbus_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x8000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 15);
    _regval = (_regval | (0xf1f0e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_drvvbus_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_drvvbus_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x10000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf1e8e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testen_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x20000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 17);
    _regval = (_regval | (0xf1d8e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxen_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxen_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x40000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 18);
    _regval = (_regval | (0xf1b8e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxdat_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxdat_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x80000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 19);
    _regval = (_regval | (0xf178e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_testtxse0_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_testtxse0_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0x100000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 20);
    _regval = (_regval | (0xf0f8e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_tll_channel_conf_i_1_fslsmode_wrf(__DN(t) *_dev, omap44xx_usbtllhs_config_fslsmode_status_t _fieldval)
{
    omap44xx_usbtllhs_config_tll_channel_conf_i_1_t _regval = 0xf000000 & (((omap44xx_usbtllhs_config_tll_channel_conf_i_1_t )(_fieldval)) << 24);
    _regval = (_regval | (0x1f8e7f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x3f1f8eff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register usbtll_sar_cntx_j_0: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_0 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_sar_cntx_j_1: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x404);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_1 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_sar_cntx_j_2: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x408));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x408));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x408, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x408, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x408);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_2 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_sar_cntx_j_3: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40c, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40c, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_3 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_sar_cntx_j_4: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_4 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_sar_cntx_j_5: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x414));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x414));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x414, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x414, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x414);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_5 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register usbtll_sar_cntx_j_6: Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.
 * Type: omap44xx_usbtllhs_config.uint32 (primitive type)
 */
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x418));
}

static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x418));
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x418, _regval);
}

static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x418, _regval);
}

static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x418);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbtll_sar_cntx_j_6 (Save and Restore context array. Array size is indicated in. When in SAR mode, read to save and write to restore. Do not access when not in SAR mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int omap44xx_usbtllhs_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_usbtllhs_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_usbtllhs_config ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_revision_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_hwinfo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sysconfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sysstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_irqstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_irqenable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tll_shared_conf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tll_channel_conf_i_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_tll_channel_conf_i_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_usbtllhs_config_usbtll_sar_cntx_j_6_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_usbtllhs_config\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_usbtllhs_config_DEV_H
