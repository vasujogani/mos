#ifndef __omap44xx_emif_DEV_H
#define __omap44xx_emif_DEV_H 1
/*
 * DEVICE DEFINITION: OMAP44xx external memory intf.
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_emif ## _ ## x
/*
 * Constants defn: omap44xx_emif.sdram_type (SDRAM type values)
 *  - width 3 bits
 */
typedef uint8_t omap44xx_emif_sdram_type_t;
#define omap44xx_emif_sdram_s4 ((omap44xx_emif_sdram_type_t)0x4)
#define omap44xx_emif_sdram_s2 ((omap44xx_emif_sdram_type_t)0x5)

static inline char *omap44xx_emif_sdram_type_describe(omap44xx_emif_sdram_type_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_emif_sdram_type_describe(omap44xx_emif_sdram_type_t _e)
{
    switch (_e) {
    case omap44xx_emif_sdram_s4:
        return("sdram_s4: LPDDR2-S4");
    case omap44xx_emif_sdram_s2:
        return("sdram_s2: LPDDR2-S2");
    default:
        return(NULL);
    }
}

static inline int omap44xx_emif_sdram_type_prtval(char *_s, size_t _size, omap44xx_emif_sdram_type_t _e) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_type_prtval(char *_s, size_t _size, omap44xx_emif_sdram_type_t _e)
{
    char *d = omap44xx_emif_sdram_type_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_emif_sdram_type_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_emif.apm_mode (Auto power management mode)
 *  - width 3 bits
 */
typedef uint8_t omap44xx_emif_apm_mode_t;
#define omap44xx_emif_apm_cs ((omap44xx_emif_apm_mode_t)0x1)
#define omap44xx_emif_apm_sr ((omap44xx_emif_apm_mode_t)0x2)
#define omap44xx_emif_apm_pd ((omap44xx_emif_apm_mode_t)0x4)

static inline char *omap44xx_emif_apm_mode_describe(omap44xx_emif_apm_mode_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_emif_apm_mode_describe(omap44xx_emif_apm_mode_t _e)
{
    switch (_e) {
    case omap44xx_emif_apm_cs:
        return("apm_cs: Clock stop");
    case omap44xx_emif_apm_sr:
        return("apm_sr: Self-refresh");
    case omap44xx_emif_apm_pd:
        return("apm_pd: Power down");
    default:
        return(NULL);
    }
}

static inline int omap44xx_emif_apm_mode_prtval(char *_s, size_t _size, omap44xx_emif_apm_mode_t _e) __attribute__ ((always_inline));
static inline int omap44xx_emif_apm_mode_prtval(char *_s, size_t _size, omap44xx_emif_apm_mode_t _e)
{
    char *d = omap44xx_emif_apm_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_emif_apm_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_emif.pcfilter (Performance counter filter)
 *  - width 4 bits
 */
typedef uint8_t omap44xx_emif_pcfilter_t;
#define omap44xx_emif_pcf_sdr_acc ((omap44xx_emif_pcfilter_t)0x0)
#define omap44xx_emif_pcf_sdr_act ((omap44xx_emif_pcfilter_t)0x1)
#define omap44xx_emif_pcf_tot_rds ((omap44xx_emif_pcfilter_t)0x2)
#define omap44xx_emif_pcf_tot_wrs ((omap44xx_emif_pcfilter_t)0x3)
#define omap44xx_emif_pcf_cf_full ((omap44xx_emif_pcfilter_t)0x4)
#define omap44xx_emif_pcf_wf_full ((omap44xx_emif_pcfilter_t)0x5)
#define omap44xx_emif_pcf_rf_full ((omap44xx_emif_pcfilter_t)0x6)
#define omap44xx_emif_pcf_tf_full ((omap44xx_emif_pcfilter_t)0x7)
#define omap44xx_emif_pcf_pri_elv ((omap44xx_emif_pcfilter_t)0x8)
#define omap44xx_emif_pcf_cmd_pnd ((omap44xx_emif_pcfilter_t)0x9)
#define omap44xx_emif_pcf_mem_xfr ((omap44xx_emif_pcfilter_t)0xa)

static inline char *omap44xx_emif_pcfilter_describe(omap44xx_emif_pcfilter_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_emif_pcfilter_describe(omap44xx_emif_pcfilter_t _e)
{
    switch (_e) {
    case omap44xx_emif_pcf_sdr_acc:
        return("pcf_sdr_acc: Total SDRAM accesses");
    case omap44xx_emif_pcf_sdr_act:
        return("pcf_sdr_act: Total SDRAM activates");
    case omap44xx_emif_pcf_tot_rds:
        return("pcf_tot_rds: Total reads");
    case omap44xx_emif_pcf_tot_wrs:
        return("pcf_tot_wrs: Total writes");
    case omap44xx_emif_pcf_cf_full:
        return("pcf_cf_full: Cycles L3 command FIFO is full");
    case omap44xx_emif_pcf_wf_full:
        return("pcf_wf_full: Cycles L3 Write Data FIFO is full");
    case omap44xx_emif_pcf_rf_full:
        return("pcf_rf_full: Cycles L3 Read Data FIFO is full");
    case omap44xx_emif_pcf_tf_full:
        return("pcf_tf_full: Cycles L3 Return Command FIFO is full");
    case omap44xx_emif_pcf_pri_elv:
        return("pcf_pri_elv: Priority elevations");
    case omap44xx_emif_pcf_cmd_pnd:
        return("pcf_cmd_pnd: Cycles that a command was pending");
    case omap44xx_emif_pcf_mem_xfr:
        return("pcf_mem_xfr: Cycles for which mem. data bus xferd data");
    default:
        return(NULL);
    }
}

static inline int omap44xx_emif_pcfilter_prtval(char *_s, size_t _size, omap44xx_emif_pcfilter_t _e) __attribute__ ((always_inline));
static inline int omap44xx_emif_pcfilter_prtval(char *_s, size_t _size, omap44xx_emif_pcfilter_t _e)
{
    char *d = omap44xx_emif_pcfilter_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_emif_pcfilter_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_emif.err_spc (Address space of errored transaction)
 *  - width 2 bits
 */
typedef uint8_t omap44xx_emif_err_spc_t;
#define omap44xx_emif_es_sdram ((omap44xx_emif_err_spc_t)0x0)
#define omap44xx_emif_es_ddr2 ((omap44xx_emif_err_spc_t)0x1)
#define omap44xx_emif_es_int ((omap44xx_emif_err_spc_t)0x3)

static inline char *omap44xx_emif_err_spc_describe(omap44xx_emif_err_spc_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_emif_err_spc_describe(omap44xx_emif_err_spc_t _e)
{
    switch (_e) {
    case omap44xx_emif_es_sdram:
        return("es_sdram: SDRAM");
    case omap44xx_emif_es_ddr2:
        return("es_ddr2: LPDDR2-NVM");
    case omap44xx_emif_es_int:
        return("es_int: Internal registers");
    default:
        return(NULL);
    }
}

static inline int omap44xx_emif_err_spc_prtval(char *_s, size_t _size, omap44xx_emif_err_spc_t _e) __attribute__ ((always_inline));
static inline int omap44xx_emif_err_spc_prtval(char *_s, size_t _size, omap44xx_emif_err_spc_t _e)
{
    char *d = omap44xx_emif_err_spc_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_emif_err_spc_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_emif_status_t
 * Description: Implicit type of SDRAM status register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   phy_dll_ready	(size 1, offset 2, init 0):	RO	DDR Phy ready
 *   _anon3	(size 26, offset 3, init 0):	MBZ	_
 *   fast_init	(size 1, offset 29, init 0):	RO	Fast initialization mode
 *   dual_clk	(size 1, offset 30, init 0):	RO	Dual Clock mode
 *   be	(size 1, offset 31, init 0):	RO	Big endian select for 8 and 16-bit devices
 */
typedef uint32_t omap44xx_emif_status_t;
#define omap44xx_emif_status_default 0x0
static inline uint8_t omap44xx_emif_status_phy_dll_ready_extract(omap44xx_emif_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_phy_dll_ready_extract(omap44xx_emif_status_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_emif_status_t omap44xx_emif_status_phy_dll_ready_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_status_t omap44xx_emif_status_phy_dll_ready_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_emif_status_t )(_fieldval)) << 2)));
}

static inline uint8_t omap44xx_emif_status_fast_init_extract(omap44xx_emif_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_fast_init_extract(omap44xx_emif_status_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_emif_status_t omap44xx_emif_status_fast_init_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_status_t omap44xx_emif_status_fast_init_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_emif_status_t )(_fieldval)) << 29)));
}

static inline uint8_t omap44xx_emif_status_dual_clk_extract(omap44xx_emif_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_dual_clk_extract(omap44xx_emif_status_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_emif_status_t omap44xx_emif_status_dual_clk_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_status_t omap44xx_emif_status_dual_clk_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_emif_status_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_emif_status_be_extract(omap44xx_emif_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_be_extract(omap44xx_emif_status_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_emif_status_t omap44xx_emif_status_be_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_status_t omap44xx_emif_status_be_insert(omap44xx_emif_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_emif_status_t )(_fieldval)) << 31)));
}

static inline int omap44xx_emif_status_prtval(char *_s, size_t _size, omap44xx_emif_status_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_status_prtval(char *_s, size_t _size, omap44xx_emif_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_dll_ready =\t%" PRIx8 "\t(DDR Phy ready)\n", omap44xx_emif_status_phy_dll_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fast_init =\t%" PRIx8 "\t(Fast initialization mode)\n", omap44xx_emif_status_fast_init_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dual_clk =\t%" PRIx8 "\t(Dual Clock mode)\n", omap44xx_emif_status_dual_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Big endian select for 8 and 16-bit devices)\n", omap44xx_emif_status_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_sdram_config_t
 * Description: Implicit type of SDRAM config register
 * Fields:
 *   pagesize	(size 3, offset 0, init 0):	RW	Page size (add 9 for # column bits)
 *   ebank	(size 1, offset 3, init 0):	RW	External chip select setup
 *   ibank	(size 3, offset 4, init 0):	RW	Internal bank setup: (1<<x) banks
 *   rowsize	(size 3, offset 7, init 0):	RW	Row size (add 9 for # row bits)
 *   cl	(size 4, offset 10, init 0):	RW	CAS latency
 *   narrow_mode	(size 2, offset 14, init 0):	RW	SDRAM data bus width
 *   _anon16	(size 11, offset 16, init 0):	RSVD	_
 *   ibank_pos	(size 2, offset 27, init 0):	RW	Internal bank position
 *   sdram_type	(size 3, offset 29, init 0):	RW	SDRAM type
 */
typedef uint32_t omap44xx_emif_sdram_config_t;
#define omap44xx_emif_sdram_config_default 0x0
static inline uint8_t omap44xx_emif_sdram_config_pagesize_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_pagesize_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_pagesize_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_pagesize_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_sdram_config_ebank_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_ebank_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_ebank_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_ebank_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 3)));
}

static inline uint8_t omap44xx_emif_sdram_config_ibank_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_ibank_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0x70) >> 4));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_ibank_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_ibank_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff8f) | (0x70 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_emif_sdram_config_rowsize_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_rowsize_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0x380) >> 7));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_rowsize_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_rowsize_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffc7f) | (0x380 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 7)));
}

static inline uint8_t omap44xx_emif_sdram_config_cl_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_cl_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0x3c00) >> 10));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_cl_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_cl_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc3ff) | (0x3c00 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 10)));
}

static inline uint8_t omap44xx_emif_sdram_config_narrow_mode_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_narrow_mode_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_narrow_mode_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_narrow_mode_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 14)));
}

static inline uint8_t omap44xx_emif_sdram_config_ibank_pos_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_ibank_pos_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((uint8_t )((_regval & 0x18000000) >> 27));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_ibank_pos_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_ibank_pos_insert(omap44xx_emif_sdram_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xe7ffffff) | (0x18000000 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 27)));
}

static inline omap44xx_emif_sdram_type_t omap44xx_emif_sdram_config_sdram_type_extract(omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_type_t omap44xx_emif_sdram_config_sdram_type_extract(omap44xx_emif_sdram_config_t _regval)
{
    return((omap44xx_emif_sdram_type_t )((_regval & 0xe0000000) >> 29));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_sdram_type_insert(omap44xx_emif_sdram_config_t _regval, omap44xx_emif_sdram_type_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_sdram_type_insert(omap44xx_emif_sdram_config_t _regval, omap44xx_emif_sdram_type_t _fieldval)
{
    return((_regval & 0x1fffffff) | (0xe0000000 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 29)));
}

static inline int omap44xx_emif_sdram_config_prtval(char *_s, size_t _size, omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_config_prtval(char *_s, size_t _size, omap44xx_emif_sdram_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pagesize =\t%" PRIx8 "\t(Page size (add 9 for # column bits))\n", omap44xx_emif_sdram_config_pagesize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ebank =\t%" PRIx8 "\t(External chip select setup)\n", omap44xx_emif_sdram_config_ebank_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibank =\t%" PRIx8 "\t(Internal bank setup: (1<<x) banks)\n", omap44xx_emif_sdram_config_ibank_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rowsize =\t%" PRIx8 "\t(Row size (add 9 for # row bits))\n", omap44xx_emif_sdram_config_rowsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cl =\t%" PRIx8 "\t(CAS latency)\n", omap44xx_emif_sdram_config_cl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " narrow_mode =\t%" PRIx8 "\t(SDRAM data bus width)\n", omap44xx_emif_sdram_config_narrow_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibank_pos =\t%" PRIx8 "\t(Internal bank position)\n", omap44xx_emif_sdram_config_ibank_pos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdram_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_type_prtval(_s + _r, _avail, omap44xx_emif_sdram_config_sdram_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SDRAM type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_sdram_config2_t
 * Description: Implicit type of SDRAM config 2 register
 * Fields:
 *   rdbsize	(size 3, offset 0, init 0):	RW	Row data buffer size 32(1<<x) bytes
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   rdbnum	(size 2, offset 4, init 0):	RW	Row buffer setup (1<<x) row buffers
 *   _anon6	(size 21, offset 6, init 0):	RSVD	_
 *   ebank_pos	(size 1, offset 27, init 0):	RW	External bank position
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   cs1nvmen	(size 1, offset 30, init 0):	RW	CS1 LPDDR2-NVM enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_sdram_config2_t;
#define omap44xx_emif_sdram_config2_default 0x0
static inline uint8_t omap44xx_emif_sdram_config2_rdbsize_extract(omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_rdbsize_extract(omap44xx_emif_sdram_config2_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rdbsize_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rdbsize_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_sdram_config2_rdbnum_extract(omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_rdbnum_extract(omap44xx_emif_sdram_config2_t _regval)
{
    return((uint8_t )((_regval & 0x30) >> 4));
}

static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rdbnum_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rdbnum_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_emif_sdram_config2_ebank_pos_extract(omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_ebank_pos_extract(omap44xx_emif_sdram_config2_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_ebank_pos_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_ebank_pos_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 27)));
}

static inline uint8_t omap44xx_emif_sdram_config2_cs1nvmen_extract(omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_cs1nvmen_extract(omap44xx_emif_sdram_config2_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_cs1nvmen_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_cs1nvmen_insert(omap44xx_emif_sdram_config2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 30)));
}

static inline int omap44xx_emif_sdram_config2_prtval(char *_s, size_t _size, omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_config2_prtval(char *_s, size_t _size, omap44xx_emif_sdram_config2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdbsize =\t%" PRIx8 "\t(Row data buffer size 32(1<<x) bytes)\n", omap44xx_emif_sdram_config2_rdbsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdbnum =\t%" PRIx8 "\t(Row buffer setup (1<<x) row buffers)\n", omap44xx_emif_sdram_config2_rdbnum_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ebank_pos =\t%" PRIx8 "\t(External bank position)\n", omap44xx_emif_sdram_config2_ebank_pos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs1nvmen =\t%" PRIx8 "\t(CS1 LPDDR2-NVM enable)\n", omap44xx_emif_sdram_config2_cs1nvmen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_sdram_ref_ctrl_t
 * Description: Implicit type of SDRAM refresh control register
 * Fields:
 *   refresh_rate	(size 16, offset 0, init 0):	RW	Refresh rate
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   initref_dis	(size 1, offset 31, init 0):	RW	Initialization and refresh disable
 */
typedef uint32_t omap44xx_emif_sdram_ref_ctrl_t;
#define omap44xx_emif_sdram_ref_ctrl_default 0x0
static inline uint16_t omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_refresh_rate_insert(omap44xx_emif_sdram_ref_ctrl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_refresh_rate_insert(omap44xx_emif_sdram_ref_ctrl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((omap44xx_emif_sdram_ref_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_initref_dis_insert(omap44xx_emif_sdram_ref_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_initref_dis_insert(omap44xx_emif_sdram_ref_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_emif_sdram_ref_ctrl_t )(_fieldval)) << 31)));
}

static inline int omap44xx_emif_sdram_ref_ctrl_prtval(char *_s, size_t _size, omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_ref_ctrl_prtval(char *_s, size_t _size, omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refresh_rate =\t%" PRIx16 "\t(Refresh rate)\n", omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " initref_dis =\t%" PRIx8 "\t(Initialization and refresh disable)\n", omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_sdram_tim1_t
 * Description: Implicit type of SDRAM timing 1 register
 * Fields:
 *   wtr	(size 3, offset 0, init 0):	RW	Minimum #DDR clocks last write to read
 *   rrd	(size 3, offset 3, init 0):	RW	Minimum #DDR clocks act. to act. other bank
 *   rc	(size 6, offset 6, init 0):	RW	Minimum #DDR clocks activate to activate
 *   ras	(size 5, offset 12, init 0):	RW	Minimum #DDR clocks activate to precharge
 *   wr	(size 4, offset 17, init 0):	RW	Minimum #DDR clocks write to precharge
 *   rcd	(size 4, offset 21, init 0):	RW	Minimum #DDR clocks activate to r or w
 *   rp	(size 4, offset 25, init 0):	RW	Minimum #DDR clocks precharge to act. or ref.
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_sdram_tim1_t;
#define omap44xx_emif_sdram_tim1_default 0x0
static inline uint8_t omap44xx_emif_sdram_tim1_wtr_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_wtr_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_wtr_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_wtr_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rrd_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rrd_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0x38) >> 3));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rrd_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rrd_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc7) | (0x38 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 3)));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rc_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rc_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0xfc0) >> 6));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rc_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rc_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff03f) | (0xfc0 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 6)));
}

static inline uint8_t omap44xx_emif_sdram_tim1_ras_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_ras_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0x1f000) >> 12));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_ras_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_ras_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe0fff) | (0x1f000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 12)));
}

static inline uint8_t omap44xx_emif_sdram_tim1_wr_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_wr_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0x1e0000) >> 17));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_wr_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_wr_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe1ffff) | (0x1e0000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 17)));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rcd_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rcd_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0x1e00000) >> 21));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rcd_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rcd_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe1fffff) | (0x1e00000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 21)));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rp_extract(omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rp_extract(omap44xx_emif_sdram_tim1_t _regval)
{
    return((uint8_t )((_regval & 0x1e000000) >> 25));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rp_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rp_insert(omap44xx_emif_sdram_tim1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xe1ffffff) | (0x1e000000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 25)));
}

static inline int omap44xx_emif_sdram_tim1_prtval(char *_s, size_t _size, omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim1_prtval(char *_s, size_t _size, omap44xx_emif_sdram_tim1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wtr =\t%" PRIx8 "\t(Minimum #DDR clocks last write to read)\n", omap44xx_emif_sdram_tim1_wtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrd =\t%" PRIx8 "\t(Minimum #DDR clocks act. to act. other bank)\n", omap44xx_emif_sdram_tim1_rrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rc =\t%" PRIx8 "\t(Minimum #DDR clocks activate to activate)\n", omap44xx_emif_sdram_tim1_rc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ras =\t%" PRIx8 "\t(Minimum #DDR clocks activate to precharge)\n", omap44xx_emif_sdram_tim1_ras_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wr =\t%" PRIx8 "\t(Minimum #DDR clocks write to precharge)\n", omap44xx_emif_sdram_tim1_wr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcd =\t%" PRIx8 "\t(Minimum #DDR clocks activate to r or w)\n", omap44xx_emif_sdram_tim1_rcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rp =\t%" PRIx8 "\t(Minimum #DDR clocks precharge to act. or ref.)\n", omap44xx_emif_sdram_tim1_rp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_sdram_tim2_t
 * Description: Implicit type of SDRAM timing 2 register
 * Fields:
 *   cke	(size 3, offset 0, init 0):	RW	Minimum #DDR clocks between pad_cke_o changes
 *   rtp	(size 3, offset 3, init 0):	RW	Minimum #DDR clocks last read to precharge
 *   xsrd	(size 10, offset 6, init 0):	RW	Minimum #DDR clocks self-refresh to read
 *   xsnr	(size 9, offset 16, init 0):	RW	Minimum #DDR clocks self-refresh to non-read
 *   _anon25	(size 3, offset 25, init 0):	RSVD	_
 *   xp	(size 3, offset 28, init 0):	RW	Minimum #DDR clocks powerdown to non-read
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_sdram_tim2_t;
#define omap44xx_emif_sdram_tim2_default 0x0
static inline uint8_t omap44xx_emif_sdram_tim2_cke_extract(omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_cke_extract(omap44xx_emif_sdram_tim2_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_cke_insert(omap44xx_emif_sdram_tim2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_cke_insert(omap44xx_emif_sdram_tim2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_sdram_tim2_rtp_extract(omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_rtp_extract(omap44xx_emif_sdram_tim2_t _regval)
{
    return((uint8_t )((_regval & 0x38) >> 3));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_rtp_insert(omap44xx_emif_sdram_tim2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_rtp_insert(omap44xx_emif_sdram_tim2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc7) | (0x38 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 3)));
}

static inline uint16_t omap44xx_emif_sdram_tim2_xsrd_extract(omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim2_xsrd_extract(omap44xx_emif_sdram_tim2_t _regval)
{
    return((uint16_t )((_regval & 0xffc0) >> 6));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_xsrd_insert(omap44xx_emif_sdram_tim2_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_xsrd_insert(omap44xx_emif_sdram_tim2_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff003f) | (0xffc0 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 6)));
}

static inline uint16_t omap44xx_emif_sdram_tim2_xsnr_extract(omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim2_xsnr_extract(omap44xx_emif_sdram_tim2_t _regval)
{
    return((uint16_t )((_regval & 0x1ff0000) >> 16));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_xsnr_insert(omap44xx_emif_sdram_tim2_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_xsnr_insert(omap44xx_emif_sdram_tim2_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfe00ffff) | (0x1ff0000 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 16)));
}

static inline uint8_t omap44xx_emif_sdram_tim2_xp_extract(omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_xp_extract(omap44xx_emif_sdram_tim2_t _regval)
{
    return((uint8_t )((_regval & 0x70000000) >> 28));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_xp_insert(omap44xx_emif_sdram_tim2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_xp_insert(omap44xx_emif_sdram_tim2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x8fffffff) | (0x70000000 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 28)));
}

static inline int omap44xx_emif_sdram_tim2_prtval(char *_s, size_t _size, omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim2_prtval(char *_s, size_t _size, omap44xx_emif_sdram_tim2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cke =\t%" PRIx8 "\t(Minimum #DDR clocks between pad_cke_o changes)\n", omap44xx_emif_sdram_tim2_cke_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtp =\t%" PRIx8 "\t(Minimum #DDR clocks last read to precharge)\n", omap44xx_emif_sdram_tim2_rtp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xsrd =\t%" PRIx16 "\t(Minimum #DDR clocks self-refresh to read)\n", omap44xx_emif_sdram_tim2_xsrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xsnr =\t%" PRIx16 "\t(Minimum #DDR clocks self-refresh to non-read)\n", omap44xx_emif_sdram_tim2_xsnr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xp =\t%" PRIx8 "\t(Minimum #DDR clocks powerdown to non-read)\n", omap44xx_emif_sdram_tim2_xp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_sdram_tim3_t
 * Description: Implicit type of SDRAM timing 3 register
 * Fields:
 *   ras_max	(size 4, offset 0, init 0):	RW	Maximum #interfaces from act. to precharge
 *   rfc	(size 9, offset 4, init 0):	RW	Minimum #DDR clocks from ref/ld to ref/act.
 *   tdqsckmax	(size 2, offset 13, init 0):	RW	#DDR clocks that satisfies tDQSCKmax
 *   zqcs	(size 6, offset 15, init 0):	RW	#DDR clocks a ZQCS command
 *   ckesr	(size 3, offset 21, init 0):	RW	Minimum #DDR clocks LPDDR2 in self-refresh
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_sdram_tim3_t;
#define omap44xx_emif_sdram_tim3_default 0x0
static inline uint8_t omap44xx_emif_sdram_tim3_ras_max_extract(omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_ras_max_extract(omap44xx_emif_sdram_tim3_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_ras_max_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_ras_max_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 0)));
}

static inline uint16_t omap44xx_emif_sdram_tim3_rfc_extract(omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim3_rfc_extract(omap44xx_emif_sdram_tim3_t _regval)
{
    return((uint16_t )((_regval & 0x1ff0) >> 4));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_rfc_insert(omap44xx_emif_sdram_tim3_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_rfc_insert(omap44xx_emif_sdram_tim3_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffe00f) | (0x1ff0 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_emif_sdram_tim3_tdqsckmax_extract(omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_tdqsckmax_extract(omap44xx_emif_sdram_tim3_t _regval)
{
    return((uint8_t )((_regval & 0x6000) >> 13));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_tdqsckmax_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_tdqsckmax_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff9fff) | (0x6000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 13)));
}

static inline uint8_t omap44xx_emif_sdram_tim3_zqcs_extract(omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_zqcs_extract(omap44xx_emif_sdram_tim3_t _regval)
{
    return((uint8_t )((_regval & 0x1f8000) >> 15));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_zqcs_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_zqcs_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe07fff) | (0x1f8000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 15)));
}

static inline uint8_t omap44xx_emif_sdram_tim3_ckesr_extract(omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_ckesr_extract(omap44xx_emif_sdram_tim3_t _regval)
{
    return((uint8_t )((_regval & 0xe00000) >> 21));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_ckesr_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_ckesr_insert(omap44xx_emif_sdram_tim3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff1fffff) | (0xe00000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 21)));
}

static inline int omap44xx_emif_sdram_tim3_prtval(char *_s, size_t _size, omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim3_prtval(char *_s, size_t _size, omap44xx_emif_sdram_tim3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ras_max =\t%" PRIx8 "\t(Maximum #interfaces from act. to precharge)\n", omap44xx_emif_sdram_tim3_ras_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfc =\t%" PRIx16 "\t(Minimum #DDR clocks from ref/ld to ref/act.)\n", omap44xx_emif_sdram_tim3_rfc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdqsckmax =\t%" PRIx8 "\t(#DDR clocks that satisfies tDQSCKmax)\n", omap44xx_emif_sdram_tim3_tdqsckmax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqcs =\t%" PRIx8 "\t(#DDR clocks a ZQCS command)\n", omap44xx_emif_sdram_tim3_zqcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ckesr =\t%" PRIx8 "\t(Minimum #DDR clocks LPDDR2 in self-refresh)\n", omap44xx_emif_sdram_tim3_ckesr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_lpddr2_nvm_tim_t
 * Description: Implicit type of LPDDR2-NVM timing register
 * Fields:
 *   rcdmin	(size 8, offset 0, init 0):	RW	Minimum #DDR clocks activate to r/w
 *   rrd	(size 8, offset 8, init 0):	RW	Minimum #DDR clocks act. to act. other bank.
 *   wra	(size 4, offset 16, init 0):	RW	Minimum #DDR clocks last write to activate
 *   rp	(size 4, offset 20, init 0):	RW	Minimum #DDR clocks preactive to activate
 *   wtr	(size 3, offset 24, init 0):	RW	Minimum #DDR clocks last write to read
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   xp	(size 3, offset 28, init 0):	RW	Minimum #DDR clocks from powerdown
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_lpddr2_nvm_tim_t;
#define omap44xx_emif_lpddr2_nvm_tim_default 0x0
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rcdmin_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rcdmin_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rrd_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rrd_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rrd_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rrd_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wra_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wra_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_wra_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_wra_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 16)));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rp_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rp_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    return((uint8_t )((_regval & 0xf00000) >> 20));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rp_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rp_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff0fffff) | (0xf00000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 20)));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wtr_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wtr_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    return((uint8_t )((_regval & 0x7000000) >> 24));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_wtr_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_wtr_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf8ffffff) | (0x7000000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 24)));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_xp_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_xp_extract(omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    return((uint8_t )((_regval & 0x70000000) >> 28));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_xp_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_xp_insert(omap44xx_emif_lpddr2_nvm_tim_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x8fffffff) | (0x70000000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 28)));
}

static inline int omap44xx_emif_lpddr2_nvm_tim_prtval(char *_s, size_t _size, omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_lpddr2_nvm_tim_prtval(char *_s, size_t _size, omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcdmin =\t%" PRIx8 "\t(Minimum #DDR clocks activate to r/w)\n", omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrd =\t%" PRIx8 "\t(Minimum #DDR clocks act. to act. other bank.)\n", omap44xx_emif_lpddr2_nvm_tim_rrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wra =\t%" PRIx8 "\t(Minimum #DDR clocks last write to activate)\n", omap44xx_emif_lpddr2_nvm_tim_wra_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rp =\t%" PRIx8 "\t(Minimum #DDR clocks preactive to activate)\n", omap44xx_emif_lpddr2_nvm_tim_rp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wtr =\t%" PRIx8 "\t(Minimum #DDR clocks last write to read)\n", omap44xx_emif_lpddr2_nvm_tim_wtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xp =\t%" PRIx8 "\t(Minimum #DDR clocks from powerdown)\n", omap44xx_emif_lpddr2_nvm_tim_xp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_pwr_mgmt_ctrl_t
 * Description: Implicit type of Power management control register
 * Fields:
 *   cs_tim	(size 4, offset 0, init 0):	RW	Power mangement timer for clock stop
 *   sr_tim	(size 4, offset 4, init 0):	RW	Power mangement timer for self refresh
 *   lp_mode	(size 3, offset 8, init 0):	RW	Automatic power management enable
 *   dpd_en	(size 1, offset 11, init 0):	RW	Deep power down enable
 *   pd_tim	(size 4, offset 12, init 0):	RW	Power mangement timer for power-down
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_pwr_mgmt_ctrl_t;
#define omap44xx_emif_pwr_mgmt_ctrl_default 0x0
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_cs_tim_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_cs_tim_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_sr_tim_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_sr_tim_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 4)));
}

static inline omap44xx_emif_apm_mode_t omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_emif_apm_mode_t omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    return((omap44xx_emif_apm_mode_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_lp_mode_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, omap44xx_emif_apm_mode_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_lp_mode_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, omap44xx_emif_apm_mode_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_dpd_en_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_dpd_en_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0xf000) >> 12));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_pd_tim_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_pd_tim_insert(omap44xx_emif_pwr_mgmt_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff0fff) | (0xf000 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 12)));
}

static inline int omap44xx_emif_pwr_mgmt_ctrl_prtval(char *_s, size_t _size, omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_pwr_mgmt_ctrl_prtval(char *_s, size_t _size, omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs_tim =\t%" PRIx8 "\t(Power mangement timer for clock stop)\n", omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_tim =\t%" PRIx8 "\t(Power mangement timer for self refresh)\n", omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lp_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_apm_mode_prtval(_s + _r, _avail, omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Automatic power management enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpd_en =\t%" PRIx8 "\t(Deep power down enable)\n", omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pd_tim =\t%" PRIx8 "\t(Power mangement timer for power-down)\n", omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_lpddr2_mode_reg_cfg_t
 * Description: Implicit type of LPDDR2 mode register config register
 * Fields:
 *   address	(size 8, offset 0, init 0):	RW	Mode register address
 *   _anon8	(size 22, offset 8, init 0):	RSVD	_
 *   refresh_en	(size 1, offset 30, init 0):	RW	Refresh Enable after MRW write
 *   cs	(size 1, offset 31, init 0):	RW	Chip select to issue mode register command
 */
typedef uint32_t omap44xx_emif_lpddr2_mode_reg_cfg_t;
#define omap44xx_emif_lpddr2_mode_reg_cfg_default 0x0
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_address_extract(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_address_extract(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_address_insert(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_address_insert(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_emif_lpddr2_mode_reg_cfg_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_extract(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_extract(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_insert(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_insert(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_emif_lpddr2_mode_reg_cfg_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_cs_extract(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_cs_extract(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_cs_insert(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_cs_insert(omap44xx_emif_lpddr2_mode_reg_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_emif_lpddr2_mode_reg_cfg_t )(_fieldval)) << 31)));
}

static inline int omap44xx_emif_lpddr2_mode_reg_cfg_prtval(char *_s, size_t _size, omap44xx_emif_lpddr2_mode_reg_cfg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_lpddr2_mode_reg_cfg_prtval(char *_s, size_t _size, omap44xx_emif_lpddr2_mode_reg_cfg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Mode register address)\n", omap44xx_emif_lpddr2_mode_reg_cfg_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refresh_en =\t%" PRIx8 "\t(Refresh Enable after MRW write)\n", omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs =\t%" PRIx8 "\t(Chip select to issue mode register command)\n", omap44xx_emif_lpddr2_mode_reg_cfg_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_l3_config_t
 * Description: Implicit type of L3 configuration register
 * Fields:
 *   pr_old_count	(size 8, offset 0, init 0):	RW	Priority raise old counter
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 *   ll_thresh_max	(size 4, offset 16, init 0):	RW	Low-latency L3 threshold maximum
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   sys_thresh_max	(size 4, offset 24, init 0):	RW	System L3 threshold maximum
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_l3_config_t;
#define omap44xx_emif_l3_config_default 0x0
static inline uint8_t omap44xx_emif_l3_config_pr_old_count_extract(omap44xx_emif_l3_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_config_pr_old_count_extract(omap44xx_emif_l3_config_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_pr_old_count_insert(omap44xx_emif_l3_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_pr_old_count_insert(omap44xx_emif_l3_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_emif_l3_config_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_l3_config_ll_thresh_max_extract(omap44xx_emif_l3_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_config_ll_thresh_max_extract(omap44xx_emif_l3_config_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_ll_thresh_max_insert(omap44xx_emif_l3_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_ll_thresh_max_insert(omap44xx_emif_l3_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_emif_l3_config_t )(_fieldval)) << 16)));
}

static inline uint8_t omap44xx_emif_l3_config_sys_thresh_max_extract(omap44xx_emif_l3_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_config_sys_thresh_max_extract(omap44xx_emif_l3_config_t _regval)
{
    return((uint8_t )((_regval & 0xf000000) >> 24));
}

static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_sys_thresh_max_insert(omap44xx_emif_l3_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_sys_thresh_max_insert(omap44xx_emif_l3_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((omap44xx_emif_l3_config_t )(_fieldval)) << 24)));
}

static inline int omap44xx_emif_l3_config_prtval(char *_s, size_t _size, omap44xx_emif_l3_config_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_config_prtval(char *_s, size_t _size, omap44xx_emif_l3_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr_old_count =\t%" PRIx8 "\t(Priority raise old counter)\n", omap44xx_emif_l3_config_pr_old_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ll_thresh_max =\t%" PRIx8 "\t(Low-latency L3 threshold maximum)\n", omap44xx_emif_l3_config_ll_thresh_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_thresh_max =\t%" PRIx8 "\t(System L3 threshold maximum)\n", omap44xx_emif_l3_config_sys_thresh_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_l3_cfg_val1_t
 * Description: Implicit type of L3 config value 1 register
 * Fields:
 *   cmd_fifo_depth	(size 8, offset 0, init 0):	RO	Command FIFO depth
 *   wr_fifo_depth	(size 8, offset 8, init 0):	RO	Write data FIFO depth
 *   _anon16	(size 12, offset 16, init 0):	MBZ	_
 *   ll_bus_width	(size 2, offset 28, init 0):	RO	Low-latency L3 data bus width 32*(1<<x)
 *   sys_bus_width	(size 2, offset 30, init 0):	RO	System L3 data bus width 32*(1<<x) bits
 */
typedef uint32_t omap44xx_emif_l3_cfg_val1_t;
#define omap44xx_emif_l3_cfg_val1_default 0x0
static inline uint8_t omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_extract(omap44xx_emif_l3_cfg_val1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_extract(omap44xx_emif_l3_cfg_val1_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_emif_l3_cfg_val1_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_wr_fifo_depth_extract(omap44xx_emif_l3_cfg_val1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_wr_fifo_depth_extract(omap44xx_emif_l3_cfg_val1_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_wr_fifo_depth_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_wr_fifo_depth_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((omap44xx_emif_l3_cfg_val1_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_ll_bus_width_extract(omap44xx_emif_l3_cfg_val1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_ll_bus_width_extract(omap44xx_emif_l3_cfg_val1_t _regval)
{
    return((uint8_t )((_regval & 0x30000000) >> 28));
}

static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_ll_bus_width_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_ll_bus_width_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((omap44xx_emif_l3_cfg_val1_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_sys_bus_width_extract(omap44xx_emif_l3_cfg_val1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_sys_bus_width_extract(omap44xx_emif_l3_cfg_val1_t _regval)
{
    return((uint8_t )((_regval & 0xc0000000) >> 30));
}

static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_sys_bus_width_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_sys_bus_width_insert(omap44xx_emif_l3_cfg_val1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x3fffffff) | (0xc0000000 & (((omap44xx_emif_l3_cfg_val1_t )(_fieldval)) << 30)));
}

static inline int omap44xx_emif_l3_cfg_val1_prtval(char *_s, size_t _size, omap44xx_emif_l3_cfg_val1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_cfg_val1_prtval(char *_s, size_t _size, omap44xx_emif_l3_cfg_val1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd_fifo_depth =\t%" PRIx8 "\t(Command FIFO depth)\n", omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wr_fifo_depth =\t%" PRIx8 "\t(Write data FIFO depth)\n", omap44xx_emif_l3_cfg_val1_wr_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ll_bus_width =\t%" PRIx8 "\t(Low-latency L3 data bus width 32*(1<<x))\n", omap44xx_emif_l3_cfg_val1_ll_bus_width_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_bus_width =\t%" PRIx8 "\t(System L3 data bus width 32*(1<<x) bits)\n", omap44xx_emif_l3_cfg_val1_sys_bus_width_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_l3_cfg_val2_t
 * Description: Implicit type of L3 config value 2 register
 * Fields:
 *   rcmd_fifo_depth	(size 8, offset 0, init 0):	RO	Read command FIFO depth
 *   rsd_fifo_depth	(size 8, offset 8, init 0):	RO	SDRAM read data FIFO depth
 *   rreg_fifo_depth	(size 8, offset 16, init 0):	RO	Register Read Data FIFO depth
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_emif_l3_cfg_val2_t;
#define omap44xx_emif_l3_cfg_val2_default 0x0
static inline uint8_t omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_extract(omap44xx_emif_l3_cfg_val2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_extract(omap44xx_emif_l3_cfg_val2_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_insert(omap44xx_emif_l3_cfg_val2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_insert(omap44xx_emif_l3_cfg_val2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_emif_l3_cfg_val2_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_extract(omap44xx_emif_l3_cfg_val2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_extract(omap44xx_emif_l3_cfg_val2_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_insert(omap44xx_emif_l3_cfg_val2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_insert(omap44xx_emif_l3_cfg_val2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((omap44xx_emif_l3_cfg_val2_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_extract(omap44xx_emif_l3_cfg_val2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_extract(omap44xx_emif_l3_cfg_val2_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_insert(omap44xx_emif_l3_cfg_val2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_insert(omap44xx_emif_l3_cfg_val2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((omap44xx_emif_l3_cfg_val2_t )(_fieldval)) << 16)));
}

static inline int omap44xx_emif_l3_cfg_val2_prtval(char *_s, size_t _size, omap44xx_emif_l3_cfg_val2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_cfg_val2_prtval(char *_s, size_t _size, omap44xx_emif_l3_cfg_val2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcmd_fifo_depth =\t%" PRIx8 "\t(Read command FIFO depth)\n", omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsd_fifo_depth =\t%" PRIx8 "\t(SDRAM read data FIFO depth)\n", omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rreg_fifo_depth =\t%" PRIx8 "\t(Register Read Data FIFO depth)\n", omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_perf_cnt_cfg_t
 * Description: Implicit type of Perf. cntr. config register
 * Fields:
 *   cntr1_cfg	(size 4, offset 0, init 0):	RW	Filter config. for perf. cntr. 1
 *   _anon4	(size 10, offset 4, init 0):	RSVD	_
 *   cntr1_region_en	(size 1, offset 14, init 0):	RW	Chip Select filter enable for Perf. cntr 1
 *   cntr1_mconnid_en	(size 1, offset 15, init 0):	RW	MConnID filter enable for perf. cntr. 1
 *   cntr2_cfg	(size 4, offset 16, init 0):	RW	Filter config. for perf. cntr. 2
 *   _anon20	(size 10, offset 20, init 0):	RSVD	_
 *   cntr2_region_en	(size 1, offset 30, init 0):	RW	Chip Select filter enable for Perf. cntr 2
 *   cntr2_mconnid_en	(size 1, offset 31, init 0):	RW	MConnID filter enable for perf. cntr. 2
 */
typedef uint32_t omap44xx_emif_perf_cnt_cfg_t;
#define omap44xx_emif_perf_cnt_cfg_default 0x0
static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr1_cfg_extract(omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr1_cfg_extract(omap44xx_emif_perf_cnt_cfg_t _regval)
{
    return((omap44xx_emif_pcfilter_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr1_cfg_insert(omap44xx_emif_perf_cnt_cfg_t _regval, omap44xx_emif_pcfilter_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr1_cfg_insert(omap44xx_emif_perf_cnt_cfg_t _regval, omap44xx_emif_pcfilter_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_region_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_region_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr1_region_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr1_region_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 14)));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 15)));
}

static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr2_cfg_extract(omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr2_cfg_extract(omap44xx_emif_perf_cnt_cfg_t _regval)
{
    return((omap44xx_emif_pcfilter_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr2_cfg_insert(omap44xx_emif_perf_cnt_cfg_t _regval, omap44xx_emif_pcfilter_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr2_cfg_insert(omap44xx_emif_perf_cnt_cfg_t _regval, omap44xx_emif_pcfilter_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 16)));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_region_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_region_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr2_region_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr2_region_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_extract(omap44xx_emif_perf_cnt_cfg_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_insert(omap44xx_emif_perf_cnt_cfg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 31)));
}

static inline int omap44xx_emif_perf_cnt_cfg_prtval(char *_s, size_t _size, omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_cfg_prtval(char *_s, size_t _size, omap44xx_emif_perf_cnt_cfg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr1_cfg =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_pcfilter_prtval(_s + _r, _avail, omap44xx_emif_perf_cnt_cfg_cntr1_cfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Filter config. for perf. cntr. 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr1_region_en =\t%" PRIx8 "\t(Chip Select filter enable for Perf. cntr 1)\n", omap44xx_emif_perf_cnt_cfg_cntr1_region_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr1_mconnid_en =\t%" PRIx8 "\t(MConnID filter enable for perf. cntr. 1)\n", omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr2_cfg =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_pcfilter_prtval(_s + _r, _avail, omap44xx_emif_perf_cnt_cfg_cntr2_cfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Filter config. for perf. cntr. 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr2_region_en =\t%" PRIx8 "\t(Chip Select filter enable for Perf. cntr 2)\n", omap44xx_emif_perf_cnt_cfg_cntr2_region_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr2_mconnid_en =\t%" PRIx8 "\t(MConnID filter enable for perf. cntr. 2)\n", omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_perf_cnt_sel_t
 * Description: Implicit type of Perf. cntr. master reg. sel. register
 * Fields:
 *   region_sel1	(size 2, offset 0, init 0):	RW	MAddrSpace for perf. counter 1
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   mconnid1	(size 8, offset 8, init 0):	RW	MConnID for perf. counter 1
 *   region_sel2	(size 2, offset 16, init 0):	RW	MAddrSpace for perf. counter 2
 *   _anon18	(size 6, offset 18, init 0):	RSVD	_
 *   mconnid2	(size 8, offset 24, init 0):	RW	MConnID for perf. counter 2
 */
typedef uint32_t omap44xx_emif_perf_cnt_sel_t;
#define omap44xx_emif_perf_cnt_sel_default 0x0
static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel1_extract(omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel1_extract(omap44xx_emif_perf_cnt_sel_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_region_sel1_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_region_sel1_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid1_extract(omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid1_extract(omap44xx_emif_perf_cnt_sel_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_mconnid1_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_mconnid1_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel2_extract(omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel2_extract(omap44xx_emif_perf_cnt_sel_t _regval)
{
    return((uint8_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_region_sel2_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_region_sel2_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 16)));
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid2_extract(omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid2_extract(omap44xx_emif_perf_cnt_sel_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_mconnid2_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_mconnid2_insert(omap44xx_emif_perf_cnt_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 24)));
}

static inline int omap44xx_emif_perf_cnt_sel_prtval(char *_s, size_t _size, omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_sel_prtval(char *_s, size_t _size, omap44xx_emif_perf_cnt_sel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " region_sel1 =\t%" PRIx8 "\t(MAddrSpace for perf. counter 1)\n", omap44xx_emif_perf_cnt_sel_region_sel1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mconnid1 =\t%" PRIx8 "\t(MConnID for perf. counter 1)\n", omap44xx_emif_perf_cnt_sel_mconnid1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " region_sel2 =\t%" PRIx8 "\t(MAddrSpace for perf. counter 2)\n", omap44xx_emif_perf_cnt_sel_region_sel2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mconnid2 =\t%" PRIx8 "\t(MConnID for perf. counter 2)\n", omap44xx_emif_perf_cnt_sel_mconnid2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_read_idle_ctrl_t
 * Description: Implicit type of Read idle control register
 * Fields:
 *   read_idle_interval	(size 9, offset 0, init 0):	RW	Read idle interval
 *   _anon9	(size 7, offset 9, init 0):	RSVD	_
 *   read_idle_len	(size 4, offset 16, init 0):	RW	Min size of read idle window
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_read_idle_ctrl_t;
#define omap44xx_emif_read_idle_ctrl_default 0x0
static inline uint16_t omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(omap44xx_emif_read_idle_ctrl_t _regval)
{
    return((uint16_t )((_regval & 0x1ff) >> 0));
}

static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_read_idle_interval_insert(omap44xx_emif_read_idle_ctrl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_read_idle_interval_insert(omap44xx_emif_read_idle_ctrl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffe00) | (0x1ff & (((omap44xx_emif_read_idle_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_read_idle_ctrl_read_idle_len_extract(omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_read_idle_ctrl_read_idle_len_extract(omap44xx_emif_read_idle_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_read_idle_len_insert(omap44xx_emif_read_idle_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_read_idle_len_insert(omap44xx_emif_read_idle_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_emif_read_idle_ctrl_t )(_fieldval)) << 16)));
}

static inline int omap44xx_emif_read_idle_ctrl_prtval(char *_s, size_t _size, omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_read_idle_ctrl_prtval(char *_s, size_t _size, omap44xx_emif_read_idle_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_idle_interval =\t%" PRIx16 "\t(Read idle interval)\n", omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_idle_len =\t%" PRIx8 "\t(Min size of read idle window)\n", omap44xx_emif_read_idle_ctrl_read_idle_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_irq_l3_t
 * Description: L3 interrupt
 * Fields:
 *   err_sys	(size 1, offset 0, init 0):	NOATTR	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	NOATTR	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_irq_l3_t;
#define omap44xx_emif_irq_l3_default 0x0
static inline uint8_t omap44xx_emif_irq_l3_err_sys_extract(omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irq_l3_err_sys_extract(omap44xx_emif_irq_l3_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irq_l3_err_sys_insert(omap44xx_emif_irq_l3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irq_l3_err_sys_insert(omap44xx_emif_irq_l3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_irq_l3_ta_sys_extract(omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irq_l3_ta_sys_extract(omap44xx_emif_irq_l3_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irq_l3_ta_sys_insert(omap44xx_emif_irq_l3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irq_l3_ta_sys_insert(omap44xx_emif_irq_l3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1)));
}

static inline int omap44xx_emif_irq_l3_prtval(char *_s, size_t _size, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_irq_l3_prtval(char *_s, size_t _size, omap44xx_emif_irq_l3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_zq_config_t
 * Description: Implicit type of SDRAM output impedance calibration config register
 * Fields:
 *   refinterval	(size 16, offset 0, init 0):	RW	Num rfrsh periods between ZQCS commands
 *   zqcl_mult	(size 2, offset 16, init 0):	RW	Num ZQCS intervals in a ZQCL interval -1
 *   zqinit_mult	(size 2, offset 18, init 0):	RW	Num ZQCL intervals in a ZQINIT interval -1
 *   _anon20	(size 8, offset 20, init 0):	RSVD	_
 *   sfexiten	(size 1, offset 28, init 0):	RW	ZQCL on self-rfr., act. pwrdn, prchrge pwrdwn
 *   dualcalen	(size 1, offset 29, init 0):	RW	ZQ Dual Calibration enable
 *   cs0en	(size 1, offset 30, init 0):	RW	Enable ZQ calibration for CS0
 *   cs1en	(size 1, offset 31, init 0):	RW	Enable ZQ calibration for CS1
 */
typedef uint32_t omap44xx_emif_zq_config_t;
#define omap44xx_emif_zq_config_default 0x0
static inline uint16_t omap44xx_emif_zq_config_refinterval_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_zq_config_refinterval_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_refinterval_insert(omap44xx_emif_zq_config_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_refinterval_insert(omap44xx_emif_zq_config_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((omap44xx_emif_zq_config_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_zq_config_zqcl_mult_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_zqcl_mult_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint8_t )((_regval & 0x30000) >> 16));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_zqcl_mult_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_zqcl_mult_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 16)));
}

static inline uint8_t omap44xx_emif_zq_config_zqinit_mult_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_zqinit_mult_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint8_t )((_regval & 0xc0000) >> 18));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_zqinit_mult_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_zqinit_mult_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 18)));
}

static inline uint8_t omap44xx_emif_zq_config_sfexiten_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_sfexiten_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_sfexiten_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_sfexiten_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_emif_zq_config_dualcalen_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_dualcalen_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_dualcalen_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_dualcalen_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 29)));
}

static inline uint8_t omap44xx_emif_zq_config_cs0en_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_cs0en_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_cs0en_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_cs0en_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_emif_zq_config_cs1en_extract(omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_cs1en_extract(omap44xx_emif_zq_config_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_cs1en_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_cs1en_insert(omap44xx_emif_zq_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 31)));
}

static inline int omap44xx_emif_zq_config_prtval(char *_s, size_t _size, omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_zq_config_prtval(char *_s, size_t _size, omap44xx_emif_zq_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refinterval =\t%" PRIx16 "\t(Num rfrsh periods between ZQCS commands)\n", omap44xx_emif_zq_config_refinterval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqcl_mult =\t%" PRIx8 "\t(Num ZQCS intervals in a ZQCL interval -1)\n", omap44xx_emif_zq_config_zqcl_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqinit_mult =\t%" PRIx8 "\t(Num ZQCL intervals in a ZQINIT interval -1)\n", omap44xx_emif_zq_config_zqinit_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfexiten =\t%" PRIx8 "\t(ZQCL on self-rfr., act. pwrdn, prchrge pwrdwn)\n", omap44xx_emif_zq_config_sfexiten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dualcalen =\t%" PRIx8 "\t(ZQ Dual Calibration enable)\n", omap44xx_emif_zq_config_dualcalen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs0en =\t%" PRIx8 "\t(Enable ZQ calibration for CS0)\n", omap44xx_emif_zq_config_cs0en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs1en =\t%" PRIx8 "\t(Enable ZQ calibration for CS1)\n", omap44xx_emif_zq_config_cs1en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_temp_alert_config_t
 * Description: Implicit type of Temperature Alert Config register
 * Fields:
 *   refinterval	(size 22, offset 0, init 0):	RW	Num. refresh periods btw alert polls
 *   _anon22	(size 2, offset 22, init 0):	RSVD	_
 *   devcnt	(size 2, offset 24, init 0):	RW	#lanes w/ temp. monitoring device
 *   devwdt	(size 2, offset 26, init 0):	RW	Physical device width
 *   sfexiten	(size 1, offset 28, init 0):	RW	Poll on self-rfr., act. pwrdn, prchrge pwrdwn
 *   _anon29	(size 1, offset 29, init 0):	RSVD	_
 *   cs0en	(size 1, offset 30, init 0):	RW	Enables temperature alert polling for CS0
 *   cs1en	(size 1, offset 31, init 0):	RW	Enables temperature alert polling for CS1
 */
typedef uint32_t omap44xx_emif_temp_alert_config_t;
#define omap44xx_emif_temp_alert_config_default 0x0
static inline uint32_t omap44xx_emif_temp_alert_config_refinterval_extract(omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_temp_alert_config_refinterval_extract(omap44xx_emif_temp_alert_config_t _regval)
{
    return((uint32_t )((_regval & 0x3fffff) >> 0));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_refinterval_insert(omap44xx_emif_temp_alert_config_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_refinterval_insert(omap44xx_emif_temp_alert_config_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xffc00000) | (0x3fffff & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_temp_alert_config_devcnt_extract(omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_devcnt_extract(omap44xx_emif_temp_alert_config_t _regval)
{
    return((uint8_t )((_regval & 0x3000000) >> 24));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_devcnt_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_devcnt_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 24)));
}

static inline uint8_t omap44xx_emif_temp_alert_config_devwdt_extract(omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_devwdt_extract(omap44xx_emif_temp_alert_config_t _regval)
{
    return((uint8_t )((_regval & 0xc000000) >> 26));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_devwdt_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_devwdt_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 26)));
}

static inline uint8_t omap44xx_emif_temp_alert_config_sfexiten_extract(omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_sfexiten_extract(omap44xx_emif_temp_alert_config_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_sfexiten_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_sfexiten_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_emif_temp_alert_config_cs0en_extract(omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_cs0en_extract(omap44xx_emif_temp_alert_config_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_cs0en_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_cs0en_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_emif_temp_alert_config_cs1en_extract(omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_cs1en_extract(omap44xx_emif_temp_alert_config_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_cs1en_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_cs1en_insert(omap44xx_emif_temp_alert_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 31)));
}

static inline int omap44xx_emif_temp_alert_config_prtval(char *_s, size_t _size, omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_temp_alert_config_prtval(char *_s, size_t _size, omap44xx_emif_temp_alert_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refinterval =\t%" PRIx32 "\t(Num. refresh periods btw alert polls)\n", omap44xx_emif_temp_alert_config_refinterval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devcnt =\t%" PRIx8 "\t(#lanes w/ temp. monitoring device)\n", omap44xx_emif_temp_alert_config_devcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devwdt =\t%" PRIx8 "\t(Physical device width)\n", omap44xx_emif_temp_alert_config_devwdt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfexiten =\t%" PRIx8 "\t(Poll on self-rfr., act. pwrdn, prchrge pwrdwn)\n", omap44xx_emif_temp_alert_config_sfexiten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs0en =\t%" PRIx8 "\t(Enables temperature alert polling for CS0)\n", omap44xx_emif_temp_alert_config_cs0en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs1en =\t%" PRIx8 "\t(Enables temperature alert polling for CS1)\n", omap44xx_emif_temp_alert_config_cs1en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_l3_err_log_t
 * Description: Implicit type of Error log register
 * Fields:
 *   mconnid	(size 8, offset 0, init 0):	RO	Connection ID of 1st errored transaction
 *   mcmd	(size 3, offset 8, init 0):	RO	Cmd type of 1st errored transaction
 *   mburstseq	(size 3, offset 11, init 0):	RO	Addr mode of 1st errored transaction
 *   maddrspace	(size 2, offset 14, init 0):	RO	Addr spc of 1st errored transaction
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_l3_err_log_t;
#define omap44xx_emif_l3_err_log_default 0x0
static inline uint8_t omap44xx_emif_l3_err_log_mconnid_extract(omap44xx_emif_l3_err_log_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_err_log_mconnid_extract(omap44xx_emif_l3_err_log_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_mconnid_insert(omap44xx_emif_l3_err_log_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_mconnid_insert(omap44xx_emif_l3_err_log_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_emif_l3_err_log_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_l3_err_log_mcmd_extract(omap44xx_emif_l3_err_log_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_err_log_mcmd_extract(omap44xx_emif_l3_err_log_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_mcmd_insert(omap44xx_emif_l3_err_log_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_mcmd_insert(omap44xx_emif_l3_err_log_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_emif_l3_err_log_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_emif_l3_err_log_mburstseq_extract(omap44xx_emif_l3_err_log_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_err_log_mburstseq_extract(omap44xx_emif_l3_err_log_t _regval)
{
    return((uint8_t )((_regval & 0x3800) >> 11));
}

static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_mburstseq_insert(omap44xx_emif_l3_err_log_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_mburstseq_insert(omap44xx_emif_l3_err_log_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc7ff) | (0x3800 & (((omap44xx_emif_l3_err_log_t )(_fieldval)) << 11)));
}

static inline omap44xx_emif_err_spc_t omap44xx_emif_l3_err_log_maddrspace_extract(omap44xx_emif_l3_err_log_t _regval) __attribute__ ((always_inline));
static inline omap44xx_emif_err_spc_t omap44xx_emif_l3_err_log_maddrspace_extract(omap44xx_emif_l3_err_log_t _regval)
{
    return((omap44xx_emif_err_spc_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_maddrspace_insert(omap44xx_emif_l3_err_log_t _regval, omap44xx_emif_err_spc_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_maddrspace_insert(omap44xx_emif_l3_err_log_t _regval, omap44xx_emif_err_spc_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_emif_l3_err_log_t )(_fieldval)) << 14)));
}

static inline int omap44xx_emif_l3_err_log_prtval(char *_s, size_t _size, omap44xx_emif_l3_err_log_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_err_log_prtval(char *_s, size_t _size, omap44xx_emif_l3_err_log_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mconnid =\t%" PRIx8 "\t(Connection ID of 1st errored transaction)\n", omap44xx_emif_l3_err_log_mconnid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcmd =\t%" PRIx8 "\t(Cmd type of 1st errored transaction)\n", omap44xx_emif_l3_err_log_mcmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mburstseq =\t%" PRIx8 "\t(Addr mode of 1st errored transaction)\n", omap44xx_emif_l3_err_log_mburstseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maddrspace =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_err_spc_prtval(_s + _r, _avail, omap44xx_emif_l3_err_log_maddrspace_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addr spc of 1st errored transaction)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_emif_ddr_phy_ctrl_1_t
 * Description: Implicit type of DDR PHY control 1 register
 * Fields:
 *   read_latency	(size 4, offset 0, init 0):	RW	Read latency for the read data from SDRAM in DDR clock cycles
 *   dll_slave_dly_ctrl	(size 8, offset 4, init 0):	RW	DLL slave delay ratio control
 *   dll_master_sw_code_ctrl	(size 10, offset 12, init 0):	RW	DLL delay code when in software override mode
 *   freeze_delay_code_preamble	(size 4, offset 22, init 0):	RW	Preamble time respected by the DATA PHY
 *   freeze_delay_code_postamble	(size 4, offset 26, init 0):	RW	Postamble time respected by the DATA PHY
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_emif_ddr_phy_ctrl_1_t;
#define omap44xx_emif_ddr_phy_ctrl_1_default 0x0
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_read_latency_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_read_latency_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    return((uint8_t )((_regval & 0xff0) >> 4));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff00f) | (0xff0 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 4)));
}

static inline uint16_t omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    return((uint16_t )((_regval & 0x3ff000) >> 12));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffc00fff) | (0x3ff000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 12)));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    return((uint8_t )((_regval & 0x3c00000) >> 22));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfc3fffff) | (0x3c00000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 22)));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    return((uint8_t )((_regval & 0x3c000000) >> 26));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_insert(omap44xx_emif_ddr_phy_ctrl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xc3ffffff) | (0x3c000000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 26)));
}

static inline int omap44xx_emif_ddr_phy_ctrl_1_prtval(char *_s, size_t _size, omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_emif_ddr_phy_ctrl_1_prtval(char *_s, size_t _size, omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_latency =\t%" PRIx8 "\t(Read latency for the read data from SDRAM in DDR clock cycles)\n", omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_slave_dly_ctrl =\t%" PRIx8 "\t(DLL slave delay ratio control)\n", omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_master_sw_code_ctrl =\t%" PRIx16 "\t(DLL delay code when in software override mode)\n", omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freeze_delay_code_preamble =\t%" PRIx8 "\t(Preamble time respected by the DATA PHY)\n", omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freeze_delay_code_postamble =\t%" PRIx8 "\t(Postamble time respected by the DATA PHY)\n", omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_emif_initials {
    omap44xx_emif_mod_id_rev_initial = 0x0,
    omap44xx_emif_status_initial = 0x0,
    omap44xx_emif_sdram_config_initial = 0x0,
    omap44xx_emif_sdram_config2_initial = 0x0,
    omap44xx_emif_sdram_ref_ctrl_initial = 0x0,
    omap44xx_emif_sdram_ref_ctrl_shdw_initial = 0x0,
    omap44xx_emif_sdram_tim1_initial = 0x0,
    omap44xx_emif_sdram_tim1_shdw_initial = 0x0,
    omap44xx_emif_sdram_tim2_initial = 0x0,
    omap44xx_emif_sdram_tim2_shdw_initial = 0x0,
    omap44xx_emif_sdram_tim3_initial = 0x0,
    omap44xx_emif_sdram_tim3_shdw_initial = 0x0,
    omap44xx_emif_lpddr2_nvm_tim_initial = 0x0,
    omap44xx_emif_lpddr2_nvm_tim_shdw_initial = 0x0,
    omap44xx_emif_pwr_mgmt_ctrl_initial = 0x0,
    omap44xx_emif_pwr_mgmt_ctrl_shdw_initial = 0x0,
    omap44xx_emif_lpddr2_mode_reg_data_initial = 0x0,
    omap44xx_emif_lpddr2_mode_reg_cfg_initial = 0x0,
    omap44xx_emif_l3_config_initial = 0x0,
    omap44xx_emif_l3_cfg_val1_initial = 0x0,
    omap44xx_emif_l3_cfg_val2_initial = 0x0,
    omap44xx_emif_perf_cnt_1_initial = 0x0,
    omap44xx_emif_perf_cnt_2_initial = 0x0,
    omap44xx_emif_perf_cnt_cfg_initial = 0x0,
    omap44xx_emif_perf_cnt_sel_initial = 0x0,
    omap44xx_emif_perf_cnt_tim_initial = 0x0,
    omap44xx_emif_read_idle_ctrl_initial = 0x0,
    omap44xx_emif_read_idle_ctrl_shdw_initial = 0x0,
    omap44xx_emif_irqstatus_raw_sys_initial = 0x0,
    omap44xx_emif_irqstatus_raw_ll_initial = 0x0,
    omap44xx_emif_irqstatus_sys_initial = 0x0,
    omap44xx_emif_irqstatus_ll_initial = 0x0,
    omap44xx_emif_irqenable_set_sys_initial = 0x0,
    omap44xx_emif_irqenable_set_ll_initial = 0x0,
    omap44xx_emif_irqenable_clr_sys_initial = 0x0,
    omap44xx_emif_irqenable_clr_ll_initial = 0x0,
    omap44xx_emif_zq_config_initial = 0x0,
    omap44xx_emif_temp_alert_config_initial = 0x0,
    omap44xx_emif_l3_err_log_initial = 0x0,
    omap44xx_emif_ddr_phy_ctrl_1_initial = 0x0,
    omap44xx_emif_ddr_phy_ctrl_1_shdw_initial = 0x0,
    omap44xx_emif_ddr_phy_ctrl_2_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_emif_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_emif_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register mod_id_rev: Revision
 * Type: omap44xx_emif.uint32 (primitive type)
 */
static inline uint32_t omap44xx_emif_mod_id_rev_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_mod_id_rev_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t omap44xx_emif_mod_id_rev_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_mod_id_rev_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_emif_mod_id_rev_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_mod_id_rev_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register mod_id_rev is not writeable
static inline int omap44xx_emif_mod_id_rev_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_mod_id_rev_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mod_id_rev (Revision): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register status: SDRAM status
 * Type: omap44xx_emif.status (Implicit type of SDRAM status register)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   phy_dll_ready	(size 1, offset 2, init 0):	RO	DDR Phy ready
 *   _anon3	(size 26, offset 3, init 0):	MBZ	_
 *   fast_init	(size 1, offset 29, init 0):	RO	Fast initialization mode
 *   dual_clk	(size 1, offset 30, init 0):	RO	Dual Clock mode
 *   be	(size 1, offset 31, init 0):	RO	Big endian select for 8 and 16-bit devices
 */
static inline omap44xx_emif_status_t omap44xx_emif_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_status_t omap44xx_emif_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_emif_status_t omap44xx_emif_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_status_t omap44xx_emif_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_emif_status_rawwr(__DN(t) *_dev, omap44xx_emif_status_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_status_rawwr(__DN(t) *_dev, omap44xx_emif_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

// Register status is not writeable
static inline int omap44xx_emif_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_status_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register status (SDRAM status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_dll_ready =\t%" PRIx8 "\t(DDR Phy ready)\n", omap44xx_emif_status_phy_dll_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fast_init =\t%" PRIx8 "\t(Fast initialization mode)\n", omap44xx_emif_status_fast_init_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dual_clk =\t%" PRIx8 "\t(Dual Clock mode)\n", omap44xx_emif_status_dual_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Big endian select for 8 and 16-bit devices)\n", omap44xx_emif_status_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_emif_status_phy_dll_ready_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_phy_dll_ready_rdf(__DN(t) *_dev)
{
    omap44xx_emif_status_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_emif_status_phy_dll_ready_extract(_regval));
}

static inline uint8_t omap44xx_emif_status_fast_init_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_fast_init_rdf(__DN(t) *_dev)
{
    omap44xx_emif_status_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_emif_status_fast_init_extract(_regval));
}

static inline uint8_t omap44xx_emif_status_dual_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_dual_clk_rdf(__DN(t) *_dev)
{
    omap44xx_emif_status_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_emif_status_dual_clk_extract(_regval));
}

static inline uint8_t omap44xx_emif_status_be_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_status_be_rdf(__DN(t) *_dev)
{
    omap44xx_emif_status_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_emif_status_be_extract(_regval));
}

/*
 * Register sdram_config: SDRAM config
 * Type: omap44xx_emif.sdram_config (Implicit type of SDRAM config register)
 *   pagesize	(size 3, offset 0, init 0):	RW	Page size (add 9 for # column bits)
 *   ebank	(size 1, offset 3, init 0):	RW	External chip select setup
 *   ibank	(size 3, offset 4, init 0):	RW	Internal bank setup: (1<<x) banks
 *   rowsize	(size 3, offset 7, init 0):	RW	Row size (add 9 for # row bits)
 *   cl	(size 4, offset 10, init 0):	RW	CAS latency
 *   narrow_mode	(size 2, offset 14, init 0):	RW	SDRAM data bus width
 *   _anon16	(size 11, offset 16, init 0):	RSVD	_
 *   ibank_pos	(size 2, offset 27, init 0):	RW	Internal bank position
 *   sdram_type	(size 3, offset 29, init 0):	RW	SDRAM type
 */
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config_t omap44xx_emif_sdram_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_emif_sdram_config_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_config_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void omap44xx_emif_sdram_config_wr(__DN(t) *_dev, omap44xx_emif_sdram_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_wr(__DN(t) *_dev, omap44xx_emif_sdram_config_t _regval)
{
    _regval = (_regval & 0xf800ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7ff0000 & mackerel_read_addr_32(_dev->base, 0x8)));
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int omap44xx_emif_sdram_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_config (SDRAM config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pagesize =\t%" PRIx8 "\t(Page size (add 9 for # column bits))\n", omap44xx_emif_sdram_config_pagesize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ebank =\t%" PRIx8 "\t(External chip select setup)\n", omap44xx_emif_sdram_config_ebank_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibank =\t%" PRIx8 "\t(Internal bank setup: (1<<x) banks)\n", omap44xx_emif_sdram_config_ibank_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rowsize =\t%" PRIx8 "\t(Row size (add 9 for # row bits))\n", omap44xx_emif_sdram_config_rowsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cl =\t%" PRIx8 "\t(CAS latency)\n", omap44xx_emif_sdram_config_cl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " narrow_mode =\t%" PRIx8 "\t(SDRAM data bus width)\n", omap44xx_emif_sdram_config_narrow_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibank_pos =\t%" PRIx8 "\t(Internal bank position)\n", omap44xx_emif_sdram_config_ibank_pos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdram_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_type_prtval(_s + _r, _avail, omap44xx_emif_sdram_config_sdram_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SDRAM type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_config_pagesize_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_pagesize_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_pagesize_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config_ebank_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_ebank_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_ebank_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config_ibank_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_ibank_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_ibank_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config_rowsize_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_rowsize_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_rowsize_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config_cl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_cl_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_cl_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config_narrow_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_narrow_mode_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_narrow_mode_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config_ibank_pos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config_ibank_pos_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_ibank_pos_extract(_regval));
}

static inline omap44xx_emif_sdram_type_t omap44xx_emif_sdram_config_sdram_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_type_t omap44xx_emif_sdram_config_sdram_type_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_emif_sdram_config_sdram_type_extract(_regval));
}

static inline void omap44xx_emif_sdram_config_pagesize_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_pagesize_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0x7 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_ebank_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_ebank_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0x8 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_ibank_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_ibank_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0x70 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff8f & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_rowsize_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_rowsize_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0x380 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffffc7f & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_cl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_cl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0x3c00 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 10);
    _regval = (_regval | (0xffffc3ff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_narrow_mode_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_narrow_mode_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0xc000 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffff3fff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_ibank_pos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_ibank_pos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0x18000000 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 27);
    _regval = (_regval | (0xe7ffffff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config_sdram_type_wrf(__DN(t) *_dev, omap44xx_emif_sdram_type_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config_sdram_type_wrf(__DN(t) *_dev, omap44xx_emif_sdram_type_t _fieldval)
{
    omap44xx_emif_sdram_config_t _regval = 0xe0000000 & (((omap44xx_emif_sdram_config_t )(_fieldval)) << 29);
    _regval = (_regval | (0x1fffffff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_config2: SDRAM config 2
 * Type: omap44xx_emif.sdram_config2 (Implicit type of SDRAM config 2 register)
 *   rdbsize	(size 3, offset 0, init 0):	RW	Row data buffer size 32(1<<x) bytes
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   rdbnum	(size 2, offset 4, init 0):	RW	Row buffer setup (1<<x) row buffers
 *   _anon6	(size 21, offset 6, init 0):	RSVD	_
 *   ebank_pos	(size 1, offset 27, init 0):	RW	External bank position
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   cs1nvmen	(size 1, offset 30, init 0):	RW	CS1 LPDDR2-NVM enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_config2_t omap44xx_emif_sdram_config2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void omap44xx_emif_sdram_config2_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config2_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_config2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void omap44xx_emif_sdram_config2_wr(__DN(t) *_dev, omap44xx_emif_sdram_config2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config2_wr(__DN(t) *_dev, omap44xx_emif_sdram_config2_t _regval)
{
    _regval = (_regval & 0x48000037);
    // No MB1 fields present
    _regval = (_regval | (0xb7ffffc8 & mackerel_read_addr_32(_dev->base, 0xc)));
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int omap44xx_emif_sdram_config2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_config2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_config2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_config2 (SDRAM config 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdbsize =\t%" PRIx8 "\t(Row data buffer size 32(1<<x) bytes)\n", omap44xx_emif_sdram_config2_rdbsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdbnum =\t%" PRIx8 "\t(Row buffer setup (1<<x) row buffers)\n", omap44xx_emif_sdram_config2_rdbnum_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ebank_pos =\t%" PRIx8 "\t(External bank position)\n", omap44xx_emif_sdram_config2_ebank_pos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs1nvmen =\t%" PRIx8 "\t(CS1 LPDDR2-NVM enable)\n", omap44xx_emif_sdram_config2_cs1nvmen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_config2_rdbsize_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_rdbsize_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_emif_sdram_config2_rdbsize_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config2_rdbnum_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_rdbnum_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_emif_sdram_config2_rdbnum_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config2_ebank_pos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_ebank_pos_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_emif_sdram_config2_ebank_pos_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_config2_cs1nvmen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_config2_cs1nvmen_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_config2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_emif_sdram_config2_cs1nvmen_extract(_regval));
}

static inline void omap44xx_emif_sdram_config2_rdbsize_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config2_rdbsize_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config2_t _regval = 0x7 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config2_rdbnum_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config2_rdbnum_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config2_t _regval = 0x30 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffcf & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config2_ebank_pos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config2_ebank_pos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config2_t _regval = 0x8000000 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7ffffff & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_config2_cs1nvmen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_config2_cs1nvmen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_config2_t _regval = 0x40000000 & (((omap44xx_emif_sdram_config2_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_ref_ctrl: SDRAM refresh control
 * Type: omap44xx_emif.sdram_ref_ctrl (Implicit type of SDRAM refresh control register)
 *   refresh_rate	(size 16, offset 0, init 0):	RW	Refresh rate
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   initref_dis	(size 1, offset 31, init 0):	RW	Initialization and refresh disable
 */
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_emif_sdram_ref_ctrl_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_emif_sdram_ref_ctrl_wr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_wr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x10)));
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_emif_sdram_ref_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_ref_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_ref_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_ref_ctrl (SDRAM refresh control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refresh_rate =\t%" PRIx16 "\t(Refresh rate)\n", omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " initref_dis =\t%" PRIx8 "\t(Initialization and refresh disable)\n", omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t omap44xx_emif_sdram_ref_ctrl_refresh_rate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_ref_ctrl_refresh_rate_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_ref_ctrl_initref_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_ref_ctrl_initref_dis_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(_regval));
}

static inline void omap44xx_emif_sdram_ref_ctrl_refresh_rate_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_refresh_rate_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = 0xffff & (((omap44xx_emif_sdram_ref_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_ref_ctrl_initref_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_initref_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = 0x80000000 & (((omap44xx_emif_sdram_ref_ctrl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_ref_ctrl_shdw: SDRAM refresh control shadow
 * Type: omap44xx_emif.sdram_ref_ctrl (Implicit type of SDRAM refresh control register)
 *   refresh_rate	(size 16, offset 0, init 0):	RW	Refresh rate
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   initref_dis	(size 1, offset 31, init 0):	RW	Initialization and refresh disable
 */
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_ref_ctrl_t omap44xx_emif_sdram_ref_ctrl_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_emif_sdram_ref_ctrl_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void omap44xx_emif_sdram_ref_ctrl_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_ref_ctrl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x14)));
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int omap44xx_emif_sdram_ref_ctrl_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_ref_ctrl_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_ref_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_ref_ctrl_shdw (SDRAM refresh control shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refresh_rate =\t%" PRIx16 "\t(Refresh rate)\n", omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " initref_dis =\t%" PRIx8 "\t(Initialization and refresh disable)\n", omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t omap44xx_emif_sdram_ref_ctrl_shdw_refresh_rate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_ref_ctrl_shdw_refresh_rate_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_emif_sdram_ref_ctrl_refresh_rate_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_ref_ctrl_shdw_initref_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_ref_ctrl_shdw_initref_dis_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_emif_sdram_ref_ctrl_initref_dis_extract(_regval));
}

static inline void omap44xx_emif_sdram_ref_ctrl_shdw_refresh_rate_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_shdw_refresh_rate_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = 0xffff & (((omap44xx_emif_sdram_ref_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_ref_ctrl_shdw_initref_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_ref_ctrl_shdw_initref_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_ref_ctrl_t _regval = 0x80000000 & (((omap44xx_emif_sdram_ref_ctrl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_tim1: SDRAM timing 1
 * Type: omap44xx_emif.sdram_tim1 (Implicit type of SDRAM timing 1 register)
 *   wtr	(size 3, offset 0, init 0):	RW	Minimum #DDR clocks last write to read
 *   rrd	(size 3, offset 3, init 0):	RW	Minimum #DDR clocks act. to act. other bank
 *   rc	(size 6, offset 6, init 0):	RW	Minimum #DDR clocks activate to activate
 *   ras	(size 5, offset 12, init 0):	RW	Minimum #DDR clocks activate to precharge
 *   wr	(size 4, offset 17, init 0):	RW	Minimum #DDR clocks write to precharge
 *   rcd	(size 4, offset 21, init 0):	RW	Minimum #DDR clocks activate to r or w
 *   rp	(size 4, offset 25, init 0):	RW	Minimum #DDR clocks precharge to act. or ref.
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void omap44xx_emif_sdram_tim1_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void omap44xx_emif_sdram_tim1_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval)
{
    _regval = (_regval & 0x1fffffff);
    // No MB1 fields present
    _regval = (_regval | (0xe0000000 & mackerel_read_addr_32(_dev->base, 0x18)));
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int omap44xx_emif_sdram_tim1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_tim1 (SDRAM timing 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wtr =\t%" PRIx8 "\t(Minimum #DDR clocks last write to read)\n", omap44xx_emif_sdram_tim1_wtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrd =\t%" PRIx8 "\t(Minimum #DDR clocks act. to act. other bank)\n", omap44xx_emif_sdram_tim1_rrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rc =\t%" PRIx8 "\t(Minimum #DDR clocks activate to activate)\n", omap44xx_emif_sdram_tim1_rc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ras =\t%" PRIx8 "\t(Minimum #DDR clocks activate to precharge)\n", omap44xx_emif_sdram_tim1_ras_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wr =\t%" PRIx8 "\t(Minimum #DDR clocks write to precharge)\n", omap44xx_emif_sdram_tim1_wr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcd =\t%" PRIx8 "\t(Minimum #DDR clocks activate to r or w)\n", omap44xx_emif_sdram_tim1_rcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rp =\t%" PRIx8 "\t(Minimum #DDR clocks precharge to act. or ref.)\n", omap44xx_emif_sdram_tim1_rp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_tim1_wtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_wtr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_wtr_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rrd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rrd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_rrd_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rc_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_rc_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_ras_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_ras_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_ras_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_wr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_wr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_wr_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rcd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_rcd_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_rp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_rp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_emif_sdram_tim1_rp_extract(_regval));
}

static inline void omap44xx_emif_sdram_tim1_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x7 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x38 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_rc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_rc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0xfc0 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffff03f & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_ras_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_ras_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1f000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfffe0fff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_wr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_wr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1e0000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 17);
    _regval = (_regval | (0xffe1ffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_rcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_rcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1e00000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfe1fffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_rp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_rp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1e000000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 25);
    _regval = (_regval | (0xe1ffffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_tim1_shdw: SDRAM timing 1 shadow
 * Type: omap44xx_emif.sdram_tim1 (Implicit type of SDRAM timing 1 register)
 *   wtr	(size 3, offset 0, init 0):	RW	Minimum #DDR clocks last write to read
 *   rrd	(size 3, offset 3, init 0):	RW	Minimum #DDR clocks act. to act. other bank
 *   rc	(size 6, offset 6, init 0):	RW	Minimum #DDR clocks activate to activate
 *   ras	(size 5, offset 12, init 0):	RW	Minimum #DDR clocks activate to precharge
 *   wr	(size 4, offset 17, init 0):	RW	Minimum #DDR clocks write to precharge
 *   rcd	(size 4, offset 21, init 0):	RW	Minimum #DDR clocks activate to r or w
 *   rp	(size 4, offset 25, init 0):	RW	Minimum #DDR clocks precharge to act. or ref.
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim1_t omap44xx_emif_sdram_tim1_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void omap44xx_emif_sdram_tim1_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void omap44xx_emif_sdram_tim1_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim1_t _regval)
{
    _regval = (_regval & 0x1fffffff);
    // No MB1 fields present
    _regval = (_regval | (0xe0000000 & mackerel_read_addr_32(_dev->base, 0x1c)));
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int omap44xx_emif_sdram_tim1_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim1_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_tim1_shdw (SDRAM timing 1 shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wtr =\t%" PRIx8 "\t(Minimum #DDR clocks last write to read)\n", omap44xx_emif_sdram_tim1_wtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrd =\t%" PRIx8 "\t(Minimum #DDR clocks act. to act. other bank)\n", omap44xx_emif_sdram_tim1_rrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rc =\t%" PRIx8 "\t(Minimum #DDR clocks activate to activate)\n", omap44xx_emif_sdram_tim1_rc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ras =\t%" PRIx8 "\t(Minimum #DDR clocks activate to precharge)\n", omap44xx_emif_sdram_tim1_ras_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wr =\t%" PRIx8 "\t(Minimum #DDR clocks write to precharge)\n", omap44xx_emif_sdram_tim1_wr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcd =\t%" PRIx8 "\t(Minimum #DDR clocks activate to r or w)\n", omap44xx_emif_sdram_tim1_rcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rp =\t%" PRIx8 "\t(Minimum #DDR clocks precharge to act. or ref.)\n", omap44xx_emif_sdram_tim1_rp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_wtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_wtr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_wtr_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rrd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rrd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_rrd_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rc_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_rc_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_ras_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_ras_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_ras_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_wr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_wr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_wr_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rcd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_rcd_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim1_shdw_rp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim1_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_emif_sdram_tim1_rp_extract(_regval));
}

static inline void omap44xx_emif_sdram_tim1_shdw_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x7 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_shdw_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x38 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_shdw_rc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_rc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0xfc0 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffff03f & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_shdw_ras_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_ras_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1f000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfffe0fff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_shdw_wr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_wr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1e0000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 17);
    _regval = (_regval | (0xffe1ffff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_shdw_rcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_rcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1e00000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfe1fffff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim1_shdw_rp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim1_shdw_rp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim1_t _regval = 0x1e000000 & (((omap44xx_emif_sdram_tim1_t )(_fieldval)) << 25);
    _regval = (_regval | (0xe1ffffff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_tim2: SDRAM timing 2
 * Type: omap44xx_emif.sdram_tim2 (Implicit type of SDRAM timing 2 register)
 *   cke	(size 3, offset 0, init 0):	RW	Minimum #DDR clocks between pad_cke_o changes
 *   rtp	(size 3, offset 3, init 0):	RW	Minimum #DDR clocks last read to precharge
 *   xsrd	(size 10, offset 6, init 0):	RW	Minimum #DDR clocks self-refresh to read
 *   xsnr	(size 9, offset 16, init 0):	RW	Minimum #DDR clocks self-refresh to non-read
 *   _anon25	(size 3, offset 25, init 0):	RSVD	_
 *   xp	(size 3, offset 28, init 0):	RW	Minimum #DDR clocks powerdown to non-read
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void omap44xx_emif_sdram_tim2_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void omap44xx_emif_sdram_tim2_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval)
{
    _regval = (_regval & 0x71ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x8e000000 & mackerel_read_addr_32(_dev->base, 0x20)));
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int omap44xx_emif_sdram_tim2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_tim2 (SDRAM timing 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cke =\t%" PRIx8 "\t(Minimum #DDR clocks between pad_cke_o changes)\n", omap44xx_emif_sdram_tim2_cke_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtp =\t%" PRIx8 "\t(Minimum #DDR clocks last read to precharge)\n", omap44xx_emif_sdram_tim2_rtp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xsrd =\t%" PRIx16 "\t(Minimum #DDR clocks self-refresh to read)\n", omap44xx_emif_sdram_tim2_xsrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xsnr =\t%" PRIx16 "\t(Minimum #DDR clocks self-refresh to non-read)\n", omap44xx_emif_sdram_tim2_xsnr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xp =\t%" PRIx8 "\t(Minimum #DDR clocks powerdown to non-read)\n", omap44xx_emif_sdram_tim2_xp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_tim2_cke_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_cke_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_emif_sdram_tim2_cke_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim2_rtp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_rtp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_emif_sdram_tim2_rtp_extract(_regval));
}

static inline uint16_t omap44xx_emif_sdram_tim2_xsrd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim2_xsrd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_emif_sdram_tim2_xsrd_extract(_regval));
}

static inline uint16_t omap44xx_emif_sdram_tim2_xsnr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim2_xsnr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_emif_sdram_tim2_xsnr_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim2_xp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_xp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_emif_sdram_tim2_xp_extract(_regval));
}

static inline void omap44xx_emif_sdram_tim2_cke_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_cke_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x7 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_rtp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_rtp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x38 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_xsrd_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_xsrd_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0xffc0 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffff003f & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_xsnr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_xsnr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x1ff0000 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfe00ffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_xp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_xp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x70000000 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 28);
    _regval = (_regval | (0x8fffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_tim2_shdw: SDRAM timing 2 shadow
 * Type: omap44xx_emif.sdram_tim2 (Implicit type of SDRAM timing 2 register)
 *   cke	(size 3, offset 0, init 0):	RW	Minimum #DDR clocks between pad_cke_o changes
 *   rtp	(size 3, offset 3, init 0):	RW	Minimum #DDR clocks last read to precharge
 *   xsrd	(size 10, offset 6, init 0):	RW	Minimum #DDR clocks self-refresh to read
 *   xsnr	(size 9, offset 16, init 0):	RW	Minimum #DDR clocks self-refresh to non-read
 *   _anon25	(size 3, offset 25, init 0):	RSVD	_
 *   xp	(size 3, offset 28, init 0):	RW	Minimum #DDR clocks powerdown to non-read
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim2_t omap44xx_emif_sdram_tim2_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void omap44xx_emif_sdram_tim2_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void omap44xx_emif_sdram_tim2_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim2_t _regval)
{
    _regval = (_regval & 0x71ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x8e000000 & mackerel_read_addr_32(_dev->base, 0x24)));
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int omap44xx_emif_sdram_tim2_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim2_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_tim2_shdw (SDRAM timing 2 shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cke =\t%" PRIx8 "\t(Minimum #DDR clocks between pad_cke_o changes)\n", omap44xx_emif_sdram_tim2_cke_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtp =\t%" PRIx8 "\t(Minimum #DDR clocks last read to precharge)\n", omap44xx_emif_sdram_tim2_rtp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xsrd =\t%" PRIx16 "\t(Minimum #DDR clocks self-refresh to read)\n", omap44xx_emif_sdram_tim2_xsrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xsnr =\t%" PRIx16 "\t(Minimum #DDR clocks self-refresh to non-read)\n", omap44xx_emif_sdram_tim2_xsnr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xp =\t%" PRIx8 "\t(Minimum #DDR clocks powerdown to non-read)\n", omap44xx_emif_sdram_tim2_xp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_tim2_shdw_cke_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_shdw_cke_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_emif_sdram_tim2_cke_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim2_shdw_rtp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_shdw_rtp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_emif_sdram_tim2_rtp_extract(_regval));
}

static inline uint16_t omap44xx_emif_sdram_tim2_shdw_xsrd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim2_shdw_xsrd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_emif_sdram_tim2_xsrd_extract(_regval));
}

static inline uint16_t omap44xx_emif_sdram_tim2_shdw_xsnr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim2_shdw_xsnr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_emif_sdram_tim2_xsnr_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim2_shdw_xp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim2_shdw_xp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_emif_sdram_tim2_xp_extract(_regval));
}

static inline void omap44xx_emif_sdram_tim2_shdw_cke_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_cke_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x7 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_shdw_rtp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_rtp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x38 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_shdw_xsrd_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_xsrd_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0xffc0 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffff003f & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_shdw_xsnr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_xsnr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x1ff0000 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfe00ffff & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim2_shdw_xp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim2_shdw_xp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim2_t _regval = 0x70000000 & (((omap44xx_emif_sdram_tim2_t )(_fieldval)) << 28);
    _regval = (_regval | (0x8fffffff & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_tim3: SDRAM timing 3
 * Type: omap44xx_emif.sdram_tim3 (Implicit type of SDRAM timing 3 register)
 *   ras_max	(size 4, offset 0, init 0):	RW	Maximum #interfaces from act. to precharge
 *   rfc	(size 9, offset 4, init 0):	RW	Minimum #DDR clocks from ref/ld to ref/act.
 *   tdqsckmax	(size 2, offset 13, init 0):	RW	#DDR clocks that satisfies tDQSCKmax
 *   zqcs	(size 6, offset 15, init 0):	RW	#DDR clocks a ZQCS command
 *   ckesr	(size 3, offset 21, init 0):	RW	Minimum #DDR clocks LPDDR2 in self-refresh
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_emif_sdram_tim3_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_emif_sdram_tim3_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval)
{
    _regval = (_regval & 0xffffff);
    // No MB1 fields present
    _regval = (_regval | (0xff000000 & mackerel_read_addr_32(_dev->base, 0x28)));
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_emif_sdram_tim3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_tim3 (SDRAM timing 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ras_max =\t%" PRIx8 "\t(Maximum #interfaces from act. to precharge)\n", omap44xx_emif_sdram_tim3_ras_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfc =\t%" PRIx16 "\t(Minimum #DDR clocks from ref/ld to ref/act.)\n", omap44xx_emif_sdram_tim3_rfc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdqsckmax =\t%" PRIx8 "\t(#DDR clocks that satisfies tDQSCKmax)\n", omap44xx_emif_sdram_tim3_tdqsckmax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqcs =\t%" PRIx8 "\t(#DDR clocks a ZQCS command)\n", omap44xx_emif_sdram_tim3_zqcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ckesr =\t%" PRIx8 "\t(Minimum #DDR clocks LPDDR2 in self-refresh)\n", omap44xx_emif_sdram_tim3_ckesr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_tim3_ras_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_ras_max_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_emif_sdram_tim3_ras_max_extract(_regval));
}

static inline uint16_t omap44xx_emif_sdram_tim3_rfc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim3_rfc_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_emif_sdram_tim3_rfc_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim3_tdqsckmax_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_tdqsckmax_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_emif_sdram_tim3_tdqsckmax_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim3_zqcs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_zqcs_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_emif_sdram_tim3_zqcs_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim3_ckesr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_ckesr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_emif_sdram_tim3_ckesr_extract(_regval));
}

static inline void omap44xx_emif_sdram_tim3_ras_max_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_ras_max_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0xf & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_rfc_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_rfc_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0x1ff0 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffe00f & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_tdqsckmax_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_tdqsckmax_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0x6000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffff9fff & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_zqcs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_zqcs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0x1f8000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffe07fff & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_ckesr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_ckesr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0xe00000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 21);
    _regval = (_regval | (0xff1fffff & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register sdram_tim3_shdw: SDRAM timing 3 shadow
 * Type: omap44xx_emif.sdram_tim3 (Implicit type of SDRAM timing 3 register)
 *   ras_max	(size 4, offset 0, init 0):	RW	Maximum #interfaces from act. to precharge
 *   rfc	(size 9, offset 4, init 0):	RW	Minimum #DDR clocks from ref/ld to ref/act.
 *   tdqsckmax	(size 2, offset 13, init 0):	RW	#DDR clocks that satisfies tDQSCKmax
 *   zqcs	(size 6, offset 15, init 0):	RW	#DDR clocks a ZQCS command
 *   ckesr	(size 3, offset 21, init 0):	RW	Minimum #DDR clocks LPDDR2 in self-refresh
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_sdram_tim3_t omap44xx_emif_sdram_tim3_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void omap44xx_emif_sdram_tim3_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void omap44xx_emif_sdram_tim3_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_wr(__DN(t) *_dev, omap44xx_emif_sdram_tim3_t _regval)
{
    _regval = (_regval & 0xffffff);
    // No MB1 fields present
    _regval = (_regval | (0xff000000 & mackerel_read_addr_32(_dev->base, 0x2c)));
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int omap44xx_emif_sdram_tim3_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_sdram_tim3_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sdram_tim3_shdw (SDRAM timing 3 shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ras_max =\t%" PRIx8 "\t(Maximum #interfaces from act. to precharge)\n", omap44xx_emif_sdram_tim3_ras_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfc =\t%" PRIx16 "\t(Minimum #DDR clocks from ref/ld to ref/act.)\n", omap44xx_emif_sdram_tim3_rfc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdqsckmax =\t%" PRIx8 "\t(#DDR clocks that satisfies tDQSCKmax)\n", omap44xx_emif_sdram_tim3_tdqsckmax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqcs =\t%" PRIx8 "\t(#DDR clocks a ZQCS command)\n", omap44xx_emif_sdram_tim3_zqcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ckesr =\t%" PRIx8 "\t(Minimum #DDR clocks LPDDR2 in self-refresh)\n", omap44xx_emif_sdram_tim3_ckesr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_sdram_tim3_shdw_ras_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_shdw_ras_max_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_emif_sdram_tim3_ras_max_extract(_regval));
}

static inline uint16_t omap44xx_emif_sdram_tim3_shdw_rfc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_sdram_tim3_shdw_rfc_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_emif_sdram_tim3_rfc_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim3_shdw_tdqsckmax_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_shdw_tdqsckmax_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_emif_sdram_tim3_tdqsckmax_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim3_shdw_zqcs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_shdw_zqcs_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_emif_sdram_tim3_zqcs_extract(_regval));
}

static inline uint8_t omap44xx_emif_sdram_tim3_shdw_ckesr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_sdram_tim3_shdw_ckesr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_sdram_tim3_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_emif_sdram_tim3_ckesr_extract(_regval));
}

static inline void omap44xx_emif_sdram_tim3_shdw_ras_max_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_ras_max_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0xf & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_shdw_rfc_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_rfc_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0x1ff0 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffe00f & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_shdw_tdqsckmax_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_tdqsckmax_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0x6000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffff9fff & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_shdw_zqcs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_zqcs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0x1f8000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffe07fff & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_sdram_tim3_shdw_ckesr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_sdram_tim3_shdw_ckesr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_sdram_tim3_t _regval = 0xe00000 & (((omap44xx_emif_sdram_tim3_t )(_fieldval)) << 21);
    _regval = (_regval | (0xff1fffff & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register lpddr2_nvm_tim: LPDDR2-NVM timing
 * Type: omap44xx_emif.lpddr2_nvm_tim (Implicit type of LPDDR2-NVM timing register)
 *   rcdmin	(size 8, offset 0, init 0):	RW	Minimum #DDR clocks activate to r/w
 *   rrd	(size 8, offset 8, init 0):	RW	Minimum #DDR clocks act. to act. other bank.
 *   wra	(size 4, offset 16, init 0):	RW	Minimum #DDR clocks last write to activate
 *   rp	(size 4, offset 20, init 0):	RW	Minimum #DDR clocks preactive to activate
 *   wtr	(size 3, offset 24, init 0):	RW	Minimum #DDR clocks last write to read
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   xp	(size 3, offset 28, init 0):	RW	Minimum #DDR clocks from powerdown
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_emif_lpddr2_nvm_tim_rawwr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_rawwr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_emif_lpddr2_nvm_tim_wr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_wr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    _regval = (_regval & 0x77ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x88000000 & mackerel_read_addr_32(_dev->base, 0x30)));
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_emif_lpddr2_nvm_tim_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_lpddr2_nvm_tim_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lpddr2_nvm_tim (LPDDR2-NVM timing): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcdmin =\t%" PRIx8 "\t(Minimum #DDR clocks activate to r/w)\n", omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrd =\t%" PRIx8 "\t(Minimum #DDR clocks act. to act. other bank.)\n", omap44xx_emif_lpddr2_nvm_tim_rrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wra =\t%" PRIx8 "\t(Minimum #DDR clocks last write to activate)\n", omap44xx_emif_lpddr2_nvm_tim_wra_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rp =\t%" PRIx8 "\t(Minimum #DDR clocks preactive to activate)\n", omap44xx_emif_lpddr2_nvm_tim_rp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wtr =\t%" PRIx8 "\t(Minimum #DDR clocks last write to read)\n", omap44xx_emif_lpddr2_nvm_tim_wtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xp =\t%" PRIx8 "\t(Minimum #DDR clocks from powerdown)\n", omap44xx_emif_lpddr2_nvm_tim_xp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rcdmin_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rcdmin_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rrd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rrd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_emif_lpddr2_nvm_tim_rrd_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wra_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wra_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_emif_lpddr2_nvm_tim_wra_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_rp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_emif_lpddr2_nvm_tim_rp_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_wtr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_emif_lpddr2_nvm_tim_wtr_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_xp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_xp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_emif_lpddr2_nvm_tim_xp_extract(_regval));
}

static inline void omap44xx_emif_lpddr2_nvm_tim_rcdmin_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_rcdmin_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xff & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xff00 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_wra_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_wra_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xf0000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_rp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_rp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xf00000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 20);
    _regval = (_regval | (0xff0fffff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0x7000000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf8ffffff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_xp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_xp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0x70000000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 28);
    _regval = (_regval | (0x8fffffff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register lpddr2_nvm_tim_shdw: LPDDR2-NVM timing shadow
 * Type: omap44xx_emif.lpddr2_nvm_tim (Implicit type of LPDDR2-NVM timing register)
 *   rcdmin	(size 8, offset 0, init 0):	RW	Minimum #DDR clocks activate to r/w
 *   rrd	(size 8, offset 8, init 0):	RW	Minimum #DDR clocks act. to act. other bank.
 *   wra	(size 4, offset 16, init 0):	RW	Minimum #DDR clocks last write to activate
 *   rp	(size 4, offset 20, init 0):	RW	Minimum #DDR clocks preactive to activate
 *   wtr	(size 3, offset 24, init 0):	RW	Minimum #DDR clocks last write to read
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   xp	(size 3, offset 28, init 0):	RW	Minimum #DDR clocks from powerdown
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_nvm_tim_t omap44xx_emif_lpddr2_nvm_tim_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_wr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_wr(__DN(t) *_dev, omap44xx_emif_lpddr2_nvm_tim_t _regval)
{
    _regval = (_regval & 0x77ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x88000000 & mackerel_read_addr_32(_dev->base, 0x34)));
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int omap44xx_emif_lpddr2_nvm_tim_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_lpddr2_nvm_tim_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lpddr2_nvm_tim_shdw (LPDDR2-NVM timing shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcdmin =\t%" PRIx8 "\t(Minimum #DDR clocks activate to r/w)\n", omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrd =\t%" PRIx8 "\t(Minimum #DDR clocks act. to act. other bank.)\n", omap44xx_emif_lpddr2_nvm_tim_rrd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wra =\t%" PRIx8 "\t(Minimum #DDR clocks last write to activate)\n", omap44xx_emif_lpddr2_nvm_tim_wra_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rp =\t%" PRIx8 "\t(Minimum #DDR clocks preactive to activate)\n", omap44xx_emif_lpddr2_nvm_tim_rp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wtr =\t%" PRIx8 "\t(Minimum #DDR clocks last write to read)\n", omap44xx_emif_lpddr2_nvm_tim_wtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xp =\t%" PRIx8 "\t(Minimum #DDR clocks from powerdown)\n", omap44xx_emif_lpddr2_nvm_tim_xp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_rcdmin_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_rcdmin_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_emif_lpddr2_nvm_tim_rcdmin_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_rrd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_rrd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_emif_lpddr2_nvm_tim_rrd_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_wra_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_wra_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_emif_lpddr2_nvm_tim_wra_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_rp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_rp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_emif_lpddr2_nvm_tim_rp_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_wtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_wtr_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_emif_lpddr2_nvm_tim_wtr_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_xp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_nvm_tim_shdw_xp_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_emif_lpddr2_nvm_tim_xp_extract(_regval));
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rcdmin_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rcdmin_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xff & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rrd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xff00 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_wra_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_wra_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xf0000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_rp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0xf00000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 20);
    _regval = (_regval | (0xff0fffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_wtr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0x7000000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf8ffffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_xp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_nvm_tim_shdw_xp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_nvm_tim_t _regval = 0x70000000 & (((omap44xx_emif_lpddr2_nvm_tim_t )(_fieldval)) << 28);
    _regval = (_regval | (0x8fffffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

/*
 * Register pwr_mgmt_ctrl: Power management control
 * Type: omap44xx_emif.pwr_mgmt_ctrl (Implicit type of Power management control register)
 *   cs_tim	(size 4, offset 0, init 0):	RW	Power mangement timer for clock stop
 *   sr_tim	(size 4, offset 4, init 0):	RW	Power mangement timer for self refresh
 *   lp_mode	(size 3, offset 8, init 0):	RW	Automatic power management enable
 *   dpd_en	(size 1, offset 11, init 0):	RW	Deep power down enable
 *   pd_tim	(size 4, offset 12, init 0):	RW	Power mangement timer for power-down
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_rawwr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_rawwr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_wr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_wr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x38)));
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int omap44xx_emif_pwr_mgmt_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_pwr_mgmt_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pwr_mgmt_ctrl (Power management control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs_tim =\t%" PRIx8 "\t(Power mangement timer for clock stop)\n", omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_tim =\t%" PRIx8 "\t(Power mangement timer for self refresh)\n", omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lp_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_apm_mode_prtval(_s + _r, _avail, omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Automatic power management enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpd_en =\t%" PRIx8 "\t(Deep power down enable)\n", omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pd_tim =\t%" PRIx8 "\t(Power mangement timer for power-down)\n", omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_cs_tim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_cs_tim_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(_regval));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_sr_tim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_sr_tim_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(_regval));
}

static inline omap44xx_emif_apm_mode_t omap44xx_emif_pwr_mgmt_ctrl_lp_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_apm_mode_t omap44xx_emif_pwr_mgmt_ctrl_lp_mode_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(_regval));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_dpd_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_dpd_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(_regval));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_pd_tim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_pd_tim_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(_regval));
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_cs_tim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_cs_tim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0xf & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_sr_tim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_sr_tim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0xf0 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff0f & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_lp_mode_wrf(__DN(t) *_dev, omap44xx_emif_apm_mode_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_lp_mode_wrf(__DN(t) *_dev, omap44xx_emif_apm_mode_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0x700 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff8ff & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_dpd_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_dpd_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0x800 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_pd_tim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_pd_tim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0xf000 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffff0fff & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register pwr_mgmt_ctrl_shdw: Power management control shadow
 * Type: omap44xx_emif.pwr_mgmt_ctrl (Implicit type of Power management control register)
 *   cs_tim	(size 4, offset 0, init 0):	RW	Power mangement timer for clock stop
 *   sr_tim	(size 4, offset 4, init 0):	RW	Power mangement timer for self refresh
 *   lp_mode	(size 3, offset 8, init 0):	RW	Automatic power management enable
 *   dpd_en	(size 1, offset 11, init 0):	RW	Deep power down enable
 *   pd_tim	(size 4, offset 12, init 0):	RW	Power mangement timer for power-down
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_pwr_mgmt_ctrl_t omap44xx_emif_pwr_mgmt_ctrl_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_wr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_wr(__DN(t) *_dev, omap44xx_emif_pwr_mgmt_ctrl_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x3c)));
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline int omap44xx_emif_pwr_mgmt_ctrl_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_pwr_mgmt_ctrl_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pwr_mgmt_ctrl_shdw (Power management control shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs_tim =\t%" PRIx8 "\t(Power mangement timer for clock stop)\n", omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_tim =\t%" PRIx8 "\t(Power mangement timer for self refresh)\n", omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lp_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_apm_mode_prtval(_s + _r, _avail, omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Automatic power management enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpd_en =\t%" PRIx8 "\t(Deep power down enable)\n", omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pd_tim =\t%" PRIx8 "\t(Power mangement timer for power-down)\n", omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_cs_tim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_cs_tim_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_emif_pwr_mgmt_ctrl_cs_tim_extract(_regval));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_sr_tim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_sr_tim_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_emif_pwr_mgmt_ctrl_sr_tim_extract(_regval));
}

static inline omap44xx_emif_apm_mode_t omap44xx_emif_pwr_mgmt_ctrl_shdw_lp_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_apm_mode_t omap44xx_emif_pwr_mgmt_ctrl_shdw_lp_mode_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_emif_pwr_mgmt_ctrl_lp_mode_extract(_regval));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_dpd_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_dpd_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_emif_pwr_mgmt_ctrl_dpd_en_extract(_regval));
}

static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_pd_tim_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_pwr_mgmt_ctrl_shdw_pd_tim_rdf(__DN(t) *_dev)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_emif_pwr_mgmt_ctrl_pd_tim_extract(_regval));
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_cs_tim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_cs_tim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0xf & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_sr_tim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_sr_tim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0xf0 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff0f & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_lp_mode_wrf(__DN(t) *_dev, omap44xx_emif_apm_mode_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_lp_mode_wrf(__DN(t) *_dev, omap44xx_emif_apm_mode_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0x700 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff8ff & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_dpd_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_dpd_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0x800 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_pd_tim_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_pwr_mgmt_ctrl_shdw_pd_tim_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_pwr_mgmt_ctrl_t _regval = 0xf000 & (((omap44xx_emif_pwr_mgmt_ctrl_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffff0fff & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

/*
 * Register lpddr2_mode_reg_data: LPDDR2 mode register data
 * Type: omap44xx_emif.uint32 (primitive type)
 */
static inline uint32_t omap44xx_emif_lpddr2_mode_reg_data_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_lpddr2_mode_reg_data_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline uint32_t omap44xx_emif_lpddr2_mode_reg_data_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_lpddr2_mode_reg_data_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_emif_lpddr2_mode_reg_data_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_data_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_emif_lpddr2_mode_reg_data_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_data_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_emif_lpddr2_mode_reg_data_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_lpddr2_mode_reg_data_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lpddr2_mode_reg_data (LPDDR2 mode register data): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register lpddr2_mode_reg_cfg: LPDDR2 mode register config
 * Type: omap44xx_emif.lpddr2_mode_reg_cfg (Implicit type of LPDDR2 mode register config register)
 *   address	(size 8, offset 0, init 0):	RW	Mode register address
 *   _anon8	(size 22, offset 8, init 0):	RSVD	_
 *   refresh_en	(size 1, offset 30, init 0):	RW	Refresh Enable after MRW write
 *   cs	(size 1, offset 31, init 0):	RW	Chip select to issue mode register command
 */
static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_lpddr2_mode_reg_cfg_t omap44xx_emif_lpddr2_mode_reg_cfg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void omap44xx_emif_lpddr2_mode_reg_cfg_rawwr(__DN(t) *_dev, omap44xx_emif_lpddr2_mode_reg_cfg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_cfg_rawwr(__DN(t) *_dev, omap44xx_emif_lpddr2_mode_reg_cfg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void omap44xx_emif_lpddr2_mode_reg_cfg_wr(__DN(t) *_dev, omap44xx_emif_lpddr2_mode_reg_cfg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_cfg_wr(__DN(t) *_dev, omap44xx_emif_lpddr2_mode_reg_cfg_t _regval)
{
    _regval = (_regval & 0xc00000ff);
    // No MB1 fields present
    _regval = (_regval | (0x3fffff00 & mackerel_read_addr_32(_dev->base, 0x50)));
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int omap44xx_emif_lpddr2_mode_reg_cfg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_lpddr2_mode_reg_cfg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lpddr2_mode_reg_cfg (LPDDR2 mode register config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Mode register address)\n", omap44xx_emif_lpddr2_mode_reg_cfg_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refresh_en =\t%" PRIx8 "\t(Refresh Enable after MRW write)\n", omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs =\t%" PRIx8 "\t(Chip select to issue mode register command)\n", omap44xx_emif_lpddr2_mode_reg_cfg_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_address_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_emif_lpddr2_mode_reg_cfg_address_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_extract(_regval));
}

static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_cs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_lpddr2_mode_reg_cfg_cs_rdf(__DN(t) *_dev)
{
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_emif_lpddr2_mode_reg_cfg_cs_extract(_regval));
}

static inline void omap44xx_emif_lpddr2_mode_reg_cfg_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_cfg_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = 0xff & (((omap44xx_emif_lpddr2_mode_reg_cfg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_cfg_refresh_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = 0x40000000 & (((omap44xx_emif_lpddr2_mode_reg_cfg_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_lpddr2_mode_reg_cfg_cs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_lpddr2_mode_reg_cfg_cs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_lpddr2_mode_reg_cfg_t _regval = 0x80000000 & (((omap44xx_emif_lpddr2_mode_reg_cfg_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register l3_config: L3 configuration
 * Type: omap44xx_emif.l3_config (Implicit type of L3 configuration register)
 *   pr_old_count	(size 8, offset 0, init 0):	RW	Priority raise old counter
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 *   ll_thresh_max	(size 4, offset 16, init 0):	RW	Low-latency L3 threshold maximum
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   sys_thresh_max	(size 4, offset 24, init 0):	RW	System L3 threshold maximum
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_config_t omap44xx_emif_l3_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline void omap44xx_emif_l3_config_rawwr(__DN(t) *_dev, omap44xx_emif_l3_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_config_rawwr(__DN(t) *_dev, omap44xx_emif_l3_config_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline void omap44xx_emif_l3_config_wr(__DN(t) *_dev, omap44xx_emif_l3_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_config_wr(__DN(t) *_dev, omap44xx_emif_l3_config_t _regval)
{
    _regval = (_regval & 0xf0f00ff);
    // No MB1 fields present
    _regval = (_regval | (0xf0f0ff00 & mackerel_read_addr_32(_dev->base, 0x54)));
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline int omap44xx_emif_l3_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_l3_config_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register l3_config (L3 configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr_old_count =\t%" PRIx8 "\t(Priority raise old counter)\n", omap44xx_emif_l3_config_pr_old_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ll_thresh_max =\t%" PRIx8 "\t(Low-latency L3 threshold maximum)\n", omap44xx_emif_l3_config_ll_thresh_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_thresh_max =\t%" PRIx8 "\t(System L3 threshold maximum)\n", omap44xx_emif_l3_config_sys_thresh_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_l3_config_pr_old_count_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_config_pr_old_count_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_config_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_emif_l3_config_pr_old_count_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_config_ll_thresh_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_config_ll_thresh_max_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_config_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_emif_l3_config_ll_thresh_max_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_config_sys_thresh_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_config_sys_thresh_max_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_config_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_emif_l3_config_sys_thresh_max_extract(_regval));
}

static inline void omap44xx_emif_l3_config_pr_old_count_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_config_pr_old_count_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_l3_config_t _regval = 0xff & (((omap44xx_emif_l3_config_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_l3_config_ll_thresh_max_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_config_ll_thresh_max_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_l3_config_t _regval = 0xf0000 & (((omap44xx_emif_l3_config_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_l3_config_sys_thresh_max_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_config_sys_thresh_max_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_l3_config_t _regval = 0xf000000 & (((omap44xx_emif_l3_config_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf0ffffff & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

/*
 * Register l3_cfg_val1: L3 config value 1
 * Type: omap44xx_emif.l3_cfg_val1 (Implicit type of L3 config value 1 register)
 *   cmd_fifo_depth	(size 8, offset 0, init 0):	RO	Command FIFO depth
 *   wr_fifo_depth	(size 8, offset 8, init 0):	RO	Write data FIFO depth
 *   _anon16	(size 12, offset 16, init 0):	MBZ	_
 *   ll_bus_width	(size 2, offset 28, init 0):	RO	Low-latency L3 data bus width 32*(1<<x)
 *   sys_bus_width	(size 2, offset 30, init 0):	RO	System L3 data bus width 32*(1<<x) bits
 */
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val1_t omap44xx_emif_l3_cfg_val1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline void omap44xx_emif_l3_cfg_val1_rawwr(__DN(t) *_dev, omap44xx_emif_l3_cfg_val1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_cfg_val1_rawwr(__DN(t) *_dev, omap44xx_emif_l3_cfg_val1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

// Register l3_cfg_val1 is not writeable
static inline int omap44xx_emif_l3_cfg_val1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_cfg_val1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_l3_cfg_val1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register l3_cfg_val1 (L3 config value 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd_fifo_depth =\t%" PRIx8 "\t(Command FIFO depth)\n", omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wr_fifo_depth =\t%" PRIx8 "\t(Write data FIFO depth)\n", omap44xx_emif_l3_cfg_val1_wr_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ll_bus_width =\t%" PRIx8 "\t(Low-latency L3 data bus width 32*(1<<x))\n", omap44xx_emif_l3_cfg_val1_ll_bus_width_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_bus_width =\t%" PRIx8 "\t(System L3 data bus width 32*(1<<x) bits)\n", omap44xx_emif_l3_cfg_val1_sys_bus_width_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_emif_l3_cfg_val1_cmd_fifo_depth_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_wr_fifo_depth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_wr_fifo_depth_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_emif_l3_cfg_val1_wr_fifo_depth_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_ll_bus_width_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_ll_bus_width_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_emif_l3_cfg_val1_ll_bus_width_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_cfg_val1_sys_bus_width_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val1_sys_bus_width_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_emif_l3_cfg_val1_sys_bus_width_extract(_regval));
}

/*
 * Register l3_cfg_val2: L3 config value 2
 * Type: omap44xx_emif.l3_cfg_val2 (Implicit type of L3 config value 2 register)
 *   rcmd_fifo_depth	(size 8, offset 0, init 0):	RO	Read command FIFO depth
 *   rsd_fifo_depth	(size 8, offset 8, init 0):	RO	SDRAM read data FIFO depth
 *   rreg_fifo_depth	(size 8, offset 16, init 0):	RO	Register Read Data FIFO depth
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_cfg_val2_t omap44xx_emif_l3_cfg_val2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline void omap44xx_emif_l3_cfg_val2_rawwr(__DN(t) *_dev, omap44xx_emif_l3_cfg_val2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_cfg_val2_rawwr(__DN(t) *_dev, omap44xx_emif_l3_cfg_val2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

// Register l3_cfg_val2 is not writeable
static inline int omap44xx_emif_l3_cfg_val2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_cfg_val2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_l3_cfg_val2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register l3_cfg_val2 (L3 config value 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcmd_fifo_depth =\t%" PRIx8 "\t(Read command FIFO depth)\n", omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsd_fifo_depth =\t%" PRIx8 "\t(SDRAM read data FIFO depth)\n", omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rreg_fifo_depth =\t%" PRIx8 "\t(Register Read Data FIFO depth)\n", omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_emif_l3_cfg_val2_rcmd_fifo_depth_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_emif_l3_cfg_val2_rsd_fifo_depth_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_cfg_val2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_emif_l3_cfg_val2_rreg_fifo_depth_extract(_regval));
}

/*
 * Register perf_cnt_1: Perf. counter 1
 * Type: omap44xx_emif.uint32 (primitive type)
 */
static inline uint32_t omap44xx_emif_perf_cnt_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_perf_cnt_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline uint32_t omap44xx_emif_perf_cnt_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_perf_cnt_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline void omap44xx_emif_perf_cnt_1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

// Register perf_cnt_1 is not writeable
static inline int omap44xx_emif_perf_cnt_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register perf_cnt_1 (Perf. counter 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register perf_cnt_2: Perf. counter 2
 * Type: omap44xx_emif.uint32 (primitive type)
 */
static inline uint32_t omap44xx_emif_perf_cnt_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_perf_cnt_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x84));
}

static inline uint32_t omap44xx_emif_perf_cnt_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_perf_cnt_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x84));
}

static inline void omap44xx_emif_perf_cnt_2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
}

// Register perf_cnt_2 is not writeable
static inline int omap44xx_emif_perf_cnt_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x84);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register perf_cnt_2 (Perf. counter 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register perf_cnt_cfg: Perf. cntr. config
 * Type: omap44xx_emif.perf_cnt_cfg (Implicit type of Perf. cntr. config register)
 *   cntr1_cfg	(size 4, offset 0, init 0):	RW	Filter config. for perf. cntr. 1
 *   _anon4	(size 10, offset 4, init 0):	RSVD	_
 *   cntr1_region_en	(size 1, offset 14, init 0):	RW	Chip Select filter enable for Perf. cntr 1
 *   cntr1_mconnid_en	(size 1, offset 15, init 0):	RW	MConnID filter enable for perf. cntr. 1
 *   cntr2_cfg	(size 4, offset 16, init 0):	RW	Filter config. for perf. cntr. 2
 *   _anon20	(size 10, offset 20, init 0):	RSVD	_
 *   cntr2_region_en	(size 1, offset 30, init 0):	RW	Chip Select filter enable for Perf. cntr 2
 *   cntr2_mconnid_en	(size 1, offset 31, init 0):	RW	MConnID filter enable for perf. cntr. 2
 */
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x88));
}

static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_cfg_t omap44xx_emif_perf_cnt_cfg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x88));
}

static inline void omap44xx_emif_perf_cnt_cfg_rawwr(__DN(t) *_dev, omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_rawwr(__DN(t) *_dev, omap44xx_emif_perf_cnt_cfg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
}

static inline void omap44xx_emif_perf_cnt_cfg_wr(__DN(t) *_dev, omap44xx_emif_perf_cnt_cfg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_wr(__DN(t) *_dev, omap44xx_emif_perf_cnt_cfg_t _regval)
{
    _regval = (_regval & 0xc00fc00f);
    // No MB1 fields present
    _regval = (_regval | (0x3ff03ff0 & mackerel_read_addr_32(_dev->base, 0x88)));
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
}

static inline int omap44xx_emif_perf_cnt_cfg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_cfg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register perf_cnt_cfg (Perf. cntr. config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr1_cfg =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_pcfilter_prtval(_s + _r, _avail, omap44xx_emif_perf_cnt_cfg_cntr1_cfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Filter config. for perf. cntr. 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr1_region_en =\t%" PRIx8 "\t(Chip Select filter enable for Perf. cntr 1)\n", omap44xx_emif_perf_cnt_cfg_cntr1_region_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr1_mconnid_en =\t%" PRIx8 "\t(MConnID filter enable for perf. cntr. 1)\n", omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr2_cfg =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_pcfilter_prtval(_s + _r, _avail, omap44xx_emif_perf_cnt_cfg_cntr2_cfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Filter config. for perf. cntr. 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr2_region_en =\t%" PRIx8 "\t(Chip Select filter enable for Perf. cntr 2)\n", omap44xx_emif_perf_cnt_cfg_cntr2_region_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cntr2_mconnid_en =\t%" PRIx8 "\t(MConnID filter enable for perf. cntr. 2)\n", omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr1_cfg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr1_cfg_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_emif_perf_cnt_cfg_cntr1_cfg_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_region_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_region_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_emif_perf_cnt_cfg_cntr1_region_en_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_extract(_regval));
}

static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr2_cfg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_pcfilter_t omap44xx_emif_perf_cnt_cfg_cntr2_cfg_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_emif_perf_cnt_cfg_cntr2_cfg_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_region_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_region_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_emif_perf_cnt_cfg_cntr2_region_en_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_extract(_regval));
}

static inline void omap44xx_emif_perf_cnt_cfg_cntr1_cfg_wrf(__DN(t) *_dev, omap44xx_emif_pcfilter_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_cntr1_cfg_wrf(__DN(t) *_dev, omap44xx_emif_pcfilter_t _fieldval)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = 0xf & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_cfg_cntr1_region_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_cntr1_region_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = 0x4000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_cntr1_mconnid_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = 0x8000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_cfg_cntr2_cfg_wrf(__DN(t) *_dev, omap44xx_emif_pcfilter_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_cntr2_cfg_wrf(__DN(t) *_dev, omap44xx_emif_pcfilter_t _fieldval)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = 0xf0000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_cfg_cntr2_region_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_cntr2_region_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = 0x40000000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_cfg_cntr2_mconnid_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_cfg_t _regval = 0x80000000 & (((omap44xx_emif_perf_cnt_cfg_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

/*
 * Register perf_cnt_sel: Perf. cntr. master reg. sel.
 * Type: omap44xx_emif.perf_cnt_sel (Implicit type of Perf. cntr. master reg. sel. register)
 *   region_sel1	(size 2, offset 0, init 0):	RW	MAddrSpace for perf. counter 1
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   mconnid1	(size 8, offset 8, init 0):	RW	MConnID for perf. counter 1
 *   region_sel2	(size 2, offset 16, init 0):	RW	MAddrSpace for perf. counter 2
 *   _anon18	(size 6, offset 18, init 0):	RSVD	_
 *   mconnid2	(size 8, offset 24, init 0):	RW	MConnID for perf. counter 2
 */
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8c));
}

static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_perf_cnt_sel_t omap44xx_emif_perf_cnt_sel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8c));
}

static inline void omap44xx_emif_perf_cnt_sel_rawwr(__DN(t) *_dev, omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_sel_rawwr(__DN(t) *_dev, omap44xx_emif_perf_cnt_sel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
}

static inline void omap44xx_emif_perf_cnt_sel_wr(__DN(t) *_dev, omap44xx_emif_perf_cnt_sel_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_sel_wr(__DN(t) *_dev, omap44xx_emif_perf_cnt_sel_t _regval)
{
    _regval = (_regval & 0xff03ff03);
    // No MB1 fields present
    _regval = (_regval | (0xfc00fc & mackerel_read_addr_32(_dev->base, 0x8c)));
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
}

static inline int omap44xx_emif_perf_cnt_sel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_sel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_perf_cnt_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register perf_cnt_sel (Perf. cntr. master reg. sel.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " region_sel1 =\t%" PRIx8 "\t(MAddrSpace for perf. counter 1)\n", omap44xx_emif_perf_cnt_sel_region_sel1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mconnid1 =\t%" PRIx8 "\t(MConnID for perf. counter 1)\n", omap44xx_emif_perf_cnt_sel_mconnid1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " region_sel2 =\t%" PRIx8 "\t(MAddrSpace for perf. counter 2)\n", omap44xx_emif_perf_cnt_sel_region_sel2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mconnid2 =\t%" PRIx8 "\t(MConnID for perf. counter 2)\n", omap44xx_emif_perf_cnt_sel_mconnid2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel1_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    return(omap44xx_emif_perf_cnt_sel_region_sel1_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid1_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    return(omap44xx_emif_perf_cnt_sel_mconnid1_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_region_sel2_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    return(omap44xx_emif_perf_cnt_sel_region_sel2_extract(_regval));
}

static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_perf_cnt_sel_mconnid2_rdf(__DN(t) *_dev)
{
    omap44xx_emif_perf_cnt_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    return(omap44xx_emif_perf_cnt_sel_mconnid2_extract(_regval));
}

static inline void omap44xx_emif_perf_cnt_sel_region_sel1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_sel_region_sel1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_sel_t _regval = 0x3 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x8c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_sel_mconnid1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_sel_mconnid1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_sel_t _regval = 0xff00 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x8c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_sel_region_sel2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_sel_region_sel2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_sel_t _regval = 0x30000 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffcffff & mackerel_read_addr_32(_dev->base, 0x8c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_perf_cnt_sel_mconnid2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_sel_mconnid2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_perf_cnt_sel_t _regval = 0xff000000 & (((omap44xx_emif_perf_cnt_sel_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x8c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
    // No shadow register to write to
}

/*
 * Register perf_cnt_tim: Perf. counter time
 * Type: omap44xx_emif.uint32 (primitive type)
 */
static inline uint32_t omap44xx_emif_perf_cnt_tim_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_perf_cnt_tim_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline uint32_t omap44xx_emif_perf_cnt_tim_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_perf_cnt_tim_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline void omap44xx_emif_perf_cnt_tim_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_perf_cnt_tim_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
}

// Register perf_cnt_tim is not writeable
static inline int omap44xx_emif_perf_cnt_tim_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_perf_cnt_tim_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register perf_cnt_tim (Perf. counter time): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register read_idle_ctrl: Read idle control
 * Type: omap44xx_emif.read_idle_ctrl (Implicit type of Read idle control register)
 *   read_idle_interval	(size 9, offset 0, init 0):	RW	Read idle interval
 *   _anon9	(size 7, offset 9, init 0):	RSVD	_
 *   read_idle_len	(size 4, offset 16, init 0):	RW	Min size of read idle window
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x98));
}

static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x98));
}

static inline void omap44xx_emif_read_idle_ctrl_rawwr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_rawwr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
}

static inline void omap44xx_emif_read_idle_ctrl_wr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_wr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval)
{
    _regval = (_regval & 0xf01ff);
    // No MB1 fields present
    _regval = (_regval | (0xfff0fe00 & mackerel_read_addr_32(_dev->base, 0x98)));
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
}

static inline int omap44xx_emif_read_idle_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_read_idle_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_read_idle_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x98);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register read_idle_ctrl (Read idle control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_idle_interval =\t%" PRIx16 "\t(Read idle interval)\n", omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_idle_len =\t%" PRIx8 "\t(Min size of read idle window)\n", omap44xx_emif_read_idle_ctrl_read_idle_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_emif_read_idle_ctrl_read_idle_interval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_read_idle_ctrl_read_idle_interval_rdf(__DN(t) *_dev)
{
    omap44xx_emif_read_idle_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x98);
    return(omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(_regval));
}

static inline uint8_t omap44xx_emif_read_idle_ctrl_read_idle_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_read_idle_ctrl_read_idle_len_rdf(__DN(t) *_dev)
{
    omap44xx_emif_read_idle_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x98);
    return(omap44xx_emif_read_idle_ctrl_read_idle_len_extract(_regval));
}

static inline void omap44xx_emif_read_idle_ctrl_read_idle_interval_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_read_idle_interval_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_read_idle_ctrl_t _regval = 0x1ff & (((omap44xx_emif_read_idle_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffe00 & mackerel_read_addr_32(_dev->base, 0x98)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_read_idle_ctrl_read_idle_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_read_idle_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_read_idle_ctrl_t _regval = 0xf0000 & (((omap44xx_emif_read_idle_ctrl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x98)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
    // No shadow register to write to
}

/*
 * Register read_idle_ctrl_shdw: Read idle control shadow
 * Type: omap44xx_emif.read_idle_ctrl (Implicit type of Read idle control register)
 *   read_idle_interval	(size 9, offset 0, init 0):	RW	Read idle interval
 *   _anon9	(size 7, offset 9, init 0):	RSVD	_
 *   read_idle_len	(size 4, offset 16, init 0):	RW	Min size of read idle window
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9c));
}

static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_read_idle_ctrl_t omap44xx_emif_read_idle_ctrl_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9c));
}

static inline void omap44xx_emif_read_idle_ctrl_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
}

static inline void omap44xx_emif_read_idle_ctrl_shdw_wr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_shdw_wr(__DN(t) *_dev, omap44xx_emif_read_idle_ctrl_t _regval)
{
    _regval = (_regval & 0xf01ff);
    // No MB1 fields present
    _regval = (_regval | (0xfff0fe00 & mackerel_read_addr_32(_dev->base, 0x9c)));
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
}

static inline int omap44xx_emif_read_idle_ctrl_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_read_idle_ctrl_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_read_idle_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register read_idle_ctrl_shdw (Read idle control shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_idle_interval =\t%" PRIx16 "\t(Read idle interval)\n", omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_idle_len =\t%" PRIx8 "\t(Min size of read idle window)\n", omap44xx_emif_read_idle_ctrl_read_idle_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_emif_read_idle_ctrl_shdw_read_idle_interval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_read_idle_ctrl_shdw_read_idle_interval_rdf(__DN(t) *_dev)
{
    omap44xx_emif_read_idle_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    return(omap44xx_emif_read_idle_ctrl_read_idle_interval_extract(_regval));
}

static inline uint8_t omap44xx_emif_read_idle_ctrl_shdw_read_idle_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_read_idle_ctrl_shdw_read_idle_len_rdf(__DN(t) *_dev)
{
    omap44xx_emif_read_idle_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    return(omap44xx_emif_read_idle_ctrl_read_idle_len_extract(_regval));
}

static inline void omap44xx_emif_read_idle_ctrl_shdw_read_idle_interval_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_shdw_read_idle_interval_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_read_idle_ctrl_t _regval = 0x1ff & (((omap44xx_emif_read_idle_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffe00 & mackerel_read_addr_32(_dev->base, 0x9c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_read_idle_ctrl_shdw_read_idle_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_read_idle_ctrl_shdw_read_idle_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_read_idle_ctrl_t _regval = 0xf0000 & (((omap44xx_emif_read_idle_ctrl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x9c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
    // No shadow register to write to
}

/*
 * Register irqstatus_raw_sys: System L3 interrupt raw status
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_sys_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_sys_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_sys_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_sys_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline void omap44xx_emif_irqstatus_raw_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

static inline void omap44xx_emif_irqstatus_raw_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xa4)));
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

static inline int omap44xx_emif_irqstatus_raw_sys_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqstatus_raw_sys_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_raw_sys (System L3 interrupt raw status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqstatus_raw_sys_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_raw_sys_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqstatus_raw_sys_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_raw_sys_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqstatus_raw_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqstatus_raw_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

/*
 * Register irqstatus_raw_ll: Low-latency L3 interrupt raw status
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_ll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_ll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa8));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_ll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_raw_ll_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa8));
}

static inline void omap44xx_emif_irqstatus_raw_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
}

static inline void omap44xx_emif_irqstatus_raw_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xa8)));
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
}

static inline int omap44xx_emif_irqstatus_raw_ll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqstatus_raw_ll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_raw_ll (Low-latency L3 interrupt raw status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqstatus_raw_ll_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_raw_ll_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqstatus_raw_ll_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_raw_ll_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqstatus_raw_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xa8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqstatus_raw_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_raw_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xa8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
    // No shadow register to write to
}

/*
 * Register irqstatus_sys: System L3 interrupt status
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_sys_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_sys_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xac));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_sys_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_sys_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xac));
}

static inline void omap44xx_emif_irqstatus_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
}

static inline void omap44xx_emif_irqstatus_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xac)));
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
}

static inline int omap44xx_emif_irqstatus_sys_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqstatus_sys_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_sys (System L3 interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqstatus_sys_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_sys_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqstatus_sys_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_sys_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqstatus_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xac)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqstatus_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xac)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
    // No shadow register to write to
}

/*
 * Register irqstatus_ll: Low-latency L3 interrupt status
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_ll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_ll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb0));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_ll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqstatus_ll_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb0));
}

static inline void omap44xx_emif_irqstatus_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
}

static inline void omap44xx_emif_irqstatus_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xb0)));
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
}

static inline int omap44xx_emif_irqstatus_ll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqstatus_ll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqstatus_ll (Low-latency L3 interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqstatus_ll_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_ll_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb0);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqstatus_ll_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqstatus_ll_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb0);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqstatus_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xb0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqstatus_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqstatus_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xb0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
    // No shadow register to write to
}

/*
 * Register irqenable_set_sys: System L3 interrupt enable set
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_sys_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_sys_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb4));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_sys_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_sys_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb4));
}

static inline void omap44xx_emif_irqenable_set_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xb4, _regval);
}

static inline void omap44xx_emif_irqenable_set_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xb4)));
    mackerel_write_addr_32(_dev->base, 0xb4, _regval);
}

static inline int omap44xx_emif_irqenable_set_sys_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqenable_set_sys_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqenable_set_sys (System L3 interrupt enable set): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqenable_set_sys_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_set_sys_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb4);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqenable_set_sys_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_set_sys_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb4);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqenable_set_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xb4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqenable_set_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xb4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb4, _regval);
    // No shadow register to write to
}

/*
 * Register irqenable_set_ll: Low-latency L3 interrupt enable set
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_ll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_ll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb8));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_ll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_set_ll_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb8));
}

static inline void omap44xx_emif_irqenable_set_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
}

static inline void omap44xx_emif_irqenable_set_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xb8)));
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
}

static inline int omap44xx_emif_irqenable_set_ll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqenable_set_ll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqenable_set_ll (Low-latency L3 interrupt enable set): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqenable_set_ll_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_set_ll_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqenable_set_ll_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_set_ll_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqenable_set_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xb8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqenable_set_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_set_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xb8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
    // No shadow register to write to
}

/*
 * Register irqenable_clr_sys: System L3 interrupt enable clear
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_sys_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_sys_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xbc));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_sys_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_sys_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xbc));
}

static inline void omap44xx_emif_irqenable_clr_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_sys_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
}

static inline void omap44xx_emif_irqenable_clr_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_sys_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xbc)));
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
}

static inline int omap44xx_emif_irqenable_clr_sys_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqenable_clr_sys_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqenable_clr_sys (System L3 interrupt enable clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqenable_clr_sys_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_clr_sys_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqenable_clr_sys_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_clr_sys_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqenable_clr_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_sys_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xbc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqenable_clr_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_sys_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xbc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
    // No shadow register to write to
}

/*
 * Register irqenable_clr_ll: Low-latency L3 interrupt enable clear
 * Type: omap44xx_emif.irq_l3 (L3 interrupt)
 *   err_sys	(size 1, offset 0, init 0):	RW	Command or address error.
 *   ta_sys	(size 1, offset 1, init 0):	RW	SDRAM temperature alert.
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_ll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_ll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc0));
}

static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_ll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_irq_l3_t omap44xx_emif_irqenable_clr_ll_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc0));
}

static inline void omap44xx_emif_irqenable_clr_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_ll_rawwr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc0, _regval);
}

static inline void omap44xx_emif_irqenable_clr_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_ll_wr(__DN(t) *_dev, omap44xx_emif_irq_l3_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xc0)));
    mackerel_write_addr_32(_dev->base, 0xc0, _regval);
}

static inline int omap44xx_emif_irqenable_clr_ll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_irqenable_clr_ll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register irqenable_clr_ll (Low-latency L3 interrupt enable clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_sys =\t%" PRIx8 "\t(Command or address error.)\n", omap44xx_emif_irq_l3_err_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ta_sys =\t%" PRIx8 "\t(SDRAM temperature alert.)\n", omap44xx_emif_irq_l3_ta_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_irqenable_clr_ll_err_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_clr_ll_err_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(omap44xx_emif_irq_l3_err_sys_extract(_regval));
}

static inline uint8_t omap44xx_emif_irqenable_clr_ll_ta_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_irqenable_clr_ll_ta_sys_rdf(__DN(t) *_dev)
{
    omap44xx_emif_irq_l3_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(omap44xx_emif_irq_l3_ta_sys_extract(_regval));
}

static inline void omap44xx_emif_irqenable_clr_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_ll_err_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x1 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xc0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_irqenable_clr_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_irqenable_clr_ll_ta_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_irq_l3_t _regval = 0x2 & (((omap44xx_emif_irq_l3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xc0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc0, _regval);
    // No shadow register to write to
}

/*
 * Register zq_config: SDRAM output impedance calibration config
 * Type: omap44xx_emif.zq_config (Implicit type of SDRAM output impedance calibration config register)
 *   refinterval	(size 16, offset 0, init 0):	RW	Num rfrsh periods between ZQCS commands
 *   zqcl_mult	(size 2, offset 16, init 0):	RW	Num ZQCS intervals in a ZQCL interval -1
 *   zqinit_mult	(size 2, offset 18, init 0):	RW	Num ZQCL intervals in a ZQINIT interval -1
 *   _anon20	(size 8, offset 20, init 0):	RSVD	_
 *   sfexiten	(size 1, offset 28, init 0):	RW	ZQCL on self-rfr., act. pwrdn, prchrge pwrdwn
 *   dualcalen	(size 1, offset 29, init 0):	RW	ZQ Dual Calibration enable
 *   cs0en	(size 1, offset 30, init 0):	RW	Enable ZQ calibration for CS0
 *   cs1en	(size 1, offset 31, init 0):	RW	Enable ZQ calibration for CS1
 */
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc8));
}

static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_zq_config_t omap44xx_emif_zq_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc8));
}

static inline void omap44xx_emif_zq_config_rawwr(__DN(t) *_dev, omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_rawwr(__DN(t) *_dev, omap44xx_emif_zq_config_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
}

static inline void omap44xx_emif_zq_config_wr(__DN(t) *_dev, omap44xx_emif_zq_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_wr(__DN(t) *_dev, omap44xx_emif_zq_config_t _regval)
{
    _regval = (_regval & 0xf00fffff);
    // No MB1 fields present
    _regval = (_regval | (0xff00000 & mackerel_read_addr_32(_dev->base, 0xc8)));
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
}

static inline int omap44xx_emif_zq_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_zq_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register zq_config (SDRAM output impedance calibration config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refinterval =\t%" PRIx16 "\t(Num rfrsh periods between ZQCS commands)\n", omap44xx_emif_zq_config_refinterval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqcl_mult =\t%" PRIx8 "\t(Num ZQCS intervals in a ZQCL interval -1)\n", omap44xx_emif_zq_config_zqcl_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " zqinit_mult =\t%" PRIx8 "\t(Num ZQCL intervals in a ZQINIT interval -1)\n", omap44xx_emif_zq_config_zqinit_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfexiten =\t%" PRIx8 "\t(ZQCL on self-rfr., act. pwrdn, prchrge pwrdwn)\n", omap44xx_emif_zq_config_sfexiten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dualcalen =\t%" PRIx8 "\t(ZQ Dual Calibration enable)\n", omap44xx_emif_zq_config_dualcalen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs0en =\t%" PRIx8 "\t(Enable ZQ calibration for CS0)\n", omap44xx_emif_zq_config_cs0en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs1en =\t%" PRIx8 "\t(Enable ZQ calibration for CS1)\n", omap44xx_emif_zq_config_cs1en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t omap44xx_emif_zq_config_refinterval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_zq_config_refinterval_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_refinterval_extract(_regval));
}

static inline uint8_t omap44xx_emif_zq_config_zqcl_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_zqcl_mult_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_zqcl_mult_extract(_regval));
}

static inline uint8_t omap44xx_emif_zq_config_zqinit_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_zqinit_mult_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_zqinit_mult_extract(_regval));
}

static inline uint8_t omap44xx_emif_zq_config_sfexiten_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_sfexiten_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_sfexiten_extract(_regval));
}

static inline uint8_t omap44xx_emif_zq_config_dualcalen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_dualcalen_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_dualcalen_extract(_regval));
}

static inline uint8_t omap44xx_emif_zq_config_cs0en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_cs0en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_cs0en_extract(_regval));
}

static inline uint8_t omap44xx_emif_zq_config_cs1en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_zq_config_cs1en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_zq_config_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_emif_zq_config_cs1en_extract(_regval));
}

static inline void omap44xx_emif_zq_config_refinterval_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_refinterval_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0xffff & (((omap44xx_emif_zq_config_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_zq_config_zqcl_mult_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_zqcl_mult_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0x30000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffcffff & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_zq_config_zqinit_mult_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_zqinit_mult_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0xc0000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff3ffff & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_zq_config_sfexiten_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_sfexiten_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0x10000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_zq_config_dualcalen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_dualcalen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0x20000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_zq_config_cs0en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_cs0en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0x40000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_zq_config_cs1en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_zq_config_cs1en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_zq_config_t _regval = 0x80000000 & (((omap44xx_emif_zq_config_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xc8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

/*
 * Register temp_alert_config: Temperature Alert Config
 * Type: omap44xx_emif.temp_alert_config (Implicit type of Temperature Alert Config register)
 *   refinterval	(size 22, offset 0, init 0):	RW	Num. refresh periods btw alert polls
 *   _anon22	(size 2, offset 22, init 0):	RSVD	_
 *   devcnt	(size 2, offset 24, init 0):	RW	#lanes w/ temp. monitoring device
 *   devwdt	(size 2, offset 26, init 0):	RW	Physical device width
 *   sfexiten	(size 1, offset 28, init 0):	RW	Poll on self-rfr., act. pwrdn, prchrge pwrdwn
 *   _anon29	(size 1, offset 29, init 0):	RSVD	_
 *   cs0en	(size 1, offset 30, init 0):	RW	Enables temperature alert polling for CS0
 *   cs1en	(size 1, offset 31, init 0):	RW	Enables temperature alert polling for CS1
 */
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc));
}

static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_temp_alert_config_t omap44xx_emif_temp_alert_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc));
}

static inline void omap44xx_emif_temp_alert_config_rawwr(__DN(t) *_dev, omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_rawwr(__DN(t) *_dev, omap44xx_emif_temp_alert_config_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
}

static inline void omap44xx_emif_temp_alert_config_wr(__DN(t) *_dev, omap44xx_emif_temp_alert_config_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_wr(__DN(t) *_dev, omap44xx_emif_temp_alert_config_t _regval)
{
    _regval = (_regval & 0xdf3fffff);
    // No MB1 fields present
    _regval = (_regval | (0x20c00000 & mackerel_read_addr_32(_dev->base, 0xcc)));
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
}

static inline int omap44xx_emif_temp_alert_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_temp_alert_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register temp_alert_config (Temperature Alert Config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " refinterval =\t%" PRIx32 "\t(Num. refresh periods btw alert polls)\n", omap44xx_emif_temp_alert_config_refinterval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devcnt =\t%" PRIx8 "\t(#lanes w/ temp. monitoring device)\n", omap44xx_emif_temp_alert_config_devcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devwdt =\t%" PRIx8 "\t(Physical device width)\n", omap44xx_emif_temp_alert_config_devwdt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfexiten =\t%" PRIx8 "\t(Poll on self-rfr., act. pwrdn, prchrge pwrdwn)\n", omap44xx_emif_temp_alert_config_sfexiten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs0en =\t%" PRIx8 "\t(Enables temperature alert polling for CS0)\n", omap44xx_emif_temp_alert_config_cs0en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs1en =\t%" PRIx8 "\t(Enables temperature alert polling for CS1)\n", omap44xx_emif_temp_alert_config_cs1en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t omap44xx_emif_temp_alert_config_refinterval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_temp_alert_config_refinterval_rdf(__DN(t) *_dev)
{
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_emif_temp_alert_config_refinterval_extract(_regval));
}

static inline uint8_t omap44xx_emif_temp_alert_config_devcnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_devcnt_rdf(__DN(t) *_dev)
{
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_emif_temp_alert_config_devcnt_extract(_regval));
}

static inline uint8_t omap44xx_emif_temp_alert_config_devwdt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_devwdt_rdf(__DN(t) *_dev)
{
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_emif_temp_alert_config_devwdt_extract(_regval));
}

static inline uint8_t omap44xx_emif_temp_alert_config_sfexiten_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_sfexiten_rdf(__DN(t) *_dev)
{
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_emif_temp_alert_config_sfexiten_extract(_regval));
}

static inline uint8_t omap44xx_emif_temp_alert_config_cs0en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_cs0en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_emif_temp_alert_config_cs0en_extract(_regval));
}

static inline uint8_t omap44xx_emif_temp_alert_config_cs1en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_temp_alert_config_cs1en_rdf(__DN(t) *_dev)
{
    omap44xx_emif_temp_alert_config_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_emif_temp_alert_config_cs1en_extract(_regval));
}

static inline void omap44xx_emif_temp_alert_config_refinterval_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_refinterval_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_emif_temp_alert_config_t _regval = 0x3fffff & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffc00000 & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_temp_alert_config_devcnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_devcnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_temp_alert_config_t _regval = 0x3000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfcffffff & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_temp_alert_config_devwdt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_devwdt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_temp_alert_config_t _regval = 0xc000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf3ffffff & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_temp_alert_config_sfexiten_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_sfexiten_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_temp_alert_config_t _regval = 0x10000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_temp_alert_config_cs0en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_cs0en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_temp_alert_config_t _regval = 0x40000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_temp_alert_config_cs1en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_temp_alert_config_cs1en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_temp_alert_config_t _regval = 0x80000000 & (((omap44xx_emif_temp_alert_config_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

/*
 * Register l3_err_log: Error log
 * Type: omap44xx_emif.l3_err_log (Implicit type of Error log register)
 *   mconnid	(size 8, offset 0, init 0):	RO	Connection ID of 1st errored transaction
 *   mcmd	(size 3, offset 8, init 0):	RO	Cmd type of 1st errored transaction
 *   mburstseq	(size 3, offset 11, init 0):	RO	Addr mode of 1st errored transaction
 *   maddrspace	(size 2, offset 14, init 0):	RO	Addr spc of 1st errored transaction
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_l3_err_log_t omap44xx_emif_l3_err_log_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline void omap44xx_emif_l3_err_log_rawwr(__DN(t) *_dev, omap44xx_emif_l3_err_log_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_l3_err_log_rawwr(__DN(t) *_dev, omap44xx_emif_l3_err_log_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

// Register l3_err_log is not writeable
static inline int omap44xx_emif_l3_err_log_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_l3_err_log_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_l3_err_log_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register l3_err_log (Error log): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mconnid =\t%" PRIx8 "\t(Connection ID of 1st errored transaction)\n", omap44xx_emif_l3_err_log_mconnid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcmd =\t%" PRIx8 "\t(Cmd type of 1st errored transaction)\n", omap44xx_emif_l3_err_log_mcmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mburstseq =\t%" PRIx8 "\t(Addr mode of 1st errored transaction)\n", omap44xx_emif_l3_err_log_mburstseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maddrspace =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_err_spc_prtval(_s + _r, _avail, omap44xx_emif_l3_err_log_maddrspace_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addr spc of 1st errored transaction)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_l3_err_log_mconnid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_err_log_mconnid_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_err_log_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_emif_l3_err_log_mconnid_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_err_log_mcmd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_err_log_mcmd_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_err_log_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_emif_l3_err_log_mcmd_extract(_regval));
}

static inline uint8_t omap44xx_emif_l3_err_log_mburstseq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_l3_err_log_mburstseq_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_err_log_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_emif_l3_err_log_mburstseq_extract(_regval));
}

static inline omap44xx_emif_err_spc_t omap44xx_emif_l3_err_log_maddrspace_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_err_spc_t omap44xx_emif_l3_err_log_maddrspace_rdf(__DN(t) *_dev)
{
    omap44xx_emif_l3_err_log_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(omap44xx_emif_l3_err_log_maddrspace_extract(_regval));
}

/*
 * Register ddr_phy_ctrl_1: DDR PHY control 1
 * Type: omap44xx_emif.ddr_phy_ctrl_1 (Implicit type of DDR PHY control 1 register)
 *   read_latency	(size 4, offset 0, init 0):	RW	Read latency for the read data from SDRAM in DDR clock cycles
 *   dll_slave_dly_ctrl	(size 8, offset 4, init 0):	RW	DLL slave delay ratio control
 *   dll_master_sw_code_ctrl	(size 10, offset 12, init 0):	RW	DLL delay code when in software override mode
 *   freeze_delay_code_preamble	(size 4, offset 22, init 0):	RW	Preamble time respected by the DATA PHY
 *   freeze_delay_code_postamble	(size 4, offset 26, init 0):	RW	Postamble time respected by the DATA PHY
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe4));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe4));
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_rawwr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_rawwr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_wr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_wr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    _regval = (_regval & 0x3fffffff);
    // No MB1 fields present
    _regval = (_regval | (0xc0000000 & mackerel_read_addr_32(_dev->base, 0xe4)));
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
}

static inline int omap44xx_emif_ddr_phy_ctrl_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_ddr_phy_ctrl_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ddr_phy_ctrl_1 (DDR PHY control 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_latency =\t%" PRIx8 "\t(Read latency for the read data from SDRAM in DDR clock cycles)\n", omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_slave_dly_ctrl =\t%" PRIx8 "\t(DLL slave delay ratio control)\n", omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_master_sw_code_ctrl =\t%" PRIx16 "\t(DLL delay code when in software override mode)\n", omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freeze_delay_code_preamble =\t%" PRIx8 "\t(Preamble time respected by the DATA PHY)\n", omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freeze_delay_code_postamble =\t%" PRIx8 "\t(Postamble time respected by the DATA PHY)\n", omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_read_latency_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_read_latency_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(_regval));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(_regval));
}

static inline uint16_t omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(_regval));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(_regval));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(_regval));
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_read_latency_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_read_latency_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0xf & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0xe4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0xff0 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfffff00f & mackerel_read_addr_32(_dev->base, 0xe4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0x3ff000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffc00fff & mackerel_read_addr_32(_dev->base, 0xe4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0x3c00000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 22);
    _regval = (_regval | (0xfc3fffff & mackerel_read_addr_32(_dev->base, 0xe4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0x3c000000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 26);
    _regval = (_regval | (0xc3ffffff & mackerel_read_addr_32(_dev->base, 0xe4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
    // No shadow register to write to
}

/*
 * Register ddr_phy_ctrl_1_shdw: DDR PHY control 1 shadow
 * Type: omap44xx_emif.ddr_phy_ctrl_1 (Implicit type of DDR PHY control 1 register)
 *   read_latency	(size 4, offset 0, init 0):	RW	Read latency for the read data from SDRAM in DDR clock cycles
 *   dll_slave_dly_ctrl	(size 8, offset 4, init 0):	RW	DLL slave delay ratio control
 *   dll_master_sw_code_ctrl	(size 10, offset 12, init 0):	RW	DLL delay code when in software override mode
 *   freeze_delay_code_preamble	(size 4, offset 22, init 0):	RW	Preamble time respected by the DATA PHY
 *   freeze_delay_code_postamble	(size 4, offset 26, init 0):	RW	Postamble time respected by the DATA PHY
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_shdw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_shdw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe8));
}

static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_shdw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_emif_ddr_phy_ctrl_1_t omap44xx_emif_ddr_phy_ctrl_1_shdw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe8));
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_rawwr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_wr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_wr(__DN(t) *_dev, omap44xx_emif_ddr_phy_ctrl_1_t _regval)
{
    _regval = (_regval & 0x3fffffff);
    // No MB1 fields present
    _regval = (_regval | (0xc0000000 & mackerel_read_addr_32(_dev->base, 0xe8)));
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
}

static inline int omap44xx_emif_ddr_phy_ctrl_1_shdw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_ddr_phy_ctrl_1_shdw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ddr_phy_ctrl_1_shdw (DDR PHY control 1 shadow): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_latency =\t%" PRIx8 "\t(Read latency for the read data from SDRAM in DDR clock cycles)\n", omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_slave_dly_ctrl =\t%" PRIx8 "\t(DLL slave delay ratio control)\n", omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_master_sw_code_ctrl =\t%" PRIx16 "\t(DLL delay code when in software override mode)\n", omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freeze_delay_code_preamble =\t%" PRIx8 "\t(Preamble time respected by the DATA PHY)\n", omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freeze_delay_code_postamble =\t%" PRIx8 "\t(Postamble time respected by the DATA PHY)\n", omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_read_latency_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_read_latency_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    return(omap44xx_emif_ddr_phy_ctrl_1_read_latency_extract(_regval));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_slave_dly_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_slave_dly_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    return(omap44xx_emif_ddr_phy_ctrl_1_dll_slave_dly_ctrl_extract(_regval));
}

static inline uint16_t omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_master_sw_code_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_master_sw_code_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    return(omap44xx_emif_ddr_phy_ctrl_1_dll_master_sw_code_ctrl_extract(_regval));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_preamble_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_preamble_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    return(omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_preamble_extract(_regval));
}

static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_postamble_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_postamble_rdf(__DN(t) *_dev)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    return(omap44xx_emif_ddr_phy_ctrl_1_freeze_delay_code_postamble_extract(_regval));
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_read_latency_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_read_latency_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0xf & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0xe8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_slave_dly_ctrl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_slave_dly_ctrl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0xff0 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfffff00f & mackerel_read_addr_32(_dev->base, 0xe8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_master_sw_code_ctrl_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_dll_master_sw_code_ctrl_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0x3ff000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffc00fff & mackerel_read_addr_32(_dev->base, 0xe8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_preamble_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_preamble_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0x3c00000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 22);
    _regval = (_regval | (0xfc3fffff & mackerel_read_addr_32(_dev->base, 0xe8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_postamble_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_1_shdw_freeze_delay_code_postamble_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_emif_ddr_phy_ctrl_1_t _regval = 0x3c000000 & (((omap44xx_emif_ddr_phy_ctrl_1_t )(_fieldval)) << 26);
    _regval = (_regval | (0xc3ffffff & mackerel_read_addr_32(_dev->base, 0xe8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
    // No shadow register to write to
}

/*
 * Register ddr_phy_ctrl_2: DDR PHY control 2
 * Type: omap44xx_emif.uint32 (primitive type)
 */
static inline uint32_t omap44xx_emif_ddr_phy_ctrl_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_ddr_phy_ctrl_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec));
}

static inline uint32_t omap44xx_emif_ddr_phy_ctrl_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_emif_ddr_phy_ctrl_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec));
}

static inline void omap44xx_emif_ddr_phy_ctrl_2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec, _regval);
}

static inline void omap44xx_emif_ddr_phy_ctrl_2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_emif_ddr_phy_ctrl_2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xec, _regval);
}

static inline int omap44xx_emif_ddr_phy_ctrl_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_ddr_phy_ctrl_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ddr_phy_ctrl_2 (DDR PHY control 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int omap44xx_emif_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_emif_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_emif (OMAP44xx external memory intf.):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_mod_id_rev_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_config2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_ref_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_ref_ctrl_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_tim1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_tim1_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_tim2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_tim2_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_tim3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_sdram_tim3_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_lpddr2_nvm_tim_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_lpddr2_nvm_tim_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_pwr_mgmt_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_pwr_mgmt_ctrl_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_lpddr2_mode_reg_data_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_lpddr2_mode_reg_cfg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_l3_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_l3_cfg_val1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_l3_cfg_val2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_perf_cnt_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_perf_cnt_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_perf_cnt_cfg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_perf_cnt_sel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_perf_cnt_tim_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_read_idle_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_read_idle_ctrl_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqstatus_raw_sys_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqstatus_raw_ll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqstatus_sys_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqstatus_ll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqenable_set_sys_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqenable_set_ll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqenable_clr_sys_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_irqenable_clr_ll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_zq_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_temp_alert_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_l3_err_log_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_ddr_phy_ctrl_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_ddr_phy_ctrl_1_shdw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_emif_ddr_phy_ctrl_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_emif\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_emif_DEV_H
