#ifndef __omap44xx_sysctrl_padconf_wkup_DEV_H
#define __omap44xx_sysctrl_padconf_wkup_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_sysctrl_padconf_wkup ## _ ## x
/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.ip_sysconfig_idlemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t;
#define omap44xx_sysctrl_padconf_wkup_IP_SYSCONFIG_IDLEMODE_0 ((omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_IP_SYSCONFIG_IDLEMODE_1 ((omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_describe(omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_describe(omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_IP_SYSCONFIG_IDLEMODE_0:
        return("IP_SYSCONFIG_IDLEMODE_0: Clock is manually gated");
    case omap44xx_sysctrl_padconf_wkup_IP_SYSCONFIG_IDLEMODE_1:
        return("IP_SYSCONFIG_IDLEMODE_1: Clock is manually enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk1_wakeupevent_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPEVENT_0_r ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPEVENT_1_r ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPEVENT_0_r:
        return("GPIO_WK1_WAKEUPEVENT_0_r: No wake-up event occurred");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPEVENT_1_r:
        return("GPIO_WK1_WAKEUPEVENT_1_r: A wake-up event occurred");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk1_wakeupenable_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPENABLE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPENABLE_1 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPENABLE_0:
        return("GPIO_WK1_WAKEUPENABLE_0: wake-up detection is disabled");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_WAKEUPENABLE_1:
        return("GPIO_WK1_WAKEUPENABLE_1: wake-up detection is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk1_inputenable_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_INPUTENABLE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_INPUTENABLE_1 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_INPUTENABLE_0:
        return("GPIO_WK1_INPUTENABLE_0: Input buffer of I/O cell is disabled");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_INPUTENABLE_1:
        return("GPIO_WK1_INPUTENABLE_1: Input buffer of I/O cell is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk1_pulltypeselect_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLTYPESELECT_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLTYPESELECT_1 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLTYPESELECT_0:
        return("GPIO_WK1_PULLTYPESELECT_0: pulldown selected");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLTYPESELECT_1:
        return("GPIO_WK1_PULLTYPESELECT_1: pullup selected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk1_pulludenable_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLUDENABLE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLUDENABLE_1 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLUDENABLE_0:
        return("GPIO_WK1_PULLUDENABLE_0: pullup/down disabled");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_PULLUDENABLE_1:
        return("GPIO_WK1_PULLUDENABLE_1: pullup/down enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk1_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_0:
        return("GPIO_WK1_MUXMODE_0: Reserved");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_3:
        return("GPIO_WK1_MUXMODE_3: Select gpio_wk1");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_6:
        return("GPIO_WK1_MUXMODE_6: Select hw_dbg2");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK1_MUXMODE_7:
        return("GPIO_WK1_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk0_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_4 ((omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t)0x4)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_0:
        return("GPIO_WK0_MUXMODE_0: Reserved");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_3:
        return("GPIO_WK0_MUXMODE_3: Select gpio_wk0");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_4:
        return("GPIO_WK0_MUXMODE_4: Select c2c_pwkup");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_6:
        return("GPIO_WK0_MUXMODE_6: Select hw_dbg1");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK0_MUXMODE_7:
        return("GPIO_WK0_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk3_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_0:
        return("GPIO_WK3_MUXMODE_0: Reserved");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_3:
        return("GPIO_WK3_MUXMODE_3: Select gpio_wk3");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_6:
        return("GPIO_WK3_MUXMODE_6: Select hw_dbg4");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK3_MUXMODE_7:
        return("GPIO_WK3_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk2_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_0:
        return("GPIO_WK2_MUXMODE_0: Reserved");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_3:
        return("GPIO_WK2_MUXMODE_3: Select gpio_wk2");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_6:
        return("GPIO_WK2_MUXMODE_6: Select hw_dbg3");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK2_MUXMODE_7:
        return("GPIO_WK2_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.gpio_wk4_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_0:
        return("GPIO_WK4_MUXMODE_0: Reserved");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_3:
        return("GPIO_WK4_MUXMODE_3: Select gpio_wk4");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_6:
        return("GPIO_WK4_MUXMODE_6: Select hw_dbg5");
    case omap44xx_sysctrl_padconf_wkup_GPIO_WK4_MUXMODE_7:
        return("GPIO_WK4_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_xtal_in_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_XTAL_IN_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_XTAL_IN_MUXMODE_4 ((omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t)0x4)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_XTAL_IN_MUXMODE_0:
        return("FREF_XTAL_IN_MUXMODE_0: Select fref_xtal_in");
    case omap44xx_sysctrl_padconf_wkup_FREF_XTAL_IN_MUXMODE_4:
        return("FREF_XTAL_IN_MUXMODE_4: Select c2c_wakereqin");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_slicer_in_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_4 ((omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t)0x4)
#define omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_0:
        return("FREF_SLICER_IN_MUXMODE_0: Select fref_slicer_in");
    case omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_3:
        return("FREF_SLICER_IN_MUXMODE_3: Select gpi_wk5");
    case omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_4:
        return("FREF_SLICER_IN_MUXMODE_4: Select c2c_wakereqin");
    case omap44xx_sysctrl_padconf_wkup_FREF_SLICER_IN_MUXMODE_7:
        return("FREF_SLICER_IN_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_clk3_req_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_1 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_2 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x2)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_4 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x4)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_5 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x5)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_0:
        return("FREF_CLK3_REQ_MUXMODE_0: Select fref_clk3_req");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_1:
        return("FREF_CLK3_REQ_MUXMODE_1: Select fref_clk1_req");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_2:
        return("FREF_CLK3_REQ_MUXMODE_2: Reserved");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_3:
        return("FREF_CLK3_REQ_MUXMODE_3: Select gpio_wk30");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_4:
        return("FREF_CLK3_REQ_MUXMODE_4: Select c2c_wakereqin");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_5:
        return("FREF_CLK3_REQ_MUXMODE_5: Select sdmmc2_dat4");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_6:
        return("FREF_CLK3_REQ_MUXMODE_6: Select hw_dbg7");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_REQ_MUXMODE_7:
        return("FREF_CLK3_REQ_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_clk0_out_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_1 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_2 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x2)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_5 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x5)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_0:
        return("FREF_CLK0_OUT_MUXMODE_0: Select fref_clk0_out");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_1:
        return("FREF_CLK0_OUT_MUXMODE_1: Select fref_clk1_req");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_2:
        return("FREF_CLK0_OUT_MUXMODE_2: Reserved");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_3:
        return("FREF_CLK0_OUT_MUXMODE_3: Select gpio_wk6");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_5:
        return("FREF_CLK0_OUT_MUXMODE_5: Select sdmmc2_dat7");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_6:
        return("FREF_CLK0_OUT_MUXMODE_6: Select hw_dbg6");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK0_OUT_MUXMODE_7:
        return("FREF_CLK0_OUT_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_clk4_req_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_1 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_5 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t)0x5)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t)0x6)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_0:
        return("FREF_CLK4_REQ_MUXMODE_0: Select fref_clk4_req");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_1:
        return("FREF_CLK4_REQ_MUXMODE_1: Select fref_clk5_out");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_3:
        return("FREF_CLK4_REQ_MUXMODE_3: Select gpio_wk7");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_5:
        return("FREF_CLK4_REQ_MUXMODE_5: Select sdmmc2_dat6");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_REQ_MUXMODE_6:
        return("FREF_CLK4_REQ_MUXMODE_6: Select hw_dbg9");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_clk3_out_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_1 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_2 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x2)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_4 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x4)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_5 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x5)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_0:
        return("FREF_CLK3_OUT_MUXMODE_0: Select fref_clk3_out");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_1:
        return("FREF_CLK3_OUT_MUXMODE_1: Select fref_clk2_req");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_2:
        return("FREF_CLK3_OUT_MUXMODE_2: Reserved");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_3:
        return("FREF_CLK3_OUT_MUXMODE_3: Select gpio_wk31");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_4:
        return("FREF_CLK3_OUT_MUXMODE_4: Select c2c_wakereqout");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_5:
        return("FREF_CLK3_OUT_MUXMODE_5: Select sdmmc2_dat5");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_6:
        return("FREF_CLK3_OUT_MUXMODE_6: Select hw_dbg8");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK3_OUT_MUXMODE_7:
        return("FREF_CLK3_OUT_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_clk4_out_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_OUT_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_OUT_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_FREF_CLK4_OUT_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t)0x6)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_OUT_MUXMODE_0:
        return("FREF_CLK4_OUT_MUXMODE_0: Select fref_clk4_out");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_OUT_MUXMODE_3:
        return("FREF_CLK4_OUT_MUXMODE_3: Select gpio_wk8");
    case omap44xx_sysctrl_padconf_wkup_FREF_CLK4_OUT_MUXMODE_6:
        return("FREF_CLK4_OUT_MUXMODE_6: Select hw_dbg10");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sys_pwron_reset_out_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_5 ((omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t)0x5)
#define omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t)0x6)

static inline char *omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_0:
        return("SYS_PWRON_RESET_OUT_MUXMODE_0: Select sys_pwron_reset_out");
    case omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_3:
        return("SYS_PWRON_RESET_OUT_MUXMODE_3: Select gpio_wk29");
    case omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_5:
        return("SYS_PWRON_RESET_OUT_MUXMODE_5: Select hw_dbg0");
    case omap44xx_sysctrl_padconf_wkup_SYS_PWRON_RESET_OUT_MUXMODE_6:
        return("SYS_PWRON_RESET_OUT_MUXMODE_6: Select hw_dbg11");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sys_boot7_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_1 ((omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_0:
        return("SYS_BOOT7_MUXMODE_0: Select sys_boot7");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_1:
        return("SYS_BOOT7_MUXMODE_1: Select dpm_emu19");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_3:
        return("SYS_BOOT7_MUXMODE_3: Select gpio_wk10");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_6:
        return("SYS_BOOT7_MUXMODE_6: Select hw_dbg13");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT7_MUXMODE_7:
        return("SYS_BOOT7_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sys_boot6_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_1 ((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_3 ((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t)0x3)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_4 ((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t)0x4)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_6 ((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t)0x6)
#define omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_0:
        return("SYS_BOOT6_MUXMODE_0: Select sys_boot6");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_1:
        return("SYS_BOOT6_MUXMODE_1: Select dpm_emu18");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_3:
        return("SYS_BOOT6_MUXMODE_3: Select gpio_wk9");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_4:
        return("SYS_BOOT6_MUXMODE_4: Select c2c_wakereqout");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_6:
        return("SYS_BOOT6_MUXMODE_6: Select hw_dbg12");
    case omap44xx_sysctrl_padconf_wkup_SYS_BOOT6_MUXMODE_7:
        return("SYS_BOOT6_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.jtag_tck_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_JTAG_TCK_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_JTAG_TCK_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_JTAG_TCK_MUXMODE_0:
        return("JTAG_TCK_MUXMODE_0: Select jtag_tck");
    case omap44xx_sysctrl_padconf_wkup_JTAG_TCK_MUXMODE_7:
        return("JTAG_TCK_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.jtag_tms_tmsc_muxmode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t;
#define omap44xx_sysctrl_padconf_wkup_JTAG_TMS_TMSC_MUXMODE_0 ((omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_JTAG_TMS_TMSC_MUXMODE_7 ((omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t)0x7)

static inline char *omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_describe(omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_JTAG_TMS_TMSC_MUXMODE_0:
        return("JTAG_TMS_TMSC_MUXMODE_0: Select jtag_tms_tmsc");
    case omap44xx_sysctrl_padconf_wkup_JTAG_TMS_TMSC_MUXMODE_7:
        return("JTAG_TMS_TMSC_MUXMODE_7: Select safe_mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.fref_dr0_lb_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t;
#define omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_0 ((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_1 ((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_2 ((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t)0x2)
#define omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_3 ((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t)0x3)

static inline char *omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_describe(omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_describe(omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_0:
        return("FREF_DR0_LB_0: TL Length= [2cm-20cm] / Farend cap per TL= [1pF-10pF]");
    case omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_1:
        return("FREF_DR0_LB_1: Dual TL Length= [20cm-40cm] / Farend cap per TL= [1pF-10pF]");
    case omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_2:
        return("FREF_DR0_LB_2: TL Length = [2cm-20cm] / Farend cap per TL= [10pF-20pF]");
    case omap44xx_sysctrl_padconf_wkup_FREF_DR0_LB_3:
        return("FREF_DR0_LB_3: Dual TL Length = [20cm-40cm] / Farend cap per TL= [10pF-20pF]");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.vdds_dv_fref_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t;
#define omap44xx_sysctrl_padconf_wkup_VDDS_DV_FREF_0 ((omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_VDDS_DV_FREF_1 ((omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_describe(omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_describe(omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_VDDS_DV_FREF_0:
        return("VDDS_DV_FREF_0: VDDS = 1.8V");
    case omap44xx_sysctrl_padconf_wkup_VDDS_DV_FREF_1:
        return("VDDS_DV_FREF_1: VDDS = 1.2V");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.oscillator_boost_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t;
#define omap44xx_sysctrl_padconf_wkup_OSCILLATOR_BOOST_0 ((omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_OSCILLATOR_BOOST_1 ((omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_describe(omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_describe(omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_OSCILLATOR_BOOST_0:
        return("OSCILLATOR_BOOST_0: Fast startup is disabled");
    case omap44xx_sysctrl_padconf_wkup_OSCILLATOR_BOOST_1:
        return("OSCILLATOR_BOOST_1: Fast startup is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.oscillator_os_out_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t;
#define omap44xx_sysctrl_padconf_wkup_OSCILLATOR_OS_OUT_0_r ((omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_OSCILLATOR_OS_OUT_1_r ((omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_describe(omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_describe(omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_OSCILLATOR_OS_OUT_0_r:
        return("OSCILLATOR_OS_OUT_0_r: low to high transition in BOOST mode");
    case omap44xx_sysctrl_padconf_wkup_OSCILLATOR_OS_OUT_1_r:
        return("OSCILLATOR_OS_OUT_1_r: BOOST is disabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sr_sda_glfenb_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t;
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_GLFENB_0 ((omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_GLFENB_1 ((omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_describe(omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_describe(omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_GLFENB_0:
        return("SR_SDA_GLFENB_0: Disable i2c4 glitch free operation");
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_GLFENB_1:
        return("SR_SDA_GLFENB_1: Enable i2c4 glitch free operation");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sr_sda_load_bits_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t;
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_0 ((omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_1 ((omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t)0x1)
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_2 ((omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t)0x2)
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_3 ((omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t)0x3)

static inline char *omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_describe(omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_describe(omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_0:
        return("SR_SDA_LOAD_BITS_0: 4.5 kohm (5-15 pF) / 1.66 kohm (5-12 pF)");
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_1:
        return("SR_SDA_LOAD_BITS_1: 2.1 kohm (15-50 pF) / 920 ohm (12-25 pF)");
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_2:
        return("SR_SDA_LOAD_BITS_2: 860 ohm (50-150 pF) / 500 ohm (25-50 pF)");
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_LOAD_BITS_3:
        return("SR_SDA_LOAD_BITS_3: N.A / 300 ohm (50-80 pF)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sr_sda_pullupresx_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t;
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_PULLUPRESX_0 ((omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SR_SDA_PULLUPRESX_1 ((omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_describe(omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_describe(omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_PULLUPRESX_0:
        return("SR_SDA_PULLUPRESX_0: Enable Internal Pull up resistor");
    case omap44xx_sysctrl_padconf_wkup_SR_SDA_PULLUPRESX_1:
        return("SR_SDA_PULLUPRESX_1: Disable Internal Pull up resisitor");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.jtag_ntrst_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t;
#define omap44xx_sysctrl_padconf_wkup_JTAG_NTRST_EN_0 ((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_JTAG_NTRST_EN_1 ((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_describe(omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_describe(omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_JTAG_NTRST_EN_0:
        return("JTAG_NTRST_EN_0: Disable bus holder functionality");
    case omap44xx_sysctrl_padconf_wkup_JTAG_NTRST_EN_1:
        return("JTAG_NTRST_EN_1: Enable bus holder functionality");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_sysctrl_padconf_wkup.sys_nreswarm_pipu_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t;
#define omap44xx_sysctrl_padconf_wkup_SYS_NRESWARM_PIPU_0 ((omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t)0x0)
#define omap44xx_sysctrl_padconf_wkup_SYS_NRESWARM_PIPU_1 ((omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t)0x1)

static inline char *omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_describe(omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_describe(omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _e)
{
    switch (_e) {
    case omap44xx_sysctrl_padconf_wkup_SYS_NRESWARM_PIPU_0:
        return("SYS_NRESWARM_PIPU_0: Enable pull up");
    case omap44xx_sysctrl_padconf_wkup_SYS_NRESWARM_PIPU_1:
        return("SYS_NRESWARM_PIPU_1: Disable pull up");
    default:
        return(NULL);
    }
}

static inline int omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _e)
{
    char *d = omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t
 * Description: Implicit type of Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   ip_sysconfig_idlemode	(size 2, offset 2, init 0):	RW	Select the local clock-gating strategy0x2,0x3: Clock is automatically gated when there is no access to the Control Module through L4-interconnect .
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t;
#define omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_extract(omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_extract(omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t )((_regval & 0xc) >> 2));
}

static inline omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_insert(omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval, omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_insert(omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval, omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t )(_fieldval)) << 2)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip_sysconfig_idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the local clock-gating strategy0x2,0x3: Clock is automatically gated when there is no access to the Control Module through L4-interconnect .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t
 * Description: Implicit type of Register control for Pads gpio_wk0 and gpio_wk1 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   gpio_wk0_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad gpio_wk0
 *   gpio_wk0_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad gpio_wk0
 *   gpio_wk0_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad gpio_wk0
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   gpio_wk0_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad gpio_wk0
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   gpio_wk0_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk0_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   gpio_wk1_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad gpio_wk1
 *   gpio_wk1_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad gpio_wk1
 *   gpio_wk1_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad gpio_wk1
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   gpio_wk1_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad gpio_wk1
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   gpio_wk1_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk1_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t
 * Description: Implicit type of Register control for Pads gpio_wk2 and gpio_wk3 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   gpio_wk2_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad gpio_wk2
 *   gpio_wk2_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad gpio_wk2
 *   gpio_wk2_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad gpio_wk2
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   gpio_wk2_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad gpio_wk2
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   gpio_wk2_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk2_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   gpio_wk3_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad gpio_wk3
 *   gpio_wk3_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad gpio_wk3
 *   gpio_wk3_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad gpio_wk3
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   gpio_wk3_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad gpio_wk3
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   gpio_wk3_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk3_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t
 * Description: Implicit type of Register control for Pads gpio_wk4 and sr_scl Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   gpio_wk4_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad gpio_wk4
 *   gpio_wk4_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad gpio_wk4
 *   gpio_wk4_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad gpio_wk4
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   gpio_wk4_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad gpio_wk4
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   gpio_wk4_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk4_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   sr_scl_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sr_scl
 *   sr_scl_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sr_scl
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sr_scl_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sr_scl
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sr_scl_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sr_scl_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t
 * Description: Implicit type of Register control for Pads sr_sda and fref_xtal_in Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   sr_sda_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad sr_sda
 *   sr_sda_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad sr_sda
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   sr_sda_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad sr_sda
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   sr_sda_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sr_sda_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   fref_xtal_in_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad fref_xtal_in
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval, omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 16)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_xtal_in_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_xtal_in)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t
 * Description: Implicit type of Register control for Pads fref_slicer_in and fref_clk_ioreq Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   fref_slicer_in_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_slicer_in
 *   _anon3	(size 16, offset 3, init 0):	MBZ	_
 *   fref_clk_ioreq_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad fref_clk_ioreq
 *   fref_clk_ioreq_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad fref_clk_ioreq
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fref_clk_ioreq_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad fref_clk_ioreq
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   fref_clk_ioreq_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk_ioreq_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_slicer_in_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_slicer_in)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t
 * Description: Implicit type of Register control for Pads fref_clk0_out and fref_clk3_req Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   fref_clk0_out_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_clk0_out
 *   fref_clk0_out_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad fref_clk0_out
 *   fref_clk0_out_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad fref_clk0_out
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   fref_clk0_out_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad fref_clk0_out
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   fref_clk0_out_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk0_out_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   fref_clk3_req_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad fref_clk3_req
 *   fref_clk3_req_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad fref_clk3_req
 *   fref_clk3_req_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad fref_clk3_req
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fref_clk3_req_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad fref_clk3_req
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   fref_clk3_req_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk3_req_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t
 * Description: Implicit type of Register control for Pads fref_clk3_out and fref_clk4_req Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   fref_clk3_out_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_clk3_out
 *   fref_clk3_out_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad fref_clk3_out
 *   fref_clk3_out_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad fref_clk3_out
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   fref_clk3_out_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad fref_clk3_out
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   fref_clk3_out_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk3_out_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   fref_clk4_req_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad fref_clk4_req
 *   fref_clk4_req_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad fref_clk4_req
 *   fref_clk4_req_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad fref_clk4_req
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fref_clk4_req_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad fref_clk4_req
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   fref_clk4_req_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk4_req_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t
 * Description: Implicit type of Register control for Pads fref_clk4_out and sys_32k Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   fref_clk4_out_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_clk4_out
 *   fref_clk4_out_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad fref_clk4_out
 *   fref_clk4_out_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad fref_clk4_out
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   fref_clk4_out_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad fref_clk4_out
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   fref_clk4_out_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk4_out_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   sys_32k_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sys_32k
 *   sys_32k_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sys_32k
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sys_32k_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sys_32k
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sys_32k_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_32k_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t
 * Description: Implicit type of Register control for Pads sys_nreswarm Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 30, offset 0, init 0):	MBZ	_
 *   sys_nreswarm_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_nreswarm_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t
 * Description: Implicit type of Register control for Pads sys_pwr_req and sys_pwron_reset_out Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   sys_pwr_req_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad sys_pwr_req
 *   sys_pwr_req_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad sys_pwr_req
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   sys_pwr_req_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad sys_pwr_req
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   sys_pwr_req_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_pwr_req_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   sys_pwron_reset_out_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad sys_pwron_reset_out
 *   sys_pwron_reset_out_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sys_pwron_reset_out
 *   sys_pwron_reset_out_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sys_pwron_reset_out
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sys_pwron_reset_out_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sys_pwron_reset_out
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sys_pwron_reset_out_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_pwron_reset_out_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t
 * Description: Implicit type of Register control for Pads sys_boot6 and sys_boot7 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   sys_boot6_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad sys_boot6
 *   sys_boot6_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad sys_boot6
 *   sys_boot6_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad sys_boot6
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   sys_boot6_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad sys_boot6
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   sys_boot6_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_boot6_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   sys_boot7_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad sys_boot7
 *   sys_boot7_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sys_boot7
 *   sys_boot7_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sys_boot7
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sys_boot7_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sys_boot7
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sys_boot7_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_boot7_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t
 * Description: Implicit type of Register control for Pads jtag_ntrst and jtag_tck Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   jtag_ntrst_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad jtag_ntrst
 *   jtag_ntrst_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad jtag_ntrst
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   jtag_ntrst_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad jtag_ntrst
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   jtag_ntrst_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_ntrst_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   jtag_tck_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad jtag_tck
 *   jtag_tck_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad jtag_tck
 *   jtag_tck_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad jtag_tck
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   jtag_tck_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad jtag_tck
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   jtag_tck_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tck_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t
 * Description: Implicit type of Register control for Pads jtag_rtck and jtag_tms_tmsc Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   jtag_rtck_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad jtag_rtck
 *   jtag_rtck_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad jtag_rtck
 *   _anon5	(size 9, offset 5, init 0):	MBZ	_
 *   jtag_rtck_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_rtck_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   jtag_tms_tmsc_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad jtag_tms_tmsc
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   jtag_tms_tmsc_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad jtag_tms_tmsc
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   jtag_tms_tmsc_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tms_tmsc_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t )((_regval & 0x70000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_rtck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_rtck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad jtag_tms_tmsc)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tms_tmsc)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t
 * Description: Implicit type of Register control for Pads jtag_tdi and jtag_tdo Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   jtag_tdi_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad jtag_tdi
 *   jtag_tdi_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad jtag_tdi
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   jtag_tdi_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad jtag_tdi
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   jtag_tdi_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tdi_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   jtag_tdo_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad jtag_tdo
 *   jtag_tdo_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad jtag_tdo
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   jtag_tdo_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad jtag_tdo
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   jtag_tdo_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tdo_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t
 * Description: Implicit type of Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   gpio_wk0_duplicatewakeupevent	(size 1, offset 0, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk0
 *   gpio_wk1_duplicatewakeupevent	(size 1, offset 1, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk1
 *   gpio_wk2_duplicatewakeupevent	(size 1, offset 2, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk2
 *   gpio_wk3_duplicatewakeupevent	(size 1, offset 3, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk3
 *   gpio_wk4_duplicatewakeupevent	(size 1, offset 4, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk4
 *   sr_scl_duplicatewakeupevent	(size 1, offset 5, init 0):	RO	Wake-up event status latched in the I/O for pad sr_scl
 *   sr_sda_duplicatewakeupevent	(size 1, offset 6, init 0):	RO	Wake-up event status latched in the I/O for pad sr_sda
 *   fref_clk_ioreq_duplicatewakeupevent	(size 1, offset 7, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk_ioreq
 *   fref_clk0_out_duplicatewakeupevent	(size 1, offset 8, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk0_out
 *   fref_clk3_req_duplicatewakeupevent	(size 1, offset 9, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk3_req
 *   fref_clk3_out_duplicatewakeupevent	(size 1, offset 10, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk3_out
 *   fref_clk4_req_duplicatewakeupevent	(size 1, offset 11, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk4_req
 *   fref_clk4_out_duplicatewakeupevent	(size 1, offset 12, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk4_out
 *   sys_32k_duplicatewakeupevent	(size 1, offset 13, init 0):	RO	Wake-up event status latched in the I/O for pad sys_32k
 *   sys_nreswarm_duplicatewakeupevent	(size 1, offset 14, init 0):	RO	Wake-up event status latched in the I/O for pad sys_nreswarm
 *   sys_pwr_req_duplicatewakeupevent	(size 1, offset 15, init 0):	RO	Wake-up event status latched in the I/O for pad sys_pwr_req
 *   sys_pwron_reset_out_duplicatewakeupevent	(size 1, offset 16, init 0):	RO	Wake-up event status latched in the I/O for pad sys_pwron_reset_out
 *   sys_boot6_duplicatewakeupevent	(size 1, offset 17, init 0):	RO	Wake-up event status latched in the I/O for pad sys_boot6
 *   sys_boot7_duplicatewakeupevent	(size 1, offset 18, init 0):	RO	Wake-up event status latched in the I/O for pad sys_boot7
 *   jtag_ntrst_duplicatewakeupevent	(size 1, offset 19, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_ntrst
 *   jtag_tck_duplicatewakeupevent	(size 1, offset 20, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tck
 *   jtag_rtck_duplicatewakeupevent	(size 1, offset 21, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_rtck
 *   jtag_tms_tmsc_duplicatewakeupevent	(size 1, offset 22, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tms_tmsc
 *   jtag_tdi_duplicatewakeupevent	(size 1, offset 23, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tdi
 *   jtag_tdo_duplicatewakeupevent	(size 1, offset 24, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tdo
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 0)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 1)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 2)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 3)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 4)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 5)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 6)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 7)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 8)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 9)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 10)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 11)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 12)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 13)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 15)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 16)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 17)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x40000) >> 18));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 18)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 19)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 20)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x200000) >> 21));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 21)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x400000) >> 22));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 22)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x800000) >> 23));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 23)));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t )(_fieldval)) << 24)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_nreswarm)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_rtck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tms_tmsc)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t
 * Description: Implicit type of SMART1 NOPM I/O control 0 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   gpiowk4_dr0_sc	(size 2, offset 12, init 0):	RW	Slew rate control for group gpiowk4_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 *   dpm_dr0_sc	(size 2, offset 14, init 0):	RW	Slew rate control for group dpm_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 *   _anon16	(size 2, offset 16, init 0):	MBZ	_
 *   gpio_dr7_sc	(size 2, offset 18, init 0):	RW	Slew rate control for group gpio_dr7 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 *   _anon20	(size 10, offset 20, init 0):	MBZ	_
 *   fref_dr0_sc	(size 2, offset 30, init 0):	RW	Slew rate control for group fref_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t;
#define omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_default 0x0
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0x3000) >> 12));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 12)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 14)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0xc0000) >> 18));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 18)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0xc0000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x3fffffff) | (0xc0000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 30)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpiowk4_dr0_sc =\t%" PRIx8 "\t(Slew rate control for group gpiowk4_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpm_dr0_sc =\t%" PRIx8 "\t(Slew rate control for group dpm_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_dr7_sc =\t%" PRIx8 "\t(Slew rate control for group gpio_dr7 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr0_sc =\t%" PRIx8 "\t(Slew rate control for group fref_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t
 * Description: Implicit type of SMART1 NOPM I/O control 1 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   gpiowk4_dr0_lb	(size 2, offset 12, init 0):	RW	Load control for group gpiowk4_dr0
 *   dpm_dr0_lb	(size 2, offset 14, init 0):	RW	Load control for group dpm_dr0
 *   _anon16	(size 2, offset 16, init 0):	MBZ	_
 *   gpio_dr7_lb	(size 2, offset 18, init 0):	RW	Load control for group gpio_dr7
 *   _anon20	(size 10, offset 20, init 0):	MBZ	_
 *   fref_dr0_lb	(size 2, offset 30, init 0):	RW	Load control for group fref_dr0
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t;
#define omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t )((_regval & 0x3000) >> 12));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 12)));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 14)));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t )((_regval & 0xc0000) >> 18));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 18)));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_extract(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t )((_regval & 0xc0000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_insert(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    return((_regval & 0x3fffffff) | (0xc0000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 30)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpiowk4_dr0_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group gpiowk4_dr0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpm_dr0_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group dpm_dr0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_dr7_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group gpio_dr7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr0_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group fref_dr0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t
 * Description: Implicit type of PAD Voltage Mode control Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 30, offset 0, init 0):	MBZ	_
 *   vdds_dv_bank2_shared1	(size 1, offset 30, init 0):	RW	PAD Voltage level control for vdds_dv_bank2_shared1
 *   vdds_dv_fref	(size 1, offset 31, init 0):	RW	PAD Voltage level control for vdds_dv_fref
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vdds_dv_bank2_shared1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PAD Voltage level control for vdds_dv_bank2_shared1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vdds_dv_fref =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PAD Voltage level control for vdds_dv_fref)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t
 * Description: Implicit type of XTAL OSCILLATOR control Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 30, offset 0, init 0):	MBZ	_
 *   oscillator_os_out	(size 1, offset 30, init 0):	RO	Oscillator output
 *   oscillator_boost	(size 1, offset 31, init 0):	RW	Fast startup control
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t;
#define omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_extract(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_extract(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_insert(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval, omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_insert(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval, omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_extract(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_extract(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_insert(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval, omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_insert(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval, omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oscillator_os_out =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Oscillator output)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oscillator_boost =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Fast startup control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t
 * Description: Implicit type of SMART3 NOPM IO control 0 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 22, offset 0, init 0):	MBZ	_
 *   fref_dr4_mb	(size 2, offset 22, init 0):	RW	50-ohm output buffer mode control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr7_mb	(size 2, offset 24, init 0):	RW	50-ohm output buffer mode control for group Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr6_mb	(size 2, offset 26, init 0):	RW	50-ohm output buffer mode control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr5_mb	(size 2, offset 28, init 0):	RW	50-ohm output buffer mode control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr1_mb	(size 2, offset 30, init 0):	RW	50-ohm output buffer mode control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t;
#define omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_default 0x0
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0xc00000) >> 22));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff3fffff) | (0xc00000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 22)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0x3000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 24)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0xc000000) >> 26));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 26)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0x30000000) >> 28));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    return((uint8_t )((_regval & 0xc0000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x3fffffff) | (0xc0000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 30)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr4_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr7_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr6_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr5_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr1_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t
 * Description: Implicit type of SMART3 NOPM IO control 1 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 27, offset 0, init 0):	MBZ	_
 *   fref_dr4_lb0	(size 1, offset 27, init 0):	RW	50-ohm output buffer load control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr7_lb0	(size 1, offset 28, init 0):	RW	50-ohm output buffer load control for group fref_dr7 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr6_lb0	(size 1, offset 29, init 0):	RW	50-ohm output buffer load control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr5_lb0	(size 1, offset 30, init 0):	RW	50-ohm output buffer load control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr1_lb0	(size 1, offset 31, init 0):	RW	50-ohm output buffer load control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t;
#define omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_default 0x0
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 27)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 29)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_extract(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_insert(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr4_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr7_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr7 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr6_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr5_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr1_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_gpiowk_t
 * Description: Implicit type of GPIOWK pads I/O control Access conditions. Read: unrestricted; Write: unrestricted register
 * Fields:
 *   _anon0	(size 28, offset 0, init 0):	RSVD	_
 *   gpiowk_io_pwrdnz	(size 1, offset 28, init 0):	RW	PWRDNZ control to gpiowk0-gpiowk2 IOsThis bit is used to protect the gpio_wk0-gpio_wk2 pads associated I/O cell when SIM_VDDS is not stable. .
 *   pad_gpio_wk2_low	(size 1, offset 29, init 0):	RW	LOW enable for gpio_wk2 PAD
 *   _anon30	(size 1, offset 30, init 0):	RSVD	_
 *   pad_gpio_wk1_low	(size 1, offset 31, init 0):	RW	LOW enable for gpio_wk1 PAD
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_t;
#define omap44xx_sysctrl_padconf_wkup_control_gpiowk_default 0x0
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_extract(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_extract(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_insert(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_insert(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_gpiowk_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_extract(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_extract(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_insert(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_insert(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_gpiowk_t )(_fieldval)) << 29)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_extract(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_extract(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_insert(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_insert(omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_gpiowk_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_gpiowk_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_gpiowk_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpiowk_io_pwrdnz =\t%" PRIx8 "\t(PWRDNZ control to gpiowk0-gpiowk2 IOsThis bit is used to protect the gpio_wk0-gpio_wk2 pads associated I/O cell when SIM_VDDS is not stable. .)\n", omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pad_gpio_wk2_low =\t%" PRIx8 "\t(LOW enable for gpio_wk2 PAD)\n", omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pad_gpio_wk1_low =\t%" PRIx8 "\t(LOW enable for gpio_wk1 PAD)\n", omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_i2c_2_t
 * Description: Implicit type of I2C pads control 2 Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 24, offset 0, init 0):	MBZ	_
 *   sr_scl_pullupresx	(size 1, offset 24, init 0):	RW	Active_low internal pull_up resistor enabled for sr i2c
 *   sr_scl_load_bits	(size 2, offset 25, init 0):	RW	Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c
 *   sr_scl_glfenb	(size 1, offset 27, init 0):	RW	Active_high glitch free operation enable pin for sr i2c receiver
 *   sr_sda_pullupresx	(size 1, offset 28, init 0):	RW	Active_low internal pull_up resistor enabled for sr i2c
 *   sr_sda_load_bits	(size 2, offset 29, init 0):	RW	Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c
 *   sr_sda_glfenb	(size 1, offset 31, init 0):	RW	Active_high glitch free operation enable pin for sr i2c receiver
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_t;
#define omap44xx_sysctrl_padconf_wkup_control_i2c_2_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 24)));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t )((_regval & 0x6000000) >> 25));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval)
{
    return((_regval & 0xf9ffffff) | (0x6000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 25)));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t )((_regval & 0x8000000) >> 27));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 27)));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 28)));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t )((_regval & 0x60000000) >> 29));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval)
{
    return((_regval & 0x9fffffff) | (0x60000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 29)));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_extract(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_insert(omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_i2c_2_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_i2c_2_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_pullupresx =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_low internal pull_up resistor enabled for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_load_bits =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_glfenb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_high glitch free operation enable pin for sr i2c receiver)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_pullupresx =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_low internal pull_up resistor enabled for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_load_bits =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_glfenb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_high glitch free operation enable pin for sr i2c receiver)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_jtag_t
 * Description: Implicit type of JTAG pads control Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 27, offset 0, init 0):	MBZ	_
 *   jtag_tdo_en	(size 1, offset 27, init 0):	RW	bus holder enable for jtag_tdo PAD
 *   jtag_tdi_en	(size 1, offset 28, init 0):	RW	bus holder enable for jtag_tdi PAD
 *   jtag_rtck_en	(size 1, offset 29, init 0):	RW	bus holder enable for jtag_rtck PAD
 *   jtag_tck_en	(size 1, offset 30, init 0):	RW	bus holder enable for jtag_tck PAD
 *   jtag_ntrst_en	(size 1, offset 31, init 0):	RW	bus holder enable for jtag_ntrst PAD
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_jtag_t;
#define omap44xx_sysctrl_padconf_wkup_control_jtag_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t )((_regval & 0x8000000) >> 27));
}

static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 27)));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 28)));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 29)));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 30)));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_extract(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_insert(omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_jtag_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_jtag_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_tdo PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_tdi PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_rtck PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_tck PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_ntrst PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_sys_t
 * Description: Implicit type of SYS controls Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 31, offset 0, init 0):	MBZ	_
 *   sys_nreswarm_pipu	(size 1, offset 31, init 0):	RW	Pull up enable for sys_nreswarm PAD
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_sys_t;
#define omap44xx_sysctrl_padconf_wkup_control_sys_default 0x0
static inline omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_extract(omap44xx_sysctrl_padconf_wkup_control_sys_t _regval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_extract(omap44xx_sysctrl_padconf_wkup_control_sys_t _regval)
{
    return((omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_sys_t omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_insert(omap44xx_sysctrl_padconf_wkup_control_sys_t _regval, omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_sys_t omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_insert(omap44xx_sysctrl_padconf_wkup_control_sys_t _regval, omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_sys_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_sys_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_sys_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_sys_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_sys_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_pipu =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pull up enable for sys_nreswarm PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t
 * Description: Implicit type of Wake-up control spare RC Access conditions. Read: unrestricted, Write: unrestricted register
 * Fields:
 *   _anon0	(size 24, offset 0, init 0):	MBZ	_
 *   wkup_control_spare_r_c7	(size 1, offset 24, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c6	(size 1, offset 25, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c5	(size 1, offset 26, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c4	(size 1, offset 27, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c3	(size 1, offset 28, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c2	(size 1, offset 29, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c1	(size 1, offset 30, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c0	(size 1, offset 31, init 0):	RW	Wake-up control spare register bits RC
 */
typedef uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t;
#define omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_default 0x0
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 24)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 25)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 26)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 27)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 28)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 29)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 30)));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_extract(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_insert(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 31)));
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_prtval(char *_s, size_t _size, omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c7 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c6 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c5 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c4 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c3 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c2 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c1 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c0 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_sysctrl_padconf_wkup_initials {
    omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_jtag_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_sys_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_initial = 0x0,
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_sysctrl_padconf_wkup_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register control_padconf_wkup_revision: Control module revision identifier Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register control_padconf_wkup_revision is not writeable
static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_padconf_wkup_revision (Control module revision identifier Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_padconf_wkup_hwinfo: Information about the IP module hardware configuration that is, typically the module HDL generics (if any). Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

// Register control_padconf_wkup_hwinfo is not writeable
static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_padconf_wkup_hwinfo (Information about the IP module hardware configuration that is, typically the module HDL generics (if any). Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_padconf_wkup_sysconfig: Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_padconf_wkup_sysconfig (Implicit type of Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   ip_sysconfig_idlemode	(size 2, offset 2, init 0):	RW	Select the local clock-gating strategy0x2,0x3: Clock is automatically gated when there is no access to the Control Module through L4-interconnect .
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
static inline omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval)
{
    _regval = (_regval & 0xc);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_padconf_wkup_sysconfig (Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip_sysconfig_idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the local clock-gating strategy0x2,0x3: Clock is automatically gated when there is no access to the Control Module through L4-interconnect .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_ip_sysconfig_idlemode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_ip_sysconfig_idlemode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t _regval = 0xc & (((omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_t )(_fieldval)) << 2);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_gpio_wk0_pad1_gpio_wk1: Register control for Pads gpio_wk0 and gpio_wk1 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_gpio_wk0_pad1_gpio_wk1 (Implicit type of Register control for Pads gpio_wk0 and gpio_wk1 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   gpio_wk0_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad gpio_wk0
 *   gpio_wk0_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad gpio_wk0
 *   gpio_wk0_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad gpio_wk0
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   gpio_wk0_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad gpio_wk0
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   gpio_wk0_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk0_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   gpio_wk1_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad gpio_wk1
 *   gpio_wk1_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad gpio_wk1
 *   gpio_wk1_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad gpio_wk1
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   gpio_wk1_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad gpio_wk1
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   gpio_wk1_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk1_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval)
{
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_gpio_wk0_pad1_gpio_wk1 (Register control for Pads gpio_wk0 and gpio_wk1 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk0_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 0);
    _regval = (_regval | (0x411f4118 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4117 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f410f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f401f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk0_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f011f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 16);
    _regval = (_regval | (0x4118411f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4117411f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f411f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f411f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_gpio_wk1_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f411f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_gpio_wk2_pad1_gpio_wk3: Register control for Pads gpio_wk2 and gpio_wk3 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_gpio_wk2_pad1_gpio_wk3 (Implicit type of Register control for Pads gpio_wk2 and gpio_wk3 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   gpio_wk2_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad gpio_wk2
 *   gpio_wk2_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad gpio_wk2
 *   gpio_wk2_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad gpio_wk2
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   gpio_wk2_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad gpio_wk2
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   gpio_wk2_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk2_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   gpio_wk3_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad gpio_wk3
 *   gpio_wk3_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad gpio_wk3
 *   gpio_wk3_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad gpio_wk3
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   gpio_wk3_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad gpio_wk3
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   gpio_wk3_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk3_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval)
{
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_gpio_wk2_pad1_gpio_wk3 (Register control for Pads gpio_wk2 and gpio_wk3 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk2_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 0);
    _regval = (_regval | (0x411f4118 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4117 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f410f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f401f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk2_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f011f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk3_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 16);
    _regval = (_regval | (0x4118411f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4117411f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f411f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f411f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_gpio_wk3_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f411f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_gpio_wk4_pad1_sr_scl: Register control for Pads gpio_wk4 and sr_scl Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_gpio_wk4_pad1_sr_scl (Implicit type of Register control for Pads gpio_wk4 and sr_scl Access conditions. Read: unrestricted, Write: unrestricted register)
 *   gpio_wk4_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad gpio_wk4
 *   gpio_wk4_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad gpio_wk4
 *   gpio_wk4_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad gpio_wk4
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   gpio_wk4_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad gpio_wk4
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   gpio_wk4_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   gpio_wk4_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   sr_scl_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sr_scl
 *   sr_scl_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sr_scl
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sr_scl_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sr_scl
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sr_scl_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sr_scl_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval)
{
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_gpio_wk4_pad1_sr_scl (Register control for Pads gpio_wk4 and sr_scl Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk4_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x41184118 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 3);
    _regval = (_regval | (0x41184117 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 4);
    _regval = (_regval | (0x4118410f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x4118401f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_gpio_wk4_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 14);
    _regval = (_regval | (0x4118011f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4110411f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 20);
    _regval = (_regval | (0x4108411f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x4018411f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_sr_scl_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_t )(_fieldval)) << 30);
    _regval = (_regval | (0x118411f & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_sr_sda_pad1_fref_xtal_in: Register control for Pads sr_sda and fref_xtal_in Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_sr_sda_pad1_fref_xtal_in (Implicit type of Register control for Pads sr_sda and fref_xtal_in Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   sr_sda_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad sr_sda
 *   sr_sda_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad sr_sda
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   sr_sda_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad sr_sda
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   sr_sda_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sr_sda_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   fref_xtal_in_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad fref_xtal_in
 *   _anon19	(size 13, offset 19, init 0):	MBZ	_
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval)
{
    _regval = (_regval & 0x7c118);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_sr_sda_pad1_fref_xtal_in (Register control for Pads sr_sda and fref_xtal_in Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_xtal_in_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_xtal_in)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 3);
    _regval = (_regval | (0x74110 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x7c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 4);
    _regval = (_regval | (0x74108 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x7c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 8);
    _regval = (_regval | (0x74018 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x7c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_sr_sda_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 14);
    _regval = (_regval | (0x70118 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x7c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_fref_xtal_in_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_xtal_in_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_t )(_fieldval)) << 16);
    _regval = (_regval | (0x4118 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x7c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq: Register control for Pads fref_slicer_in and fref_clk_ioreq Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq (Implicit type of Register control for Pads fref_slicer_in and fref_clk_ioreq Access conditions. Read: unrestricted, Write: unrestricted register)
 *   fref_slicer_in_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_slicer_in
 *   _anon3	(size 16, offset 3, init 0):	MBZ	_
 *   fref_clk_ioreq_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad fref_clk_ioreq
 *   fref_clk_ioreq_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad fref_clk_ioreq
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fref_clk_ioreq_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad fref_clk_ioreq
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   fref_clk_ioreq_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk_ioreq_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval)
{
    _regval = (_regval & 0xc1180007);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq (Register control for Pads fref_slicer_in and fref_clk_ioreq Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_slicer_in_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_slicer_in)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_slicer_in_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_slicer_in_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 0);
    _regval = (_regval | (0x41180000 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xc1180007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 19);
    _regval = (_regval | (0x41100007 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xc1180007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 20);
    _regval = (_regval | (0x41080007 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xc1180007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 24);
    _regval = (_regval | (0x40180007 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xc1180007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_fref_clk_ioreq_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_t )(_fieldval)) << 30);
    _regval = (_regval | (0x1180007 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xc1180007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req: Register control for Pads fref_clk0_out and fref_clk3_req Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req (Implicit type of Register control for Pads fref_clk0_out and fref_clk3_req Access conditions. Read: unrestricted, Write: unrestricted register)
 *   fref_clk0_out_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_clk0_out
 *   fref_clk0_out_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad fref_clk0_out
 *   fref_clk0_out_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad fref_clk0_out
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   fref_clk0_out_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad fref_clk0_out
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   fref_clk0_out_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk0_out_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   fref_clk3_req_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad fref_clk3_req
 *   fref_clk3_req_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad fref_clk3_req
 *   fref_clk3_req_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad fref_clk3_req
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fref_clk3_req_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad fref_clk3_req
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   fref_clk3_req_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk3_req_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval)
{
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req (Register control for Pads fref_clk0_out and fref_clk3_req Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk0_out_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 0);
    _regval = (_regval | (0x411f4118 & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4117 & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f410f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f401f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk0_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f011f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk3_req_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 16);
    _regval = (_regval | (0x4118411f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4117411f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f411f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f411f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_fref_clk3_req_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f411f & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req: Register control for Pads fref_clk3_out and fref_clk4_req Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req (Implicit type of Register control for Pads fref_clk3_out and fref_clk4_req Access conditions. Read: unrestricted, Write: unrestricted register)
 *   fref_clk3_out_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_clk3_out
 *   fref_clk3_out_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad fref_clk3_out
 *   fref_clk3_out_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad fref_clk3_out
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   fref_clk3_out_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad fref_clk3_out
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   fref_clk3_out_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk3_out_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   fref_clk4_req_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad fref_clk4_req
 *   fref_clk4_req_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad fref_clk4_req
 *   fref_clk4_req_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad fref_clk4_req
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   fref_clk4_req_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad fref_clk4_req
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   fref_clk4_req_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk4_req_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval)
{
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req (Register control for Pads fref_clk3_out and fref_clk4_req Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk3_out_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 0);
    _regval = (_regval | (0x411f4118 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4117 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f410f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f401f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk3_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f011f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk4_req_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 16);
    _regval = (_regval | (0x4118411f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4117411f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f411f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f411f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_fref_clk4_req_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f411f & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_fref_clk4_out_pad1_sys_32k: Register control for Pads fref_clk4_out and sys_32k Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_fref_clk4_out_pad1_sys_32k (Implicit type of Register control for Pads fref_clk4_out and sys_32k Access conditions. Read: unrestricted, Write: unrestricted register)
 *   fref_clk4_out_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad fref_clk4_out
 *   fref_clk4_out_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad fref_clk4_out
 *   fref_clk4_out_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad fref_clk4_out
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   fref_clk4_out_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad fref_clk4_out
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   fref_clk4_out_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   fref_clk4_out_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   sys_32k_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sys_32k
 *   sys_32k_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sys_32k
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sys_32k_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sys_32k
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sys_32k_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_32k_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval)
{
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_fref_clk4_out_pad1_sys_32k (Register control for Pads fref_clk4_out and sys_32k Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_clk4_out_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 0);
    _regval = (_regval | (0x41184118 & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 3);
    _regval = (_regval | (0x41184117 & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 4);
    _regval = (_regval | (0x4118410f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 8);
    _regval = (_regval | (0x4118401f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_fref_clk4_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 14);
    _regval = (_regval | (0x4118011f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4110411f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 20);
    _regval = (_regval | (0x4108411f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 24);
    _regval = (_regval | (0x4018411f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_sys_32k_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_t )(_fieldval)) << 30);
    _regval = (_regval | (0x118411f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm: Register control for Pads sys_nreswarm Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm (Implicit type of Register control for Pads sys_nreswarm Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 30, offset 0, init 0):	MBZ	_
 *   sys_nreswarm_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_nreswarm_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval)
{
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm (Register control for Pads sys_nreswarm Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_sys_nreswarm_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_t )(_fieldval)) << 30);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out: Register control for Pads sys_pwr_req and sys_pwron_reset_out Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out (Implicit type of Register control for Pads sys_pwr_req and sys_pwron_reset_out Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   sys_pwr_req_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad sys_pwr_req
 *   sys_pwr_req_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad sys_pwr_req
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   sys_pwr_req_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad sys_pwr_req
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   sys_pwr_req_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_pwr_req_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   sys_pwron_reset_out_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad sys_pwron_reset_out
 *   sys_pwron_reset_out_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sys_pwron_reset_out
 *   sys_pwron_reset_out_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sys_pwron_reset_out
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sys_pwron_reset_out_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sys_pwron_reset_out
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sys_pwron_reset_out_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_pwron_reset_out_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval)
{
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out (Register control for Pads sys_pwr_req and sys_pwron_reset_out Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4110 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f4108 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f4018 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwr_req_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f0118 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_pwron_reset_out_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 16);
    _regval = (_regval | (0x41184118 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 19);
    _regval = (_regval | (0x41174118 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f4118 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f4118 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_sys_pwron_reset_out_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f4118 & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_sys_boot6_pad1_sys_boot7: Register control for Pads sys_boot6 and sys_boot7 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_sys_boot6_pad1_sys_boot7 (Implicit type of Register control for Pads sys_boot6 and sys_boot7 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   sys_boot6_muxmode	(size 3, offset 0, init 0):	RW	Functional multiplexing selection for pad sys_boot6
 *   sys_boot6_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad sys_boot6
 *   sys_boot6_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad sys_boot6
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   sys_boot6_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad sys_boot6
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   sys_boot6_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_boot6_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   sys_boot7_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad sys_boot7
 *   sys_boot7_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad sys_boot7
 *   sys_boot7_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad sys_boot7
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   sys_boot7_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad sys_boot7
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   sys_boot7_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   sys_boot7_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval)
{
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_sys_boot6_pad1_sys_boot7 (Register control for Pads sys_boot6 and sys_boot7 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_boot6_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x7 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 0);
    _regval = (_regval | (0x411f4118 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4117 & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f410f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f401f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot6_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f011f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_boot7_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 16);
    _regval = (_regval | (0x4118411f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 19);
    _regval = (_regval | (0x4117411f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f411f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f411f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_sys_boot7_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f411f & mackerel_read_addr_32(_dev->base, 0x68)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_jtag_ntrst_pad1_jtag_tck: Register control for Pads jtag_ntrst and jtag_tck Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_jtag_ntrst_pad1_jtag_tck (Implicit type of Register control for Pads jtag_ntrst and jtag_tck Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   jtag_ntrst_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad jtag_ntrst
 *   jtag_ntrst_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad jtag_ntrst
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   jtag_ntrst_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad jtag_ntrst
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   jtag_ntrst_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_ntrst_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   jtag_tck_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad jtag_tck
 *   jtag_tck_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad jtag_tck
 *   jtag_tck_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad jtag_tck
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   jtag_tck_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad jtag_tck
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   jtag_tck_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tck_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval)
{
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_jtag_ntrst_pad1_jtag_tck (Register control for Pads jtag_ntrst and jtag_tck Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 3);
    _regval = (_regval | (0x411f4110 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 4);
    _regval = (_regval | (0x411f4108 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 8);
    _regval = (_regval | (0x411f4018 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_ntrst_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 14);
    _regval = (_regval | (0x411f0118 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_tck_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 16);
    _regval = (_regval | (0x41184118 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 19);
    _regval = (_regval | (0x41174118 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 20);
    _regval = (_regval | (0x410f4118 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 24);
    _regval = (_regval | (0x401f4118 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_jtag_tck_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_t )(_fieldval)) << 30);
    _regval = (_regval | (0x11f4118 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xc11fc118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc: Register control for Pads jtag_rtck and jtag_tms_tmsc Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc (Implicit type of Register control for Pads jtag_rtck and jtag_tms_tmsc Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   jtag_rtck_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad jtag_rtck
 *   jtag_rtck_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad jtag_rtck
 *   _anon5	(size 9, offset 5, init 0):	MBZ	_
 *   jtag_rtck_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_rtck_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   jtag_tms_tmsc_muxmode	(size 3, offset 16, init 0):	RW	Functional multiplexing selection for pad jtag_tms_tmsc
 *   _anon19	(size 5, offset 19, init 0):	MBZ	_
 *   jtag_tms_tmsc_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad jtag_tms_tmsc
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   jtag_tms_tmsc_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tms_tmsc_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval)
{
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc (Register control for Pads jtag_rtck and jtag_tms_tmsc Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_rtck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_rtck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_muxmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Functional multiplexing selection for pad jtag_tms_tmsc)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tms_tmsc)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 3);
    _regval = (_regval | (0x41074010 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 4);
    _regval = (_regval | (0x41074008 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_rtck_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 14);
    _regval = (_regval | (0x41070018 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_muxmode_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_tms_tmsc_muxmode_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = 0x70000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 16);
    _regval = (_regval | (0x41004018 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 24);
    _regval = (_regval | (0x40074018 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_jtag_tms_tmsc_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_t )(_fieldval)) << 30);
    _regval = (_regval | (0x1074018 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0xc107c018);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_pad0_jtag_tdi_pad1_jtag_tdo: Register control for Pads jtag_tdi and jtag_tdo Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_pad0_jtag_tdi_pad1_jtag_tdo (Implicit type of Register control for Pads jtag_tdi and jtag_tdo Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   jtag_tdi_pulludenable	(size 1, offset 3, init 0):	RW	pullup/down enable for pad jtag_tdi
 *   jtag_tdi_pulltypeselect	(size 1, offset 4, init 0):	RW	pullup/down selection for pad jtag_tdi
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   jtag_tdi_inputenable	(size 1, offset 8, init 0):	RW	Input enable value for pad jtag_tdi
 *   _anon9	(size 5, offset 9, init 0):	MBZ	_
 *   jtag_tdi_wakeupenable	(size 1, offset 14, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tdi_wakeupevent	(size 1, offset 15, init 0):	RO	Pad_x wake-up event status latched in the IO
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   jtag_tdo_pulludenable	(size 1, offset 19, init 0):	RW	pullup/down enable for pad jtag_tdo
 *   jtag_tdo_pulltypeselect	(size 1, offset 20, init 0):	RW	pullup/down selection for pad jtag_tdo
 *   _anon21	(size 3, offset 21, init 0):	MBZ	_
 *   jtag_tdo_inputenable	(size 1, offset 24, init 0):	RW	Input enable value for pad jtag_tdo
 *   _anon25	(size 5, offset 25, init 0):	MBZ	_
 *   jtag_tdo_wakeupenable	(size 1, offset 30, init 0):	RW	Input pad wake-up enable (and OFF mode input enable value)
 *   jtag_tdo_wakeupevent	(size 1, offset 31, init 0):	RO	Pad_x wake-up event status latched in the IO
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x74));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x74));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval)
{
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_pad0_jtag_tdi_pad1_jtag_tdo (Register control for Pads jtag_tdi and jtag_tdo Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_pulludenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down enable for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_pulltypeselect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(pullup/down selection for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_inputenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input enable value for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_wakeupenable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Input pad wake-up enable (and OFF mode input enable value))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_wakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pad_x wake-up event status latched in the IO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupevent_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x8 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 3);
    _regval = (_regval | (0x41184110 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x10 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 4);
    _regval = (_regval | (0x41184108 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x100 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 8);
    _regval = (_regval | (0x41184018 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdi_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x4000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 14);
    _regval = (_regval | (0x41180118 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulludenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulludenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x80000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 19);
    _regval = (_regval | (0x41104118 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_pulltypeselect_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_pulltypeselect_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x100000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 20);
    _regval = (_regval | (0x41084118 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_inputenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_inputenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 24);
    _regval = (_regval | (0x40184118 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_jtag_tdo_wakeupenable_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupenable_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_t )(_fieldval)) << 30);
    _regval = (_regval | (0x1184118 & mackerel_read_addr_32(_dev->base, 0x74)));
    // No read of register shadow required
    _regval = (_regval & 0xc118c118);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_padconf_wakeupevent_0: Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_padconf_wakeupevent_0 (Implicit type of Access conditions. Read: unrestricted, Write: unrestricted register)
 *   gpio_wk0_duplicatewakeupevent	(size 1, offset 0, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk0
 *   gpio_wk1_duplicatewakeupevent	(size 1, offset 1, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk1
 *   gpio_wk2_duplicatewakeupevent	(size 1, offset 2, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk2
 *   gpio_wk3_duplicatewakeupevent	(size 1, offset 3, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk3
 *   gpio_wk4_duplicatewakeupevent	(size 1, offset 4, init 0):	RO	Wake-up event status latched in the I/O for pad gpio_wk4
 *   sr_scl_duplicatewakeupevent	(size 1, offset 5, init 0):	RO	Wake-up event status latched in the I/O for pad sr_scl
 *   sr_sda_duplicatewakeupevent	(size 1, offset 6, init 0):	RO	Wake-up event status latched in the I/O for pad sr_sda
 *   fref_clk_ioreq_duplicatewakeupevent	(size 1, offset 7, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk_ioreq
 *   fref_clk0_out_duplicatewakeupevent	(size 1, offset 8, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk0_out
 *   fref_clk3_req_duplicatewakeupevent	(size 1, offset 9, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk3_req
 *   fref_clk3_out_duplicatewakeupevent	(size 1, offset 10, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk3_out
 *   fref_clk4_req_duplicatewakeupevent	(size 1, offset 11, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk4_req
 *   fref_clk4_out_duplicatewakeupevent	(size 1, offset 12, init 0):	RO	Wake-up event status latched in the I/O for pad fref_clk4_out
 *   sys_32k_duplicatewakeupevent	(size 1, offset 13, init 0):	RO	Wake-up event status latched in the I/O for pad sys_32k
 *   sys_nreswarm_duplicatewakeupevent	(size 1, offset 14, init 0):	RO	Wake-up event status latched in the I/O for pad sys_nreswarm
 *   sys_pwr_req_duplicatewakeupevent	(size 1, offset 15, init 0):	RO	Wake-up event status latched in the I/O for pad sys_pwr_req
 *   sys_pwron_reset_out_duplicatewakeupevent	(size 1, offset 16, init 0):	RO	Wake-up event status latched in the I/O for pad sys_pwron_reset_out
 *   sys_boot6_duplicatewakeupevent	(size 1, offset 17, init 0):	RO	Wake-up event status latched in the I/O for pad sys_boot6
 *   sys_boot7_duplicatewakeupevent	(size 1, offset 18, init 0):	RO	Wake-up event status latched in the I/O for pad sys_boot7
 *   jtag_ntrst_duplicatewakeupevent	(size 1, offset 19, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_ntrst
 *   jtag_tck_duplicatewakeupevent	(size 1, offset 20, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tck
 *   jtag_rtck_duplicatewakeupevent	(size 1, offset 21, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_rtck
 *   jtag_tms_tmsc_duplicatewakeupevent	(size 1, offset 22, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tms_tmsc
 *   jtag_tdi_duplicatewakeupevent	(size 1, offset 23, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tdi
 *   jtag_tdo_duplicatewakeupevent	(size 1, offset 24, init 0):	RO	Wake-up event status latched in the I/O for pad jtag_tdo
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x7c));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x7c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x7c, _regval);
}

// Register control_wkup_padconf_wakeupevent_0 is not writeable
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_padconf_wakeupevent_0 (Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk0_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk1_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk2_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk3_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_wk4_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad gpio_wk4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sr_scl)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sr_sda)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk_ioreq_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk_ioreq)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk0_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk0_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_req_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk3_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk3_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk3_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_req_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk4_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_clk4_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad fref_clk4_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_32k_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_32k)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_nreswarm)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwr_req_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_pwr_req)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_pwron_reset_out_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_pwron_reset_out)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot6_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_boot6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_boot7_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad sys_boot7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_ntrst)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_rtck)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tms_tmsc_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tms_tmsc)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tdi)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_duplicatewakeupevent =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up event status latched in the I/O for pad jtag_tdo)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk0_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk1_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk2_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk3_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_gpio_wk4_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_scl_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sr_sda_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk_ioreq_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk0_out_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_req_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk3_out_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_req_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_fref_clk4_out_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_32k_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_nreswarm_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwr_req_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_pwron_reset_out_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot6_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_sys_boot7_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_ntrst_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tck_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_rtck_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tms_tmsc_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdi_duplicatewakeupevent_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_gpio_wk1_wakeupevent_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_t _regval = mackerel_read_addr_32(_dev->base, 0x7c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_jtag_tdo_duplicatewakeupevent_extract(_regval));
}

/*
 * Register control_smart1nopmio_padconf_0: SMART1 NOPM I/O control 0 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_smart1nopmio_padconf_0 (Implicit type of SMART1 NOPM I/O control 0 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   gpiowk4_dr0_sc	(size 2, offset 12, init 0):	RW	Slew rate control for group gpiowk4_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 *   dpm_dr0_sc	(size 2, offset 14, init 0):	RW	Slew rate control for group dpm_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 *   _anon16	(size 2, offset 16, init 0):	MBZ	_
 *   gpio_dr7_sc	(size 2, offset 18, init 0):	RW	Slew rate control for group gpio_dr7 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 *   _anon20	(size 10, offset 20, init 0):	MBZ	_
 *   fref_dr0_sc	(size 2, offset 30, init 0):	RW	Slew rate control for group fref_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.
 */
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a0));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval)
{
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_smart1nopmio_padconf_0 (SMART1 NOPM I/O control 0 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpiowk4_dr0_sc =\t%" PRIx8 "\t(Slew rate control for group gpiowk4_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpm_dr0_sc =\t%" PRIx8 "\t(Slew rate control for group dpm_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_dr7_sc =\t%" PRIx8 "\t(Slew rate control for group gpio_dr7 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr0_sc =\t%" PRIx8 "\t(Slew rate control for group fref_dr0 Refer to , section Low Speed I/Os Combined Slew Rate vs TL Length and Load Settings for more details on SR settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5a0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5a0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5a0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5a0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpiowk4_dr0_sc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = 0x3000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 12);
    _regval = (_regval | (0xc00cc000 & mackerel_read_addr_32(_dev->base, 0x5a0)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_dpm_dr0_sc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = 0xc000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 14);
    _regval = (_regval | (0xc00c3000 & mackerel_read_addr_32(_dev->base, 0x5a0)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_gpio_dr7_sc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = 0xc0000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 18);
    _regval = (_regval | (0xc000f000 & mackerel_read_addr_32(_dev->base, 0x5a0)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_fref_dr0_sc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t _regval = 0xc0000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_t )(_fieldval)) << 30);
    _regval = (_regval | (0xcf000 & mackerel_read_addr_32(_dev->base, 0x5a0)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a0, _regval);
    // No shadow register to write to
}

/*
 * Register control_smart1nopmio_padconf_1: SMART1 NOPM I/O control 1 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_smart1nopmio_padconf_1 (Implicit type of SMART1 NOPM I/O control 1 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   gpiowk4_dr0_lb	(size 2, offset 12, init 0):	RW	Load control for group gpiowk4_dr0
 *   dpm_dr0_lb	(size 2, offset 14, init 0):	RW	Load control for group dpm_dr0
 *   _anon16	(size 2, offset 16, init 0):	MBZ	_
 *   gpio_dr7_lb	(size 2, offset 18, init 0):	RW	Load control for group gpio_dr7
 *   _anon20	(size 10, offset 20, init 0):	MBZ	_
 *   fref_dr0_lb	(size 2, offset 30, init 0):	RW	Load control for group fref_dr0
 */
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a4));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval)
{
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_smart1nopmio_padconf_1 (SMART1 NOPM I/O control 1 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpiowk4_dr0_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group gpiowk4_dr0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpm_dr0_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group dpm_dr0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpio_dr7_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group gpio_dr7)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr0_lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Load control for group fref_dr0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5a4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5a4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5a4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5a4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpiowk4_dr0_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = 0x3000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 12);
    _regval = (_regval | (0xc00cc000 & mackerel_read_addr_32(_dev->base, 0x5a4)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_dpm_dr0_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = 0xc000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 14);
    _regval = (_regval | (0xc00c3000 & mackerel_read_addr_32(_dev->base, 0x5a4)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_gpio_dr7_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = 0xc0000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 18);
    _regval = (_regval | (0xc000f000 & mackerel_read_addr_32(_dev->base, 0x5a4)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_fref_dr0_lb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_fref_dr0_lb_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t _regval = 0xc0000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_t )(_fieldval)) << 30);
    _regval = (_regval | (0xcf000 & mackerel_read_addr_32(_dev->base, 0x5a4)));
    // No read of register shadow required
    _regval = (_regval & 0xc00cf000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a4, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_padconf_mode: PAD Voltage Mode control Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_padconf_mode (Implicit type of PAD Voltage Mode control Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 30, offset 0, init 0):	MBZ	_
 *   vdds_dv_bank2_shared1	(size 1, offset 30, init 0):	RW	PAD Voltage level control for vdds_dv_bank2_shared1
 *   vdds_dv_fref	(size 1, offset 31, init 0):	RW	PAD Voltage level control for vdds_dv_fref
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a8));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a8));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a8, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval)
{
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a8, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval = mackerel_read_addr_32(_dev->base, 0x5a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_padconf_mode (PAD Voltage Mode control Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vdds_dv_bank2_shared1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PAD Voltage level control for vdds_dv_bank2_shared1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vdds_dv_fref =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PAD Voltage level control for vdds_dv_fref)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval = mackerel_read_addr_32(_dev->base, 0x5a8);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval = mackerel_read_addr_32(_dev->base, 0x5a8);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_bank2_shared1_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t )(_fieldval)) << 30);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x5a8)));
    // No read of register shadow required
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_vdds_dv_fref_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_vdds_dv_fref_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_t )(_fieldval)) << 31);
    _regval = (_regval | (0x40000000 & mackerel_read_addr_32(_dev->base, 0x5a8)));
    // No read of register shadow required
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5a8, _regval);
    // No shadow register to write to
}

/*
 * Register control_xtal_oscillator: XTAL OSCILLATOR control Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_xtal_oscillator (Implicit type of XTAL OSCILLATOR control Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 30, offset 0, init 0):	MBZ	_
 *   oscillator_os_out	(size 1, offset 30, init 0):	RO	Oscillator output
 *   oscillator_boost	(size 1, offset 31, init 0):	RW	Fast startup control
 */
static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5ac));
}

static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5ac));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5ac, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval)
{
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5ac, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval = mackerel_read_addr_32(_dev->base, 0x5ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_xtal_oscillator (XTAL OSCILLATOR control Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oscillator_os_out =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Oscillator output)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oscillator_boost =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Fast startup control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_oscillator_os_out_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval = mackerel_read_addr_32(_dev->base, 0x5ac);
    return(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_os_out_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval = mackerel_read_addr_32(_dev->base, 0x5ac);
    return(omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_oscillator_boost_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_oscillator_boost_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_t )(_fieldval)) << 31);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xc0000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5ac, _regval);
    // No shadow register to write to
}

/*
 * Register control_smart3nopmio_padconf_0: SMART3 NOPM IO control 0 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_smart3nopmio_padconf_0 (Implicit type of SMART3 NOPM IO control 0 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 22, offset 0, init 0):	MBZ	_
 *   fref_dr4_mb	(size 2, offset 22, init 0):	RW	50-ohm output buffer mode control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr7_mb	(size 2, offset 24, init 0):	RW	50-ohm output buffer mode control for group Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr6_mb	(size 2, offset 26, init 0):	RW	50-ohm output buffer mode control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr5_mb	(size 2, offset 28, init 0):	RW	50-ohm output buffer mode control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr1_mb	(size 2, offset 30, init 0):	RW	50-ohm output buffer mode control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 */
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b0));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b0));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval)
{
    _regval = (_regval & 0xffc00000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_smart3nopmio_padconf_0 (SMART3 NOPM IO control 0 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr4_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr7_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr6_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr5_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr1_mb =\t%" PRIx8 "\t(50-ohm output buffer mode control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = mackerel_read_addr_32(_dev->base, 0x5b0);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr4_mb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = 0xc00000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 22);
    _regval = (_regval | (0xff000000 & mackerel_read_addr_32(_dev->base, 0x5b0)));
    // No read of register shadow required
    _regval = (_regval & 0xffc00000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr7_mb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = 0x3000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfcc00000 & mackerel_read_addr_32(_dev->base, 0x5b0)));
    // No read of register shadow required
    _regval = (_regval & 0xffc00000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr6_mb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = 0xc000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf3c00000 & mackerel_read_addr_32(_dev->base, 0x5b0)));
    // No read of register shadow required
    _regval = (_regval & 0xffc00000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr5_mb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = 0x30000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 28);
    _regval = (_regval | (0xcfc00000 & mackerel_read_addr_32(_dev->base, 0x5b0)));
    // No read of register shadow required
    _regval = (_regval & 0xffc00000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_fref_dr1_mb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t _regval = 0xc0000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_t )(_fieldval)) << 30);
    _regval = (_regval | (0x3fc00000 & mackerel_read_addr_32(_dev->base, 0x5b0)));
    // No read of register shadow required
    _regval = (_regval & 0xffc00000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b0, _regval);
    // No shadow register to write to
}

/*
 * Register control_smart3nopmio_padconf_1: SMART3 NOPM IO control 1 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_smart3nopmio_padconf_1 (Implicit type of SMART3 NOPM IO control 1 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 27, offset 0, init 0):	MBZ	_
 *   fref_dr4_lb0	(size 1, offset 27, init 0):	RW	50-ohm output buffer load control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr7_lb0	(size 1, offset 28, init 0):	RW	50-ohm output buffer load control for group fref_dr7 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr6_lb0	(size 1, offset 29, init 0):	RW	50-ohm output buffer load control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr5_lb0	(size 1, offset 30, init 0):	RW	50-ohm output buffer load control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 *   fref_dr1_lb0	(size 1, offset 31, init 0):	RW	50-ohm output buffer load control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.
 */
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b4));
}

static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b4));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval)
{
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_smart3nopmio_padconf_1 (SMART3 NOPM IO control 1 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr4_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr4 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr7_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr7 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr6_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr6 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr5_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr5 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fref_dr1_lb0 =\t%" PRIx8 "\t(50-ohm output buffer load control for group fref_dr1 Refer to 50-ohm output buffer I/Os with combined Mode and Load Settings for more details on mode settings.)\n", omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4);
    return(omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr4_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = 0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf0000000 & mackerel_read_addr_32(_dev->base, 0x5b4)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr7_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = 0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 28);
    _regval = (_regval | (0xe8000000 & mackerel_read_addr_32(_dev->base, 0x5b4)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr6_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = 0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 29);
    _regval = (_regval | (0xd8000000 & mackerel_read_addr_32(_dev->base, 0x5b4)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr5_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 30);
    _regval = (_regval | (0xb8000000 & mackerel_read_addr_32(_dev->base, 0x5b4)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_fref_dr1_lb0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_t )(_fieldval)) << 31);
    _regval = (_regval | (0x78000000 & mackerel_read_addr_32(_dev->base, 0x5b4)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4, _regval);
    // No shadow register to write to
}

/*
 * Register control_gpiowk: GPIOWK pads I/O control Access conditions. Read: unrestricted; Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_gpiowk (Implicit type of GPIOWK pads I/O control Access conditions. Read: unrestricted; Write: unrestricted register)
 *   _anon0	(size 28, offset 0, init 0):	RSVD	_
 *   gpiowk_io_pwrdnz	(size 1, offset 28, init 0):	RW	PWRDNZ control to gpiowk0-gpiowk2 IOsThis bit is used to protect the gpio_wk0-gpio_wk2 pads associated I/O cell when SIM_VDDS is not stable. .
 *   pad_gpio_wk2_low	(size 1, offset 29, init 0):	RW	LOW enable for gpio_wk2 PAD
 *   _anon30	(size 1, offset 30, init 0):	RSVD	_
 *   pad_gpio_wk1_low	(size 1, offset 31, init 0):	RW	LOW enable for gpio_wk1 PAD
 */
static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x600));
}

static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_gpiowk_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x600));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval)
{
    _regval = (_regval & 0xb0000000);
    // No MB1 fields present
    _regval = (_regval | (0x4fffffff & mackerel_read_addr_32(_dev->base, 0x600)));
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_gpiowk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_gpiowk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = mackerel_read_addr_32(_dev->base, 0x600);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_gpiowk (GPIOWK pads I/O control Access conditions. Read: unrestricted; Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpiowk_io_pwrdnz =\t%" PRIx8 "\t(PWRDNZ control to gpiowk0-gpiowk2 IOsThis bit is used to protect the gpio_wk0-gpio_wk2 pads associated I/O cell when SIM_VDDS is not stable. .)\n", omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pad_gpio_wk2_low =\t%" PRIx8 "\t(LOW enable for gpio_wk2 PAD)\n", omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pad_gpio_wk1_low =\t%" PRIx8 "\t(LOW enable for gpio_wk1 PAD)\n", omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = mackerel_read_addr_32(_dev->base, 0x600);
    return(omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = mackerel_read_addr_32(_dev->base, 0x600);
    return(omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = mackerel_read_addr_32(_dev->base, 0x600);
    return(omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_gpiowk_io_pwrdnz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = 0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_gpiowk_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x600)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk2_low_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = 0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_gpiowk_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x600)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_gpiowk_pad_gpio_wk1_low_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_gpiowk_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_gpiowk_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x600)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600, _regval);
    // No shadow register to write to
}

/*
 * Register control_i2c_2: I2C pads control 2 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_i2c_2 (Implicit type of I2C pads control 2 Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 24, offset 0, init 0):	MBZ	_
 *   sr_scl_pullupresx	(size 1, offset 24, init 0):	RW	Active_low internal pull_up resistor enabled for sr i2c
 *   sr_scl_load_bits	(size 2, offset 25, init 0):	RW	Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c
 *   sr_scl_glfenb	(size 1, offset 27, init 0):	RW	Active_high glitch free operation enable pin for sr i2c receiver
 *   sr_sda_pullupresx	(size 1, offset 28, init 0):	RW	Active_low internal pull_up resistor enabled for sr i2c
 *   sr_sda_load_bits	(size 2, offset 29, init 0):	RW	Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c
 *   sr_sda_glfenb	(size 1, offset 31, init 0):	RW	Active_high glitch free operation enable pin for sr i2c receiver
 */
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x604));
}

static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_i2c_2_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x604));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval)
{
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_i2c_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_i2c_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_i2c_2 (I2C pads control 2 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_pullupresx =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_low internal pull_up resistor enabled for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_load_bits =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_scl_glfenb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_high glitch free operation enable pin for sr i2c receiver)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_pullupresx =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_low internal pull_up resistor enabled for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_load_bits =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal Pull up resistor in Fast or Standard mode / High_speed mode for sr i2c)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_sda_glfenb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Active_high glitch free operation enable pin for sr i2c receiver)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    return(omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    return(omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    return(omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    return(omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    return(omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = mackerel_read_addr_32(_dev->base, 0x604);
    return(omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_pullupresx_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfe000000 & mackerel_read_addr_32(_dev->base, 0x604)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_load_bits_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = 0x6000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf9000000 & mackerel_read_addr_32(_dev->base, 0x604)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_scl_glfenb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = 0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7000000 & mackerel_read_addr_32(_dev->base, 0x604)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_pullupresx_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_pullupresx_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = 0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 28);
    _regval = (_regval | (0xef000000 & mackerel_read_addr_32(_dev->base, 0x604)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_load_bits_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_load_bits_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = 0x60000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 29);
    _regval = (_regval | (0x9f000000 & mackerel_read_addr_32(_dev->base, 0x604)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_i2c_2_sr_sda_glfenb_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sr_sda_glfenb_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_i2c_2_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_i2c_2_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7f000000 & mackerel_read_addr_32(_dev->base, 0x604)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x604, _regval);
    // No shadow register to write to
}

/*
 * Register control_jtag: JTAG pads control Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_jtag (Implicit type of JTAG pads control Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 27, offset 0, init 0):	MBZ	_
 *   jtag_tdo_en	(size 1, offset 27, init 0):	RW	bus holder enable for jtag_tdo PAD
 *   jtag_tdi_en	(size 1, offset 28, init 0):	RW	bus holder enable for jtag_tdi PAD
 *   jtag_rtck_en	(size 1, offset 29, init 0):	RW	bus holder enable for jtag_rtck PAD
 *   jtag_tck_en	(size 1, offset 30, init 0):	RW	bus holder enable for jtag_tck PAD
 *   jtag_ntrst_en	(size 1, offset 31, init 0):	RW	bus holder enable for jtag_ntrst PAD
 */
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x608));
}

static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_jtag_t omap44xx_sysctrl_padconf_wkup_control_jtag_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x608));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval)
{
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_jtag_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_jtag_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_jtag (JTAG pads control Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdo_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_tdo PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tdi_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_tdi PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_rtck_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_rtck PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_tck_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_tck PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jtag_ntrst_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(bus holder enable for jtag_ntrst PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    return(omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    return(omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    return(omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    return(omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_extract(_regval));
}

static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = mackerel_read_addr_32(_dev->base, 0x608);
    return(omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdo_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = 0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf0000000 & mackerel_read_addr_32(_dev->base, 0x608)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tdi_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = 0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 28);
    _regval = (_regval | (0xe8000000 & mackerel_read_addr_32(_dev->base, 0x608)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_rtck_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = 0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 29);
    _regval = (_regval | (0xd8000000 & mackerel_read_addr_32(_dev->base, 0x608)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_tck_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 30);
    _regval = (_regval | (0xb8000000 & mackerel_read_addr_32(_dev->base, 0x608)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_jtag_jtag_ntrst_en_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_jtag_ntrst_en_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_jtag_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_jtag_t )(_fieldval)) << 31);
    _regval = (_regval | (0x78000000 & mackerel_read_addr_32(_dev->base, 0x608)));
    // No read of register shadow required
    _regval = (_regval & 0xf8000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x608, _regval);
    // No shadow register to write to
}

/*
 * Register control_sys: SYS controls Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_sys (Implicit type of SYS controls Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 31, offset 0, init 0):	MBZ	_
 *   sys_nreswarm_pipu	(size 1, offset 31, init 0):	RW	Pull up enable for sys_nreswarm PAD
 */
static inline omap44xx_sysctrl_padconf_wkup_control_sys_t omap44xx_sysctrl_padconf_wkup_control_sys_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_sys_t omap44xx_sysctrl_padconf_wkup_control_sys_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60c));
}

static inline omap44xx_sysctrl_padconf_wkup_control_sys_t omap44xx_sysctrl_padconf_wkup_control_sys_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_sys_t omap44xx_sysctrl_padconf_wkup_control_sys_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_sys_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_sys_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_sys_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_sys_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_sys_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_sys_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_sys_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_sys_t _regval)
{
    _regval = (_regval & 0x80000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_sys_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_sys_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_sys_t _regval = mackerel_read_addr_32(_dev->base, 0x60c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_sys (SYS controls Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys_nreswarm_pipu =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_prtval(_s + _r, _avail, omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pull up enable for sys_nreswarm PAD)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_sys_t _regval = mackerel_read_addr_32(_dev->base, 0x60c);
    return(omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_sys_sys_nreswarm_pipu_wrf(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_sys_nreswarm_pipu_status_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_sys_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_sys_t )(_fieldval)) << 31);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x80000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60c, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_control_spare_rw: Wake-up control spare RW Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x614));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x614));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x614, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x614, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x614);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw (Wake-up control spare RW Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_r: Wake-up control spare R Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x618));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x618));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x618, _regval);
}

// Register control_wkup_control_spare_r is not writeable
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x618);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_r (Wake-up control spare R Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_r_c0: Wake-up control spare RC Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.control_wkup_control_spare_r_c0 (Implicit type of Wake-up control spare RC Access conditions. Read: unrestricted, Write: unrestricted register)
 *   _anon0	(size 24, offset 0, init 0):	MBZ	_
 *   wkup_control_spare_r_c7	(size 1, offset 24, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c6	(size 1, offset 25, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c5	(size 1, offset 26, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c4	(size 1, offset 27, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c3	(size 1, offset 28, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c2	(size 1, offset 29, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c1	(size 1, offset 30, init 0):	RW	Wake-up control spare register bits RC
 *   wkup_control_spare_r_c0	(size 1, offset 31, init 0):	RW	Wake-up control spare register bits RC
 */
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x61c));
}

static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x61c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_rawwr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wr(__DN(t) *_dev, omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval)
{
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_r_c0 (Wake-up control spare RC Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c7 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c6 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c5 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c4 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c3 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c2 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c1 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkup_control_spare_r_c0 =\t%" PRIx8 "\t(Wake-up control spare register bits RC)\n", omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_extract(_regval));
}

static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_rdf(__DN(t) *_dev)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = mackerel_read_addr_32(_dev->base, 0x61c);
    return(omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_extract(_regval));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c7_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x1000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfe000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x2000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfd000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c5_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x4000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfb000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x8000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x10000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 28);
    _regval = (_regval | (0xef000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x20000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdf000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x40000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbf000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_wkup_control_spare_r_c0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t _regval = 0x80000000 & (((omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7f000000 & mackerel_read_addr_32(_dev->base, 0x61c)));
    // No read of register shadow required
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x61c, _regval);
    // No shadow register to write to
}

/*
 * Register control_wkup_control_spare_rw1: WKUP control spare RW1 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x620));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x620));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x620, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x620, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x620);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw1 (WKUP control spare RW1 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw2: WKUP control spare RW2 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x624));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x624));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x624, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x624, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x624);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw2 (WKUP control spare RW2 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw3: WKUP control spare RW3 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x628));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x628));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x628, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x628, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x628);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw3 (WKUP control spare RW3 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw4: WKUP control spare RW4 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x62c));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x62c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x62c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x62c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x62c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw4 (WKUP control spare RW4 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw5: WKUP control spare RW5 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x630));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x630));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x630, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x630, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x630);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw5 (WKUP control spare RW5 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw6: WKUP control spare RW6 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x634));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x634));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x634, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x634, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x634);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw6 (WKUP control spare RW6 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw7: WKUP control spare RW7 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x638));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x638));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x638, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x638, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x638);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw7 (WKUP control spare RW7 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw8: WKUP control spare RW8 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x63c));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x63c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x63c, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x63c, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x63c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw8 (WKUP control spare RW8 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_rw9: WKUP control spare RW9 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x640));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x640));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x640, _regval);
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x640, _regval);
}

static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x640);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_rw9 (WKUP control spare RW9 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register control_wkup_control_spare_r1: WKUP control spare R1 Access conditions. Read: unrestricted, Write: unrestricted
 * Type: omap44xx_sysctrl_padconf_wkup.uint32 (primitive type)
 */
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64c));
}

static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64c));
}

static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x64c, _regval);
}

// Register control_wkup_control_spare_r1 is not writeable
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x64c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control_wkup_control_spare_r1 (WKUP control spare R1 Access conditions. Read: unrestricted, Write: unrestricted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int omap44xx_sysctrl_padconf_wkup_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_sysctrl_padconf_wkup_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_sysctrl_padconf_wkup ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_revision_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_hwinfo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_padconf_wkup_sysconfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk0_pad1_gpio_wk1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk2_pad1_gpio_wk3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_gpio_wk4_pad1_sr_scl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sr_sda_pad1_fref_xtal_in_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_slicer_in_pad1_fref_clk_ioreq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk0_out_pad1_fref_clk3_req_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk3_out_pad1_fref_clk4_req_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_fref_clk4_out_pad1_sys_32k_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_nrespwron_pad1_sys_nreswarm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_pwr_req_pad1_sys_pwron_reset_out_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_sys_boot6_pad1_sys_boot7_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_ntrst_pad1_jtag_tck_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_rtck_pad1_jtag_tms_tmsc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_pad0_jtag_tdi_pad1_jtag_tdo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_wakeupevent_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_smart1nopmio_padconf_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_padconf_mode_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_xtal_oscillator_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_smart3nopmio_padconf_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_gpiowk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_i2c_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_jtag_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_sys_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r_c0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw6_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw7_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw8_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_rw9_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_sysctrl_padconf_wkup_control_wkup_control_spare_r1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_sysctrl_padconf_wkup\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_sysctrl_padconf_wkup_DEV_H
