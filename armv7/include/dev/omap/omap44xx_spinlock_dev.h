#ifndef __omap44xx_spinlock_DEV_H
#define __omap44xx_spinlock_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_spinlock ## _ ## x
/*
 * Constants defn: omap44xx_spinlock.clockactivity_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_clockactivity_status_t;
#define omap44xx_spinlock_CLOCKACTIVITY_0_r ((omap44xx_spinlock_clockactivity_status_t)0x0)
#define omap44xx_spinlock_CLOCKACTIVITY_1_r ((omap44xx_spinlock_clockactivity_status_t)0x1)

static inline char *omap44xx_spinlock_clockactivity_status_describe(omap44xx_spinlock_clockactivity_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_clockactivity_status_describe(omap44xx_spinlock_clockactivity_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_CLOCKACTIVITY_0_r:
        return("CLOCKACTIVITY_0_r: Interface clock is not required by the module during IDLE mode and may be switched off.");
    case omap44xx_spinlock_CLOCKACTIVITY_1_r:
        return("CLOCKACTIVITY_1_r: Interface clock is required by the module, even during idle mode.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_clockactivity_status_prtval(char *_s, size_t _size, omap44xx_spinlock_clockactivity_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_clockactivity_status_prtval(char *_s, size_t _size, omap44xx_spinlock_clockactivity_status_t _e)
{
    char *d = omap44xx_spinlock_clockactivity_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_clockactivity_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.sidlemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_spinlock_sidlemode_status_t;
#define omap44xx_spinlock_SIDLEMODE_0_r ((omap44xx_spinlock_sidlemode_status_t)0x0)
#define omap44xx_spinlock_SIDLEMODE_1_r ((omap44xx_spinlock_sidlemode_status_t)0x1)
#define omap44xx_spinlock_SIDLEMODE_2_r ((omap44xx_spinlock_sidlemode_status_t)0x2)
#define omap44xx_spinlock_SIDLEMODE_3_r ((omap44xx_spinlock_sidlemode_status_t)0x3)

static inline char *omap44xx_spinlock_sidlemode_status_describe(omap44xx_spinlock_sidlemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_sidlemode_status_describe(omap44xx_spinlock_sidlemode_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_SIDLEMODE_0_r:
        return("SIDLEMODE_0_r: Force-idle. IDLE request is acknowledged unconditionally and immediately.");
    case omap44xx_spinlock_SIDLEMODE_1_r:
        return("SIDLEMODE_1_r: No-idle. IDLE request is never acknowledged.");
    case omap44xx_spinlock_SIDLEMODE_2_r:
        return("SIDLEMODE_2_r: Smart-idle. IDLE request acknowledgement is based on the internal module activity.");
    case omap44xx_spinlock_SIDLEMODE_3_r:
        return("SIDLEMODE_3_r: Reserved. Do not use.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_sidlemode_status_prtval(char *_s, size_t _size, omap44xx_spinlock_sidlemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_sidlemode_status_prtval(char *_s, size_t _size, omap44xx_spinlock_sidlemode_status_t _e)
{
    char *d = omap44xx_spinlock_sidlemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_sidlemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.enwakeup_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_enwakeup_status_t;
#define omap44xx_spinlock_ENWAKEUP_0_r ((omap44xx_spinlock_enwakeup_status_t)0x0)
#define omap44xx_spinlock_ENWAKEUP_1_r ((omap44xx_spinlock_enwakeup_status_t)0x1)

static inline char *omap44xx_spinlock_enwakeup_status_describe(omap44xx_spinlock_enwakeup_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_enwakeup_status_describe(omap44xx_spinlock_enwakeup_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_ENWAKEUP_0_r:
        return("ENWAKEUP_0_r: Wakeup generation is disabled.");
    case omap44xx_spinlock_ENWAKEUP_1_r:
        return("ENWAKEUP_1_r: Wakeup generation is enabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_enwakeup_status_prtval(char *_s, size_t _size, omap44xx_spinlock_enwakeup_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_enwakeup_status_prtval(char *_s, size_t _size, omap44xx_spinlock_enwakeup_status_t _e)
{
    char *d = omap44xx_spinlock_enwakeup_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_enwakeup_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.softreset_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_softreset_status_t;
#define omap44xx_spinlock_SOFTRESET_0_w ((omap44xx_spinlock_softreset_status_t)0x0)
#define omap44xx_spinlock_SOFTRESET_1_w ((omap44xx_spinlock_softreset_status_t)0x1)

static inline char *omap44xx_spinlock_softreset_status_describe(omap44xx_spinlock_softreset_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_softreset_status_describe(omap44xx_spinlock_softreset_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_SOFTRESET_0_w:
        return("SOFTRESET_0_w: No action");
    case omap44xx_spinlock_SOFTRESET_1_w:
        return("SOFTRESET_1_w: Start soft reset sequence");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_softreset_status_prtval(char *_s, size_t _size, omap44xx_spinlock_softreset_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_softreset_status_prtval(char *_s, size_t _size, omap44xx_spinlock_softreset_status_t _e)
{
    char *d = omap44xx_spinlock_softreset_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_softreset_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.autogating_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_autogating_status_t;
#define omap44xx_spinlock_AUTOGATING_0_r ((omap44xx_spinlock_autogating_status_t)0x0)
#define omap44xx_spinlock_AUTOGATING_1_r ((omap44xx_spinlock_autogating_status_t)0x1)

static inline char *omap44xx_spinlock_autogating_status_describe(omap44xx_spinlock_autogating_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_autogating_status_describe(omap44xx_spinlock_autogating_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_AUTOGATING_0_r:
        return("AUTOGATING_0_r: Interface clock is not gated when the L4-CFG interface is idle.");
    case omap44xx_spinlock_AUTOGATING_1_r:
        return("AUTOGATING_1_r: Automatic internal interface clock gating strategy is applied, based on the L4-CFG interface activity.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_autogating_status_prtval(char *_s, size_t _size, omap44xx_spinlock_autogating_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_autogating_status_prtval(char *_s, size_t _size, omap44xx_spinlock_autogating_status_t _e)
{
    char *d = omap44xx_spinlock_autogating_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_autogating_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.numlocks_status ()
 *  - width 8 bits
 */
typedef uint8_t omap44xx_spinlock_numlocks_status_t;
#define omap44xx_spinlock_NUMLOCKS_1_r ((omap44xx_spinlock_numlocks_status_t)0x1)
#define omap44xx_spinlock_NUMLOCKS_2_r ((omap44xx_spinlock_numlocks_status_t)0x2)
#define omap44xx_spinlock_NUMLOCKS_4_r ((omap44xx_spinlock_numlocks_status_t)0x4)
#define omap44xx_spinlock_NUMLOCKS_8_r ((omap44xx_spinlock_numlocks_status_t)0x8)

static inline char *omap44xx_spinlock_numlocks_status_describe(omap44xx_spinlock_numlocks_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_numlocks_status_describe(omap44xx_spinlock_numlocks_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_NUMLOCKS_1_r:
        return("NUMLOCKS_1_r: This instance has 32 lock registers.");
    case omap44xx_spinlock_NUMLOCKS_2_r:
        return("NUMLOCKS_2_r: This instance has 64 lock registers.");
    case omap44xx_spinlock_NUMLOCKS_4_r:
        return("NUMLOCKS_4_r: This instance has 128 lock registers.");
    case omap44xx_spinlock_NUMLOCKS_8_r:
        return("NUMLOCKS_8_r: This instance has 256 lock registers.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_numlocks_status_prtval(char *_s, size_t _size, omap44xx_spinlock_numlocks_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_numlocks_status_prtval(char *_s, size_t _size, omap44xx_spinlock_numlocks_status_t _e)
{
    char *d = omap44xx_spinlock_numlocks_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_numlocks_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.iu0_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_iu0_status_t;
#define omap44xx_spinlock_IU0_0_r ((omap44xx_spinlock_iu0_status_t)0x0)
#define omap44xx_spinlock_IU0_1_r ((omap44xx_spinlock_iu0_status_t)0x1)

static inline char *omap44xx_spinlock_iu0_status_describe(omap44xx_spinlock_iu0_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_iu0_status_describe(omap44xx_spinlock_iu0_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_IU0_0_r:
        return("IU0_0_r: All lock registers 0 31 are in the Not Taken state.");
    case omap44xx_spinlock_IU0_1_r:
        return("IU0_1_r: At least one of the lock registers 0 31 is in the Taken state.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_iu0_status_prtval(char *_s, size_t _size, omap44xx_spinlock_iu0_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_iu0_status_prtval(char *_s, size_t _size, omap44xx_spinlock_iu0_status_t _e)
{
    char *d = omap44xx_spinlock_iu0_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_iu0_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.resetdone_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_resetdone_status_t;
#define omap44xx_spinlock_RESETDONE_0_r ((omap44xx_spinlock_resetdone_status_t)0x0)
#define omap44xx_spinlock_RESETDONE_1_r ((omap44xx_spinlock_resetdone_status_t)0x1)

static inline char *omap44xx_spinlock_resetdone_status_describe(omap44xx_spinlock_resetdone_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_resetdone_status_describe(omap44xx_spinlock_resetdone_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_RESETDONE_0_r:
        return("RESETDONE_0_r: Reset in progress.");
    case omap44xx_spinlock_RESETDONE_1_r:
        return("RESETDONE_1_r: Reset is completed.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_resetdone_status_prtval(char *_s, size_t _size, omap44xx_spinlock_resetdone_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_resetdone_status_prtval(char *_s, size_t _size, omap44xx_spinlock_resetdone_status_t _e)
{
    char *d = omap44xx_spinlock_resetdone_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_resetdone_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_spinlock.taken_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_spinlock_taken_status_t;
#define omap44xx_spinlock_TAKEN_0_r ((omap44xx_spinlock_taken_status_t)0x0)
#define omap44xx_spinlock_TAKEN_1_r ((omap44xx_spinlock_taken_status_t)0x1)

static inline char *omap44xx_spinlock_taken_status_describe(omap44xx_spinlock_taken_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_spinlock_taken_status_describe(omap44xx_spinlock_taken_status_t _e)
{
    switch (_e) {
    case omap44xx_spinlock_TAKEN_0_r:
        return("TAKEN_0_r: Lock was previously Not Taken (free). The requester is granted the lock.");
    case omap44xx_spinlock_TAKEN_1_r:
        return("TAKEN_1_r: Lock was previously Taken. The requester is not granted the lock and must retry.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_spinlock_taken_status_prtval(char *_s, size_t _size, omap44xx_spinlock_taken_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_taken_status_prtval(char *_s, size_t _size, omap44xx_spinlock_taken_status_t _e)
{
    char *d = omap44xx_spinlock_taken_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_spinlock_taken_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_spinlock_sysconfig_t
 * Description: Implicit type of This register controls the various parameters of the L4-CFG interface. Note that most fields are read-only. register
 * Fields:
 *   autogating	(size 1, offset 0, init 0):	RO	Internal interface clock gating strategy.
 *   softreset	(size 1, offset 1, init 0):	WO	Module software reset.
 *   enwakeup	(size 1, offset 2, init 0):	RO	Asynchronous wakeup gereration.
 *   sidlemode	(size 2, offset 3, init 0):	RO	Slave interface power management (IDLE request/acknowledgement control).
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   clockactivity	(size 1, offset 8, init 0):	RO	Indicates whether the module requires the interface clock when in IDLE mode.
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_spinlock_sysconfig_t;
#define omap44xx_spinlock_sysconfig_default 0x0
static inline omap44xx_spinlock_autogating_status_t omap44xx_spinlock_sysconfig_autogating_extract(omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_autogating_status_t omap44xx_spinlock_sysconfig_autogating_extract(omap44xx_spinlock_sysconfig_t _regval)
{
    return((omap44xx_spinlock_autogating_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_autogating_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_autogating_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_autogating_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_autogating_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_spinlock_sysconfig_t )(_fieldval)) << 0)));
}

static inline omap44xx_spinlock_softreset_status_t omap44xx_spinlock_sysconfig_softreset_extract(omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_softreset_status_t omap44xx_spinlock_sysconfig_softreset_extract(omap44xx_spinlock_sysconfig_t _regval)
{
    return((omap44xx_spinlock_softreset_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_softreset_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_softreset_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_softreset_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_spinlock_sysconfig_t )(_fieldval)) << 1)));
}

static inline omap44xx_spinlock_enwakeup_status_t omap44xx_spinlock_sysconfig_enwakeup_extract(omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_enwakeup_status_t omap44xx_spinlock_sysconfig_enwakeup_extract(omap44xx_spinlock_sysconfig_t _regval)
{
    return((omap44xx_spinlock_enwakeup_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_enwakeup_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_enwakeup_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_enwakeup_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_enwakeup_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_spinlock_sysconfig_t )(_fieldval)) << 2)));
}

static inline omap44xx_spinlock_sidlemode_status_t omap44xx_spinlock_sysconfig_sidlemode_extract(omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sidlemode_status_t omap44xx_spinlock_sysconfig_sidlemode_extract(omap44xx_spinlock_sysconfig_t _regval)
{
    return((omap44xx_spinlock_sidlemode_status_t )((_regval & 0x18) >> 3));
}

static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_sidlemode_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_sidlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_sidlemode_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_sidlemode_status_t _fieldval)
{
    return((_regval & 0xffffffe7) | (0x18 & (((omap44xx_spinlock_sysconfig_t )(_fieldval)) << 3)));
}

static inline omap44xx_spinlock_clockactivity_status_t omap44xx_spinlock_sysconfig_clockactivity_extract(omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_clockactivity_status_t omap44xx_spinlock_sysconfig_clockactivity_extract(omap44xx_spinlock_sysconfig_t _regval)
{
    return((omap44xx_spinlock_clockactivity_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_clockactivity_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_clockactivity_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_clockactivity_insert(omap44xx_spinlock_sysconfig_t _regval, omap44xx_spinlock_clockactivity_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_spinlock_sysconfig_t )(_fieldval)) << 8)));
}

static inline int omap44xx_spinlock_sysconfig_prtval(char *_s, size_t _size, omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_sysconfig_prtval(char *_s, size_t _size, omap44xx_spinlock_sysconfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autogating =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_autogating_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_autogating_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal interface clock gating strategy.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_softreset_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module software reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enwakeup =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_enwakeup_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_enwakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous wakeup gereration.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sidlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_sidlemode_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_sidlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Slave interface power management (IDLE request/acknowledgement control).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clockactivity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_clockactivity_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_clockactivity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates whether the module requires the interface clock when in IDLE mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_spinlock_systatus_t
 * Description: Implicit type of This register provides status information about this instance of the Spinlock module. register
 * Fields:
 *   resetdone	(size 1, offset 0, init 0):	RO	Reset done status.
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   iu0	(size 1, offset 8, init 0):	RO	In-Use flag 0, covering lock registers 0 - 31.
 *   iu1	(size 1, offset 9, init 0):	RO	In-Use flag 1. Reads always return 0.
 *   iu2	(size 1, offset 10, init 0):	RO	In-Use flag 2. Reads always return 0.
 *   iu3	(size 1, offset 11, init 0):	RO	In-Use flag 3. Reads always return 0.
 *   iu4	(size 1, offset 12, init 0):	RO	In-Use flag 4. Reads always return 0.
 *   iu5	(size 1, offset 13, init 0):	RO	In-Use flag 5. Reads always return 0.
 *   iu6	(size 1, offset 14, init 0):	RO	In-Use flag 6. Reads always return 0.
 *   iu7	(size 1, offset 15, init 0):	RO	In-Use flag 7. Reads always return 0.
 *   _anon16	(size 8, offset 16, init 0):	MBZ	_
 *   numlocks	(size 8, offset 24, init 0):	RO	Number of lock registers implemeted.
 */
typedef uint32_t omap44xx_spinlock_systatus_t;
#define omap44xx_spinlock_systatus_default 0x0
static inline omap44xx_spinlock_resetdone_status_t omap44xx_spinlock_systatus_resetdone_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_resetdone_status_t omap44xx_spinlock_systatus_resetdone_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((omap44xx_spinlock_resetdone_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_resetdone_insert(omap44xx_spinlock_systatus_t _regval, omap44xx_spinlock_resetdone_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_resetdone_insert(omap44xx_spinlock_systatus_t _regval, omap44xx_spinlock_resetdone_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 0)));
}

static inline omap44xx_spinlock_iu0_status_t omap44xx_spinlock_systatus_iu0_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_iu0_status_t omap44xx_spinlock_systatus_iu0_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((omap44xx_spinlock_iu0_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu0_insert(omap44xx_spinlock_systatus_t _regval, omap44xx_spinlock_iu0_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu0_insert(omap44xx_spinlock_systatus_t _regval, omap44xx_spinlock_iu0_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu1_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu1_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu1_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu1_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 9)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu2_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu2_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu2_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu2_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 10)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu3_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu3_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu3_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu3_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 11)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu4_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu4_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu4_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu4_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 12)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu5_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu5_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu5_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu5_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 13)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu6_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu6_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu6_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu6_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 14)));
}

static inline uint8_t omap44xx_spinlock_systatus_iu7_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu7_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu7_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_iu7_insert(omap44xx_spinlock_systatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 15)));
}

static inline omap44xx_spinlock_numlocks_status_t omap44xx_spinlock_systatus_numlocks_extract(omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_numlocks_status_t omap44xx_spinlock_systatus_numlocks_extract(omap44xx_spinlock_systatus_t _regval)
{
    return((omap44xx_spinlock_numlocks_status_t )((_regval & 0xff000000) >> 24));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_numlocks_insert(omap44xx_spinlock_systatus_t _regval, omap44xx_spinlock_numlocks_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_numlocks_insert(omap44xx_spinlock_systatus_t _regval, omap44xx_spinlock_numlocks_status_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((omap44xx_spinlock_systatus_t )(_fieldval)) << 24)));
}

static inline int omap44xx_spinlock_systatus_prtval(char *_s, size_t _size, omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_systatus_prtval(char *_s, size_t _size, omap44xx_spinlock_systatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_resetdone_status_prtval(_s + _r, _avail, omap44xx_spinlock_systatus_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Reset done status.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_iu0_status_prtval(_s + _r, _avail, omap44xx_spinlock_systatus_iu0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(In-Use flag 0, covering lock registers 0 - 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu1 =\t%" PRIx8 "\t(In-Use flag 1. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu2 =\t%" PRIx8 "\t(In-Use flag 2. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu3 =\t%" PRIx8 "\t(In-Use flag 3. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu4 =\t%" PRIx8 "\t(In-Use flag 4. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu5 =\t%" PRIx8 "\t(In-Use flag 5. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu6 =\t%" PRIx8 "\t(In-Use flag 6. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu7 =\t%" PRIx8 "\t(In-Use flag 7. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " numlocks =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_numlocks_status_prtval(_s + _r, _avail, omap44xx_spinlock_systatus_numlocks_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Number of lock registers implemeted.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_spinlock_lock_reg_i_t
 * Description: Implicit type of This register contains the state of one lock. register array
 * Fields:
 *   taken	(size 1, offset 0, init 0):	RW	Lock State
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_spinlock_lock_reg_i_t;
#define omap44xx_spinlock_lock_reg_i_default 0x0
static inline omap44xx_spinlock_taken_status_t omap44xx_spinlock_lock_reg_i_taken_extract(omap44xx_spinlock_lock_reg_i_t _regval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_taken_status_t omap44xx_spinlock_lock_reg_i_taken_extract(omap44xx_spinlock_lock_reg_i_t _regval)
{
    return((omap44xx_spinlock_taken_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_spinlock_lock_reg_i_t omap44xx_spinlock_lock_reg_i_taken_insert(omap44xx_spinlock_lock_reg_i_t _regval, omap44xx_spinlock_taken_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_spinlock_lock_reg_i_t omap44xx_spinlock_lock_reg_i_taken_insert(omap44xx_spinlock_lock_reg_i_t _regval, omap44xx_spinlock_taken_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_spinlock_lock_reg_i_t )(_fieldval)) << 0)));
}

static inline int omap44xx_spinlock_lock_reg_i_prtval(char *_s, size_t _size, omap44xx_spinlock_lock_reg_i_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_lock_reg_i_prtval(char *_s, size_t _size, omap44xx_spinlock_lock_reg_i_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " taken =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_taken_status_prtval(_s + _r, _avail, omap44xx_spinlock_lock_reg_i_taken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Lock State)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    omap44xx_spinlock_sysconfig_t sysconfig_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_spinlock_initials {
    omap44xx_spinlock_revision_initial = 0x0,
    omap44xx_spinlock_sysconfig_initial = 0x0,
    omap44xx_spinlock_systatus_initial = 0x0,
    omap44xx_spinlock_lock_reg_i_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_spinlock_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register revision: This register contains the IP revision code
 * Type: omap44xx_spinlock.uint32 (primitive type)
 */
static inline uint32_t omap44xx_spinlock_revision_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_spinlock_revision_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t omap44xx_spinlock_revision_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_spinlock_revision_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_spinlock_revision_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_revision_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register revision is not writeable
static inline int omap44xx_spinlock_revision_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_revision_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register revision (This register contains the IP revision code): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sysconfig: This register controls the various parameters of the L4-CFG interface. Note that most fields are read-only.
 * Type: omap44xx_spinlock.sysconfig (Implicit type of This register controls the various parameters of the L4-CFG interface. Note that most fields are read-only. register)
 *   autogating	(size 1, offset 0, init 0):	RO	Internal interface clock gating strategy.
 *   softreset	(size 1, offset 1, init 0):	WO	Module software reset.
 *   enwakeup	(size 1, offset 2, init 0):	RO	Asynchronous wakeup gereration.
 *   sidlemode	(size 2, offset 3, init 0):	RO	Slave interface power management (IDLE request/acknowledgement control).
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   clockactivity	(size 1, offset 8, init 0):	RO	Indicates whether the module requires the interface clock when in IDLE mode.
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sysconfig_t omap44xx_spinlock_sysconfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_spinlock_sysconfig_rawwr(__DN(t) *_dev, omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_sysconfig_rawwr(__DN(t) *_dev, omap44xx_spinlock_sysconfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_spinlock_sysconfig_wr(__DN(t) *_dev, omap44xx_spinlock_sysconfig_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_sysconfig_wr(__DN(t) *_dev, omap44xx_spinlock_sysconfig_t _regval)
{
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_spinlock_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_sysconfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_spinlock_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sysconfig (This register controls the various parameters of the L4-CFG interface. Note that most fields are read-only.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autogating =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_autogating_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_autogating_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal interface clock gating strategy.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_softreset_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Module software reset.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enwakeup =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_enwakeup_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_enwakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous wakeup gereration.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sidlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_sidlemode_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_sidlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Slave interface power management (IDLE request/acknowledgement control).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clockactivity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_clockactivity_status_prtval(_s + _r, _avail, omap44xx_spinlock_sysconfig_clockactivity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicates whether the module requires the interface clock when in IDLE mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_spinlock_autogating_status_t omap44xx_spinlock_sysconfig_autogating_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_autogating_status_t omap44xx_spinlock_sysconfig_autogating_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_spinlock_sysconfig_autogating_extract(_regval));
}

static inline omap44xx_spinlock_enwakeup_status_t omap44xx_spinlock_sysconfig_enwakeup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_enwakeup_status_t omap44xx_spinlock_sysconfig_enwakeup_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_spinlock_sysconfig_enwakeup_extract(_regval));
}

static inline omap44xx_spinlock_sidlemode_status_t omap44xx_spinlock_sysconfig_sidlemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_sidlemode_status_t omap44xx_spinlock_sysconfig_sidlemode_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_spinlock_sysconfig_sidlemode_extract(_regval));
}

static inline omap44xx_spinlock_clockactivity_status_t omap44xx_spinlock_sysconfig_clockactivity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_clockactivity_status_t omap44xx_spinlock_sysconfig_clockactivity_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_sysconfig_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_spinlock_sysconfig_clockactivity_extract(_regval));
}

static inline omap44xx_spinlock_softreset_status_t omap44xx_spinlock_sysconfig_softreset_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_softreset_status_t omap44xx_spinlock_sysconfig_softreset_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_spinlock_sysconfig_softreset_extract(_dev->sysconfig_shadow));
}

static inline void omap44xx_spinlock_sysconfig_softreset_wrf(__DN(t) *_dev, omap44xx_spinlock_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_sysconfig_softreset_wrf(__DN(t) *_dev, omap44xx_spinlock_softreset_status_t _fieldval)
{
    omap44xx_spinlock_sysconfig_t _regval = 0x2 & (((omap44xx_spinlock_sysconfig_t )(_fieldval)) << 1);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x11f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->sysconfig_shadow = _regval;
}

/*
 * Register systatus: This register provides status information about this instance of the Spinlock module.
 * Type: omap44xx_spinlock.systatus (Implicit type of This register provides status information about this instance of the Spinlock module. register)
 *   resetdone	(size 1, offset 0, init 0):	RO	Reset done status.
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   iu0	(size 1, offset 8, init 0):	RO	In-Use flag 0, covering lock registers 0 - 31.
 *   iu1	(size 1, offset 9, init 0):	RO	In-Use flag 1. Reads always return 0.
 *   iu2	(size 1, offset 10, init 0):	RO	In-Use flag 2. Reads always return 0.
 *   iu3	(size 1, offset 11, init 0):	RO	In-Use flag 3. Reads always return 0.
 *   iu4	(size 1, offset 12, init 0):	RO	In-Use flag 4. Reads always return 0.
 *   iu5	(size 1, offset 13, init 0):	RO	In-Use flag 5. Reads always return 0.
 *   iu6	(size 1, offset 14, init 0):	RO	In-Use flag 6. Reads always return 0.
 *   iu7	(size 1, offset 15, init 0):	RO	In-Use flag 7. Reads always return 0.
 *   _anon16	(size 8, offset 16, init 0):	MBZ	_
 *   numlocks	(size 8, offset 24, init 0):	RO	Number of lock registers implemeted.
 */
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_systatus_t omap44xx_spinlock_systatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_spinlock_systatus_rawwr(__DN(t) *_dev, omap44xx_spinlock_systatus_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_systatus_rawwr(__DN(t) *_dev, omap44xx_spinlock_systatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

// Register systatus is not writeable
static inline int omap44xx_spinlock_systatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_systatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register systatus (This register provides status information about this instance of the Spinlock module.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_resetdone_status_prtval(_s + _r, _avail, omap44xx_spinlock_systatus_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Reset done status.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_iu0_status_prtval(_s + _r, _avail, omap44xx_spinlock_systatus_iu0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(In-Use flag 0, covering lock registers 0 - 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu1 =\t%" PRIx8 "\t(In-Use flag 1. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu2 =\t%" PRIx8 "\t(In-Use flag 2. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu3 =\t%" PRIx8 "\t(In-Use flag 3. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu4 =\t%" PRIx8 "\t(In-Use flag 4. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu5 =\t%" PRIx8 "\t(In-Use flag 5. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu6 =\t%" PRIx8 "\t(In-Use flag 6. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iu7 =\t%" PRIx8 "\t(In-Use flag 7. Reads always return 0.)\n", omap44xx_spinlock_systatus_iu7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " numlocks =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_numlocks_status_prtval(_s + _r, _avail, omap44xx_spinlock_systatus_numlocks_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Number of lock registers implemeted.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_spinlock_resetdone_status_t omap44xx_spinlock_systatus_resetdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_resetdone_status_t omap44xx_spinlock_systatus_resetdone_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_resetdone_extract(_regval));
}

static inline omap44xx_spinlock_iu0_status_t omap44xx_spinlock_systatus_iu0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_iu0_status_t omap44xx_spinlock_systatus_iu0_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu0_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu1_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu1_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu2_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu2_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu3_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu3_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu4_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu4_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu5_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu5_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu5_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu6_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu6_extract(_regval));
}

static inline uint8_t omap44xx_spinlock_systatus_iu7_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_spinlock_systatus_iu7_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_iu7_extract(_regval));
}

static inline omap44xx_spinlock_numlocks_status_t omap44xx_spinlock_systatus_numlocks_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_spinlock_numlocks_status_t omap44xx_spinlock_systatus_numlocks_rdf(__DN(t) *_dev)
{
    omap44xx_spinlock_systatus_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_spinlock_systatus_numlocks_extract(_regval));
}

/*
 * Register array lock_reg_i: This register contains the state of one lock.
 * Type: omap44xx_spinlock.lock_reg_i (Implicit type of This register contains the state of one lock. register array)
 *   taken	(size 1, offset 0, init 0):	RW	Lock State
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static const size_t omap44xx_spinlock_lock_reg_i_length = 32;
static inline omap44xx_spinlock_lock_reg_i_t omap44xx_spinlock_lock_reg_i_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_spinlock_lock_reg_i_t omap44xx_spinlock_lock_reg_i_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x800 + (_i * (32 / 8))));
}

static inline omap44xx_spinlock_lock_reg_i_t omap44xx_spinlock_lock_reg_i_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_spinlock_lock_reg_i_t omap44xx_spinlock_lock_reg_i_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x800 + (_i * (32 / 8))));
}

static inline void omap44xx_spinlock_lock_reg_i_rawwr(__DN(t) *_dev, int _i, omap44xx_spinlock_lock_reg_i_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_lock_reg_i_rawwr(__DN(t) *_dev, int _i, omap44xx_spinlock_lock_reg_i_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x800 + (_i * (32 / 8)), _regval);
}

static inline void omap44xx_spinlock_lock_reg_i_wr(__DN(t) *_dev, int _i, omap44xx_spinlock_lock_reg_i_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_lock_reg_i_wr(__DN(t) *_dev, int _i, omap44xx_spinlock_lock_reg_i_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x800 + (_i * (32 / 8)), _regval);
}

static inline int omap44xx_spinlock_lock_reg_i_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_lock_reg_i_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_spinlock_lock_reg_i_t _regval = mackerel_read_addr_32(_dev->base, 0x800 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "lock_reg_i", _i, "This register contains the state of one lock.");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " taken =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_taken_status_prtval(_s + _r, _avail, omap44xx_spinlock_lock_reg_i_taken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Lock State)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline int omap44xx_spinlock_lock_reg_i_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_lock_reg_i_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = omap44xx_spinlock_lock_reg_i_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline omap44xx_spinlock_taken_status_t omap44xx_spinlock_lock_reg_i_taken_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline omap44xx_spinlock_taken_status_t omap44xx_spinlock_lock_reg_i_taken_rdf(__DN(t) *_dev, int _i)
{
    omap44xx_spinlock_lock_reg_i_t _regval = mackerel_read_addr_32(_dev->base, 0x800 + (_i * (32 / 8)));
    return(omap44xx_spinlock_lock_reg_i_taken_extract(_regval));
}

static inline void omap44xx_spinlock_lock_reg_i_taken_wrf(__DN(t) *_dev, int _i, omap44xx_spinlock_taken_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_spinlock_lock_reg_i_taken_wrf(__DN(t) *_dev, int _i, omap44xx_spinlock_taken_status_t _fieldval)
{
    omap44xx_spinlock_lock_reg_i_t _regval = 0x1 & (((omap44xx_spinlock_lock_reg_i_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline int omap44xx_spinlock_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_spinlock_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_spinlock ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_revision_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_sysconfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_systatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_spinlock_lock_reg_i_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_spinlock\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_spinlock_DEV_H
