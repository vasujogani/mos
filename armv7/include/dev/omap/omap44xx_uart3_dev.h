#ifndef __omap44xx_uart3_DEV_H
#define __omap44xx_uart3_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_uart3 ## _ ## x
/*
 * Constants defn: omap44xx_uart3.cts_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_cts_it_status_t;
#define omap44xx_uart3_CTS_IT_0 ((omap44xx_uart3_cts_it_status_t)0x0)
#define omap44xx_uart3_CTS_IT_1 ((omap44xx_uart3_cts_it_status_t)0x1)

static inline char *omap44xx_uart3_cts_it_status_describe(omap44xx_uart3_cts_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_cts_it_status_describe(omap44xx_uart3_cts_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_CTS_IT_0:
        return("CTS_IT_0: Disables the CTS* interrupt");
    case omap44xx_uart3_CTS_IT_1:
        return("CTS_IT_1: Enables the CTS* interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_cts_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_cts_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_cts_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_cts_it_status_t _e)
{
    char *d = omap44xx_uart3_cts_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_cts_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rts_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rts_it_status_t;
#define omap44xx_uart3_RTS_IT_0 ((omap44xx_uart3_rts_it_status_t)0x0)
#define omap44xx_uart3_RTS_IT_1 ((omap44xx_uart3_rts_it_status_t)0x1)

static inline char *omap44xx_uart3_rts_it_status_describe(omap44xx_uart3_rts_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rts_it_status_describe(omap44xx_uart3_rts_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RTS_IT_0:
        return("RTS_IT_0: Disables the RTS* interrupt");
    case omap44xx_uart3_RTS_IT_1:
        return("RTS_IT_1: Enables the RTS* interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rts_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_rts_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rts_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_rts_it_status_t _e)
{
    char *d = omap44xx_uart3_rts_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rts_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.xoff_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_xoff_it_status_t;
#define omap44xx_uart3_XOFF_IT_0 ((omap44xx_uart3_xoff_it_status_t)0x0)
#define omap44xx_uart3_XOFF_IT_1 ((omap44xx_uart3_xoff_it_status_t)0x1)

static inline char *omap44xx_uart3_xoff_it_status_describe(omap44xx_uart3_xoff_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_xoff_it_status_describe(omap44xx_uart3_xoff_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_XOFF_IT_0:
        return("XOFF_IT_0: Disables the XOFF interrupt");
    case omap44xx_uart3_XOFF_IT_1:
        return("XOFF_IT_1: Enables the XOFF interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_xoff_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_xoff_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xoff_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_xoff_it_status_t _e)
{
    char *d = omap44xx_uart3_xoff_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_xoff_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.sleep_mode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_sleep_mode_status_t;
#define omap44xx_uart3_SLEEP_MODE_0 ((omap44xx_uart3_sleep_mode_status_t)0x0)
#define omap44xx_uart3_SLEEP_MODE_1 ((omap44xx_uart3_sleep_mode_status_t)0x1)

static inline char *omap44xx_uart3_sleep_mode_status_describe(omap44xx_uart3_sleep_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_sleep_mode_status_describe(omap44xx_uart3_sleep_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SLEEP_MODE_0:
        return("SLEEP_MODE_0: Disables sleep mode");
    case omap44xx_uart3_SLEEP_MODE_1:
        return("SLEEP_MODE_1: Enables sleep mode (stop baud rate clock when the module is inactive)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_sleep_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_sleep_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sleep_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_sleep_mode_status_t _e)
{
    char *d = omap44xx_uart3_sleep_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_sleep_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.modem_sts_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_modem_sts_it_status_t;
#define omap44xx_uart3_MODEM_STS_IT_0 ((omap44xx_uart3_modem_sts_it_status_t)0x0)
#define omap44xx_uart3_MODEM_STS_IT_1 ((omap44xx_uart3_modem_sts_it_status_t)0x1)

static inline char *omap44xx_uart3_modem_sts_it_status_describe(omap44xx_uart3_modem_sts_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_modem_sts_it_status_describe(omap44xx_uart3_modem_sts_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_MODEM_STS_IT_0:
        return("MODEM_STS_IT_0: Disables the modem status register interrupt");
    case omap44xx_uart3_MODEM_STS_IT_1:
        return("MODEM_STS_IT_1: Enables the modem status register interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_modem_sts_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_modem_sts_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_modem_sts_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_modem_sts_it_status_t _e)
{
    char *d = omap44xx_uart3_modem_sts_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_modem_sts_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.thr_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_thr_it_status_t;
#define omap44xx_uart3_THR_IT_0 ((omap44xx_uart3_thr_it_status_t)0x0)
#define omap44xx_uart3_THR_IT_1 ((omap44xx_uart3_thr_it_status_t)0x1)

static inline char *omap44xx_uart3_thr_it_status_describe(omap44xx_uart3_thr_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_thr_it_status_describe(omap44xx_uart3_thr_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_THR_IT_0:
        return("THR_IT_0: Disables the THR interrupt");
    case omap44xx_uart3_THR_IT_1:
        return("THR_IT_1: Enables the THR interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_thr_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_thr_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_thr_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_thr_it_status_t _e)
{
    char *d = omap44xx_uart3_thr_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_thr_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rhr_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rhr_it_status_t;
#define omap44xx_uart3_RHR_IT_0 ((omap44xx_uart3_rhr_it_status_t)0x0)
#define omap44xx_uart3_RHR_IT_1 ((omap44xx_uart3_rhr_it_status_t)0x1)

static inline char *omap44xx_uart3_rhr_it_status_describe(omap44xx_uart3_rhr_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rhr_it_status_describe(omap44xx_uart3_rhr_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RHR_IT_0:
        return("RHR_IT_0: Disables the RHR interrupt and time-out interrupt");
    case omap44xx_uart3_RHR_IT_1:
        return("RHR_IT_1: Enables the RHR interrupt and time-out interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rhr_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_rhr_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rhr_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_rhr_it_status_t _e)
{
    char *d = omap44xx_uart3_rhr_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rhr_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.auto_cts_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_auto_cts_en_status_t;
#define omap44xx_uart3_AUTO_CTS_EN_0 ((omap44xx_uart3_auto_cts_en_status_t)0x0)
#define omap44xx_uart3_AUTO_CTS_EN_1 ((omap44xx_uart3_auto_cts_en_status_t)0x1)

static inline char *omap44xx_uart3_auto_cts_en_status_describe(omap44xx_uart3_auto_cts_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_auto_cts_en_status_describe(omap44xx_uart3_auto_cts_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_AUTO_CTS_EN_0:
        return("AUTO_CTS_EN_0: Normal operation");
    case omap44xx_uart3_AUTO_CTS_EN_1:
        return("AUTO_CTS_EN_1: Auto-CTS flow control is enabled. Transmission is halted when the CTS* pin is high (inactive).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_auto_cts_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_auto_cts_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_auto_cts_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_auto_cts_en_status_t _e)
{
    char *d = omap44xx_uart3_auto_cts_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_auto_cts_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.auto_rts_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_auto_rts_en_status_t;
#define omap44xx_uart3_AUTO_RTS_EN_0 ((omap44xx_uart3_auto_rts_en_status_t)0x0)
#define omap44xx_uart3_AUTO_RTS_EN_1 ((omap44xx_uart3_auto_rts_en_status_t)0x1)

static inline char *omap44xx_uart3_auto_rts_en_status_describe(omap44xx_uart3_auto_rts_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_auto_rts_en_status_describe(omap44xx_uart3_auto_rts_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_AUTO_RTS_EN_0:
        return("AUTO_RTS_EN_0: Normal operation");
    case omap44xx_uart3_AUTO_RTS_EN_1:
        return("AUTO_RTS_EN_1: Auto-RTS flow control is enabled. RTS* pin goes high (inactive) when the RX FIFO HALT trigger level,[3:0], is reached, and goes low (active) when the RX FIFO RESTORE transmission trigger level is reached.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_auto_rts_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_auto_rts_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_auto_rts_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_auto_rts_en_status_t _e)
{
    char *d = omap44xx_uart3_auto_rts_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_auto_rts_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.special_char_detect_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_special_char_detect_status_t;
#define omap44xx_uart3_SPECIAL_CHAR_DETECT_0 ((omap44xx_uart3_special_char_detect_status_t)0x0)
#define omap44xx_uart3_SPECIAL_CHAR_DETECT_1 ((omap44xx_uart3_special_char_detect_status_t)0x1)

static inline char *omap44xx_uart3_special_char_detect_status_describe(omap44xx_uart3_special_char_detect_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_special_char_detect_status_describe(omap44xx_uart3_special_char_detect_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SPECIAL_CHAR_DETECT_0:
        return("SPECIAL_CHAR_DETECT_0: Normal operation");
    case omap44xx_uart3_SPECIAL_CHAR_DETECT_1:
        return("SPECIAL_CHAR_DETECT_1: Special character detect enable. Received data is compared with XOFF2 data. If a match occurs, the received data is transferred to the RX FIFO and the[4] bit is set to 1 to indicate that a special character was detected.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_special_char_detect_status_prtval(char *_s, size_t _size, omap44xx_uart3_special_char_detect_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_special_char_detect_status_prtval(char *_s, size_t _size, omap44xx_uart3_special_char_detect_status_t _e)
{
    char *d = omap44xx_uart3_special_char_detect_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_special_char_detect_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.enhanced_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_enhanced_en_status_t;
#define omap44xx_uart3_ENHANCED_EN_0 ((omap44xx_uart3_enhanced_en_status_t)0x0)
#define omap44xx_uart3_ENHANCED_EN_1 ((omap44xx_uart3_enhanced_en_status_t)0x1)

static inline char *omap44xx_uart3_enhanced_en_status_describe(omap44xx_uart3_enhanced_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_enhanced_en_status_describe(omap44xx_uart3_enhanced_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_ENHANCED_EN_0:
        return("ENHANCED_EN_0: Disables writing to IER bits 4-7, bits 4-5, and MCR bits 5-7.");
    case omap44xx_uart3_ENHANCED_EN_1:
        return("ENHANCED_EN_1: Enables writing to IER bits 4-7, bits 4-5, and MCR bits 5-7.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_enhanced_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_enhanced_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_enhanced_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_enhanced_en_status_t _e)
{
    char *d = omap44xx_uart3_enhanced_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_enhanced_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dma_mode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dma_mode_status_t;
#define omap44xx_uart3_DMA_MODE_0_w ((omap44xx_uart3_dma_mode_status_t)0x0)
#define omap44xx_uart3_DMA_MODE_1_w ((omap44xx_uart3_dma_mode_status_t)0x1)

static inline char *omap44xx_uart3_dma_mode_status_describe(omap44xx_uart3_dma_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dma_mode_status_describe(omap44xx_uart3_dma_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DMA_MODE_0_w:
        return("DMA_MODE_0_w: DMA_MODE 0 (No DMA)");
    case omap44xx_uart3_DMA_MODE_1_w:
        return("DMA_MODE_1_w: DMA_MODE 1 (UART_nDMA_REQ[0] in TX, UART_nDMA_REQ[1] in RX)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dma_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dma_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_mode_status_t _e)
{
    char *d = omap44xx_uart3_dma_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dma_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.tx_fifo_clear_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_tx_fifo_clear_status_t;
#define omap44xx_uart3_TX_FIFO_CLEAR_0_w ((omap44xx_uart3_tx_fifo_clear_status_t)0x0)
#define omap44xx_uart3_TX_FIFO_CLEAR_1_w ((omap44xx_uart3_tx_fifo_clear_status_t)0x1)

static inline char *omap44xx_uart3_tx_fifo_clear_status_describe(omap44xx_uart3_tx_fifo_clear_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_tx_fifo_clear_status_describe(omap44xx_uart3_tx_fifo_clear_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TX_FIFO_CLEAR_0_w:
        return("TX_FIFO_CLEAR_0_w: No change");
    case omap44xx_uart3_TX_FIFO_CLEAR_1_w:
        return("TX_FIFO_CLEAR_1_w: Clears the TX FIFO and resets its counter logic to 0. Returns to 0 after clearing FIFO.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_tx_fifo_clear_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_fifo_clear_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_fifo_clear_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_fifo_clear_status_t _e)
{
    char *d = omap44xx_uart3_tx_fifo_clear_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_tx_fifo_clear_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_fifo_clear_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_fifo_clear_status_t;
#define omap44xx_uart3_RX_FIFO_CLEAR_0_w ((omap44xx_uart3_rx_fifo_clear_status_t)0x0)
#define omap44xx_uart3_RX_FIFO_CLEAR_1_w ((omap44xx_uart3_rx_fifo_clear_status_t)0x1)

static inline char *omap44xx_uart3_rx_fifo_clear_status_describe(omap44xx_uart3_rx_fifo_clear_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_fifo_clear_status_describe(omap44xx_uart3_rx_fifo_clear_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_FIFO_CLEAR_0_w:
        return("RX_FIFO_CLEAR_0_w: No change");
    case omap44xx_uart3_RX_FIFO_CLEAR_1_w:
        return("RX_FIFO_CLEAR_1_w: Clears the RX FIFO and resets its counter logic to 0. Returns to 0 after clearing FIFO.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_fifo_clear_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_fifo_clear_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_fifo_clear_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_fifo_clear_status_t _e)
{
    char *d = omap44xx_uart3_rx_fifo_clear_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_fifo_clear_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.fifo_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_fifo_en_status_t;
#define omap44xx_uart3_FIFO_EN_0_w ((omap44xx_uart3_fifo_en_status_t)0x0)
#define omap44xx_uart3_FIFO_EN_1_w ((omap44xx_uart3_fifo_en_status_t)0x1)

static inline char *omap44xx_uart3_fifo_en_status_describe(omap44xx_uart3_fifo_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_fifo_en_status_describe(omap44xx_uart3_fifo_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_FIFO_EN_0_w:
        return("FIFO_EN_0_w: Disables the transmit and RX FIFOs. The transmit and receive holding registers are 1-byte FIFOs.");
    case omap44xx_uart3_FIFO_EN_1_w:
        return("FIFO_EN_1_w: Enables the transmit and RX FIFOs. The transmit and receive holding registers are 64-byte FIFOs.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_fifo_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_fifo_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_fifo_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_fifo_en_status_t _e)
{
    char *d = omap44xx_uart3_fifo_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_fifo_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.it_type_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_uart3_it_type_status_t;
#define omap44xx_uart3_it_modem ((omap44xx_uart3_it_type_status_t)0x0)
#define omap44xx_uart3_it_thr ((omap44xx_uart3_it_type_status_t)0x1)
#define omap44xx_uart3_it_rhr ((omap44xx_uart3_it_type_status_t)0x2)
#define omap44xx_uart3_it_rlse ((omap44xx_uart3_it_type_status_t)0x3)
#define omap44xx_uart3_it_rxtimeout ((omap44xx_uart3_it_type_status_t)0x6)
#define omap44xx_uart3_it_xoff ((omap44xx_uart3_it_type_status_t)0x8)
#define omap44xx_uart3_it_cts ((omap44xx_uart3_it_type_status_t)0x10)

static inline char *omap44xx_uart3_it_type_status_describe(omap44xx_uart3_it_type_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_it_type_status_describe(omap44xx_uart3_it_type_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_it_modem:
        return("it_modem: Modem interrupt");
    case omap44xx_uart3_it_thr:
        return("it_thr: THR interrupt. Priority = 3");
    case omap44xx_uart3_it_rhr:
        return("it_rhr: RHR interrupt. Priority = 2");
    case omap44xx_uart3_it_rlse:
        return("it_rlse: Receiver line status error. Priority = 3");
    case omap44xx_uart3_it_rxtimeout:
        return("it_rxtimeout: Rx time-out. Priority = 2");
    case omap44xx_uart3_it_xoff:
        return("it_xoff: XOFF/special character. Priority = 5");
    case omap44xx_uart3_it_cts:
        return("it_cts: CTS, RTS, DSR change state from active (low) to inactive (high) Priority = 6");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_it_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_it_type_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_it_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_it_type_status_t _e)
{
    char *d = omap44xx_uart3_it_type_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_it_type_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.it_pending_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_it_pending_status_t;
#define omap44xx_uart3_IT_PENDING_1_r ((omap44xx_uart3_it_pending_status_t)0x1)

static inline char *omap44xx_uart3_it_pending_status_describe(omap44xx_uart3_it_pending_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_it_pending_status_describe(omap44xx_uart3_it_pending_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_IT_PENDING_1_r:
        return("IT_PENDING_1_r: No interrupt is pending.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_it_pending_status_prtval(char *_s, size_t _size, omap44xx_uart3_it_pending_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_it_pending_status_prtval(char *_s, size_t _size, omap44xx_uart3_it_pending_status_t _e)
{
    char *d = omap44xx_uart3_it_pending_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_it_pending_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.div_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_div_en_status_t;
#define omap44xx_uart3_DIV_EN_0 ((omap44xx_uart3_div_en_status_t)0x0)
#define omap44xx_uart3_DIV_EN_1 ((omap44xx_uart3_div_en_status_t)0x1)

static inline char *omap44xx_uart3_div_en_status_describe(omap44xx_uart3_div_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_div_en_status_describe(omap44xx_uart3_div_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DIV_EN_0:
        return("DIV_EN_0: Normal operating condition");
    case omap44xx_uart3_DIV_EN_1:
        return("DIV_EN_1: Divisor latch enable. Allows access to DLL, DLH, and other registers (see and ).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_div_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_div_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_div_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_div_en_status_t _e)
{
    char *d = omap44xx_uart3_div_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_div_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.break_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_break_en_status_t;
#define omap44xx_uart3_BREAK_EN_0 ((omap44xx_uart3_break_en_status_t)0x0)
#define omap44xx_uart3_BREAK_EN_1 ((omap44xx_uart3_break_en_status_t)0x1)

static inline char *omap44xx_uart3_break_en_status_describe(omap44xx_uart3_break_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_break_en_status_describe(omap44xx_uart3_break_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_BREAK_EN_0:
        return("BREAK_EN_0: Normal operating condition");
    case omap44xx_uart3_BREAK_EN_1:
        return("BREAK_EN_1: Forces the transmitter output to go low to alert the communication terminal");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_break_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_break_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_break_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_break_en_status_t _e)
{
    char *d = omap44xx_uart3_break_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_break_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.parity_type1_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_parity_type1_status_t;
#define omap44xx_uart3_PARITY_TYPE1_0 ((omap44xx_uart3_parity_type1_status_t)0x0)
#define omap44xx_uart3_PARITY_TYPE1_1 ((omap44xx_uart3_parity_type1_status_t)0x1)

static inline char *omap44xx_uart3_parity_type1_status_describe(omap44xx_uart3_parity_type1_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_parity_type1_status_describe(omap44xx_uart3_parity_type1_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_PARITY_TYPE1_0:
        return("PARITY_TYPE1_0: Odd parity is generated (if[3] = 1).");
    case omap44xx_uart3_PARITY_TYPE1_1:
        return("PARITY_TYPE1_1: Even parity is generated (if[3] = 1).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_parity_type1_status_prtval(char *_s, size_t _size, omap44xx_uart3_parity_type1_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_parity_type1_status_prtval(char *_s, size_t _size, omap44xx_uart3_parity_type1_status_t _e)
{
    char *d = omap44xx_uart3_parity_type1_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_parity_type1_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.parity_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_parity_en_status_t;
#define omap44xx_uart3_PARITY_EN_1 ((omap44xx_uart3_parity_en_status_t)0x1)

static inline char *omap44xx_uart3_parity_en_status_describe(omap44xx_uart3_parity_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_parity_en_status_describe(omap44xx_uart3_parity_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_PARITY_EN_1:
        return("PARITY_EN_1: A parity bit is generated during transmission and the receiver checks for received parity.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_parity_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_parity_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_parity_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_parity_en_status_t _e)
{
    char *d = omap44xx_uart3_parity_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_parity_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.nb_stop_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_nb_stop_status_t;
#define omap44xx_uart3_NB_STOP_0 ((omap44xx_uart3_nb_stop_status_t)0x0)
#define omap44xx_uart3_NB_STOP_1 ((omap44xx_uart3_nb_stop_status_t)0x1)

static inline char *omap44xx_uart3_nb_stop_status_describe(omap44xx_uart3_nb_stop_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_nb_stop_status_describe(omap44xx_uart3_nb_stop_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_NB_STOP_0:
        return("NB_STOP_0: 1 stop-bit (word length = 5, 6, 7, 8)");
    case omap44xx_uart3_NB_STOP_1:
        return("NB_STOP_1: 1.5 stop-bits (word length = 5) 2 stop-bits (word length = 6, 7, 8)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_nb_stop_status_prtval(char *_s, size_t _size, omap44xx_uart3_nb_stop_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_nb_stop_status_prtval(char *_s, size_t _size, omap44xx_uart3_nb_stop_status_t _e)
{
    char *d = omap44xx_uart3_nb_stop_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_nb_stop_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.char_length_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_uart3_char_length_status_t;
#define omap44xx_uart3_cl5 ((omap44xx_uart3_char_length_status_t)0x0)
#define omap44xx_uart3_cl6 ((omap44xx_uart3_char_length_status_t)0x1)
#define omap44xx_uart3_cl7 ((omap44xx_uart3_char_length_status_t)0x2)
#define omap44xx_uart3_cl8 ((omap44xx_uart3_char_length_status_t)0x3)

static inline char *omap44xx_uart3_char_length_status_describe(omap44xx_uart3_char_length_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_char_length_status_describe(omap44xx_uart3_char_length_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_cl5:
        return("cl5: 5 bits");
    case omap44xx_uart3_cl6:
        return("cl6: 6 bits");
    case omap44xx_uart3_cl7:
        return("cl7: 7 bits");
    case omap44xx_uart3_cl8:
        return("cl8: 8 bits");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_char_length_status_prtval(char *_s, size_t _size, omap44xx_uart3_char_length_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_char_length_status_prtval(char *_s, size_t _size, omap44xx_uart3_char_length_status_t _e)
{
    char *d = omap44xx_uart3_char_length_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_char_length_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.tcr_tlr_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_tcr_tlr_status_t;
#define omap44xx_uart3_TCR_TLR_1 ((omap44xx_uart3_tcr_tlr_status_t)0x1)

static inline char *omap44xx_uart3_tcr_tlr_status_describe(omap44xx_uart3_tcr_tlr_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_tcr_tlr_status_describe(omap44xx_uart3_tcr_tlr_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TCR_TLR_1:
        return("TCR_TLR_1: Enables access to the and registers");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_tcr_tlr_status_prtval(char *_s, size_t _size, omap44xx_uart3_tcr_tlr_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tcr_tlr_status_prtval(char *_s, size_t _size, omap44xx_uart3_tcr_tlr_status_t _e)
{
    char *d = omap44xx_uart3_tcr_tlr_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_tcr_tlr_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.xon_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_xon_en_status_t;
#define omap44xx_uart3_XON_EN_1 ((omap44xx_uart3_xon_en_status_t)0x1)

static inline char *omap44xx_uart3_xon_en_status_describe(omap44xx_uart3_xon_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_xon_en_status_describe(omap44xx_uart3_xon_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_XON_EN_1:
        return("XON_EN_1: Enable XON any function.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_xon_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_xon_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xon_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_xon_en_status_t _e)
{
    char *d = omap44xx_uart3_xon_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_xon_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.loopback_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_loopback_en_status_t;
#define omap44xx_uart3_LOOPBACK_EN_1 ((omap44xx_uart3_loopback_en_status_t)0x1)

static inline char *omap44xx_uart3_loopback_en_status_describe(omap44xx_uart3_loopback_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_loopback_en_status_describe(omap44xx_uart3_loopback_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_LOOPBACK_EN_1:
        return("LOOPBACK_EN_1: Enable local loopback mode (internal). In this mode, the MCR[3:0] signals are looped back into the[7:4] bit field. The transmit output is looped back to the receive input internally.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_loopback_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_loopback_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_loopback_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_loopback_en_status_t _e)
{
    char *d = omap44xx_uart3_loopback_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_loopback_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.cd_sts_ch_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_cd_sts_ch_status_t;
#define omap44xx_uart3_CD_STS_CH_1 ((omap44xx_uart3_cd_sts_ch_status_t)0x1)

static inline char *omap44xx_uart3_cd_sts_ch_status_describe(omap44xx_uart3_cd_sts_ch_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_cd_sts_ch_status_describe(omap44xx_uart3_cd_sts_ch_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_CD_STS_CH_1:
        return("CD_STS_CH_1: In loopback, forces DCD* input low and IRQ outputs to inactive state");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_cd_sts_ch_status_prtval(char *_s, size_t _size, omap44xx_uart3_cd_sts_ch_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_cd_sts_ch_status_prtval(char *_s, size_t _size, omap44xx_uart3_cd_sts_ch_status_t _e)
{
    char *d = omap44xx_uart3_cd_sts_ch_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_cd_sts_ch_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.ri_sts_ch_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_ri_sts_ch_status_t;
#define omap44xx_uart3_RI_STS_CH_1 ((omap44xx_uart3_ri_sts_ch_status_t)0x1)

static inline char *omap44xx_uart3_ri_sts_ch_status_describe(omap44xx_uart3_ri_sts_ch_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_ri_sts_ch_status_describe(omap44xx_uart3_ri_sts_ch_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RI_STS_CH_1:
        return("RI_STS_CH_1: In loopback, forces RI* input low");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_ri_sts_ch_status_prtval(char *_s, size_t _size, omap44xx_uart3_ri_sts_ch_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ri_sts_ch_status_prtval(char *_s, size_t _size, omap44xx_uart3_ri_sts_ch_status_t _e)
{
    char *d = omap44xx_uart3_ri_sts_ch_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_ri_sts_ch_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rts_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rts_status_t;
#define omap44xx_uart3_RTS_0 ((omap44xx_uart3_rts_status_t)0x0)
#define omap44xx_uart3_RTS_1 ((omap44xx_uart3_rts_status_t)0x1)

static inline char *omap44xx_uart3_rts_status_describe(omap44xx_uart3_rts_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rts_status_describe(omap44xx_uart3_rts_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RTS_0:
        return("RTS_0: Force RTS* output to inactive (high).");
    case omap44xx_uart3_RTS_1:
        return("RTS_1: Force RTS* output to active (low).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rts_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rts_status_t _e)
{
    char *d = omap44xx_uart3_rts_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rts_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dtr_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dtr_status_t;
#define omap44xx_uart3_DTR_1 ((omap44xx_uart3_dtr_status_t)0x1)

static inline char *omap44xx_uart3_dtr_status_describe(omap44xx_uart3_dtr_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dtr_status_describe(omap44xx_uart3_dtr_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DTR_1:
        return("DTR_1: Force DTR* output to active (low).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dtr_status_prtval(char *_s, size_t _size, omap44xx_uart3_dtr_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dtr_status_prtval(char *_s, size_t _size, omap44xx_uart3_dtr_status_t _e)
{
    char *d = omap44xx_uart3_dtr_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dtr_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_fifo_sts_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_fifo_sts_status_t;
#define omap44xx_uart3_RX_FIFO_STS_1_r ((omap44xx_uart3_rx_fifo_sts_status_t)0x1)

static inline char *omap44xx_uart3_rx_fifo_sts_status_describe(omap44xx_uart3_rx_fifo_sts_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_fifo_sts_status_describe(omap44xx_uart3_rx_fifo_sts_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_FIFO_STS_1_r:
        return("RX_FIFO_STS_1_r: At least one parity error, framing error, or break indication in the RX FIFO. Bit 7 is cleared when no more errors are present in the RX FIFO.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_fifo_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_fifo_sts_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_fifo_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_fifo_sts_status_t _e)
{
    char *d = omap44xx_uart3_rx_fifo_sts_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_fifo_sts_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.tx_sr_e_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_tx_sr_e_status_t;
#define omap44xx_uart3_TX_SR_E_1_r ((omap44xx_uart3_tx_sr_e_status_t)0x1)

static inline char *omap44xx_uart3_tx_sr_e_status_describe(omap44xx_uart3_tx_sr_e_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_tx_sr_e_status_describe(omap44xx_uart3_tx_sr_e_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TX_SR_E_1_r:
        return("TX_SR_E_1_r: Transmitter hold (TX FIFO) and shift registers are empty.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_tx_sr_e_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_sr_e_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_sr_e_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_sr_e_status_t _e)
{
    char *d = omap44xx_uart3_tx_sr_e_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_tx_sr_e_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_bi_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_bi_status_t;
#define omap44xx_uart3_RX_BI_1_r ((omap44xx_uart3_rx_bi_status_t)0x1)

static inline char *omap44xx_uart3_rx_bi_status_describe(omap44xx_uart3_rx_bi_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_bi_status_describe(omap44xx_uart3_rx_bi_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_BI_1_r:
        return("RX_BI_1_r: A break was detected while the data from the RX FIFO was received (for example, RX input was low for one character + 1 bit time frame).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_bi_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_bi_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_bi_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_bi_status_t _e)
{
    char *d = omap44xx_uart3_rx_bi_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_bi_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_fe_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_fe_status_t;
#define omap44xx_uart3_RX_FE_1_r ((omap44xx_uart3_rx_fe_status_t)0x1)

static inline char *omap44xx_uart3_rx_fe_status_describe(omap44xx_uart3_rx_fe_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_fe_status_describe(omap44xx_uart3_rx_fe_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_FE_1_r:
        return("RX_FE_1_r: Framing error occurred in data from RX FIFO (received data did not have a valid stop-bit).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_fe_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_fe_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_fe_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_fe_status_t _e)
{
    char *d = omap44xx_uart3_rx_fe_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_fe_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_pe_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_pe_status_t;
#define omap44xx_uart3_RX_PE_1_r ((omap44xx_uart3_rx_pe_status_t)0x1)

static inline char *omap44xx_uart3_rx_pe_status_describe(omap44xx_uart3_rx_pe_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_pe_status_describe(omap44xx_uart3_rx_pe_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_PE_1_r:
        return("RX_PE_1_r: Parity error in data from RX FIFO");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_pe_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_pe_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_pe_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_pe_status_t _e)
{
    char *d = omap44xx_uart3_rx_pe_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_pe_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_oe_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_oe_status_t;
#define omap44xx_uart3_RX_OE_1_r ((omap44xx_uart3_rx_oe_status_t)0x1)

static inline char *omap44xx_uart3_rx_oe_status_describe(omap44xx_uart3_rx_oe_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_oe_status_describe(omap44xx_uart3_rx_oe_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_OE_1_r:
        return("RX_OE_1_r: Overrun error occurred. Set when the character in the receive shift register is not transferred to the RX FIFO. This occurs only when the RX FIFO is full.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_oe_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_oe_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_oe_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_oe_status_t _e)
{
    char *d = omap44xx_uart3_rx_oe_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_oe_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dsr_sts_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dsr_sts_status_t;
#define omap44xx_uart3_DSR_STS_1_r ((omap44xx_uart3_dsr_sts_status_t)0x1)

static inline char *omap44xx_uart3_dsr_sts_status_describe(omap44xx_uart3_dsr_sts_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dsr_sts_status_describe(omap44xx_uart3_dsr_sts_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DSR_STS_1_r:
        return("DSR_STS_1_r: Indicates that DSR* input (or[0] in loopback) changed state. Cleared on a read.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dsr_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_dsr_sts_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dsr_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_dsr_sts_status_t _e)
{
    char *d = omap44xx_uart3_dsr_sts_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dsr_sts_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.frame_end_mode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_frame_end_mode_status_t;
#define omap44xx_uart3_FRAME_END_MODE_0 ((omap44xx_uart3_frame_end_mode_status_t)0x0)
#define omap44xx_uart3_FRAME_END_MODE_1 ((omap44xx_uart3_frame_end_mode_status_t)0x1)

static inline char *omap44xx_uart3_frame_end_mode_status_describe(omap44xx_uart3_frame_end_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_frame_end_mode_status_describe(omap44xx_uart3_frame_end_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_FRAME_END_MODE_0:
        return("FRAME_END_MODE_0: Frame-length method");
    case omap44xx_uart3_FRAME_END_MODE_1:
        return("FRAME_END_MODE_1: Set EOT bit method");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_frame_end_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_frame_end_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_frame_end_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_frame_end_mode_status_t _e)
{
    char *d = omap44xx_uart3_frame_end_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_frame_end_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.sip_mode_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_sip_mode_status_t;
#define omap44xx_uart3_SIP_MODE_0 ((omap44xx_uart3_sip_mode_status_t)0x0)
#define omap44xx_uart3_SIP_MODE_1 ((omap44xx_uart3_sip_mode_status_t)0x1)

static inline char *omap44xx_uart3_sip_mode_status_describe(omap44xx_uart3_sip_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_sip_mode_status_describe(omap44xx_uart3_sip_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SIP_MODE_0:
        return("SIP_MODE_0: Manual SIP mode: SIP is generated with the control of ACREG[3].");
    case omap44xx_uart3_SIP_MODE_1:
        return("SIP_MODE_1: Automatic SIP mode: SIP is generated after each transmission.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_sip_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_sip_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sip_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_sip_mode_status_t _e)
{
    char *d = omap44xx_uart3_sip_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_sip_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.sct_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_sct_status_t;
#define omap44xx_uart3_SCT_0 ((omap44xx_uart3_sct_status_t)0x0)
#define omap44xx_uart3_SCT_1 ((omap44xx_uart3_sct_status_t)0x1)

static inline char *omap44xx_uart3_sct_status_describe(omap44xx_uart3_sct_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_sct_status_describe(omap44xx_uart3_sct_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SCT_0:
        return("SCT_0: Starts the infrared transmission when a value is written to THR");
    case omap44xx_uart3_SCT_1:
        return("SCT_1: Starts the infrared transmission with the control of ACREG[2]. Note: Before starting any transmission, there must be no reception ongoing.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_sct_status_prtval(char *_s, size_t _size, omap44xx_uart3_sct_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sct_status_prtval(char *_s, size_t _size, omap44xx_uart3_sct_status_t _e)
{
    char *d = omap44xx_uart3_sct_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_sct_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.set_txir_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_set_txir_status_t;
#define omap44xx_uart3_SET_TXIR_0 ((omap44xx_uart3_set_txir_status_t)0x0)
#define omap44xx_uart3_SET_TXIR_1 ((omap44xx_uart3_set_txir_status_t)0x1)

static inline char *omap44xx_uart3_set_txir_status_describe(omap44xx_uart3_set_txir_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_set_txir_status_describe(omap44xx_uart3_set_txir_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SET_TXIR_0:
        return("SET_TXIR_0: a) No action if MDR2[7] = 0 b) TXIR pin output is forced low if MDR2[7] = 1.");
    case omap44xx_uart3_SET_TXIR_1:
        return("SET_TXIR_1: IRTX pin output is forced high (not dependent on MDR2[7] value).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_set_txir_status_prtval(char *_s, size_t _size, omap44xx_uart3_set_txir_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_set_txir_status_prtval(char *_s, size_t _size, omap44xx_uart3_set_txir_status_t _e)
{
    char *d = omap44xx_uart3_set_txir_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_set_txir_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.ir_sleep_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_ir_sleep_status_t;
#define omap44xx_uart3_IR_SLEEP_1 ((omap44xx_uart3_ir_sleep_status_t)0x1)

static inline char *omap44xx_uart3_ir_sleep_status_describe(omap44xx_uart3_ir_sleep_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_ir_sleep_status_describe(omap44xx_uart3_ir_sleep_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_IR_SLEEP_1:
        return("IR_SLEEP_1: IrDA/CIR sleep mode enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_ir_sleep_status_prtval(char *_s, size_t _size, omap44xx_uart3_ir_sleep_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ir_sleep_status_prtval(char *_s, size_t _size, omap44xx_uart3_ir_sleep_status_t _e)
{
    char *d = omap44xx_uart3_ir_sleep_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_ir_sleep_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.mode_select_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_uart3_mode_select_status_t;
#define omap44xx_uart3_MODE_SELECT_1 ((omap44xx_uart3_mode_select_status_t)0x1)
#define omap44xx_uart3_MODE_SELECT_2 ((omap44xx_uart3_mode_select_status_t)0x2)
#define omap44xx_uart3_MODE_SELECT_3 ((omap44xx_uart3_mode_select_status_t)0x3)
#define omap44xx_uart3_MODE_SELECT_4 ((omap44xx_uart3_mode_select_status_t)0x4)
#define omap44xx_uart3_MODE_SELECT_5 ((omap44xx_uart3_mode_select_status_t)0x5)
#define omap44xx_uart3_MODE_SELECT_6 ((omap44xx_uart3_mode_select_status_t)0x6)
#define omap44xx_uart3_MODE_SELECT_7 ((omap44xx_uart3_mode_select_status_t)0x7)

static inline char *omap44xx_uart3_mode_select_status_describe(omap44xx_uart3_mode_select_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_mode_select_status_describe(omap44xx_uart3_mode_select_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_MODE_SELECT_1:
        return("MODE_SELECT_1: SIR mode");
    case omap44xx_uart3_MODE_SELECT_2:
        return("MODE_SELECT_2: UART 16x auto-baud");
    case omap44xx_uart3_MODE_SELECT_3:
        return("MODE_SELECT_3: UART 13x mode");
    case omap44xx_uart3_MODE_SELECT_4:
        return("MODE_SELECT_4: MIR mode");
    case omap44xx_uart3_MODE_SELECT_5:
        return("MODE_SELECT_5: FIR mode");
    case omap44xx_uart3_MODE_SELECT_6:
        return("MODE_SELECT_6: CIR mode");
    case omap44xx_uart3_MODE_SELECT_7:
        return("MODE_SELECT_7: Disable (default state)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_mode_select_status_prtval(char *_s, size_t _size, omap44xx_uart3_mode_select_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mode_select_status_prtval(char *_s, size_t _size, omap44xx_uart3_mode_select_status_t _e)
{
    char *d = omap44xx_uart3_mode_select_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_mode_select_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.set_txir_alt_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_set_txir_alt_status_t;
#define omap44xx_uart3_SET_TXIR_ALT_0 ((omap44xx_uart3_set_txir_alt_status_t)0x0)
#define omap44xx_uart3_SET_TXIR_ALT_1 ((omap44xx_uart3_set_txir_alt_status_t)0x1)

static inline char *omap44xx_uart3_set_txir_alt_status_describe(omap44xx_uart3_set_txir_alt_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_set_txir_alt_status_describe(omap44xx_uart3_set_txir_alt_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SET_TXIR_ALT_0:
        return("SET_TXIR_ALT_0: Normal mode");
    case omap44xx_uart3_SET_TXIR_ALT_1:
        return("SET_TXIR_ALT_1: Alternate mode for SET_TXIR");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_set_txir_alt_status_prtval(char *_s, size_t _size, omap44xx_uart3_set_txir_alt_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_set_txir_alt_status_prtval(char *_s, size_t _size, omap44xx_uart3_set_txir_alt_status_t _e)
{
    char *d = omap44xx_uart3_set_txir_alt_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_set_txir_alt_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.irrxinvert_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_irrxinvert_status_t;
#define omap44xx_uart3_IRRXINVERT_0 ((omap44xx_uart3_irrxinvert_status_t)0x0)
#define omap44xx_uart3_IRRXINVERT_1 ((omap44xx_uart3_irrxinvert_status_t)0x1)

static inline char *omap44xx_uart3_irrxinvert_status_describe(omap44xx_uart3_irrxinvert_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_irrxinvert_status_describe(omap44xx_uart3_irrxinvert_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_IRRXINVERT_0:
        return("IRRXINVERT_0: Inversion is performed.");
    case omap44xx_uart3_IRRXINVERT_1:
        return("IRRXINVERT_1: No inversion is performed.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_irrxinvert_status_prtval(char *_s, size_t _size, omap44xx_uart3_irrxinvert_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_irrxinvert_status_prtval(char *_s, size_t _size, omap44xx_uart3_irrxinvert_status_t _e)
{
    char *d = omap44xx_uart3_irrxinvert_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_irrxinvert_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.cir_pulse_mode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_uart3_cir_pulse_mode_status_t;
#define omap44xx_uart3_CIR_PULSE_MODE_0 ((omap44xx_uart3_cir_pulse_mode_status_t)0x0)
#define omap44xx_uart3_CIR_PULSE_MODE_1 ((omap44xx_uart3_cir_pulse_mode_status_t)0x1)
#define omap44xx_uart3_CIR_PULSE_MODE_2 ((omap44xx_uart3_cir_pulse_mode_status_t)0x2)
#define omap44xx_uart3_CIR_PULSE_MODE_3 ((omap44xx_uart3_cir_pulse_mode_status_t)0x3)

static inline char *omap44xx_uart3_cir_pulse_mode_status_describe(omap44xx_uart3_cir_pulse_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_cir_pulse_mode_status_describe(omap44xx_uart3_cir_pulse_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_CIR_PULSE_MODE_0:
        return("CIR_PULSE_MODE_0: Pulse width of 3 from 12 cycles");
    case omap44xx_uart3_CIR_PULSE_MODE_1:
        return("CIR_PULSE_MODE_1: Pulse width of 4 from 12 cycles");
    case omap44xx_uart3_CIR_PULSE_MODE_2:
        return("CIR_PULSE_MODE_2: Pulse width of 5 from 12 cycles");
    case omap44xx_uart3_CIR_PULSE_MODE_3:
        return("CIR_PULSE_MODE_3: Pulse width of 6 from 12 cycles");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_cir_pulse_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_cir_pulse_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_cir_pulse_mode_status_prtval(char *_s, size_t _size, omap44xx_uart3_cir_pulse_mode_status_t _e)
{
    char *d = omap44xx_uart3_cir_pulse_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_cir_pulse_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.pulse_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_pulse_status_t;
#define omap44xx_uart3_UART_PULSE_0 ((omap44xx_uart3_pulse_status_t)0x0)
#define omap44xx_uart3_UART_PULSE_1 ((omap44xx_uart3_pulse_status_t)0x1)

static inline char *omap44xx_uart3_pulse_status_describe(omap44xx_uart3_pulse_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_pulse_status_describe(omap44xx_uart3_pulse_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_UART_PULSE_0:
        return("UART_PULSE_0: Normal UART mode");
    case omap44xx_uart3_UART_PULSE_1:
        return("UART_PULSE_1: UART mode with a pulse shaping");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_pulse_status_prtval(char *_s, size_t _size, omap44xx_uart3_pulse_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_pulse_status_prtval(char *_s, size_t _size, omap44xx_uart3_pulse_status_t _e)
{
    char *d = omap44xx_uart3_pulse_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_pulse_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.sts_fifo_trig_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_uart3_sts_fifo_trig_status_t;
#define omap44xx_uart3_STS_FIFO_TRIG_0 ((omap44xx_uart3_sts_fifo_trig_status_t)0x0)
#define omap44xx_uart3_STS_FIFO_TRIG_1 ((omap44xx_uart3_sts_fifo_trig_status_t)0x1)
#define omap44xx_uart3_STS_FIFO_TRIG_2 ((omap44xx_uart3_sts_fifo_trig_status_t)0x2)
#define omap44xx_uart3_STS_FIFO_TRIG_3 ((omap44xx_uart3_sts_fifo_trig_status_t)0x3)

static inline char *omap44xx_uart3_sts_fifo_trig_status_describe(omap44xx_uart3_sts_fifo_trig_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_sts_fifo_trig_status_describe(omap44xx_uart3_sts_fifo_trig_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_STS_FIFO_TRIG_0:
        return("STS_FIFO_TRIG_0: 1 entry");
    case omap44xx_uart3_STS_FIFO_TRIG_1:
        return("STS_FIFO_TRIG_1: 4 entries");
    case omap44xx_uart3_STS_FIFO_TRIG_2:
        return("STS_FIFO_TRIG_2: 7 entries");
    case omap44xx_uart3_STS_FIFO_TRIG_3:
        return("STS_FIFO_TRIG_3: 8 entries");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_sts_fifo_trig_status_prtval(char *_s, size_t _size, omap44xx_uart3_sts_fifo_trig_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sts_fifo_trig_status_prtval(char *_s, size_t _size, omap44xx_uart3_sts_fifo_trig_status_t _e)
{
    char *d = omap44xx_uart3_sts_fifo_trig_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_sts_fifo_trig_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.xbof_type_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_xbof_type_status_t;
#define omap44xx_uart3_XBOF_TYPE_0 ((omap44xx_uart3_xbof_type_status_t)0x0)
#define omap44xx_uart3_XBOF_TYPE_1 ((omap44xx_uart3_xbof_type_status_t)0x1)

static inline char *omap44xx_uart3_xbof_type_status_describe(omap44xx_uart3_xbof_type_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_xbof_type_status_describe(omap44xx_uart3_xbof_type_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_XBOF_TYPE_0:
        return("XBOF_TYPE_0: 0xFF");
    case omap44xx_uart3_XBOF_TYPE_1:
        return("XBOF_TYPE_1: 0xC0");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_xbof_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_xbof_type_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xbof_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_xbof_type_status_t _e)
{
    char *d = omap44xx_uart3_xbof_type_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_xbof_type_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.parity_type_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_uart3_parity_type_status_t;
#define omap44xx_uart3_PARITY_TYPE_1_r ((omap44xx_uart3_parity_type_status_t)0x1)
#define omap44xx_uart3_PARITY_TYPE_2_r ((omap44xx_uart3_parity_type_status_t)0x2)
#define omap44xx_uart3_PARITY_TYPE_3_r ((omap44xx_uart3_parity_type_status_t)0x3)

static inline char *omap44xx_uart3_parity_type_status_describe(omap44xx_uart3_parity_type_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_parity_type_status_describe(omap44xx_uart3_parity_type_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_PARITY_TYPE_1_r:
        return("PARITY_TYPE_1_r: Parity space");
    case omap44xx_uart3_PARITY_TYPE_2_r:
        return("PARITY_TYPE_2_r: Even parity");
    case omap44xx_uart3_PARITY_TYPE_3_r:
        return("PARITY_TYPE_3_r: Odd parity");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_parity_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_parity_type_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_parity_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_parity_type_status_t _e)
{
    char *d = omap44xx_uart3_parity_type_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_parity_type_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.bit_by_char_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_bit_by_char_status_t;
#define omap44xx_uart3_BIT_BY_CHAR_1_r ((omap44xx_uart3_bit_by_char_status_t)0x1)

static inline char *omap44xx_uart3_bit_by_char_status_describe(omap44xx_uart3_bit_by_char_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_bit_by_char_status_describe(omap44xx_uart3_bit_by_char_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_BIT_BY_CHAR_1_r:
        return("BIT_BY_CHAR_1_r: 8-bit character identified");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_bit_by_char_status_prtval(char *_s, size_t _size, omap44xx_uart3_bit_by_char_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_bit_by_char_status_prtval(char *_s, size_t _size, omap44xx_uart3_bit_by_char_status_t _e)
{
    char *d = omap44xx_uart3_bit_by_char_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_bit_by_char_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.speed_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_uart3_speed_status_t;
#define omap44xx_uart3_SPEED_0_r ((omap44xx_uart3_speed_status_t)0x0)
#define omap44xx_uart3_SPEED_1_r ((omap44xx_uart3_speed_status_t)0x1)
#define omap44xx_uart3_SPEED_2_r ((omap44xx_uart3_speed_status_t)0x2)
#define omap44xx_uart3_SPEED_3_r ((omap44xx_uart3_speed_status_t)0x3)
#define omap44xx_uart3_SPEED_4_r ((omap44xx_uart3_speed_status_t)0x4)
#define omap44xx_uart3_SPEED_5_r ((omap44xx_uart3_speed_status_t)0x5)
#define omap44xx_uart3_SPEED_6_r ((omap44xx_uart3_speed_status_t)0x6)
#define omap44xx_uart3_SPEED_7_r ((omap44xx_uart3_speed_status_t)0x7)
#define omap44xx_uart3_SPEED_8_r ((omap44xx_uart3_speed_status_t)0x8)
#define omap44xx_uart3_SPEED_9_r ((omap44xx_uart3_speed_status_t)0x9)
#define omap44xx_uart3_SPEED_10_r ((omap44xx_uart3_speed_status_t)0xa)

static inline char *omap44xx_uart3_speed_status_describe(omap44xx_uart3_speed_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_speed_status_describe(omap44xx_uart3_speed_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SPEED_0_r:
        return("SPEED_0_r: No speed identified");
    case omap44xx_uart3_SPEED_1_r:
        return("SPEED_1_r: 115,200 baud");
    case omap44xx_uart3_SPEED_2_r:
        return("SPEED_2_r: 57,600 baud");
    case omap44xx_uart3_SPEED_3_r:
        return("SPEED_3_r: 38,400 baud");
    case omap44xx_uart3_SPEED_4_r:
        return("SPEED_4_r: 28,800 baud");
    case omap44xx_uart3_SPEED_5_r:
        return("SPEED_5_r: 19,200 baud");
    case omap44xx_uart3_SPEED_6_r:
        return("SPEED_6_r: 14,400 baud");
    case omap44xx_uart3_SPEED_7_r:
        return("SPEED_7_r: 9,600 baud");
    case omap44xx_uart3_SPEED_8_r:
        return("SPEED_8_r: 4,800 baud");
    case omap44xx_uart3_SPEED_9_r:
        return("SPEED_9_r: 2,400 baud");
    case omap44xx_uart3_SPEED_10_r:
        return("SPEED_10_r: 1,200 baud");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_speed_status_prtval(char *_s, size_t _size, omap44xx_uart3_speed_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_speed_status_prtval(char *_s, size_t _size, omap44xx_uart3_speed_status_t _e)
{
    char *d = omap44xx_uart3_speed_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_speed_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.pulse_type_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_pulse_type_status_t;
#define omap44xx_uart3_PULSE_TYPE_0 ((omap44xx_uart3_pulse_type_status_t)0x0)
#define omap44xx_uart3_PULSE_TYPE_1 ((omap44xx_uart3_pulse_type_status_t)0x1)

static inline char *omap44xx_uart3_pulse_type_status_describe(omap44xx_uart3_pulse_type_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_pulse_type_status_describe(omap44xx_uart3_pulse_type_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_PULSE_TYPE_0:
        return("PULSE_TYPE_0: 3/16 of baud-rate pulse width");
    case omap44xx_uart3_PULSE_TYPE_1:
        return("PULSE_TYPE_1: 1.6 us");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_pulse_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_pulse_type_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_pulse_type_status_prtval(char *_s, size_t _size, omap44xx_uart3_pulse_type_status_t _e)
{
    char *d = omap44xx_uart3_pulse_type_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_pulse_type_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.sd_mod_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_sd_mod_status_t;
#define omap44xx_uart3_SD_MOD_0 ((omap44xx_uart3_sd_mod_status_t)0x0)
#define omap44xx_uart3_SD_MOD_1 ((omap44xx_uart3_sd_mod_status_t)0x1)

static inline char *omap44xx_uart3_sd_mod_status_describe(omap44xx_uart3_sd_mod_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_sd_mod_status_describe(omap44xx_uart3_sd_mod_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SD_MOD_0:
        return("SD_MOD_0: SD pin is set to high.");
    case omap44xx_uart3_SD_MOD_1:
        return("SD_MOD_1: SD pin is set to low.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_sd_mod_status_prtval(char *_s, size_t _size, omap44xx_uart3_sd_mod_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sd_mod_status_prtval(char *_s, size_t _size, omap44xx_uart3_sd_mod_status_t _e)
{
    char *d = omap44xx_uart3_sd_mod_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_sd_mod_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dis_tx_underrun_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dis_tx_underrun_status_t;
#define omap44xx_uart3_DIS_TX_UNDERRUN_0 ((omap44xx_uart3_dis_tx_underrun_status_t)0x0)
#define omap44xx_uart3_DIS_TX_UNDERRUN_1 ((omap44xx_uart3_dis_tx_underrun_status_t)0x1)

static inline char *omap44xx_uart3_dis_tx_underrun_status_describe(omap44xx_uart3_dis_tx_underrun_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dis_tx_underrun_status_describe(omap44xx_uart3_dis_tx_underrun_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DIS_TX_UNDERRUN_0:
        return("DIS_TX_UNDERRUN_0: Long stop-bits cannot be transmitted; TX underrun is enabled.");
    case omap44xx_uart3_DIS_TX_UNDERRUN_1:
        return("DIS_TX_UNDERRUN_1: Long stop-bits can be transmitted; TX underrun is disabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dis_tx_underrun_status_prtval(char *_s, size_t _size, omap44xx_uart3_dis_tx_underrun_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dis_tx_underrun_status_prtval(char *_s, size_t _size, omap44xx_uart3_dis_tx_underrun_status_t _e)
{
    char *d = omap44xx_uart3_dis_tx_underrun_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dis_tx_underrun_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.send_sip_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_send_sip_status_t;
#define omap44xx_uart3_SEND_SIP_0 ((omap44xx_uart3_send_sip_status_t)0x0)
#define omap44xx_uart3_SEND_SIP_1 ((omap44xx_uart3_send_sip_status_t)0x1)

static inline char *omap44xx_uart3_send_sip_status_describe(omap44xx_uart3_send_sip_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_send_sip_status_describe(omap44xx_uart3_send_sip_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SEND_SIP_0:
        return("SEND_SIP_0: No action");
    case omap44xx_uart3_SEND_SIP_1:
        return("SEND_SIP_1: Send SIP pulse.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_send_sip_status_prtval(char *_s, size_t _size, omap44xx_uart3_send_sip_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_send_sip_status_prtval(char *_s, size_t _size, omap44xx_uart3_send_sip_status_t _e)
{
    char *d = omap44xx_uart3_send_sip_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_send_sip_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dsr_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dsr_it_status_t;
#define omap44xx_uart3_DSR_IT_1 ((omap44xx_uart3_dsr_it_status_t)0x1)

static inline char *omap44xx_uart3_dsr_it_status_describe(omap44xx_uart3_dsr_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dsr_it_status_describe(omap44xx_uart3_dsr_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DSR_IT_1:
        return("DSR_IT_1: Enables DSR* interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dsr_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_dsr_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dsr_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_dsr_it_status_t _e)
{
    char *d = omap44xx_uart3_dsr_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dsr_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_cts_dsr_wake_up_enable_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t;
#define omap44xx_uart3_RX_CTS_DSR_WAKE_UP_ENABLE_1 ((omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t)0x1)

static inline char *omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_describe(omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_describe(omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_CTS_DSR_WAKE_UP_ENABLE_1:
        return("RX_CTS_DSR_WAKE_UP_ENABLE_1: Waits for a falling edge of pins RX, CTS*, or DSR* to generate an interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _e)
{
    char *d = omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.tx_empty_ctl_it_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_tx_empty_ctl_it_status_t;
#define omap44xx_uart3_TX_EMPTY_CTL_IT_1 ((omap44xx_uart3_tx_empty_ctl_it_status_t)0x1)

static inline char *omap44xx_uart3_tx_empty_ctl_it_status_describe(omap44xx_uart3_tx_empty_ctl_it_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_tx_empty_ctl_it_status_describe(omap44xx_uart3_tx_empty_ctl_it_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TX_EMPTY_CTL_IT_1:
        return("TX_EMPTY_CTL_IT_1: The THR interrupt is generated when TX FIFO and TX shift register are empty.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_tx_empty_ctl_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_empty_ctl_it_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_empty_ctl_it_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_empty_ctl_it_status_t _e)
{
    char *d = omap44xx_uart3_tx_empty_ctl_it_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_tx_empty_ctl_it_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dma_mode_2_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_uart3_dma_mode_2_status_t;
#define omap44xx_uart3_DMA_MODE_2_0 ((omap44xx_uart3_dma_mode_2_status_t)0x0)
#define omap44xx_uart3_DMA_MODE_2_1 ((omap44xx_uart3_dma_mode_2_status_t)0x1)
#define omap44xx_uart3_DMA_MODE_2_2 ((omap44xx_uart3_dma_mode_2_status_t)0x2)
#define omap44xx_uart3_DMA_MODE_2_3 ((omap44xx_uart3_dma_mode_2_status_t)0x3)

static inline char *omap44xx_uart3_dma_mode_2_status_describe(omap44xx_uart3_dma_mode_2_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dma_mode_2_status_describe(omap44xx_uart3_dma_mode_2_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DMA_MODE_2_0:
        return("DMA_MODE_2_0: DMA mode 0 (no DMA)");
    case omap44xx_uart3_DMA_MODE_2_1:
        return("DMA_MODE_2_1: DMA mode 1 (UART_nDMA_REQ[0] in TX, UART_nDMA_REQ[1] in RX)");
    case omap44xx_uart3_DMA_MODE_2_2:
        return("DMA_MODE_2_2: DMA mode 2 (UART_nDMA_REQ[0] in RX)");
    case omap44xx_uart3_DMA_MODE_2_3:
        return("DMA_MODE_2_3: DMA mode 3 (UART_nDMA_REQ[0] in TX)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dma_mode_2_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_mode_2_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dma_mode_2_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_mode_2_status_t _e)
{
    char *d = omap44xx_uart3_dma_mode_2_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dma_mode_2_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dma_mode_ctl_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dma_mode_ctl_status_t;
#define omap44xx_uart3_DMA_MODE_CTL_1 ((omap44xx_uart3_dma_mode_ctl_status_t)0x1)

static inline char *omap44xx_uart3_dma_mode_ctl_status_describe(omap44xx_uart3_dma_mode_ctl_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dma_mode_ctl_status_describe(omap44xx_uart3_dma_mode_ctl_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DMA_MODE_CTL_1:
        return("DMA_MODE_CTL_1: The DMA_MODE is set with[2:1].");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dma_mode_ctl_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_mode_ctl_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dma_mode_ctl_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_mode_ctl_status_t _e)
{
    char *d = omap44xx_uart3_dma_mode_ctl_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dma_mode_ctl_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.dma_counter_rst_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_dma_counter_rst_status_t;
#define omap44xx_uart3_DMA_COUNTER_RST_1 ((omap44xx_uart3_dma_counter_rst_status_t)0x1)

static inline char *omap44xx_uart3_dma_counter_rst_status_describe(omap44xx_uart3_dma_counter_rst_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_dma_counter_rst_status_describe(omap44xx_uart3_dma_counter_rst_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DMA_COUNTER_RST_1:
        return("DMA_COUNTER_RST_1: The DMA counter will be reset if corresponding FIFO is reset (through FCR[1] or FCR[2]).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_dma_counter_rst_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_counter_rst_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dma_counter_rst_status_prtval(char *_s, size_t _size, omap44xx_uart3_dma_counter_rst_status_t _e)
{
    char *d = omap44xx_uart3_dma_counter_rst_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_dma_counter_rst_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rx_cts_dsr_wake_up_sts_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t;
#define omap44xx_uart3_RX_CTS_DSR_WAKE_UP_STS_1_r ((omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t)0x1)

static inline char *omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_describe(omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_describe(omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RX_CTS_DSR_WAKE_UP_STS_1_r:
        return("RX_CTS_DSR_WAKE_UP_STS_1_r: A falling edge occurred on RX, CTS*, or DSR*.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t _e)
{
    char *d = omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.tx_fifo_full_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_tx_fifo_full_status_t;
#define omap44xx_uart3_TX_FIFO_FULL_1_r ((omap44xx_uart3_tx_fifo_full_status_t)0x1)

static inline char *omap44xx_uart3_tx_fifo_full_status_describe(omap44xx_uart3_tx_fifo_full_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_tx_fifo_full_status_describe(omap44xx_uart3_tx_fifo_full_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TX_FIFO_FULL_1_r:
        return("TX_FIFO_FULL_1_r: TX FIFO is full.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_tx_fifo_full_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_fifo_full_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_fifo_full_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_fifo_full_status_t _e)
{
    char *d = omap44xx_uart3_tx_fifo_full_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_tx_fifo_full_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.idlemode_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_uart3_idlemode_status_t;
#define omap44xx_uart3_IDLEMODE_0 ((omap44xx_uart3_idlemode_status_t)0x0)
#define omap44xx_uart3_IDLEMODE_1 ((omap44xx_uart3_idlemode_status_t)0x1)
#define omap44xx_uart3_IDLEMODE_2 ((omap44xx_uart3_idlemode_status_t)0x2)
#define omap44xx_uart3_IDLEMODE_3 ((omap44xx_uart3_idlemode_status_t)0x3)

static inline char *omap44xx_uart3_idlemode_status_describe(omap44xx_uart3_idlemode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_idlemode_status_describe(omap44xx_uart3_idlemode_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_IDLEMODE_0:
        return("IDLEMODE_0: Force-idle: Idle request is acknowledged unconditionally.");
    case omap44xx_uart3_IDLEMODE_1:
        return("IDLEMODE_1: No-idle: Idle request is never acknowledged.");
    case omap44xx_uart3_IDLEMODE_2:
        return("IDLEMODE_2: Smart-idle: Idle request is acknowledged based in module internal activity.");
    case omap44xx_uart3_IDLEMODE_3:
        return("IDLEMODE_3: Smart-idle Wake-up: Acknowledgement to an idle request is given based in the internal activity of the module. The module is allowed to generate wake-up request.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_idlemode_status_prtval(char *_s, size_t _size, omap44xx_uart3_idlemode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_idlemode_status_prtval(char *_s, size_t _size, omap44xx_uart3_idlemode_status_t _e)
{
    char *d = omap44xx_uart3_idlemode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_idlemode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.enawakeup_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_enawakeup_status_t;
#define omap44xx_uart3_ENAWAKEUP_0 ((omap44xx_uart3_enawakeup_status_t)0x0)
#define omap44xx_uart3_ENAWAKEUP_1 ((omap44xx_uart3_enawakeup_status_t)0x1)

static inline char *omap44xx_uart3_enawakeup_status_describe(omap44xx_uart3_enawakeup_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_enawakeup_status_describe(omap44xx_uart3_enawakeup_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_ENAWAKEUP_0:
        return("ENAWAKEUP_0: Wakeup is disabled.");
    case omap44xx_uart3_ENAWAKEUP_1:
        return("ENAWAKEUP_1: Wake-up capability is enabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_enawakeup_status_prtval(char *_s, size_t _size, omap44xx_uart3_enawakeup_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_enawakeup_status_prtval(char *_s, size_t _size, omap44xx_uart3_enawakeup_status_t _e)
{
    char *d = omap44xx_uart3_enawakeup_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_enawakeup_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.softreset_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_softreset_status_t;
#define omap44xx_uart3_SOFTRESET_0 ((omap44xx_uart3_softreset_status_t)0x0)
#define omap44xx_uart3_SOFTRESET_1 ((omap44xx_uart3_softreset_status_t)0x1)

static inline char *omap44xx_uart3_softreset_status_describe(omap44xx_uart3_softreset_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_softreset_status_describe(omap44xx_uart3_softreset_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_SOFTRESET_0:
        return("SOFTRESET_0: Normal mode");
    case omap44xx_uart3_SOFTRESET_1:
        return("SOFTRESET_1: The module is reset.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_softreset_status_prtval(char *_s, size_t _size, omap44xx_uart3_softreset_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_softreset_status_prtval(char *_s, size_t _size, omap44xx_uart3_softreset_status_t _e)
{
    char *d = omap44xx_uart3_softreset_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_softreset_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.autoidle_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_autoidle_status_t;
#define omap44xx_uart3_AUTOIDLE_0 ((omap44xx_uart3_autoidle_status_t)0x0)
#define omap44xx_uart3_AUTOIDLE_1 ((omap44xx_uart3_autoidle_status_t)0x1)

static inline char *omap44xx_uart3_autoidle_status_describe(omap44xx_uart3_autoidle_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_autoidle_status_describe(omap44xx_uart3_autoidle_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_AUTOIDLE_0:
        return("AUTOIDLE_0: Clock is running.");
    case omap44xx_uart3_AUTOIDLE_1:
        return("AUTOIDLE_1: Automatic OCP clock gating strategy is applied, based on OCP interface activity");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_autoidle_status_prtval(char *_s, size_t _size, omap44xx_uart3_autoidle_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_autoidle_status_prtval(char *_s, size_t _size, omap44xx_uart3_autoidle_status_t _e)
{
    char *d = omap44xx_uart3_autoidle_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_autoidle_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.resetdone_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_resetdone_status_t;
#define omap44xx_uart3_RESETDONE_0_r ((omap44xx_uart3_resetdone_status_t)0x0)
#define omap44xx_uart3_RESETDONE_1_r ((omap44xx_uart3_resetdone_status_t)0x1)

static inline char *omap44xx_uart3_resetdone_status_describe(omap44xx_uart3_resetdone_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_resetdone_status_describe(omap44xx_uart3_resetdone_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RESETDONE_0_r:
        return("RESETDONE_0_r: Internal module reset is ongoing.");
    case omap44xx_uart3_RESETDONE_1_r:
        return("RESETDONE_1_r: Reset complete");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_resetdone_status_prtval(char *_s, size_t _size, omap44xx_uart3_resetdone_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_resetdone_status_prtval(char *_s, size_t _size, omap44xx_uart3_resetdone_status_t _e)
{
    char *d = omap44xx_uart3_resetdone_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_resetdone_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.tx_wakeup_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_tx_wakeup_en_status_t;
#define omap44xx_uart3_TX_WAKEUP_EN_1 ((omap44xx_uart3_tx_wakeup_en_status_t)0x1)

static inline char *omap44xx_uart3_tx_wakeup_en_status_describe(omap44xx_uart3_tx_wakeup_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_tx_wakeup_en_status_describe(omap44xx_uart3_tx_wakeup_en_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TX_WAKEUP_EN_1:
        return("TX_WAKEUP_EN_1: Event can wake up the system: it can be THR_IT or TX_DMA request and/or TX_SATUS_IT.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_tx_wakeup_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_wakeup_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_wakeup_en_status_prtval(char *_s, size_t _size, omap44xx_uart3_tx_wakeup_en_status_t _e)
{
    char *d = omap44xx_uart3_tx_wakeup_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_tx_wakeup_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.event_6_receiver_line_status_interrupt_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t;
#define omap44xx_uart3_EVENT_6_RECEIVER_LINE_STATUS_INTERRUPT_1 ((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t)0x1)

static inline char *omap44xx_uart3_event_6_receiver_line_status_interrupt_status_describe(omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_event_6_receiver_line_status_interrupt_status_describe(omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_EVENT_6_RECEIVER_LINE_STATUS_INTERRUPT_1:
        return("EVENT_6_RECEIVER_LINE_STATUS_INTERRUPT_1: Event can wake up the system.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(char *_s, size_t _size, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(char *_s, size_t _size, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _e)
{
    char *d = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.event_3_dcd_cd_activity_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_event_3_dcd_cd_activity_status_t;
#define omap44xx_uart3_EVENT_3_DCD_CD_ACTIVITY_1 ((omap44xx_uart3_event_3_dcd_cd_activity_status_t)0x1)

static inline char *omap44xx_uart3_event_3_dcd_cd_activity_status_describe(omap44xx_uart3_event_3_dcd_cd_activity_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_event_3_dcd_cd_activity_status_describe(omap44xx_uart3_event_3_dcd_cd_activity_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_EVENT_3_DCD_CD_ACTIVITY_1:
        return("EVENT_3_DCD_CD_ACTIVITY_1: Event can wake up the system");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_event_3_dcd_cd_activity_status_prtval(char *_s, size_t _size, omap44xx_uart3_event_3_dcd_cd_activity_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_event_3_dcd_cd_activity_status_prtval(char *_s, size_t _size, omap44xx_uart3_event_3_dcd_cd_activity_status_t _e)
{
    char *d = omap44xx_uart3_event_3_dcd_cd_activity_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_event_3_dcd_cd_activity_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.en_txfifo_empty_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_en_txfifo_empty_status_t;
#define omap44xx_uart3_EN_TXFIFO_EMPTY_0 ((omap44xx_uart3_en_txfifo_empty_status_t)0x0)
#define omap44xx_uart3_EN_TXFIFO_EMPTY_1 ((omap44xx_uart3_en_txfifo_empty_status_t)0x1)

static inline char *omap44xx_uart3_en_txfifo_empty_status_describe(omap44xx_uart3_en_txfifo_empty_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_en_txfifo_empty_status_describe(omap44xx_uart3_en_txfifo_empty_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_EN_TXFIFO_EMPTY_0:
        return("EN_TXFIFO_EMPTY_0: Enables EN_TXFIFO_EMPTY interrupt");
    case omap44xx_uart3_EN_TXFIFO_EMPTY_1:
        return("EN_TXFIFO_EMPTY_1: Disables EN_TXFIFO_EMPTY interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_en_txfifo_empty_status_prtval(char *_s, size_t _size, omap44xx_uart3_en_txfifo_empty_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_en_txfifo_empty_status_prtval(char *_s, size_t _size, omap44xx_uart3_en_txfifo_empty_status_t _e)
{
    char *d = omap44xx_uart3_en_txfifo_empty_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_en_txfifo_empty_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.en_rxfifo_empty_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_en_rxfifo_empty_status_t;
#define omap44xx_uart3_EN_RXFIFO_EMPTY_0 ((omap44xx_uart3_en_rxfifo_empty_status_t)0x0)
#define omap44xx_uart3_EN_RXFIFO_EMPTY_1 ((omap44xx_uart3_en_rxfifo_empty_status_t)0x1)

static inline char *omap44xx_uart3_en_rxfifo_empty_status_describe(omap44xx_uart3_en_rxfifo_empty_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_en_rxfifo_empty_status_describe(omap44xx_uart3_en_rxfifo_empty_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_EN_RXFIFO_EMPTY_0:
        return("EN_RXFIFO_EMPTY_0: Enables EN_RXFIFO_EMPTY interrupt");
    case omap44xx_uart3_EN_RXFIFO_EMPTY_1:
        return("EN_RXFIFO_EMPTY_1: Disables EN_RXFIFO_EMPTY interrupt");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_en_rxfifo_empty_status_prtval(char *_s, size_t _size, omap44xx_uart3_en_rxfifo_empty_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_en_rxfifo_empty_status_prtval(char *_s, size_t _size, omap44xx_uart3_en_rxfifo_empty_status_t _e)
{
    char *d = omap44xx_uart3_en_rxfifo_empty_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_en_rxfifo_empty_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.txfifo_empty_sts_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_txfifo_empty_sts_status_t;
#define omap44xx_uart3_TXFIFO_EMPTY_STS_0 ((omap44xx_uart3_txfifo_empty_sts_status_t)0x0)
#define omap44xx_uart3_TXFIFO_EMPTY_STS_1 ((omap44xx_uart3_txfifo_empty_sts_status_t)0x1)

static inline char *omap44xx_uart3_txfifo_empty_sts_status_describe(omap44xx_uart3_txfifo_empty_sts_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_txfifo_empty_sts_status_describe(omap44xx_uart3_txfifo_empty_sts_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_TXFIFO_EMPTY_STS_0:
        return("TXFIFO_EMPTY_STS_0: TXFIFO_EMPTY interrupt not pending.");
    case omap44xx_uart3_TXFIFO_EMPTY_STS_1:
        return("TXFIFO_EMPTY_STS_1: TXFIFO_EMPTY interrupt pending.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_txfifo_empty_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_txfifo_empty_sts_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txfifo_empty_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_txfifo_empty_sts_status_t _e)
{
    char *d = omap44xx_uart3_txfifo_empty_sts_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_txfifo_empty_sts_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.rxfifo_empty_sts_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_rxfifo_empty_sts_status_t;
#define omap44xx_uart3_RXFIFO_EMPTY_STS_0 ((omap44xx_uart3_rxfifo_empty_sts_status_t)0x0)
#define omap44xx_uart3_RXFIFO_EMPTY_STS_1 ((omap44xx_uart3_rxfifo_empty_sts_status_t)0x1)

static inline char *omap44xx_uart3_rxfifo_empty_sts_status_describe(omap44xx_uart3_rxfifo_empty_sts_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_rxfifo_empty_sts_status_describe(omap44xx_uart3_rxfifo_empty_sts_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_RXFIFO_EMPTY_STS_0:
        return("RXFIFO_EMPTY_STS_0: RXFIFO_EMPTY interrupt not pending.");
    case omap44xx_uart3_RXFIFO_EMPTY_STS_1:
        return("RXFIFO_EMPTY_STS_1: RXFIFO_EMPTY interrupt pending.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_rxfifo_empty_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rxfifo_empty_sts_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxfifo_empty_sts_status_prtval(char *_s, size_t _size, omap44xx_uart3_rxfifo_empty_sts_status_t _e)
{
    char *d = omap44xx_uart3_rxfifo_empty_sts_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_rxfifo_empty_sts_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.nondefault_freq_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_nondefault_freq_status_t;
#define omap44xx_uart3_NONDEFAULT_FREQ_0 ((omap44xx_uart3_nondefault_freq_status_t)0x0)
#define omap44xx_uart3_NONDEFAULT_FREQ_1 ((omap44xx_uart3_nondefault_freq_status_t)0x1)

static inline char *omap44xx_uart3_nondefault_freq_status_describe(omap44xx_uart3_nondefault_freq_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_nondefault_freq_status_describe(omap44xx_uart3_nondefault_freq_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_NONDEFAULT_FREQ_0:
        return("NONDEFAULT_FREQ_0: Disables using NONDEFAULT fclk frequencies.");
    case omap44xx_uart3_NONDEFAULT_FREQ_1:
        return("NONDEFAULT_FREQ_1: Enables using NONDEFAULT fclk frequencies (set FREQ_SEL and DLH/DLL).");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_nondefault_freq_status_prtval(char *_s, size_t _size, omap44xx_uart3_nondefault_freq_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_nondefault_freq_status_prtval(char *_s, size_t _size, omap44xx_uart3_nondefault_freq_status_t _e)
{
    char *d = omap44xx_uart3_nondefault_freq_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_nondefault_freq_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_uart3.disable_cir_rx_demod_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_uart3_disable_cir_rx_demod_status_t;
#define omap44xx_uart3_DISABLE_CIR_RX_DEMOD_0 ((omap44xx_uart3_disable_cir_rx_demod_status_t)0x0)
#define omap44xx_uart3_DISABLE_CIR_RX_DEMOD_1 ((omap44xx_uart3_disable_cir_rx_demod_status_t)0x1)

static inline char *omap44xx_uart3_disable_cir_rx_demod_status_describe(omap44xx_uart3_disable_cir_rx_demod_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_uart3_disable_cir_rx_demod_status_describe(omap44xx_uart3_disable_cir_rx_demod_status_t _e)
{
    switch (_e) {
    case omap44xx_uart3_DISABLE_CIR_RX_DEMOD_0:
        return("DISABLE_CIR_RX_DEMOD_0: Enables CIR RX demodulation.");
    case omap44xx_uart3_DISABLE_CIR_RX_DEMOD_1:
        return("DISABLE_CIR_RX_DEMOD_1: Disables CIR RX demodulation.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_uart3_disable_cir_rx_demod_status_prtval(char *_s, size_t _size, omap44xx_uart3_disable_cir_rx_demod_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_uart3_disable_cir_rx_demod_status_prtval(char *_s, size_t _size, omap44xx_uart3_disable_cir_rx_demod_status_t _e)
{
    char *d = omap44xx_uart3_disable_cir_rx_demod_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_uart3_disable_cir_rx_demod_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_uart3_dll_t
 * Description: Implicit type of This register, with, stores the 14-bit divisor for generation of the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor. register
 * Fields:
 *   clock_lsb	(size 8, offset 0, init 0):	RW	Stores the 8-bit LSB divisor value
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_dll_t;
#define omap44xx_uart3_dll_default 0x0
static inline uint8_t omap44xx_uart3_dll_clock_lsb_extract(omap44xx_uart3_dll_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_dll_clock_lsb_extract(omap44xx_uart3_dll_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_dll_t omap44xx_uart3_dll_clock_lsb_insert(omap44xx_uart3_dll_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dll_t omap44xx_uart3_dll_clock_lsb_insert(omap44xx_uart3_dll_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_dll_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_dll_prtval(char *_s, size_t _size, omap44xx_uart3_dll_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dll_prtval(char *_s, size_t _size, omap44xx_uart3_dll_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clock_lsb =\t%" PRIx8 "\t(Stores the 8-bit LSB divisor value)\n", omap44xx_uart3_dll_clock_lsb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_rhr_t
 * Description: Implicit type of The receiver section consists of the receiver holding register (RHR) and the receiver shift register. The RHR is a 64-byte FIFO. The receiver shift register receives serial data from RX input. The data is converted to parallel data and moved to the RHR. If the FIFO is disabled, location 0 of the FIFO stores the single data character.Note:If an overflow occurs, the data in the RHR is not overwritten. register
 * Fields:
 *   rhr	(size 8, offset 0, init 0):	RO	Receive holding register
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_rhr_t;
#define omap44xx_uart3_rhr_default 0x0
static inline uint8_t omap44xx_uart3_rhr_rhr_extract(omap44xx_uart3_rhr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rhr_rhr_extract(omap44xx_uart3_rhr_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_rhr_t omap44xx_uart3_rhr_rhr_insert(omap44xx_uart3_rhr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rhr_t omap44xx_uart3_rhr_rhr_insert(omap44xx_uart3_rhr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_rhr_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_rhr_prtval(char *_s, size_t _size, omap44xx_uart3_rhr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rhr_prtval(char *_s, size_t _size, omap44xx_uart3_rhr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhr =\t%" PRIx8 "\t(Receive holding register)\n", omap44xx_uart3_rhr_rhr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_thr_t
 * Description: Implicit type of The transmitter section consists of the transmit holding register (THR) and the transmit shift register. The THR is a 64-byte FIFO. The local host (LH) writes data to the THR. The data is placed in the transmit shift register where it is shifted out serially on the TX output. If the FIFO is disabled, location 0 of the FIFO stores the data. register
 * Fields:
 *   thr	(size 8, offset 0, init 0):	WO	Transmit holding register
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_thr_t;
#define omap44xx_uart3_thr_default 0x0
static inline uint8_t omap44xx_uart3_thr_thr_extract(omap44xx_uart3_thr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_thr_thr_extract(omap44xx_uart3_thr_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_thr_t omap44xx_uart3_thr_thr_insert(omap44xx_uart3_thr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_thr_t omap44xx_uart3_thr_thr_insert(omap44xx_uart3_thr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_thr_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_thr_prtval(char *_s, size_t _size, omap44xx_uart3_thr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_thr_prtval(char *_s, size_t _size, omap44xx_uart3_thr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thr =\t%" PRIx8 "\t(Transmit holding register)\n", omap44xx_uart3_thr_thr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_dlh_t
 * Description: Implicit type of This register, with, stores the 14-bit divisor for generating the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor. register
 * Fields:
 *   clock_msb	(size 6, offset 0, init 0):	RW	Stores the 6-bit MSB divisor value
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_dlh_t;
#define omap44xx_uart3_dlh_default 0x0
static inline uint8_t omap44xx_uart3_dlh_clock_msb_extract(omap44xx_uart3_dlh_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_dlh_clock_msb_extract(omap44xx_uart3_dlh_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline omap44xx_uart3_dlh_t omap44xx_uart3_dlh_clock_msb_insert(omap44xx_uart3_dlh_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dlh_t omap44xx_uart3_dlh_clock_msb_insert(omap44xx_uart3_dlh_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((omap44xx_uart3_dlh_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_dlh_prtval(char *_s, size_t _size, omap44xx_uart3_dlh_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dlh_prtval(char *_s, size_t _size, omap44xx_uart3_dlh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clock_msb =\t%" PRIx8 "\t(Stores the 6-bit MSB divisor value)\n", omap44xx_uart3_dlh_clock_msb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_ier_t
 * Description: Implicit type of Interrupt enable register register
 * Fields:
 *   rhr_it	(size 1, offset 0, init 0):	RW	
 *   thr_it	(size 1, offset 1, init 0):	RW	
 *   line_sts_it	(size 1, offset 2, init 0):	RW	
 *   modem_sts_it	(size 1, offset 3, init 0):	RW	
 *   sleep_mode	(size 1, offset 4, init 0):	RW	
 *   xoff_it	(size 1, offset 5, init 0):	RW	
 *   rts_it	(size 1, offset 6, init 0):	RW	
 *   cts_it	(size 1, offset 7, init 0):	RW	
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_ier_t;
#define omap44xx_uart3_ier_default 0x0
static inline omap44xx_uart3_rhr_it_status_t omap44xx_uart3_ier_rhr_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rhr_it_status_t omap44xx_uart3_ier_rhr_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_rhr_it_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rhr_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_rhr_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rhr_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_rhr_it_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_ier_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_thr_it_status_t omap44xx_uart3_ier_thr_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_thr_it_status_t omap44xx_uart3_ier_thr_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_thr_it_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_thr_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_thr_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_thr_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_thr_it_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_ier_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_line_sts_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_line_sts_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_modem_sts_it_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_line_sts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_modem_sts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_line_sts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_modem_sts_it_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_ier_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_modem_sts_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_modem_sts_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_modem_sts_it_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_modem_sts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_modem_sts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_modem_sts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_modem_sts_it_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_ier_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_sleep_mode_status_t omap44xx_uart3_ier_sleep_mode_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sleep_mode_status_t omap44xx_uart3_ier_sleep_mode_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_sleep_mode_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_sleep_mode_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_sleep_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_sleep_mode_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_sleep_mode_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_ier_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_xoff_it_status_t omap44xx_uart3_ier_xoff_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff_it_status_t omap44xx_uart3_ier_xoff_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_xoff_it_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_xoff_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_xoff_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_xoff_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_xoff_it_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_ier_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_rts_it_status_t omap44xx_uart3_ier_rts_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rts_it_status_t omap44xx_uart3_ier_rts_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_rts_it_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_rts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_rts_it_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_ier_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_cts_it_status_t omap44xx_uart3_ier_cts_it_extract(omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_cts_it_status_t omap44xx_uart3_ier_cts_it_extract(omap44xx_uart3_ier_t _regval)
{
    return((omap44xx_uart3_cts_it_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_cts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_cts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_cts_it_insert(omap44xx_uart3_ier_t _regval, omap44xx_uart3_cts_it_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_ier_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_ier_prtval(char *_s, size_t _size, omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ier_prtval(char *_s, size_t _size, omap44xx_uart3_ier_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhr_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rhr_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_rhr_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thr_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_thr_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_thr_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " line_sts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_modem_sts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_line_sts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modem_sts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_modem_sts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_modem_sts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sleep_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sleep_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_sleep_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xoff_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xoff_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_xoff_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_rts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_cts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_efr_t
 * Description: Implicit type of Enhanced feature register register
 * Fields:
 *   sw_flow_control	(size 4, offset 0, init 0):	RW	Combinations of software flow control can be selected by programming bit 3 - bit 0. See.
 *   enhanced_en	(size 1, offset 4, init 0):	RW	Enhanced functions write enable bit
 *   special_char_detect	(size 1, offset 5, init 0):	RW	
 *   auto_rts_en	(size 1, offset 6, init 0):	RW	Auto-RTS enable bit
 *   auto_cts_en	(size 1, offset 7, init 0):	RW	Auto-CTS enable bit
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_efr_t;
#define omap44xx_uart3_efr_default 0x0
static inline uint8_t omap44xx_uart3_efr_sw_flow_control_extract(omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_efr_sw_flow_control_extract(omap44xx_uart3_efr_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_sw_flow_control_insert(omap44xx_uart3_efr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_sw_flow_control_insert(omap44xx_uart3_efr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_uart3_efr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_enhanced_en_status_t omap44xx_uart3_efr_enhanced_en_extract(omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_enhanced_en_status_t omap44xx_uart3_efr_enhanced_en_extract(omap44xx_uart3_efr_t _regval)
{
    return((omap44xx_uart3_enhanced_en_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_enhanced_en_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_enhanced_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_enhanced_en_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_enhanced_en_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_efr_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_special_char_detect_status_t omap44xx_uart3_efr_special_char_detect_extract(omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_special_char_detect_status_t omap44xx_uart3_efr_special_char_detect_extract(omap44xx_uart3_efr_t _regval)
{
    return((omap44xx_uart3_special_char_detect_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_special_char_detect_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_special_char_detect_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_special_char_detect_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_special_char_detect_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_efr_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_auto_rts_en_status_t omap44xx_uart3_efr_auto_rts_en_extract(omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_auto_rts_en_status_t omap44xx_uart3_efr_auto_rts_en_extract(omap44xx_uart3_efr_t _regval)
{
    return((omap44xx_uart3_auto_rts_en_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_auto_rts_en_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_auto_rts_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_auto_rts_en_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_auto_rts_en_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_efr_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_efr_auto_cts_en_extract(omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_efr_auto_cts_en_extract(omap44xx_uart3_efr_t _regval)
{
    return((omap44xx_uart3_auto_cts_en_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_auto_cts_en_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_auto_cts_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_auto_cts_en_insert(omap44xx_uart3_efr_t _regval, omap44xx_uart3_auto_cts_en_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_efr_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_efr_prtval(char *_s, size_t _size, omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_efr_prtval(char *_s, size_t _size, omap44xx_uart3_efr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_flow_control =\t%" PRIx8 "\t(Combinations of software flow control can be selected by programming bit 3 - bit 0. See.)\n", omap44xx_uart3_efr_sw_flow_control_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enhanced_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_enhanced_en_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_enhanced_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enhanced functions write enable bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " special_char_detect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_special_char_detect_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_special_char_detect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_rts_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_auto_rts_en_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_auto_rts_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto-RTS enable bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_cts_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_auto_cts_en_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_auto_cts_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto-CTS enable bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_fcr_t
 * Description: Implicit type of FIFO control register register
 * Fields:
 *   fifo_en	(size 1, offset 0, init 0):	WO	
 *   rx_fifo_clear	(size 1, offset 1, init 0):	WO	
 *   tx_fifo_clear	(size 1, offset 2, init 0):	WO	
 *   dma_mode	(size 1, offset 3, init 0):	WO	This register is considered ifUART_SCR[0] = 0.
 *   tx_fifo_trig	(size 2, offset 4, init 0):	WO	Sets the trigger level for the TX FIFO: If UART_SCR[6] = 0 and UART_TLR[3:0] = 0000: 00: 8 spaces 01: 16 spaces 10: 32 spaces 11: 56 spaces If UART_SCR[6] = 0 and UART_TLR[3:0] != 0000, TX_FIFO_TRIG is not considered. If UART_SCR[6] = 1, TX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1
 *   rx_fifo_trig	(size 2, offset 6, init 0):	WO	Sets the trigger level for the RX FIFO: If UART_SCR[7] = 0 and UART_TLR[7:4] = 0000: 00: 8 characters 01: 16 characters 10: 56 characters 11: 60 characters If UART_SCR[7] = 0 and UART_TLR[7:4] != 0000, RX_FIFO_TRIG is not considered. If UART_SCR[7] = 1, RX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_fcr_t;
#define omap44xx_uart3_fcr_default 0x0
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_fcr_fifo_en_extract(omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_fcr_fifo_en_extract(omap44xx_uart3_fcr_t _regval)
{
    return((omap44xx_uart3_fifo_en_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_fifo_en_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_fifo_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_fifo_en_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_fifo_en_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_rx_fifo_clear_status_t omap44xx_uart3_fcr_rx_fifo_clear_extract(omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fifo_clear_status_t omap44xx_uart3_fcr_rx_fifo_clear_extract(omap44xx_uart3_fcr_t _regval)
{
    return((omap44xx_uart3_rx_fifo_clear_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rx_fifo_clear_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_rx_fifo_clear_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rx_fifo_clear_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_rx_fifo_clear_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_tx_fifo_clear_status_t omap44xx_uart3_fcr_tx_fifo_clear_extract(omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_fifo_clear_status_t omap44xx_uart3_fcr_tx_fifo_clear_extract(omap44xx_uart3_fcr_t _regval)
{
    return((omap44xx_uart3_tx_fifo_clear_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_tx_fifo_clear_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_tx_fifo_clear_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_tx_fifo_clear_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_tx_fifo_clear_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_dma_mode_status_t omap44xx_uart3_fcr_dma_mode_extract(omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_mode_status_t omap44xx_uart3_fcr_dma_mode_extract(omap44xx_uart3_fcr_t _regval)
{
    return((omap44xx_uart3_dma_mode_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_dma_mode_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_dma_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_dma_mode_insert(omap44xx_uart3_fcr_t _regval, omap44xx_uart3_dma_mode_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 3)));
}

static inline uint8_t omap44xx_uart3_fcr_tx_fifo_trig_extract(omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_fcr_tx_fifo_trig_extract(omap44xx_uart3_fcr_t _regval)
{
    return((uint8_t )((_regval & 0x30) >> 4));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_tx_fifo_trig_insert(omap44xx_uart3_fcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_tx_fifo_trig_insert(omap44xx_uart3_fcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_uart3_fcr_rx_fifo_trig_extract(omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_fcr_rx_fifo_trig_extract(omap44xx_uart3_fcr_t _regval)
{
    return((uint8_t )((_regval & 0xc0) >> 6));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rx_fifo_trig_insert(omap44xx_uart3_fcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rx_fifo_trig_insert(omap44xx_uart3_fcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 6)));
}

static inline int omap44xx_uart3_fcr_prtval(char *_s, size_t _size, omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_fcr_prtval(char *_s, size_t _size, omap44xx_uart3_fcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fifo_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fifo_en_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_fifo_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_clear =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fifo_clear_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_rx_fifo_clear_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_clear =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_fifo_clear_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_tx_fifo_clear_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_dma_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This register is considered ifUART_SCR[0] = 0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_trig =\t%" PRIx8 "\t(Sets the trigger level for the TX FIFO: If UART_SCR[6] = 0 and UART_TLR[3:0] = 0000: 00: 8 spaces 01: 16 spaces 10: 32 spaces 11: 56 spaces If UART_SCR[6] = 0 and UART_TLR[3:0] != 0000, TX_FIFO_TRIG is not considered. If UART_SCR[6] = 1, TX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1)\n", omap44xx_uart3_fcr_tx_fifo_trig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig =\t%" PRIx8 "\t(Sets the trigger level for the RX FIFO: If UART_SCR[7] = 0 and UART_TLR[7:4] = 0000: 00: 8 characters 01: 16 characters 10: 56 characters 11: 60 characters If UART_SCR[7] = 0 and UART_TLR[7:4] != 0000, RX_FIFO_TRIG is not considered. If UART_SCR[7] = 1, RX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1.)\n", omap44xx_uart3_fcr_rx_fifo_trig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_iir_t
 * Description: Implicit type of Interrupt identification register. register
 * Fields:
 *   it_pending	(size 1, offset 0, init 0):	RO	Read 0x0: An interrupt is pending.
 *   it_type	(size 5, offset 1, init 0):	RO	Read 0x0: Modem interrupt. Priority = 4
 *   fcr_mirror	(size 2, offset 6, init 0):	RO	Mirror the contents ofUART_FCR[0] on both bits.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_iir_t;
#define omap44xx_uart3_iir_default 0x0
static inline omap44xx_uart3_it_pending_status_t omap44xx_uart3_iir_it_pending_extract(omap44xx_uart3_iir_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_it_pending_status_t omap44xx_uart3_iir_it_pending_extract(omap44xx_uart3_iir_t _regval)
{
    return((omap44xx_uart3_it_pending_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_it_pending_insert(omap44xx_uart3_iir_t _regval, omap44xx_uart3_it_pending_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_it_pending_insert(omap44xx_uart3_iir_t _regval, omap44xx_uart3_it_pending_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_iir_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_it_type_status_t omap44xx_uart3_iir_it_type_extract(omap44xx_uart3_iir_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_it_type_status_t omap44xx_uart3_iir_it_type_extract(omap44xx_uart3_iir_t _regval)
{
    return((omap44xx_uart3_it_type_status_t )((_regval & 0x3e) >> 1));
}

static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_it_type_insert(omap44xx_uart3_iir_t _regval, omap44xx_uart3_it_type_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_it_type_insert(omap44xx_uart3_iir_t _regval, omap44xx_uart3_it_type_status_t _fieldval)
{
    return((_regval & 0xffffffc1) | (0x3e & (((omap44xx_uart3_iir_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_uart3_iir_fcr_mirror_extract(omap44xx_uart3_iir_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_iir_fcr_mirror_extract(omap44xx_uart3_iir_t _regval)
{
    return((uint8_t )((_regval & 0xc0) >> 6));
}

static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_fcr_mirror_insert(omap44xx_uart3_iir_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_fcr_mirror_insert(omap44xx_uart3_iir_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((omap44xx_uart3_iir_t )(_fieldval)) << 6)));
}

static inline int omap44xx_uart3_iir_prtval(char *_s, size_t _size, omap44xx_uart3_iir_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_iir_prtval(char *_s, size_t _size, omap44xx_uart3_iir_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " it_pending =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_it_pending_status_prtval(_s + _r, _avail, omap44xx_uart3_iir_it_pending_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: An interrupt is pending.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " it_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_it_type_status_prtval(_s + _r, _avail, omap44xx_uart3_iir_it_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Modem interrupt. Priority = 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcr_mirror =\t%" PRIx8 "\t(Mirror the contents ofUART_FCR[0] on both bits.)\n", omap44xx_uart3_iir_fcr_mirror_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_lcr_t
 * Description: Implicit type of Line control register register
 * Fields:
 *   char_length	(size 2, offset 0, init 0):	RW	Specifies the word length to be transmitted or received
 *   nb_stop	(size 1, offset 2, init 0):	RW	Specifies the number of stop-bits
 *   parity_en	(size 1, offset 3, init 0):	RW	0x0: No parity
 *   parity_type1	(size 1, offset 4, init 0):	RW	
 *   parity_type2	(size 1, offset 5, init 0):	RW	Selects the forced parity format (ifUART_LCR[3] = 1). If UART_LCR[5] = 1 and UART_LCR[4] = 0, the parity bit is forced to 1 in the transmitted and received data. If UART_LCR[5] = 1 and UART_LCR[4] = 1, the parity bit is forced to 0 in the transmitted and received data.
 *   break_en	(size 1, offset 6, init 0):	RW	Break control bit
 *   div_en	(size 1, offset 7, init 0):	RW	
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_lcr_t;
#define omap44xx_uart3_lcr_default 0x0
static inline omap44xx_uart3_char_length_status_t omap44xx_uart3_lcr_char_length_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_char_length_status_t omap44xx_uart3_lcr_char_length_extract(omap44xx_uart3_lcr_t _regval)
{
    return((omap44xx_uart3_char_length_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_char_length_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_char_length_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_char_length_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_char_length_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_nb_stop_status_t omap44xx_uart3_lcr_nb_stop_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_nb_stop_status_t omap44xx_uart3_lcr_nb_stop_extract(omap44xx_uart3_lcr_t _regval)
{
    return((omap44xx_uart3_nb_stop_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_nb_stop_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_nb_stop_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_nb_stop_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_nb_stop_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_parity_en_status_t omap44xx_uart3_lcr_parity_en_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_parity_en_status_t omap44xx_uart3_lcr_parity_en_extract(omap44xx_uart3_lcr_t _regval)
{
    return((omap44xx_uart3_parity_en_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_parity_en_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_parity_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_parity_en_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_parity_en_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_parity_type1_status_t omap44xx_uart3_lcr_parity_type1_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_parity_type1_status_t omap44xx_uart3_lcr_parity_type1_extract(omap44xx_uart3_lcr_t _regval)
{
    return((omap44xx_uart3_parity_type1_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_parity_type1_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_parity_type1_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_parity_type1_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_parity_type1_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_uart3_lcr_parity_type2_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_lcr_parity_type2_extract(omap44xx_uart3_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_parity_type2_insert(omap44xx_uart3_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_parity_type2_insert(omap44xx_uart3_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_break_en_status_t omap44xx_uart3_lcr_break_en_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_break_en_status_t omap44xx_uart3_lcr_break_en_extract(omap44xx_uart3_lcr_t _regval)
{
    return((omap44xx_uart3_break_en_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_break_en_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_break_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_break_en_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_break_en_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_div_en_status_t omap44xx_uart3_lcr_div_en_extract(omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_div_en_status_t omap44xx_uart3_lcr_div_en_extract(omap44xx_uart3_lcr_t _regval)
{
    return((omap44xx_uart3_div_en_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_div_en_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_div_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_div_en_insert(omap44xx_uart3_lcr_t _regval, omap44xx_uart3_div_en_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_lcr_prtval(char *_s, size_t _size, omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_lcr_prtval(char *_s, size_t _size, omap44xx_uart3_lcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " char_length =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_char_length_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_char_length_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Specifies the word length to be transmitted or received)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nb_stop =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_nb_stop_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_nb_stop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Specifies the number of stop-bits)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_parity_en_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_parity_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: No parity)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_type1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_parity_type1_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_parity_type1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_type2 =\t%" PRIx8 "\t(Selects the forced parity format (ifUART_LCR[3] = 1). If UART_LCR[5] = 1 and UART_LCR[4] = 0, the parity bit is forced to 1 in the transmitted and received data. If UART_LCR[5] = 1 and UART_LCR[4] = 1, the parity bit is forced to 0 in the transmitted and received data.)\n", omap44xx_uart3_lcr_parity_type2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " break_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_break_en_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_break_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Break control bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " div_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_div_en_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_div_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_mcr_t
 * Description: Implicit type of Modem control register register
 * Fields:
 *   dtr	(size 1, offset 0, init 0):	RW	0x0: Force DTR* output to inactive (high).
 *   rts	(size 1, offset 1, init 0):	RW	In loopback, controls theUART_MSR[4] bit. If auto-RTS is enabled, the RTS* output is controlled by hardware flow control.
 *   ri_sts_ch	(size 1, offset 2, init 0):	RW	0x0: In loopback, forces RI* input high
 *   cd_sts_ch	(size 1, offset 3, init 0):	RW	0x0: In loopback, forces DCD* input high and IRQ outputs to inactive state
 *   loopback_en	(size 1, offset 4, init 0):	RW	0x0: Normal operating mode
 *   xon_en	(size 1, offset 5, init 0):	RW	0x0: Disable XON any function.
 *   tcr_tlr	(size 1, offset 6, init 0):	RW	0x0: No action
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_mcr_t;
#define omap44xx_uart3_mcr_default 0x0
static inline omap44xx_uart3_dtr_status_t omap44xx_uart3_mcr_dtr_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dtr_status_t omap44xx_uart3_mcr_dtr_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_dtr_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_dtr_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_dtr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_dtr_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_dtr_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_rts_status_t omap44xx_uart3_mcr_rts_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rts_status_t omap44xx_uart3_mcr_rts_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_rts_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_rts_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_rts_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_rts_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_rts_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_ri_sts_ch_status_t omap44xx_uart3_mcr_ri_sts_ch_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ri_sts_ch_status_t omap44xx_uart3_mcr_ri_sts_ch_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_ri_sts_ch_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_ri_sts_ch_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_ri_sts_ch_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_ri_sts_ch_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_ri_sts_ch_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_cd_sts_ch_status_t omap44xx_uart3_mcr_cd_sts_ch_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_cd_sts_ch_status_t omap44xx_uart3_mcr_cd_sts_ch_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_cd_sts_ch_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_cd_sts_ch_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_cd_sts_ch_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_cd_sts_ch_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_cd_sts_ch_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_loopback_en_status_t omap44xx_uart3_mcr_loopback_en_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_loopback_en_status_t omap44xx_uart3_mcr_loopback_en_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_loopback_en_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_loopback_en_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_loopback_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_loopback_en_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_loopback_en_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_xon_en_status_t omap44xx_uart3_mcr_xon_en_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon_en_status_t omap44xx_uart3_mcr_xon_en_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_xon_en_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_xon_en_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_xon_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_xon_en_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_xon_en_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_tcr_tlr_status_t omap44xx_uart3_mcr_tcr_tlr_extract(omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tcr_tlr_status_t omap44xx_uart3_mcr_tcr_tlr_extract(omap44xx_uart3_mcr_t _regval)
{
    return((omap44xx_uart3_tcr_tlr_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_tcr_tlr_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_tcr_tlr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_tcr_tlr_insert(omap44xx_uart3_mcr_t _regval, omap44xx_uart3_tcr_tlr_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 6)));
}

static inline int omap44xx_uart3_mcr_prtval(char *_s, size_t _size, omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mcr_prtval(char *_s, size_t _size, omap44xx_uart3_mcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dtr_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_dtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Force DTR* output to inactive (high).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rts_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_rts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(In loopback, controls theUART_MSR[4] bit. If auto-RTS is enabled, the RTS* output is controlled by hardware flow control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri_sts_ch =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ri_sts_ch_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_ri_sts_ch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: In loopback, forces RI* input high)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cd_sts_ch =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cd_sts_ch_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_cd_sts_ch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: In loopback, forces DCD* input high and IRQ outputs to inactive state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loopback_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_loopback_en_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_loopback_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Normal operating mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xon_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xon_en_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_xon_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disable XON any function.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcr_tlr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tcr_tlr_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_tcr_tlr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: No action)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_xon1_addr1_t
 * Description: Implicit type of UART mode: XON1 character, IrDA mode: ADDR1 address register
 * Fields:
 *   xon_word1	(size 8, offset 0, init 0):	RW	Stores the 8-bit XON1 character in UART modes and ADDR1 address 1 for IrDA modes
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_xon1_addr1_t;
#define omap44xx_uart3_xon1_addr1_default 0x0
static inline uint8_t omap44xx_uart3_xon1_addr1_xon_word1_extract(omap44xx_uart3_xon1_addr1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xon1_addr1_xon_word1_extract(omap44xx_uart3_xon1_addr1_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_xon1_addr1_t omap44xx_uart3_xon1_addr1_xon_word1_insert(omap44xx_uart3_xon1_addr1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon1_addr1_t omap44xx_uart3_xon1_addr1_xon_word1_insert(omap44xx_uart3_xon1_addr1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_xon1_addr1_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_xon1_addr1_prtval(char *_s, size_t _size, omap44xx_uart3_xon1_addr1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xon1_addr1_prtval(char *_s, size_t _size, omap44xx_uart3_xon1_addr1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xon_word1 =\t%" PRIx8 "\t(Stores the 8-bit XON1 character in UART modes and ADDR1 address 1 for IrDA modes)\n", omap44xx_uart3_xon1_addr1_xon_word1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_lsr_t
 * Description: Implicit type of Line status register register
 * Fields:
 *   rx_fifo_e	(size 1, offset 0, init 0):	RO	Read 0x0: No data in the RX FIFO
 *   rx_oe	(size 1, offset 1, init 0):	RO	Read 0x0: No overrun error
 *   rx_pe	(size 1, offset 2, init 0):	RO	Read 0x0: No parity error in data from RX FIFO
 *   rx_fe	(size 1, offset 3, init 0):	RO	Read 0x0: No framing error in data RX FIFO
 *   rx_bi	(size 1, offset 4, init 0):	RO	Read 0x0: No break condition
 *   tx_fifo_e	(size 1, offset 5, init 0):	RO	Read 0x0: Transmit hold register (TX FIFO) is not empty.
 *   tx_sr_e	(size 1, offset 6, init 0):	RO	Read 0x0: Transmitter hold (TX FIFO) and shift registers are not empty.
 *   rx_fifo_sts	(size 1, offset 7, init 0):	RO	Read 0x0: Normal operation
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_lsr_t;
#define omap44xx_uart3_lsr_default 0x0
static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fifo_e_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fifo_e_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_rx_fe_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_fifo_e_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_fe_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_fifo_e_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_fe_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_rx_oe_status_t omap44xx_uart3_lsr_rx_oe_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_oe_status_t omap44xx_uart3_lsr_rx_oe_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_rx_oe_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_oe_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_oe_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_oe_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_oe_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_rx_pe_status_t omap44xx_uart3_lsr_rx_pe_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_pe_status_t omap44xx_uart3_lsr_rx_pe_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_rx_pe_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_pe_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_pe_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_pe_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_pe_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fe_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fe_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_rx_fe_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_fe_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_fe_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_fe_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_fe_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_rx_bi_status_t omap44xx_uart3_lsr_rx_bi_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_bi_status_t omap44xx_uart3_lsr_rx_bi_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_rx_bi_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_bi_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_bi_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_bi_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_bi_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_fifo_e_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_fifo_e_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_tx_sr_e_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_tx_fifo_e_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_tx_sr_e_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_tx_fifo_e_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_tx_sr_e_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_sr_e_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_sr_e_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_tx_sr_e_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_tx_sr_e_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_tx_sr_e_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_tx_sr_e_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_tx_sr_e_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_rx_fifo_sts_status_t omap44xx_uart3_lsr_rx_fifo_sts_extract(omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fifo_sts_status_t omap44xx_uart3_lsr_rx_fifo_sts_extract(omap44xx_uart3_lsr_t _regval)
{
    return((omap44xx_uart3_rx_fifo_sts_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_fifo_sts_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_fifo_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rx_fifo_sts_insert(omap44xx_uart3_lsr_t _regval, omap44xx_uart3_rx_fifo_sts_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_lsr_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_lsr_prtval(char *_s, size_t _size, omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_lsr_prtval(char *_s, size_t _size, omap44xx_uart3_lsr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_e =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_fifo_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No data in the RX FIFO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_oe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_oe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No overrun error)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_pe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_pe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No parity error in data from RX FIFO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No framing error in data RX FIFO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_bi =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_bi_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_bi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No break condition)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_e =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_sr_e_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_tx_fifo_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Transmit hold register (TX FIFO) is not empty.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_sr_e =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_sr_e_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_tx_sr_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Transmitter hold (TX FIFO) and shift registers are not empty.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fifo_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_fifo_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Normal operation)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_xon2_addr2_t
 * Description: Implicit type of Stores the 8-bit XON2 character in UART moldes and ADDR2 address 2 for IrDA modes register
 * Fields:
 *   xon_word2	(size 8, offset 0, init 0):	RW	Stores the 8-bit XON2 character in UART modes and ADDR2 address 2 for IrDA modes
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_xon2_addr2_t;
#define omap44xx_uart3_xon2_addr2_default 0x0
static inline uint8_t omap44xx_uart3_xon2_addr2_xon_word2_extract(omap44xx_uart3_xon2_addr2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xon2_addr2_xon_word2_extract(omap44xx_uart3_xon2_addr2_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_xon2_addr2_t omap44xx_uart3_xon2_addr2_xon_word2_insert(omap44xx_uart3_xon2_addr2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon2_addr2_t omap44xx_uart3_xon2_addr2_xon_word2_insert(omap44xx_uart3_xon2_addr2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_xon2_addr2_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_xon2_addr2_prtval(char *_s, size_t _size, omap44xx_uart3_xon2_addr2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xon2_addr2_prtval(char *_s, size_t _size, omap44xx_uart3_xon2_addr2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xon_word2 =\t%" PRIx8 "\t(Stores the 8-bit XON2 character in UART modes and ADDR2 address 2 for IrDA modes)\n", omap44xx_uart3_xon2_addr2_xon_word2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_msr_t
 * Description: Implicit type of Modem status register. UART mode only. register
 * Fields:
 *   cts_sts	(size 1, offset 0, init 0):	RO	
 *   dsr_sts	(size 1, offset 1, init 0):	RO	
 *   ri_sts	(size 1, offset 2, init 0):	RO	Indicates that RI* input (orUART_MCR[2] in loopback) changed state from low to high. Cleared on a read.
 *   dcd_sts	(size 1, offset 3, init 0):	RO	Indicates that DCD* input (orUART_MCR[3] in loopback) changed. Cleared on a read.
 *   ncts_sts	(size 1, offset 4, init 0):	RO	This bit is the complement of the CTS* input. In loopback mode, it is equivalent toUART_MCR[1].
 *   ndsr_sts	(size 1, offset 5, init 0):	RO	This bit is the complement of the DSR* input. In loopback mode, it is equivalent toUART_MCR[0].
 *   nri_sts	(size 1, offset 6, init 0):	RO	This bit is the complement of the RI* input. In loopback mode, it is equivalent toUART_MCR[2].
 *   ncd_sts	(size 1, offset 7, init 0):	RO	This bit is the complement of the DCD* input. In loopback mode, it is equivalent toUART_MCR[3].
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_msr_t;
#define omap44xx_uart3_msr_default 0x0
static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_msr_cts_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_msr_cts_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((omap44xx_uart3_auto_cts_en_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_cts_sts_insert(omap44xx_uart3_msr_t _regval, omap44xx_uart3_auto_cts_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_cts_sts_insert(omap44xx_uart3_msr_t _regval, omap44xx_uart3_auto_cts_en_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_msr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_dsr_sts_status_t omap44xx_uart3_msr_dsr_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dsr_sts_status_t omap44xx_uart3_msr_dsr_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((omap44xx_uart3_dsr_sts_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_dsr_sts_insert(omap44xx_uart3_msr_t _regval, omap44xx_uart3_dsr_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_dsr_sts_insert(omap44xx_uart3_msr_t _regval, omap44xx_uart3_dsr_sts_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_msr_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_uart3_msr_ri_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ri_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ri_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ri_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_msr_t )(_fieldval)) << 2)));
}

static inline uint8_t omap44xx_uart3_msr_dcd_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_dcd_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_dcd_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_dcd_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_msr_t )(_fieldval)) << 3)));
}

static inline uint8_t omap44xx_uart3_msr_ncts_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ncts_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ncts_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ncts_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_msr_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_uart3_msr_ndsr_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ndsr_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ndsr_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ndsr_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_msr_t )(_fieldval)) << 5)));
}

static inline uint8_t omap44xx_uart3_msr_nri_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_nri_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_nri_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_nri_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_msr_t )(_fieldval)) << 6)));
}

static inline uint8_t omap44xx_uart3_msr_ncd_sts_extract(omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ncd_sts_extract(omap44xx_uart3_msr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ncd_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_ncd_sts_insert(omap44xx_uart3_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_msr_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_msr_prtval(char *_s, size_t _size, omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_msr_prtval(char *_s, size_t _size, omap44xx_uart3_msr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_auto_cts_en_status_prtval(_s + _r, _avail, omap44xx_uart3_msr_cts_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dsr_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_msr_dsr_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri_sts =\t%" PRIx8 "\t(Indicates that RI* input (orUART_MCR[2] in loopback) changed state from low to high. Cleared on a read.)\n", omap44xx_uart3_msr_ri_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcd_sts =\t%" PRIx8 "\t(Indicates that DCD* input (orUART_MCR[3] in loopback) changed. Cleared on a read.)\n", omap44xx_uart3_msr_dcd_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ncts_sts =\t%" PRIx8 "\t(This bit is the complement of the CTS* input. In loopback mode, it is equivalent toUART_MCR[1].)\n", omap44xx_uart3_msr_ncts_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ndsr_sts =\t%" PRIx8 "\t(This bit is the complement of the DSR* input. In loopback mode, it is equivalent toUART_MCR[0].)\n", omap44xx_uart3_msr_ndsr_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nri_sts =\t%" PRIx8 "\t(This bit is the complement of the RI* input. In loopback mode, it is equivalent toUART_MCR[2].)\n", omap44xx_uart3_msr_nri_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ncd_sts =\t%" PRIx8 "\t(This bit is the complement of the DCD* input. In loopback mode, it is equivalent toUART_MCR[3].)\n", omap44xx_uart3_msr_ncd_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_tcr_t
 * Description: Implicit type of Transmission control register register
 * Fields:
 *   rx_fifo_trig_halt	(size 4, offset 0, init 0):	RW	RX FIFO trigger level to HALT transmission (0 - 60)
 *   rx_fifo_trig_start	(size 4, offset 4, init 0):	RW	RX FIFO trigger level to RESTORE transmission (0 - 60)
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_tcr_t;
#define omap44xx_uart3_tcr_default 0x0
static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_halt_extract(omap44xx_uart3_tcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_halt_extract(omap44xx_uart3_tcr_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rx_fifo_trig_halt_insert(omap44xx_uart3_tcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rx_fifo_trig_halt_insert(omap44xx_uart3_tcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_uart3_tcr_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_start_extract(omap44xx_uart3_tcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_start_extract(omap44xx_uart3_tcr_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rx_fifo_trig_start_insert(omap44xx_uart3_tcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rx_fifo_trig_start_insert(omap44xx_uart3_tcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((omap44xx_uart3_tcr_t )(_fieldval)) << 4)));
}

static inline int omap44xx_uart3_tcr_prtval(char *_s, size_t _size, omap44xx_uart3_tcr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tcr_prtval(char *_s, size_t _size, omap44xx_uart3_tcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig_halt =\t%" PRIx8 "\t(RX FIFO trigger level to HALT transmission (0 - 60))\n", omap44xx_uart3_tcr_rx_fifo_trig_halt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig_start =\t%" PRIx8 "\t(RX FIFO trigger level to RESTORE transmission (0 - 60))\n", omap44xx_uart3_tcr_rx_fifo_trig_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_xoff1_t
 * Description: Implicit type of UART mode XOFF1 character register
 * Fields:
 *   xoff_word1	(size 8, offset 0, init 0):	RW	Stores the 8-bit XOFF1 character used in UART modes
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_xoff1_t;
#define omap44xx_uart3_xoff1_default 0x0
static inline uint8_t omap44xx_uart3_xoff1_xoff_word1_extract(omap44xx_uart3_xoff1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xoff1_xoff_word1_extract(omap44xx_uart3_xoff1_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_xoff1_t omap44xx_uart3_xoff1_xoff_word1_insert(omap44xx_uart3_xoff1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff1_t omap44xx_uart3_xoff1_xoff_word1_insert(omap44xx_uart3_xoff1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_xoff1_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_xoff1_prtval(char *_s, size_t _size, omap44xx_uart3_xoff1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xoff1_prtval(char *_s, size_t _size, omap44xx_uart3_xoff1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xoff_word1 =\t%" PRIx8 "\t(Stores the 8-bit XOFF1 character used in UART modes)\n", omap44xx_uart3_xoff1_xoff_word1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_spr_t
 * Description: Implicit type of Scratchpad register register
 * Fields:
 *   spr_word	(size 8, offset 0, init 0):	RW	Scratchpad register
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_spr_t;
#define omap44xx_uart3_spr_default 0x0
static inline uint8_t omap44xx_uart3_spr_spr_word_extract(omap44xx_uart3_spr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_spr_spr_word_extract(omap44xx_uart3_spr_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_spr_t omap44xx_uart3_spr_spr_word_insert(omap44xx_uart3_spr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_spr_t omap44xx_uart3_spr_spr_word_insert(omap44xx_uart3_spr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_spr_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_spr_prtval(char *_s, size_t _size, omap44xx_uart3_spr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_spr_prtval(char *_s, size_t _size, omap44xx_uart3_spr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spr_word =\t%" PRIx8 "\t(Scratchpad register)\n", omap44xx_uart3_spr_spr_word_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_tlr_t
 * Description: Implicit type of Trigger level register register
 * Fields:
 *   tx_fifo_trig_dma	(size 4, offset 0, init 0):	RW	Transmit FIFO trigger level
 *   rx_fifo_trig_dma	(size 4, offset 4, init 0):	RW	Receive FIFO trigger level
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_tlr_t;
#define omap44xx_uart3_tlr_default 0x0
static inline uint8_t omap44xx_uart3_tlr_tx_fifo_trig_dma_extract(omap44xx_uart3_tlr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tlr_tx_fifo_trig_dma_extract(omap44xx_uart3_tlr_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_tx_fifo_trig_dma_insert(omap44xx_uart3_tlr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_tx_fifo_trig_dma_insert(omap44xx_uart3_tlr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_uart3_tlr_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_uart3_tlr_rx_fifo_trig_dma_extract(omap44xx_uart3_tlr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tlr_rx_fifo_trig_dma_extract(omap44xx_uart3_tlr_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_rx_fifo_trig_dma_insert(omap44xx_uart3_tlr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_rx_fifo_trig_dma_insert(omap44xx_uart3_tlr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((omap44xx_uart3_tlr_t )(_fieldval)) << 4)));
}

static inline int omap44xx_uart3_tlr_prtval(char *_s, size_t _size, omap44xx_uart3_tlr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tlr_prtval(char *_s, size_t _size, omap44xx_uart3_tlr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_trig_dma =\t%" PRIx8 "\t(Transmit FIFO trigger level)\n", omap44xx_uart3_tlr_tx_fifo_trig_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig_dma =\t%" PRIx8 "\t(Receive FIFO trigger level)\n", omap44xx_uart3_tlr_rx_fifo_trig_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_xoff2_t
 * Description: Implicit type of UART mode XOFF2 character register
 * Fields:
 *   xoff_word2	(size 8, offset 0, init 0):	RW	Stores the 8-bit XOFF2 character used in UART modes.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_xoff2_t;
#define omap44xx_uart3_xoff2_default 0x0
static inline uint8_t omap44xx_uart3_xoff2_xoff_word2_extract(omap44xx_uart3_xoff2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xoff2_xoff_word2_extract(omap44xx_uart3_xoff2_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_xoff2_t omap44xx_uart3_xoff2_xoff_word2_insert(omap44xx_uart3_xoff2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff2_t omap44xx_uart3_xoff2_xoff_word2_insert(omap44xx_uart3_xoff2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_xoff2_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_xoff2_prtval(char *_s, size_t _size, omap44xx_uart3_xoff2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xoff2_prtval(char *_s, size_t _size, omap44xx_uart3_xoff2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xoff_word2 =\t%" PRIx8 "\t(Stores the 8-bit XOFF2 character used in UART modes.)\n", omap44xx_uart3_xoff2_xoff_word2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_mdr1_t
 * Description: Implicit type of Mode definition register 1 register
 * Fields:
 *   mode_select	(size 3, offset 0, init 0):	RW	0x0: UART 16x mode
 *   ir_sleep	(size 1, offset 3, init 0):	RW	0x0: IrDA/CIR sleep mode disabled
 *   set_txir	(size 1, offset 4, init 0):	RW	Used to configure the infrared transceiver
 *   sct	(size 1, offset 5, init 0):	RW	Store and control the transmission.
 *   sip_mode	(size 1, offset 6, init 0):	RW	MIR/FIR modes only
 *   frame_end_mode	(size 1, offset 7, init 0):	RW	IrDA mode only
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_mdr1_t;
#define omap44xx_uart3_mdr1_default 0x0
static inline omap44xx_uart3_mode_select_status_t omap44xx_uart3_mdr1_mode_select_extract(omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mode_select_status_t omap44xx_uart3_mdr1_mode_select_extract(omap44xx_uart3_mdr1_t _regval)
{
    return((omap44xx_uart3_mode_select_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_mode_select_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_mode_select_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_mode_select_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_mode_select_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_ir_sleep_status_t omap44xx_uart3_mdr1_ir_sleep_extract(omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ir_sleep_status_t omap44xx_uart3_mdr1_ir_sleep_extract(omap44xx_uart3_mdr1_t _regval)
{
    return((omap44xx_uart3_ir_sleep_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_ir_sleep_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_ir_sleep_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_ir_sleep_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_ir_sleep_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_set_txir_status_t omap44xx_uart3_mdr1_set_txir_extract(omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_set_txir_status_t omap44xx_uart3_mdr1_set_txir_extract(omap44xx_uart3_mdr1_t _regval)
{
    return((omap44xx_uart3_set_txir_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_set_txir_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_set_txir_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_set_txir_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_set_txir_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_sct_status_t omap44xx_uart3_mdr1_sct_extract(omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sct_status_t omap44xx_uart3_mdr1_sct_extract(omap44xx_uart3_mdr1_t _regval)
{
    return((omap44xx_uart3_sct_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_sct_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_sct_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_sct_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_sct_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_sip_mode_status_t omap44xx_uart3_mdr1_sip_mode_extract(omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sip_mode_status_t omap44xx_uart3_mdr1_sip_mode_extract(omap44xx_uart3_mdr1_t _regval)
{
    return((omap44xx_uart3_sip_mode_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_sip_mode_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_sip_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_sip_mode_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_sip_mode_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_frame_end_mode_status_t omap44xx_uart3_mdr1_frame_end_mode_extract(omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_frame_end_mode_status_t omap44xx_uart3_mdr1_frame_end_mode_extract(omap44xx_uart3_mdr1_t _regval)
{
    return((omap44xx_uart3_frame_end_mode_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_frame_end_mode_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_frame_end_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_frame_end_mode_insert(omap44xx_uart3_mdr1_t _regval, omap44xx_uart3_frame_end_mode_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_mdr1_prtval(char *_s, size_t _size, omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mdr1_prtval(char *_s, size_t _size, omap44xx_uart3_mdr1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mode_select =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mode_select_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_mode_select_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: UART 16x mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ir_sleep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ir_sleep_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_ir_sleep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: IrDA/CIR sleep mode disabled)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set_txir =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_set_txir_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_set_txir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to configure the infrared transceiver)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sct =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sct_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_sct_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Store and control the transmission.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sip_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sip_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_sip_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MIR/FIR modes only)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frame_end_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_frame_end_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_frame_end_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IrDA mode only)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_mdr2_t
 * Description: Implicit type of Mode definition register 2 register
 * Fields:
 *   irtx_underrun	(size 1, offset 0, init 0):	RO	IrDA transmission status interrupt. When theUART_IIR[5] interrupt occurs, the meaning of the interrupt is:
 *   sts_fifo_trig	(size 2, offset 1, init 0):	RW	IR-IrDA mode only. Frame status FIFO threshold select:
 *   pulse	(size 1, offset 3, init 0):	RW	UART mode only. Allows pulse shaping in UART mode.
 *   cir_pulse_mode	(size 2, offset 4, init 0):	RW	CIR pulse modulation definition. Defines high level of the pulse width associated with a digit:
 *   irrxinvert	(size 1, offset 6, init 0):	RW	IR mode only (IrDA and CIR). Invert RX pin in the module before the voting or sampling system logic of the infrared block. This does not affect the RX path in UART modem modes.
 *   set_txir_alt	(size 1, offset 7, init 0):	RO	Provide alternate function for MDR1[4] (SET_TXIR).
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_mdr2_t;
#define omap44xx_uart3_mdr2_default 0x0
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_mdr2_irtx_underrun_extract(omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_mdr2_irtx_underrun_extract(omap44xx_uart3_mdr2_t _regval)
{
    return((omap44xx_uart3_modem_sts_it_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_irtx_underrun_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_modem_sts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_irtx_underrun_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_modem_sts_it_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_sts_fifo_trig_status_t omap44xx_uart3_mdr2_sts_fifo_trig_extract(omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sts_fifo_trig_status_t omap44xx_uart3_mdr2_sts_fifo_trig_extract(omap44xx_uart3_mdr2_t _regval)
{
    return((omap44xx_uart3_sts_fifo_trig_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_sts_fifo_trig_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_sts_fifo_trig_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_sts_fifo_trig_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_sts_fifo_trig_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_pulse_status_t omap44xx_uart3_mdr2_pulse_extract(omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_pulse_status_t omap44xx_uart3_mdr2_pulse_extract(omap44xx_uart3_mdr2_t _regval)
{
    return((omap44xx_uart3_pulse_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_pulse_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_pulse_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_pulse_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_pulse_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_cir_pulse_mode_status_t omap44xx_uart3_mdr2_cir_pulse_mode_extract(omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_cir_pulse_mode_status_t omap44xx_uart3_mdr2_cir_pulse_mode_extract(omap44xx_uart3_mdr2_t _regval)
{
    return((omap44xx_uart3_cir_pulse_mode_status_t )((_regval & 0x30) >> 4));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_cir_pulse_mode_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_cir_pulse_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_cir_pulse_mode_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_cir_pulse_mode_status_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_irrxinvert_status_t omap44xx_uart3_mdr2_irrxinvert_extract(omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_irrxinvert_status_t omap44xx_uart3_mdr2_irrxinvert_extract(omap44xx_uart3_mdr2_t _regval)
{
    return((omap44xx_uart3_irrxinvert_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_irrxinvert_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_irrxinvert_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_irrxinvert_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_irrxinvert_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_set_txir_alt_status_t omap44xx_uart3_mdr2_set_txir_alt_extract(omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_set_txir_alt_status_t omap44xx_uart3_mdr2_set_txir_alt_extract(omap44xx_uart3_mdr2_t _regval)
{
    return((omap44xx_uart3_set_txir_alt_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_set_txir_alt_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_set_txir_alt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_set_txir_alt_insert(omap44xx_uart3_mdr2_t _regval, omap44xx_uart3_set_txir_alt_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_mdr2_prtval(char *_s, size_t _size, omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mdr2_prtval(char *_s, size_t _size, omap44xx_uart3_mdr2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irtx_underrun =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_modem_sts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_irtx_underrun_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IrDA transmission status interrupt. When theUART_IIR[5] interrupt occurs, the meaning of the interrupt is:)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts_fifo_trig =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sts_fifo_trig_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_sts_fifo_trig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IR-IrDA mode only. Frame status FIFO threshold select:)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pulse =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_pulse_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_pulse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(UART mode only. Allows pulse shaping in UART mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cir_pulse_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cir_pulse_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_cir_pulse_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(CIR pulse modulation definition. Defines high level of the pulse width associated with a digit:)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irrxinvert =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_irrxinvert_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_irrxinvert_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IR mode only (IrDA and CIR). Invert RX pin in the module before the voting or sampling system logic of the infrared block. This does not affect the RX path in UART modem modes.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set_txir_alt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_set_txir_alt_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_set_txir_alt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Provide alternate function for MDR1[4] (SET_TXIR).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_sflsr_t
 * Description: Implicit type of Status FIFO line status register register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   crc_error	(size 1, offset 1, init 0):	RO	Read 0x1: CRC error in frame at top of RX FIFO
 *   abort_detect	(size 1, offset 2, init 0):	RO	Read 0x1: Abort pattern detected in frame at top of RX FIFO
 *   frame_too_long_error	(size 1, offset 3, init 0):	RO	Read 0x1: Frame-length too long error in frame at top of RX FIFO
 *   oe_error	(size 1, offset 4, init 0):	RO	Read 0x1: Overrun error in RX FIFO when frame at top of RX FIFO was received Top of RX FIFO = Next frame to be read from RX FIFO
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_sflsr_t;
#define omap44xx_uart3_sflsr_default 0x0
static inline uint8_t omap44xx_uart3_sflsr_crc_error_extract(omap44xx_uart3_sflsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_crc_error_extract(omap44xx_uart3_sflsr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_crc_error_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_crc_error_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_sflsr_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_uart3_sflsr_abort_detect_extract(omap44xx_uart3_sflsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_abort_detect_extract(omap44xx_uart3_sflsr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_abort_detect_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_abort_detect_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_sflsr_t )(_fieldval)) << 2)));
}

static inline uint8_t omap44xx_uart3_sflsr_frame_too_long_error_extract(omap44xx_uart3_sflsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_frame_too_long_error_extract(omap44xx_uart3_sflsr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_frame_too_long_error_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_frame_too_long_error_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_sflsr_t )(_fieldval)) << 3)));
}

static inline uint8_t omap44xx_uart3_sflsr_oe_error_extract(omap44xx_uart3_sflsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_oe_error_extract(omap44xx_uart3_sflsr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_oe_error_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_oe_error_insert(omap44xx_uart3_sflsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_sflsr_t )(_fieldval)) << 4)));
}

static inline int omap44xx_uart3_sflsr_prtval(char *_s, size_t _size, omap44xx_uart3_sflsr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sflsr_prtval(char *_s, size_t _size, omap44xx_uart3_sflsr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc_error =\t%" PRIx8 "\t(Read 0x1: CRC error in frame at top of RX FIFO)\n", omap44xx_uart3_sflsr_crc_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abort_detect =\t%" PRIx8 "\t(Read 0x1: Abort pattern detected in frame at top of RX FIFO)\n", omap44xx_uart3_sflsr_abort_detect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frame_too_long_error =\t%" PRIx8 "\t(Read 0x1: Frame-length too long error in frame at top of RX FIFO)\n", omap44xx_uart3_sflsr_frame_too_long_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe_error =\t%" PRIx8 "\t(Read 0x1: Overrun error in RX FIFO when frame at top of RX FIFO was received Top of RX FIFO = Next frame to be read from RX FIFO)\n", omap44xx_uart3_sflsr_oe_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_txfll_t
 * Description: Implicit type of Transmit frame length register low register
 * Fields:
 *   txfll	(size 8, offset 0, init 0):	WO	LSB register used to specify the frame length
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_txfll_t;
#define omap44xx_uart3_txfll_default 0x0
static inline uint8_t omap44xx_uart3_txfll_txfll_extract(omap44xx_uart3_txfll_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_txfll_txfll_extract(omap44xx_uart3_txfll_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_txfll_t omap44xx_uart3_txfll_txfll_insert(omap44xx_uart3_txfll_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfll_t omap44xx_uart3_txfll_txfll_insert(omap44xx_uart3_txfll_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_txfll_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_txfll_prtval(char *_s, size_t _size, omap44xx_uart3_txfll_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txfll_prtval(char *_s, size_t _size, omap44xx_uart3_txfll_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfll =\t%" PRIx8 "\t(LSB register used to specify the frame length)\n", omap44xx_uart3_txfll_txfll_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_resume_t
 * Description: Implicit type of IR-IrDA and IR-CIR modes only. This register is used to clear internal flags, which halt transmission/reception when an underrun/overrun error occurs. Reading this register resumes the halted operation. This register does not physically exist and reads always as 0x00. register
 * Fields:
 *   resume	(size 8, offset 0, init 0):	RO	Dummy read to restart the TX or RX
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_resume_t;
#define omap44xx_uart3_resume_default 0x0
static inline uint8_t omap44xx_uart3_resume_resume_extract(omap44xx_uart3_resume_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_resume_resume_extract(omap44xx_uart3_resume_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_resume_t omap44xx_uart3_resume_resume_insert(omap44xx_uart3_resume_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_resume_t omap44xx_uart3_resume_resume_insert(omap44xx_uart3_resume_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_resume_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_resume_prtval(char *_s, size_t _size, omap44xx_uart3_resume_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_resume_prtval(char *_s, size_t _size, omap44xx_uart3_resume_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resume =\t%" PRIx8 "\t(Dummy read to restart the TX or RX)\n", omap44xx_uart3_resume_resume_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_txflh_t
 * Description: Implicit type of Transmit frame length register high register
 * Fields:
 *   txflh	(size 5, offset 0, init 0):	WO	MSB register used to specify the frame length
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_txflh_t;
#define omap44xx_uart3_txflh_default 0x0
static inline uint8_t omap44xx_uart3_txflh_txflh_extract(omap44xx_uart3_txflh_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_txflh_txflh_extract(omap44xx_uart3_txflh_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_uart3_txflh_t omap44xx_uart3_txflh_txflh_insert(omap44xx_uart3_txflh_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_txflh_t omap44xx_uart3_txflh_txflh_insert(omap44xx_uart3_txflh_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_uart3_txflh_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_txflh_prtval(char *_s, size_t _size, omap44xx_uart3_txflh_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txflh_prtval(char *_s, size_t _size, omap44xx_uart3_txflh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txflh =\t%" PRIx8 "\t(MSB register used to specify the frame length)\n", omap44xx_uart3_txflh_txflh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_rxfll_t
 * Description: Implicit type of Received frame length register low register
 * Fields:
 *   rxfll	(size 8, offset 0, init 0):	WO	LSB register used to specify the frame length in reception
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_rxfll_t;
#define omap44xx_uart3_rxfll_default 0x0
static inline uint8_t omap44xx_uart3_rxfll_rxfll_extract(omap44xx_uart3_rxfll_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rxfll_rxfll_extract(omap44xx_uart3_rxfll_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_rxfll_t omap44xx_uart3_rxfll_rxfll_insert(omap44xx_uart3_rxfll_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfll_t omap44xx_uart3_rxfll_rxfll_insert(omap44xx_uart3_rxfll_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_rxfll_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_rxfll_prtval(char *_s, size_t _size, omap44xx_uart3_rxfll_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxfll_prtval(char *_s, size_t _size, omap44xx_uart3_rxfll_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfll =\t%" PRIx8 "\t(LSB register used to specify the frame length in reception)\n", omap44xx_uart3_rxfll_rxfll_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_sfregl_t
 * Description: Implicit type of Status FIFO register low register
 * Fields:
 *   sfregl	(size 8, offset 0, init 0):	RO	LSB part of the frame length
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_sfregl_t;
#define omap44xx_uart3_sfregl_default 0x0
static inline uint8_t omap44xx_uart3_sfregl_sfregl_extract(omap44xx_uart3_sfregl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sfregl_sfregl_extract(omap44xx_uart3_sfregl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_sfregl_t omap44xx_uart3_sfregl_sfregl_insert(omap44xx_uart3_sfregl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sfregl_t omap44xx_uart3_sfregl_sfregl_insert(omap44xx_uart3_sfregl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_sfregl_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_sfregl_prtval(char *_s, size_t _size, omap44xx_uart3_sfregl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sfregl_prtval(char *_s, size_t _size, omap44xx_uart3_sfregl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfregl =\t%" PRIx8 "\t(LSB part of the frame length)\n", omap44xx_uart3_sfregl_sfregl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_rxflh_t
 * Description: Implicit type of Received frame length register high register
 * Fields:
 *   rxflh	(size 4, offset 0, init 0):	WO	MSB register used to specify the frame length in reception
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_rxflh_t;
#define omap44xx_uart3_rxflh_default 0x0
static inline uint8_t omap44xx_uart3_rxflh_rxflh_extract(omap44xx_uart3_rxflh_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rxflh_rxflh_extract(omap44xx_uart3_rxflh_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_uart3_rxflh_t omap44xx_uart3_rxflh_rxflh_insert(omap44xx_uart3_rxflh_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxflh_t omap44xx_uart3_rxflh_rxflh_insert(omap44xx_uart3_rxflh_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_uart3_rxflh_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_rxflh_prtval(char *_s, size_t _size, omap44xx_uart3_rxflh_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxflh_prtval(char *_s, size_t _size, omap44xx_uart3_rxflh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxflh =\t%" PRIx8 "\t(MSB register used to specify the frame length in reception)\n", omap44xx_uart3_rxflh_rxflh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_sfregh_t
 * Description: Implicit type of Status FIFO register high register
 * Fields:
 *   sfregh	(size 4, offset 0, init 0):	RO	MSB part of the frame length
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_sfregh_t;
#define omap44xx_uart3_sfregh_default 0x0
static inline uint8_t omap44xx_uart3_sfregh_sfregh_extract(omap44xx_uart3_sfregh_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sfregh_sfregh_extract(omap44xx_uart3_sfregh_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_uart3_sfregh_t omap44xx_uart3_sfregh_sfregh_insert(omap44xx_uart3_sfregh_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sfregh_t omap44xx_uart3_sfregh_sfregh_insert(omap44xx_uart3_sfregh_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_uart3_sfregh_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_sfregh_prtval(char *_s, size_t _size, omap44xx_uart3_sfregh_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sfregh_prtval(char *_s, size_t _size, omap44xx_uart3_sfregh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfregh =\t%" PRIx8 "\t(MSB part of the frame length)\n", omap44xx_uart3_sfregh_sfregh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_blr_t
 * Description: Implicit type of BOF control register register
 * Fields:
 *   _anon0	(size 6, offset 0, init 0):	MBZ	_
 *   xbof_type	(size 1, offset 6, init 0):	RW	SIR xBOF select
 *   sts_fifo_reset	(size 1, offset 7, init 0):	RW	Status FIFO reset. This bit is self-clearing.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_blr_t;
#define omap44xx_uart3_blr_default 0x0
static inline omap44xx_uart3_xbof_type_status_t omap44xx_uart3_blr_xbof_type_extract(omap44xx_uart3_blr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_xbof_type_status_t omap44xx_uart3_blr_xbof_type_extract(omap44xx_uart3_blr_t _regval)
{
    return((omap44xx_uart3_xbof_type_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_xbof_type_insert(omap44xx_uart3_blr_t _regval, omap44xx_uart3_xbof_type_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_xbof_type_insert(omap44xx_uart3_blr_t _regval, omap44xx_uart3_xbof_type_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_blr_t )(_fieldval)) << 6)));
}

static inline uint8_t omap44xx_uart3_blr_sts_fifo_reset_extract(omap44xx_uart3_blr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_blr_sts_fifo_reset_extract(omap44xx_uart3_blr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_sts_fifo_reset_insert(omap44xx_uart3_blr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_sts_fifo_reset_insert(omap44xx_uart3_blr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_blr_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_blr_prtval(char *_s, size_t _size, omap44xx_uart3_blr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_blr_prtval(char *_s, size_t _size, omap44xx_uart3_blr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xbof_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xbof_type_status_prtval(_s + _r, _avail, omap44xx_uart3_blr_xbof_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SIR xBOF select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts_fifo_reset =\t%" PRIx8 "\t(Status FIFO reset. This bit is self-clearing.)\n", omap44xx_uart3_blr_sts_fifo_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_uasr_t
 * Description: Implicit type of UART autobauding status register register
 * Fields:
 *   speed	(size 5, offset 0, init 0):	RO	Used to report the speed identified
 *   bit_by_char	(size 1, offset 5, init 0):	RO	Read 0x0: 7-bit character identified
 *   parity_type	(size 2, offset 6, init 0):	RO	Read 0x0: No parity identified
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_uasr_t;
#define omap44xx_uart3_uasr_default 0x0
static inline omap44xx_uart3_speed_status_t omap44xx_uart3_uasr_speed_extract(omap44xx_uart3_uasr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_speed_status_t omap44xx_uart3_uasr_speed_extract(omap44xx_uart3_uasr_t _regval)
{
    return((omap44xx_uart3_speed_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_speed_insert(omap44xx_uart3_uasr_t _regval, omap44xx_uart3_speed_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_speed_insert(omap44xx_uart3_uasr_t _regval, omap44xx_uart3_speed_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_uart3_uasr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_bit_by_char_status_t omap44xx_uart3_uasr_bit_by_char_extract(omap44xx_uart3_uasr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_bit_by_char_status_t omap44xx_uart3_uasr_bit_by_char_extract(omap44xx_uart3_uasr_t _regval)
{
    return((omap44xx_uart3_bit_by_char_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_bit_by_char_insert(omap44xx_uart3_uasr_t _regval, omap44xx_uart3_bit_by_char_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_bit_by_char_insert(omap44xx_uart3_uasr_t _regval, omap44xx_uart3_bit_by_char_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_uasr_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_parity_type_status_t omap44xx_uart3_uasr_parity_type_extract(omap44xx_uart3_uasr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_parity_type_status_t omap44xx_uart3_uasr_parity_type_extract(omap44xx_uart3_uasr_t _regval)
{
    return((omap44xx_uart3_parity_type_status_t )((_regval & 0xc0) >> 6));
}

static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_parity_type_insert(omap44xx_uart3_uasr_t _regval, omap44xx_uart3_parity_type_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_parity_type_insert(omap44xx_uart3_uasr_t _regval, omap44xx_uart3_parity_type_status_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((omap44xx_uart3_uasr_t )(_fieldval)) << 6)));
}

static inline int omap44xx_uart3_uasr_prtval(char *_s, size_t _size, omap44xx_uart3_uasr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_uasr_prtval(char *_s, size_t _size, omap44xx_uart3_uasr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_speed_status_prtval(_s + _r, _avail, omap44xx_uart3_uasr_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to report the speed identified)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit_by_char =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_bit_by_char_status_prtval(_s + _r, _avail, omap44xx_uart3_uasr_bit_by_char_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: 7-bit character identified)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_parity_type_status_prtval(_s + _r, _avail, omap44xx_uart3_uasr_parity_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No parity identified)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_acreg_t
 * Description: Implicit type of Auxiliary control register. IR-IrDA and IR-CIR modes only. register
 * Fields:
 *   eot_en	(size 1, offset 0, init 0):	RW	EOT (end of transmission) bit. The LH writes 1 to this bit just before it writes the last byte to the TX FIFO in set-EOT bit frame closing method. This bit is cleared automatically when the LH writes to the THR (TX FIFO).
 *   abort_en	(size 1, offset 1, init 0):	RW	Frame abort. The LH can intentionally abort transmission of a frame by writing 1 to this bit. Neither the end flag nor the CRC bits are appended to the frame. If TX FIFO is not empty and MDR1[5] = 1, UART IrDA starts a new transfer with data of the previous frame when the abort frame is sent. Therefore, TX FIFO must be reset before sending an abort frame.
 *   sctx_en	(size 1, offset 2, init 0):	RW	Store and controlled TX start. When MDR1[5] = 1 and the LH writes 1 to this bit, the TX state-machine starts frame transmission. This bit is self-clearing.
 *   send_sip	(size 1, offset 3, init 0):	RW	MIR/FIR modes only. Send serial infrared interaction pulse (SIP). If this bit is set during an MIR/FIR transmission, the SIP is sent at the end of it. This bit is cleared automatically at the end of the SIP transmission.
 *   dis_tx_underrun	(size 1, offset 4, init 0):	RW	It is recommended to disable TX FIFO underrun capability by masking corresponding underrun interrupt. When disabling underrun by setting ACREG[4] = 1, garbage data is sent over TX line.
 *   dis_ir_rx	(size 1, offset 5, init 0):	RW	0x0: Normal operation (RX input automatically disabled during transmit but enabled outside of transmit operation)
 *   sd_mod	(size 1, offset 6, init 0):	RW	Primary output used to configure transceivers. Connected to the SD/MODE input pin of IrDA transceivers.
 *   pulse_type	(size 1, offset 7, init 0):	RW	SIR pulse width select
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_acreg_t;
#define omap44xx_uart3_acreg_default 0x0
static inline uint8_t omap44xx_uart3_acreg_eot_en_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_acreg_eot_en_extract(omap44xx_uart3_acreg_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_eot_en_insert(omap44xx_uart3_acreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_eot_en_insert(omap44xx_uart3_acreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_uart3_acreg_abort_en_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_acreg_abort_en_extract(omap44xx_uart3_acreg_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_abort_en_insert(omap44xx_uart3_acreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_abort_en_insert(omap44xx_uart3_acreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_uart3_acreg_sctx_en_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_acreg_sctx_en_extract(omap44xx_uart3_acreg_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_sctx_en_insert(omap44xx_uart3_acreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_sctx_en_insert(omap44xx_uart3_acreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_send_sip_status_t omap44xx_uart3_acreg_send_sip_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_send_sip_status_t omap44xx_uart3_acreg_send_sip_extract(omap44xx_uart3_acreg_t _regval)
{
    return((omap44xx_uart3_send_sip_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_send_sip_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_send_sip_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_send_sip_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_send_sip_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_acreg_dis_tx_underrun_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_acreg_dis_tx_underrun_extract(omap44xx_uart3_acreg_t _regval)
{
    return((omap44xx_uart3_dis_tx_underrun_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_dis_tx_underrun_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_dis_tx_underrun_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_dis_tx_underrun_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_dis_tx_underrun_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_acreg_dis_ir_rx_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_acreg_dis_ir_rx_extract(omap44xx_uart3_acreg_t _regval)
{
    return((omap44xx_uart3_fifo_en_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_dis_ir_rx_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_fifo_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_dis_ir_rx_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_fifo_en_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_sd_mod_status_t omap44xx_uart3_acreg_sd_mod_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sd_mod_status_t omap44xx_uart3_acreg_sd_mod_extract(omap44xx_uart3_acreg_t _regval)
{
    return((omap44xx_uart3_sd_mod_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_sd_mod_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_sd_mod_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_sd_mod_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_sd_mod_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_pulse_type_status_t omap44xx_uart3_acreg_pulse_type_extract(omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_pulse_type_status_t omap44xx_uart3_acreg_pulse_type_extract(omap44xx_uart3_acreg_t _regval)
{
    return((omap44xx_uart3_pulse_type_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_pulse_type_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_pulse_type_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_pulse_type_insert(omap44xx_uart3_acreg_t _regval, omap44xx_uart3_pulse_type_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_acreg_prtval(char *_s, size_t _size, omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_acreg_prtval(char *_s, size_t _size, omap44xx_uart3_acreg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eot_en =\t%" PRIx8 "\t(EOT (end of transmission) bit. The LH writes 1 to this bit just before it writes the last byte to the TX FIFO in set-EOT bit frame closing method. This bit is cleared automatically when the LH writes to the THR (TX FIFO).)\n", omap44xx_uart3_acreg_eot_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abort_en =\t%" PRIx8 "\t(Frame abort. The LH can intentionally abort transmission of a frame by writing 1 to this bit. Neither the end flag nor the CRC bits are appended to the frame. If TX FIFO is not empty and MDR1[5] = 1, UART IrDA starts a new transfer with data of the previous frame when the abort frame is sent. Therefore, TX FIFO must be reset before sending an abort frame.)\n", omap44xx_uart3_acreg_abort_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sctx_en =\t%" PRIx8 "\t(Store and controlled TX start. When MDR1[5] = 1 and the LH writes 1 to this bit, the TX state-machine starts frame transmission. This bit is self-clearing.)\n", omap44xx_uart3_acreg_sctx_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " send_sip =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_send_sip_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_send_sip_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MIR/FIR modes only. Send serial infrared interaction pulse (SIP). If this bit is set during an MIR/FIR transmission, the SIP is sent at the end of it. This bit is cleared automatically at the end of the SIP transmission.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_tx_underrun =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dis_tx_underrun_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_dis_tx_underrun_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(It is recommended to disable TX FIFO underrun capability by masking corresponding underrun interrupt. When disabling underrun by setting ACREG[4] = 1, garbage data is sent over TX line.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_ir_rx =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fifo_en_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_dis_ir_rx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Normal operation (RX input automatically disabled during transmit but enabled outside of transmit operation))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sd_mod =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sd_mod_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_sd_mod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Primary output used to configure transceivers. Connected to the SD/MODE input pin of IrDA transceivers.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pulse_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_pulse_type_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_pulse_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SIR pulse width select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_scr_t
 * Description: Implicit type of Supplementary control register register
 * Fields:
 *   dma_mode_ctl	(size 1, offset 0, init 0):	RW	0x0: The DMA_MODE is set withUART_FCR[3].
 *   dma_mode_2	(size 2, offset 1, init 0):	RW	Used to specify the DMA mode valid if theUART_SCR[0] bit = 1
 *   tx_empty_ctl_it	(size 1, offset 3, init 0):	RW	0x0: Normal mode for THR interrupt (see UART mode interrupts table)
 *   rx_cts_dsr_wake_up_enable	(size 1, offset 4, init 0):	RW	0x0: Disables the wake-up interrupt and clears SSR[1]
 *   dsr_it	(size 1, offset 5, init 0):	RW	0x0: Disables DSR* interrupt
 *   tx_trig_granu1	(size 1, offset 6, init 0):	RW	0x0: Disables the granularity of 1 for trigger TX level
 *   rx_trig_granu1	(size 1, offset 7, init 0):	RW	0x0: Disables the granularity of 1 for trigger RX level
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_scr_t;
#define omap44xx_uart3_scr_default 0x0
static inline omap44xx_uart3_dma_mode_ctl_status_t omap44xx_uart3_scr_dma_mode_ctl_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_mode_ctl_status_t omap44xx_uart3_scr_dma_mode_ctl_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_dma_mode_ctl_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_dma_mode_ctl_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dma_mode_ctl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_dma_mode_ctl_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dma_mode_ctl_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_scr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_dma_mode_2_status_t omap44xx_uart3_scr_dma_mode_2_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_mode_2_status_t omap44xx_uart3_scr_dma_mode_2_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_dma_mode_2_status_t )((_regval & 0x6) >> 1));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_dma_mode_2_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dma_mode_2_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_dma_mode_2_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dma_mode_2_status_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((omap44xx_uart3_scr_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_tx_empty_ctl_it_status_t omap44xx_uart3_scr_tx_empty_ctl_it_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_empty_ctl_it_status_t omap44xx_uart3_scr_tx_empty_ctl_it_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_tx_empty_ctl_it_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_tx_empty_ctl_it_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_tx_empty_ctl_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_tx_empty_ctl_it_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_tx_empty_ctl_it_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_scr_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_scr_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_dsr_it_status_t omap44xx_uart3_scr_dsr_it_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dsr_it_status_t omap44xx_uart3_scr_dsr_it_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_dsr_it_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_dsr_it_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dsr_it_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_dsr_it_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dsr_it_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_scr_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_scr_tx_trig_granu1_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_scr_tx_trig_granu1_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_dis_tx_underrun_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_tx_trig_granu1_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dis_tx_underrun_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_tx_trig_granu1_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_dis_tx_underrun_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_scr_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_scr_rx_trig_granu1_extract(omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_scr_rx_trig_granu1_extract(omap44xx_uart3_scr_t _regval)
{
    return((omap44xx_uart3_fifo_en_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rx_trig_granu1_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_fifo_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rx_trig_granu1_insert(omap44xx_uart3_scr_t _regval, omap44xx_uart3_fifo_en_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_scr_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_scr_prtval(char *_s, size_t _size, omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_scr_prtval(char *_s, size_t _size, omap44xx_uart3_scr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode_ctl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_mode_ctl_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_dma_mode_ctl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: The DMA_MODE is set withUART_FCR[3].)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode_2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_mode_2_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_dma_mode_2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to specify the DMA mode valid if theUART_SCR[0] bit = 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_empty_ctl_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_empty_ctl_it_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_tx_empty_ctl_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Normal mode for THR interrupt (see UART mode interrupts table))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_cts_dsr_wake_up_enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables the wake-up interrupt and clears SSR[1])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dsr_it_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_dsr_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables DSR* interrupt)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_trig_granu1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dis_tx_underrun_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_tx_trig_granu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables the granularity of 1 for trigger TX level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_trig_granu1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fifo_en_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_rx_trig_granu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables the granularity of 1 for trigger RX level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_ssr_t
 * Description: Implicit type of Supplementary status register register
 * Fields:
 *   tx_fifo_full	(size 1, offset 0, init 0):	RO	Read 0x0: TX FIFO is not full.
 *   rx_cts_dsr_wake_up_sts	(size 1, offset 1, init 0):	RO	Read 0x0: No falling edge event on RX, CTS*, and DSR*
 *   dma_counter_rst	(size 1, offset 2, init 0):	RW	0x0: The DMA counter will not be reset if the corresponding FIFO is reset (through FCR[1] or FCR[2]).
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_ssr_t;
#define omap44xx_uart3_ssr_default 0x0
static inline omap44xx_uart3_tx_fifo_full_status_t omap44xx_uart3_ssr_tx_fifo_full_extract(omap44xx_uart3_ssr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_fifo_full_status_t omap44xx_uart3_ssr_tx_fifo_full_extract(omap44xx_uart3_ssr_t _regval)
{
    return((omap44xx_uart3_tx_fifo_full_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_tx_fifo_full_insert(omap44xx_uart3_ssr_t _regval, omap44xx_uart3_tx_fifo_full_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_tx_fifo_full_insert(omap44xx_uart3_ssr_t _regval, omap44xx_uart3_tx_fifo_full_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_ssr_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_extract(omap44xx_uart3_ssr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_extract(omap44xx_uart3_ssr_t _regval)
{
    return((omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_insert(omap44xx_uart3_ssr_t _regval, omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_insert(omap44xx_uart3_ssr_t _regval, omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_ssr_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_dma_counter_rst_status_t omap44xx_uart3_ssr_dma_counter_rst_extract(omap44xx_uart3_ssr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_counter_rst_status_t omap44xx_uart3_ssr_dma_counter_rst_extract(omap44xx_uart3_ssr_t _regval)
{
    return((omap44xx_uart3_dma_counter_rst_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_dma_counter_rst_insert(omap44xx_uart3_ssr_t _regval, omap44xx_uart3_dma_counter_rst_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_dma_counter_rst_insert(omap44xx_uart3_ssr_t _regval, omap44xx_uart3_dma_counter_rst_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_ssr_t )(_fieldval)) << 2)));
}

static inline int omap44xx_uart3_ssr_prtval(char *_s, size_t _size, omap44xx_uart3_ssr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ssr_prtval(char *_s, size_t _size, omap44xx_uart3_ssr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_full =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_fifo_full_status_prtval(_s + _r, _avail, omap44xx_uart3_ssr_tx_fifo_full_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: TX FIFO is not full.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_cts_dsr_wake_up_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No falling edge event on RX, CTS*, and DSR*)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_counter_rst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_counter_rst_status_prtval(_s + _r, _avail, omap44xx_uart3_ssr_dma_counter_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: The DMA counter will not be reset if the corresponding FIFO is reset (through FCR[1] or FCR[2]).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_eblr_t
 * Description: Implicit type of BOF length register register
 * Fields:
 *   eblr	(size 8, offset 0, init 0):	RW	IR-IrDA mode: This register allows definition of up to 176 xBOFs, the maximum required by IrDA specification.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_eblr_t;
#define omap44xx_uart3_eblr_default 0x0
static inline uint8_t omap44xx_uart3_eblr_eblr_extract(omap44xx_uart3_eblr_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_eblr_eblr_extract(omap44xx_uart3_eblr_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_eblr_t omap44xx_uart3_eblr_eblr_insert(omap44xx_uart3_eblr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_eblr_t omap44xx_uart3_eblr_eblr_insert(omap44xx_uart3_eblr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_eblr_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_eblr_prtval(char *_s, size_t _size, omap44xx_uart3_eblr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_eblr_prtval(char *_s, size_t _size, omap44xx_uart3_eblr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eblr =\t%" PRIx8 "\t(IR-IrDA mode: This register allows definition of up to 176 xBOFs, the maximum required by IrDA specification.)\n", omap44xx_uart3_eblr_eblr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_sysc_t
 * Description: Implicit type of System configuration register register
 * Fields:
 *   autoidle	(size 1, offset 0, init 0):	RW	Internal OCP clock gating strategy
 *   softreset	(size 1, offset 1, init 0):	RW	Software reset. Set this bit to 1 to trigger a module reset. This bit is automatically reset by the hardware. Read returns 0.
 *   enawakeup	(size 1, offset 2, init 0):	RW	Wake-up feature control
 *   idlemode	(size 2, offset 3, init 0):	RW	Power management req/ack control ref: OCP Design Guidelines Version 1.1
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_sysc_t;
#define omap44xx_uart3_sysc_default 0x0
static inline omap44xx_uart3_autoidle_status_t omap44xx_uart3_sysc_autoidle_extract(omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_autoidle_status_t omap44xx_uart3_sysc_autoidle_extract(omap44xx_uart3_sysc_t _regval)
{
    return((omap44xx_uart3_autoidle_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_autoidle_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_autoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_autoidle_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_autoidle_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_softreset_status_t omap44xx_uart3_sysc_softreset_extract(omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_softreset_status_t omap44xx_uart3_sysc_softreset_extract(omap44xx_uart3_sysc_t _regval)
{
    return((omap44xx_uart3_softreset_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_softreset_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_softreset_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_softreset_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_enawakeup_status_t omap44xx_uart3_sysc_enawakeup_extract(omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_enawakeup_status_t omap44xx_uart3_sysc_enawakeup_extract(omap44xx_uart3_sysc_t _regval)
{
    return((omap44xx_uart3_enawakeup_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_enawakeup_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_enawakeup_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_enawakeup_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_enawakeup_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_idlemode_status_t omap44xx_uart3_sysc_idlemode_extract(omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_idlemode_status_t omap44xx_uart3_sysc_idlemode_extract(omap44xx_uart3_sysc_t _regval)
{
    return((omap44xx_uart3_idlemode_status_t )((_regval & 0x18) >> 3));
}

static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_idlemode_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_idlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_idlemode_insert(omap44xx_uart3_sysc_t _regval, omap44xx_uart3_idlemode_status_t _fieldval)
{
    return((_regval & 0xffffffe7) | (0x18 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 3)));
}

static inline int omap44xx_uart3_sysc_prtval(char *_s, size_t _size, omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sysc_prtval(char *_s, size_t _size, omap44xx_uart3_sysc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_autoidle_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_autoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal OCP clock gating strategy)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_softreset_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Software reset. Set this bit to 1 to trigger a module reset. This bit is automatically reset by the hardware. Read returns 0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enawakeup =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_enawakeup_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_enawakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up feature control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_idlemode_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power management req/ack control ref: OCP Design Guidelines Version 1.1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_syss_t
 * Description: Implicit type of System status register register
 * Fields:
 *   resetdone	(size 1, offset 0, init 0):	RO	Internal reset monitoring
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_syss_t;
#define omap44xx_uart3_syss_default 0x0
static inline omap44xx_uart3_resetdone_status_t omap44xx_uart3_syss_resetdone_extract(omap44xx_uart3_syss_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_resetdone_status_t omap44xx_uart3_syss_resetdone_extract(omap44xx_uart3_syss_t _regval)
{
    return((omap44xx_uart3_resetdone_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_syss_t omap44xx_uart3_syss_resetdone_insert(omap44xx_uart3_syss_t _regval, omap44xx_uart3_resetdone_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_syss_t omap44xx_uart3_syss_resetdone_insert(omap44xx_uart3_syss_t _regval, omap44xx_uart3_resetdone_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_syss_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_syss_prtval(char *_s, size_t _size, omap44xx_uart3_syss_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_syss_prtval(char *_s, size_t _size, omap44xx_uart3_syss_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_resetdone_status_prtval(_s + _r, _avail, omap44xx_uart3_syss_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal reset monitoring)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_wer_t
 * Description: Implicit type of Wake-up enable register register
 * Fields:
 *   event_0_cts_activity	(size 1, offset 0, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_1_dsr_activity	(size 1, offset 1, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_2_ri_activity	(size 1, offset 2, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_3_dcd_cd_activity	(size 1, offset 3, init 0):	RW	0x0: Event is not allowed to wake up the system
 *   event_4_rx_activity	(size 1, offset 4, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_5_rhr_interrupt	(size 1, offset 5, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_6_receiver_line_status_interrupt	(size 1, offset 6, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   tx_wakeup_en	(size 1, offset 7, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_wer_t;
#define omap44xx_uart3_wer_default 0x0
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_0_cts_activity_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_0_cts_activity_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_0_cts_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_0_cts_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_wer_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_1_dsr_activity_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_1_dsr_activity_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_1_dsr_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_1_dsr_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_wer_t )(_fieldval)) << 1)));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_2_ri_activity_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_2_ri_activity_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_2_ri_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_2_ri_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_wer_t )(_fieldval)) << 2)));
}

static inline omap44xx_uart3_event_3_dcd_cd_activity_status_t omap44xx_uart3_wer_event_3_dcd_cd_activity_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_3_dcd_cd_activity_status_t omap44xx_uart3_wer_event_3_dcd_cd_activity_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_3_dcd_cd_activity_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_3_dcd_cd_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_3_dcd_cd_activity_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_3_dcd_cd_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_3_dcd_cd_activity_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_uart3_wer_t )(_fieldval)) << 3)));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_4_rx_activity_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_4_rx_activity_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_4_rx_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_4_rx_activity_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_uart3_wer_t )(_fieldval)) << 4)));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_5_rhr_interrupt_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_5_rhr_interrupt_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_5_rhr_interrupt_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_5_rhr_interrupt_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_uart3_wer_t )(_fieldval)) << 5)));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_uart3_wer_t )(_fieldval)) << 6)));
}

static inline omap44xx_uart3_tx_wakeup_en_status_t omap44xx_uart3_wer_tx_wakeup_en_extract(omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_wakeup_en_status_t omap44xx_uart3_wer_tx_wakeup_en_extract(omap44xx_uart3_wer_t _regval)
{
    return((omap44xx_uart3_tx_wakeup_en_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_tx_wakeup_en_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_tx_wakeup_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_tx_wakeup_en_insert(omap44xx_uart3_wer_t _regval, omap44xx_uart3_tx_wakeup_en_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_uart3_wer_t )(_fieldval)) << 7)));
}

static inline int omap44xx_uart3_wer_prtval(char *_s, size_t _size, omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_wer_prtval(char *_s, size_t _size, omap44xx_uart3_wer_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_0_cts_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_0_cts_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_1_dsr_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_1_dsr_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_2_ri_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_2_ri_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_3_dcd_cd_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_3_dcd_cd_activity_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_3_dcd_cd_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_4_rx_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_4_rx_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_5_rhr_interrupt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_5_rhr_interrupt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_6_receiver_line_status_interrupt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_wakeup_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_wakeup_en_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_tx_wakeup_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_cfps_t
 * Description: Implicit type of Carrier frequency prescaler register
 * Fields:
 *   cfps	(size 8, offset 0, init 0):	RW	System clock frequency prescaler at (12x multiple). Examples for CFPS values:Target Freq (kHz) CFPS (decimal) Actual Freq (kHz) . 30 133 30.08 . 32.75 122 32.79 . 36 111 36.04 . 36.7 109 36.69 . 38* 105 38.1 . 40 100 40 . 56.8 70 57.14 . *configured at reset to this value . Note:CFPS = 0 is not supported. .
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_cfps_t;
#define omap44xx_uart3_cfps_default 0x0
static inline uint8_t omap44xx_uart3_cfps_cfps_extract(omap44xx_uart3_cfps_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_cfps_cfps_extract(omap44xx_uart3_cfps_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_cfps_t omap44xx_uart3_cfps_cfps_insert(omap44xx_uart3_cfps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_cfps_t omap44xx_uart3_cfps_cfps_insert(omap44xx_uart3_cfps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_cfps_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_cfps_prtval(char *_s, size_t _size, omap44xx_uart3_cfps_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_cfps_prtval(char *_s, size_t _size, omap44xx_uart3_cfps_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfps =\t%" PRIx8 "\t(System clock frequency prescaler at (12x multiple). Examples for CFPS values:Target Freq (kHz) CFPS (decimal) Actual Freq (kHz) . 30 133 30.08 . 32.75 122 32.79 . 36 111 36.04 . 36.7 109 36.69 . 38* 105 38.1 . 40 100 40 . 56.8 70 57.14 . *configured at reset to this value . Note:CFPS = 0 is not supported. .)\n", omap44xx_uart3_cfps_cfps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_rxfifo_lvl_t
 * Description: Implicit type of Level of the RX FIFO register
 * Fields:
 *   rxfifo_lvl	(size 8, offset 0, init 0):	RO	Shows the number of received bytes in the RX FIFO
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_rxfifo_lvl_t;
#define omap44xx_uart3_rxfifo_lvl_default 0x0
static inline uint8_t omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_extract(omap44xx_uart3_rxfifo_lvl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_extract(omap44xx_uart3_rxfifo_lvl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_rxfifo_lvl_t omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_insert(omap44xx_uart3_rxfifo_lvl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfifo_lvl_t omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_insert(omap44xx_uart3_rxfifo_lvl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_rxfifo_lvl_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_rxfifo_lvl_prtval(char *_s, size_t _size, omap44xx_uart3_rxfifo_lvl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxfifo_lvl_prtval(char *_s, size_t _size, omap44xx_uart3_rxfifo_lvl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_lvl =\t%" PRIx8 "\t(Shows the number of received bytes in the RX FIFO)\n", omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_txfifo_lvl_t
 * Description: Implicit type of Level of the TX FIFO register
 * Fields:
 *   txfifo_lvl	(size 8, offset 0, init 0):	RO	Shows the number of written bytes in the TX FIFO
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_txfifo_lvl_t;
#define omap44xx_uart3_txfifo_lvl_default 0x0
static inline uint8_t omap44xx_uart3_txfifo_lvl_txfifo_lvl_extract(omap44xx_uart3_txfifo_lvl_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_txfifo_lvl_txfifo_lvl_extract(omap44xx_uart3_txfifo_lvl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_txfifo_lvl_t omap44xx_uart3_txfifo_lvl_txfifo_lvl_insert(omap44xx_uart3_txfifo_lvl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfifo_lvl_t omap44xx_uart3_txfifo_lvl_txfifo_lvl_insert(omap44xx_uart3_txfifo_lvl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_txfifo_lvl_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_txfifo_lvl_prtval(char *_s, size_t _size, omap44xx_uart3_txfifo_lvl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txfifo_lvl_prtval(char *_s, size_t _size, omap44xx_uart3_txfifo_lvl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_lvl =\t%" PRIx8 "\t(Shows the number of written bytes in the TX FIFO)\n", omap44xx_uart3_txfifo_lvl_txfifo_lvl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_ier2_t
 * Description: Implicit type of Enables RX/TX FIFOs empty corresponding interrupts register
 * Fields:
 *   en_rxfifo_empty	(size 1, offset 0, init 0):	RW	Enables RX FIFO empty corresponding interrupt
 *   en_txfifo_empty	(size 1, offset 1, init 0):	RW	Enables TX FIFO empty corresponding interrupt
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_ier2_t;
#define omap44xx_uart3_ier2_default 0x0
static inline omap44xx_uart3_en_rxfifo_empty_status_t omap44xx_uart3_ier2_en_rxfifo_empty_extract(omap44xx_uart3_ier2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_en_rxfifo_empty_status_t omap44xx_uart3_ier2_en_rxfifo_empty_extract(omap44xx_uart3_ier2_t _regval)
{
    return((omap44xx_uart3_en_rxfifo_empty_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_en_rxfifo_empty_insert(omap44xx_uart3_ier2_t _regval, omap44xx_uart3_en_rxfifo_empty_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_en_rxfifo_empty_insert(omap44xx_uart3_ier2_t _regval, omap44xx_uart3_en_rxfifo_empty_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_ier2_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_en_txfifo_empty_status_t omap44xx_uart3_ier2_en_txfifo_empty_extract(omap44xx_uart3_ier2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_en_txfifo_empty_status_t omap44xx_uart3_ier2_en_txfifo_empty_extract(omap44xx_uart3_ier2_t _regval)
{
    return((omap44xx_uart3_en_txfifo_empty_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_en_txfifo_empty_insert(omap44xx_uart3_ier2_t _regval, omap44xx_uart3_en_txfifo_empty_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_en_txfifo_empty_insert(omap44xx_uart3_ier2_t _regval, omap44xx_uart3_en_txfifo_empty_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_ier2_t )(_fieldval)) << 1)));
}

static inline int omap44xx_uart3_ier2_prtval(char *_s, size_t _size, omap44xx_uart3_ier2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ier2_prtval(char *_s, size_t _size, omap44xx_uart3_ier2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_rxfifo_empty =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_en_rxfifo_empty_status_prtval(_s + _r, _avail, omap44xx_uart3_ier2_en_rxfifo_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enables RX FIFO empty corresponding interrupt)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_txfifo_empty =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_en_txfifo_empty_status_prtval(_s + _r, _avail, omap44xx_uart3_ier2_en_txfifo_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enables TX FIFO empty corresponding interrupt)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_isr2_t
 * Description: Implicit type of Status of RX/TX FIFOs empty corresponding interrupts register
 * Fields:
 *   rxfifo_empty_sts	(size 1, offset 0, init 0):	RW	Used to generate interrupt if the RX_FIFO is empty (software flow control)
 *   txfifo_empty_sts	(size 1, offset 1, init 0):	RW	Used to generate interrupt if the TX_FIFO is empty (software flow control)
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_isr2_t;
#define omap44xx_uart3_isr2_default 0x0
static inline omap44xx_uart3_rxfifo_empty_sts_status_t omap44xx_uart3_isr2_rxfifo_empty_sts_extract(omap44xx_uart3_isr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfifo_empty_sts_status_t omap44xx_uart3_isr2_rxfifo_empty_sts_extract(omap44xx_uart3_isr2_t _regval)
{
    return((omap44xx_uart3_rxfifo_empty_sts_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_rxfifo_empty_sts_insert(omap44xx_uart3_isr2_t _regval, omap44xx_uart3_rxfifo_empty_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_rxfifo_empty_sts_insert(omap44xx_uart3_isr2_t _regval, omap44xx_uart3_rxfifo_empty_sts_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_isr2_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_txfifo_empty_sts_status_t omap44xx_uart3_isr2_txfifo_empty_sts_extract(omap44xx_uart3_isr2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfifo_empty_sts_status_t omap44xx_uart3_isr2_txfifo_empty_sts_extract(omap44xx_uart3_isr2_t _regval)
{
    return((omap44xx_uart3_txfifo_empty_sts_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_txfifo_empty_sts_insert(omap44xx_uart3_isr2_t _regval, omap44xx_uart3_txfifo_empty_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_txfifo_empty_sts_insert(omap44xx_uart3_isr2_t _regval, omap44xx_uart3_txfifo_empty_sts_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_isr2_t )(_fieldval)) << 1)));
}

static inline int omap44xx_uart3_isr2_prtval(char *_s, size_t _size, omap44xx_uart3_isr2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_isr2_prtval(char *_s, size_t _size, omap44xx_uart3_isr2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_empty_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rxfifo_empty_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_isr2_rxfifo_empty_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to generate interrupt if the RX_FIFO is empty (software flow control))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_empty_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_txfifo_empty_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_isr2_txfifo_empty_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to generate interrupt if the TX_FIFO is empty (software flow control))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_freq_sel_t
 * Description: Implicit type of Sample per bit selector register
 * Fields:
 *   freq_sel	(size 8, offset 0, init 0):	RW	Sets the sample per bit if nondefault frequency is used. MDR3[1] must be set to 1 after this value is set. Must be equal to or higher then 6.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_freq_sel_t;
#define omap44xx_uart3_freq_sel_default 0x0
static inline uint8_t omap44xx_uart3_freq_sel_freq_sel_extract(omap44xx_uart3_freq_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_freq_sel_freq_sel_extract(omap44xx_uart3_freq_sel_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_uart3_freq_sel_t omap44xx_uart3_freq_sel_freq_sel_insert(omap44xx_uart3_freq_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_freq_sel_t omap44xx_uart3_freq_sel_freq_sel_insert(omap44xx_uart3_freq_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_uart3_freq_sel_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_freq_sel_prtval(char *_s, size_t _size, omap44xx_uart3_freq_sel_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_freq_sel_prtval(char *_s, size_t _size, omap44xx_uart3_freq_sel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freq_sel =\t%" PRIx8 "\t(Sets the sample per bit if nondefault frequency is used. MDR3[1] must be set to 1 after this value is set. Must be equal to or higher then 6.)\n", omap44xx_uart3_freq_sel_freq_sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_mdr3_t
 * Description: Implicit type of Mode definition register 3 register
 * Fields:
 *   disable_cir_rx_demod	(size 1, offset 0, init 0):	RW	Used to enable CIR RX demodulation.
 *   nondefault_freq	(size 1, offset 1, init 0):	RW	Used to enable the NONDEFAULT fclk frequencies.
 *   set_dma_tx_threshold	(size 1, offset 2, init 0):	RW	Enable to set different TXDMA threshold inUART_TX_DMA_THRESHOLD register.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_mdr3_t;
#define omap44xx_uart3_mdr3_default 0x0
static inline omap44xx_uart3_disable_cir_rx_demod_status_t omap44xx_uart3_mdr3_disable_cir_rx_demod_extract(omap44xx_uart3_mdr3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_disable_cir_rx_demod_status_t omap44xx_uart3_mdr3_disable_cir_rx_demod_extract(omap44xx_uart3_mdr3_t _regval)
{
    return((omap44xx_uart3_disable_cir_rx_demod_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_disable_cir_rx_demod_insert(omap44xx_uart3_mdr3_t _regval, omap44xx_uart3_disable_cir_rx_demod_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_disable_cir_rx_demod_insert(omap44xx_uart3_mdr3_t _regval, omap44xx_uart3_disable_cir_rx_demod_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_uart3_mdr3_t )(_fieldval)) << 0)));
}

static inline omap44xx_uart3_nondefault_freq_status_t omap44xx_uart3_mdr3_nondefault_freq_extract(omap44xx_uart3_mdr3_t _regval) __attribute__ ((always_inline));
static inline omap44xx_uart3_nondefault_freq_status_t omap44xx_uart3_mdr3_nondefault_freq_extract(omap44xx_uart3_mdr3_t _regval)
{
    return((omap44xx_uart3_nondefault_freq_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_nondefault_freq_insert(omap44xx_uart3_mdr3_t _regval, omap44xx_uart3_nondefault_freq_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_nondefault_freq_insert(omap44xx_uart3_mdr3_t _regval, omap44xx_uart3_nondefault_freq_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_uart3_mdr3_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_uart3_mdr3_set_dma_tx_threshold_extract(omap44xx_uart3_mdr3_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_mdr3_set_dma_tx_threshold_extract(omap44xx_uart3_mdr3_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_set_dma_tx_threshold_insert(omap44xx_uart3_mdr3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_set_dma_tx_threshold_insert(omap44xx_uart3_mdr3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_uart3_mdr3_t )(_fieldval)) << 2)));
}

static inline int omap44xx_uart3_mdr3_prtval(char *_s, size_t _size, omap44xx_uart3_mdr3_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mdr3_prtval(char *_s, size_t _size, omap44xx_uart3_mdr3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " disable_cir_rx_demod =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_disable_cir_rx_demod_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr3_disable_cir_rx_demod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to enable CIR RX demodulation.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nondefault_freq =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_nondefault_freq_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr3_nondefault_freq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to enable the NONDEFAULT fclk frequencies.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set_dma_tx_threshold =\t%" PRIx8 "\t(Enable to set different TXDMA threshold inUART_TX_DMA_THRESHOLD register.)\n", omap44xx_uart3_mdr3_set_dma_tx_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_uart3_tx_dma_threshold_t
 * Description: Implicit type of Use to manually set the TX DMA threshold level. [2] SET_TX_DMA_THRESHOLD must be 1 and must be value + tx_trigger_level = 64 (TX FIFO size). If not, 64-tx_trigger_level will be used without modifying the value of this register. register
 * Fields:
 *   tx_dma_threshold	(size 6, offset 0, init 0):	RW	Used to manually set the TX DMA threshold level
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_uart3_tx_dma_threshold_t;
#define omap44xx_uart3_tx_dma_threshold_default 0x0
static inline uint8_t omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_extract(omap44xx_uart3_tx_dma_threshold_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_extract(omap44xx_uart3_tx_dma_threshold_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline omap44xx_uart3_tx_dma_threshold_t omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_insert(omap44xx_uart3_tx_dma_threshold_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_dma_threshold_t omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_insert(omap44xx_uart3_tx_dma_threshold_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((omap44xx_uart3_tx_dma_threshold_t )(_fieldval)) << 0)));
}

static inline int omap44xx_uart3_tx_dma_threshold_prtval(char *_s, size_t _size, omap44xx_uart3_tx_dma_threshold_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_dma_threshold_prtval(char *_s, size_t _size, omap44xx_uart3_tx_dma_threshold_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_dma_threshold =\t%" PRIx8 "\t(Used to manually set the TX DMA threshold level)\n", omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    omap44xx_uart3_thr_t thr_shadow;
    omap44xx_uart3_fcr_t fcr_shadow;
    omap44xx_uart3_txfll_t txfll_shadow;
    omap44xx_uart3_txflh_t txflh_shadow;
    omap44xx_uart3_rxfll_t rxfll_shadow;
    omap44xx_uart3_rxflh_t rxflh_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_uart3_initials {
    omap44xx_uart3_dll_initial = 0x0,
    omap44xx_uart3_rhr_initial = 0x0,
    omap44xx_uart3_thr_initial = 0x0,
    omap44xx_uart3_dlh_initial = 0x0,
    omap44xx_uart3_ier_initial = 0x0,
    omap44xx_uart3_efr_initial = 0x0,
    omap44xx_uart3_fcr_initial = 0x0,
    omap44xx_uart3_iir_initial = 0x0,
    omap44xx_uart3_lcr_initial = 0x0,
    omap44xx_uart3_mcr_initial = 0x0,
    omap44xx_uart3_xon1_addr1_initial = 0x0,
    omap44xx_uart3_lsr_initial = 0x0,
    omap44xx_uart3_xon2_addr2_initial = 0x0,
    omap44xx_uart3_msr_initial = 0x0,
    omap44xx_uart3_tcr_initial = 0x0,
    omap44xx_uart3_xoff1_initial = 0x0,
    omap44xx_uart3_spr_initial = 0x0,
    omap44xx_uart3_tlr_initial = 0x0,
    omap44xx_uart3_xoff2_initial = 0x0,
    omap44xx_uart3_mdr1_initial = 0x0,
    omap44xx_uart3_mdr2_initial = 0x0,
    omap44xx_uart3_sflsr_initial = 0x0,
    omap44xx_uart3_txfll_initial = 0x0,
    omap44xx_uart3_resume_initial = 0x0,
    omap44xx_uart3_txflh_initial = 0x0,
    omap44xx_uart3_rxfll_initial = 0x0,
    omap44xx_uart3_sfregl_initial = 0x0,
    omap44xx_uart3_rxflh_initial = 0x0,
    omap44xx_uart3_sfregh_initial = 0x0,
    omap44xx_uart3_blr_initial = 0x0,
    omap44xx_uart3_uasr_initial = 0x0,
    omap44xx_uart3_acreg_initial = 0x0,
    omap44xx_uart3_scr_initial = 0x0,
    omap44xx_uart3_ssr_initial = 0x0,
    omap44xx_uart3_eblr_initial = 0x0,
    omap44xx_uart3_mvr_initial = 0x0,
    omap44xx_uart3_sysc_initial = 0x0,
    omap44xx_uart3_syss_initial = 0x0,
    omap44xx_uart3_wer_initial = 0x0,
    omap44xx_uart3_cfps_initial = 0x0,
    omap44xx_uart3_rxfifo_lvl_initial = 0x0,
    omap44xx_uart3_txfifo_lvl_initial = 0x0,
    omap44xx_uart3_ier2_initial = 0x0,
    omap44xx_uart3_isr2_initial = 0x0,
    omap44xx_uart3_freq_sel_initial = 0x0,
    omap44xx_uart3_mdr3_initial = 0x0,
    omap44xx_uart3_tx_dma_threshold_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_uart3_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_uart3_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register dll: This register, with, stores the 14-bit divisor for generation of the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor.
 * Type: omap44xx_uart3.dll (Implicit type of This register, with, stores the 14-bit divisor for generation of the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor. register)
 *   clock_lsb	(size 8, offset 0, init 0):	RW	Stores the 8-bit LSB divisor value
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_dll_t omap44xx_uart3_dll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dll_t omap44xx_uart3_dll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_uart3_dll_t omap44xx_uart3_dll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dll_t omap44xx_uart3_dll_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_uart3_dll_rawwr(__DN(t) *_dev, omap44xx_uart3_dll_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_dll_rawwr(__DN(t) *_dev, omap44xx_uart3_dll_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void omap44xx_uart3_dll_wr(__DN(t) *_dev, omap44xx_uart3_dll_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_dll_wr(__DN(t) *_dev, omap44xx_uart3_dll_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int omap44xx_uart3_dll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_dll_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dll (This register, with, stores the 14-bit divisor for generation of the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clock_lsb =\t%" PRIx8 "\t(Stores the 8-bit LSB divisor value)\n", omap44xx_uart3_dll_clock_lsb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_dll_clock_lsb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_dll_clock_lsb_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_dll_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_uart3_dll_clock_lsb_extract(_regval));
}

static inline void omap44xx_uart3_dll_clock_lsb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_dll_clock_lsb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_dll_t _regval = 0xff & (((omap44xx_uart3_dll_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register rhr: The receiver section consists of the receiver holding register (RHR) and the receiver shift register. The RHR is a 64-byte FIFO. The receiver shift register receives serial data from RX input. The data is converted to parallel data and moved to the RHR. If the FIFO is disabled, location 0 of the FIFO stores the single data character.Note:If an overflow occurs, the data in the RHR is not overwritten.
 * Type: omap44xx_uart3.rhr (Implicit type of The receiver section consists of the receiver holding register (RHR) and the receiver shift register. The RHR is a 64-byte FIFO. The receiver shift register receives serial data from RX input. The data is converted to parallel data and moved to the RHR. If the FIFO is disabled, location 0 of the FIFO stores the single data character.Note:If an overflow occurs, the data in the RHR is not overwritten. register)
 *   rhr	(size 8, offset 0, init 0):	RO	Receive holding register
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_rhr_t omap44xx_uart3_rhr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rhr_t omap44xx_uart3_rhr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_uart3_rhr_t omap44xx_uart3_rhr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rhr_t omap44xx_uart3_rhr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_uart3_rhr_rawwr(__DN(t) *_dev, omap44xx_uart3_rhr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rhr_rawwr(__DN(t) *_dev, omap44xx_uart3_rhr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register rhr is not writeable
static inline int omap44xx_uart3_rhr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rhr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_rhr_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rhr (The receiver section consists of the receiver holding register (RHR) and the receiver shift register. The RHR is a 64-byte FIFO. The receiver shift register receives serial data from RX input. The data is converted to parallel data and moved to the RHR. If the FIFO is disabled, location 0 of the FIFO stores the single data character.Note:If an overflow occurs, the data in the RHR is not overwritten.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhr =\t%" PRIx8 "\t(Receive holding register)\n", omap44xx_uart3_rhr_rhr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_rhr_rhr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rhr_rhr_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_rhr_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_uart3_rhr_rhr_extract(_regval));
}

/*
 * Register thr: The transmitter section consists of the transmit holding register (THR) and the transmit shift register. The THR is a 64-byte FIFO. The local host (LH) writes data to the THR. The data is placed in the transmit shift register where it is shifted out serially on the TX output. If the FIFO is disabled, location 0 of the FIFO stores the data.
 * Type: omap44xx_uart3.thr (Implicit type of The transmitter section consists of the transmit holding register (THR) and the transmit shift register. The THR is a 64-byte FIFO. The local host (LH) writes data to the THR. The data is placed in the transmit shift register where it is shifted out serially on the TX output. If the FIFO is disabled, location 0 of the FIFO stores the data. register)
 *   thr	(size 8, offset 0, init 0):	WO	Transmit holding register
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_thr_t omap44xx_uart3_thr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_thr_t omap44xx_uart3_thr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_uart3_thr_t omap44xx_uart3_thr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_thr_t omap44xx_uart3_thr_rd(__DN(t) *_dev)
{
    return(_dev->thr_shadow);
}

static inline void omap44xx_uart3_thr_rawwr(__DN(t) *_dev, omap44xx_uart3_thr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_thr_rawwr(__DN(t) *_dev, omap44xx_uart3_thr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void omap44xx_uart3_thr_wr(__DN(t) *_dev, omap44xx_uart3_thr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_thr_wr(__DN(t) *_dev, omap44xx_uart3_thr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int omap44xx_uart3_thr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_thr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_thr_t _regval = _dev->thr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register thr (The transmitter section consists of the transmit holding register (THR) and the transmit shift register. The THR is a 64-byte FIFO. The local host (LH) writes data to the THR. The data is placed in the transmit shift register where it is shifted out serially on the TX output. If the FIFO is disabled, location 0 of the FIFO stores the data.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thr =\t%" PRIx8 "\t(Transmit holding register)\n", omap44xx_uart3_thr_thr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_thr_thr_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_thr_thr_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_thr_thr_extract(_dev->thr_shadow));
}

static inline void omap44xx_uart3_thr_thr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_thr_thr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_thr_t _regval = 0xff & (((omap44xx_uart3_thr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    _dev->thr_shadow = _regval;
}

/*
 * Register dlh: This register, with, stores the 14-bit divisor for generating the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor.
 * Type: omap44xx_uart3.dlh (Implicit type of This register, with, stores the 14-bit divisor for generating the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor. register)
 *   clock_msb	(size 6, offset 0, init 0):	RW	Stores the 6-bit MSB divisor value
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_dlh_t omap44xx_uart3_dlh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dlh_t omap44xx_uart3_dlh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_uart3_dlh_t omap44xx_uart3_dlh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dlh_t omap44xx_uart3_dlh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_uart3_dlh_rawwr(__DN(t) *_dev, omap44xx_uart3_dlh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_dlh_rawwr(__DN(t) *_dev, omap44xx_uart3_dlh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void omap44xx_uart3_dlh_wr(__DN(t) *_dev, omap44xx_uart3_dlh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_dlh_wr(__DN(t) *_dev, omap44xx_uart3_dlh_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int omap44xx_uart3_dlh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_dlh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_dlh_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dlh (This register, with, stores the 14-bit divisor for generating the baud clock in the baud rate generator. DLH stores the most-significant part of the divisor. DLL stores the least-significant part of the divisor.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clock_msb =\t%" PRIx8 "\t(Stores the 6-bit MSB divisor value)\n", omap44xx_uart3_dlh_clock_msb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_dlh_clock_msb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_dlh_clock_msb_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_dlh_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_dlh_clock_msb_extract(_regval));
}

static inline void omap44xx_uart3_dlh_clock_msb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_dlh_clock_msb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_dlh_t _regval = 0x3f & (((omap44xx_uart3_dlh_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register ier: Interrupt enable register
 * Type: omap44xx_uart3.ier (Implicit type of Interrupt enable register register)
 *   rhr_it	(size 1, offset 0, init 0):	RW	
 *   thr_it	(size 1, offset 1, init 0):	RW	
 *   line_sts_it	(size 1, offset 2, init 0):	RW	
 *   modem_sts_it	(size 1, offset 3, init 0):	RW	
 *   sleep_mode	(size 1, offset 4, init 0):	RW	
 *   xoff_it	(size 1, offset 5, init 0):	RW	
 *   rts_it	(size 1, offset 6, init 0):	RW	
 *   cts_it	(size 1, offset 7, init 0):	RW	
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier_t omap44xx_uart3_ier_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_uart3_ier_rawwr(__DN(t) *_dev, omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_rawwr(__DN(t) *_dev, omap44xx_uart3_ier_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void omap44xx_uart3_ier_wr(__DN(t) *_dev, omap44xx_uart3_ier_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_wr(__DN(t) *_dev, omap44xx_uart3_ier_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int omap44xx_uart3_ier_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ier_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ier (Interrupt enable register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhr_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rhr_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_rhr_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thr_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_thr_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_thr_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " line_sts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_modem_sts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_line_sts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modem_sts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_modem_sts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_modem_sts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sleep_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sleep_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_sleep_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xoff_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xoff_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_xoff_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_rts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_ier_cts_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_rhr_it_status_t omap44xx_uart3_ier_rhr_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rhr_it_status_t omap44xx_uart3_ier_rhr_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_rhr_it_extract(_regval));
}

static inline omap44xx_uart3_thr_it_status_t omap44xx_uart3_ier_thr_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_thr_it_status_t omap44xx_uart3_ier_thr_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_thr_it_extract(_regval));
}

static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_line_sts_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_line_sts_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_line_sts_it_extract(_regval));
}

static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_modem_sts_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_ier_modem_sts_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_modem_sts_it_extract(_regval));
}

static inline omap44xx_uart3_sleep_mode_status_t omap44xx_uart3_ier_sleep_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sleep_mode_status_t omap44xx_uart3_ier_sleep_mode_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_sleep_mode_extract(_regval));
}

static inline omap44xx_uart3_xoff_it_status_t omap44xx_uart3_ier_xoff_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff_it_status_t omap44xx_uart3_ier_xoff_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_xoff_it_extract(_regval));
}

static inline omap44xx_uart3_rts_it_status_t omap44xx_uart3_ier_rts_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rts_it_status_t omap44xx_uart3_ier_rts_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_rts_it_extract(_regval));
}

static inline omap44xx_uart3_cts_it_status_t omap44xx_uart3_ier_cts_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_cts_it_status_t omap44xx_uart3_ier_cts_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_uart3_ier_cts_it_extract(_regval));
}

static inline void omap44xx_uart3_ier_rhr_it_wrf(__DN(t) *_dev, omap44xx_uart3_rhr_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_rhr_it_wrf(__DN(t) *_dev, omap44xx_uart3_rhr_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x1 & (((omap44xx_uart3_ier_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_thr_it_wrf(__DN(t) *_dev, omap44xx_uart3_thr_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_thr_it_wrf(__DN(t) *_dev, omap44xx_uart3_thr_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x2 & (((omap44xx_uart3_ier_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_line_sts_it_wrf(__DN(t) *_dev, omap44xx_uart3_modem_sts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_line_sts_it_wrf(__DN(t) *_dev, omap44xx_uart3_modem_sts_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x4 & (((omap44xx_uart3_ier_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_modem_sts_it_wrf(__DN(t) *_dev, omap44xx_uart3_modem_sts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_modem_sts_it_wrf(__DN(t) *_dev, omap44xx_uart3_modem_sts_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x8 & (((omap44xx_uart3_ier_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_sleep_mode_wrf(__DN(t) *_dev, omap44xx_uart3_sleep_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_sleep_mode_wrf(__DN(t) *_dev, omap44xx_uart3_sleep_mode_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x10 & (((omap44xx_uart3_ier_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_xoff_it_wrf(__DN(t) *_dev, omap44xx_uart3_xoff_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_xoff_it_wrf(__DN(t) *_dev, omap44xx_uart3_xoff_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x20 & (((omap44xx_uart3_ier_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_rts_it_wrf(__DN(t) *_dev, omap44xx_uart3_rts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_rts_it_wrf(__DN(t) *_dev, omap44xx_uart3_rts_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x40 & (((omap44xx_uart3_ier_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier_cts_it_wrf(__DN(t) *_dev, omap44xx_uart3_cts_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier_cts_it_wrf(__DN(t) *_dev, omap44xx_uart3_cts_it_status_t _fieldval)
{
    omap44xx_uart3_ier_t _regval = 0x80 & (((omap44xx_uart3_ier_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register efr: Enhanced feature register
 * Type: omap44xx_uart3.efr (Implicit type of Enhanced feature register register)
 *   sw_flow_control	(size 4, offset 0, init 0):	RW	Combinations of software flow control can be selected by programming bit 3 - bit 0. See.
 *   enhanced_en	(size 1, offset 4, init 0):	RW	Enhanced functions write enable bit
 *   special_char_detect	(size 1, offset 5, init 0):	RW	
 *   auto_rts_en	(size 1, offset 6, init 0):	RW	Auto-RTS enable bit
 *   auto_cts_en	(size 1, offset 7, init 0):	RW	Auto-CTS enable bit
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_efr_t omap44xx_uart3_efr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_uart3_efr_rawwr(__DN(t) *_dev, omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_rawwr(__DN(t) *_dev, omap44xx_uart3_efr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void omap44xx_uart3_efr_wr(__DN(t) *_dev, omap44xx_uart3_efr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_wr(__DN(t) *_dev, omap44xx_uart3_efr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int omap44xx_uart3_efr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_efr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_efr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register efr (Enhanced feature register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_flow_control =\t%" PRIx8 "\t(Combinations of software flow control can be selected by programming bit 3 - bit 0. See.)\n", omap44xx_uart3_efr_sw_flow_control_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enhanced_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_enhanced_en_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_enhanced_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enhanced functions write enable bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " special_char_detect =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_special_char_detect_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_special_char_detect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_rts_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_auto_rts_en_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_auto_rts_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto-RTS enable bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_cts_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_auto_cts_en_status_prtval(_s + _r, _avail, omap44xx_uart3_efr_auto_cts_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto-CTS enable bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_efr_sw_flow_control_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_efr_sw_flow_control_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_efr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_efr_sw_flow_control_extract(_regval));
}

static inline omap44xx_uart3_enhanced_en_status_t omap44xx_uart3_efr_enhanced_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_enhanced_en_status_t omap44xx_uart3_efr_enhanced_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_efr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_efr_enhanced_en_extract(_regval));
}

static inline omap44xx_uart3_special_char_detect_status_t omap44xx_uart3_efr_special_char_detect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_special_char_detect_status_t omap44xx_uart3_efr_special_char_detect_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_efr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_efr_special_char_detect_extract(_regval));
}

static inline omap44xx_uart3_auto_rts_en_status_t omap44xx_uart3_efr_auto_rts_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_auto_rts_en_status_t omap44xx_uart3_efr_auto_rts_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_efr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_efr_auto_rts_en_extract(_regval));
}

static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_efr_auto_cts_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_efr_auto_cts_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_efr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_efr_auto_cts_en_extract(_regval));
}

static inline void omap44xx_uart3_efr_sw_flow_control_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_sw_flow_control_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_efr_t _regval = 0xf & (((omap44xx_uart3_efr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_efr_enhanced_en_wrf(__DN(t) *_dev, omap44xx_uart3_enhanced_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_enhanced_en_wrf(__DN(t) *_dev, omap44xx_uart3_enhanced_en_status_t _fieldval)
{
    omap44xx_uart3_efr_t _regval = 0x10 & (((omap44xx_uart3_efr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_efr_special_char_detect_wrf(__DN(t) *_dev, omap44xx_uart3_special_char_detect_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_special_char_detect_wrf(__DN(t) *_dev, omap44xx_uart3_special_char_detect_status_t _fieldval)
{
    omap44xx_uart3_efr_t _regval = 0x20 & (((omap44xx_uart3_efr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_efr_auto_rts_en_wrf(__DN(t) *_dev, omap44xx_uart3_auto_rts_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_auto_rts_en_wrf(__DN(t) *_dev, omap44xx_uart3_auto_rts_en_status_t _fieldval)
{
    omap44xx_uart3_efr_t _regval = 0x40 & (((omap44xx_uart3_efr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_efr_auto_cts_en_wrf(__DN(t) *_dev, omap44xx_uart3_auto_cts_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_efr_auto_cts_en_wrf(__DN(t) *_dev, omap44xx_uart3_auto_cts_en_status_t _fieldval)
{
    omap44xx_uart3_efr_t _regval = 0x80 & (((omap44xx_uart3_efr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register fcr: FIFO control register
 * Type: omap44xx_uart3.fcr (Implicit type of FIFO control register register)
 *   fifo_en	(size 1, offset 0, init 0):	WO	
 *   rx_fifo_clear	(size 1, offset 1, init 0):	WO	
 *   tx_fifo_clear	(size 1, offset 2, init 0):	WO	
 *   dma_mode	(size 1, offset 3, init 0):	WO	This register is considered ifUART_SCR[0] = 0.
 *   tx_fifo_trig	(size 2, offset 4, init 0):	WO	Sets the trigger level for the TX FIFO: If UART_SCR[6] = 0 and UART_TLR[3:0] = 0000: 00: 8 spaces 01: 16 spaces 10: 32 spaces 11: 56 spaces If UART_SCR[6] = 0 and UART_TLR[3:0] != 0000, TX_FIFO_TRIG is not considered. If UART_SCR[6] = 1, TX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1
 *   rx_fifo_trig	(size 2, offset 6, init 0):	WO	Sets the trigger level for the RX FIFO: If UART_SCR[7] = 0 and UART_TLR[7:4] = 0000: 00: 8 characters 01: 16 characters 10: 56 characters 11: 60 characters If UART_SCR[7] = 0 and UART_TLR[7:4] != 0000, RX_FIFO_TRIG is not considered. If UART_SCR[7] = 1, RX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_fcr_t omap44xx_uart3_fcr_rd(__DN(t) *_dev)
{
    return(_dev->fcr_shadow);
}

static inline void omap44xx_uart3_fcr_rawwr(__DN(t) *_dev, omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_rawwr(__DN(t) *_dev, omap44xx_uart3_fcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void omap44xx_uart3_fcr_wr(__DN(t) *_dev, omap44xx_uart3_fcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_wr(__DN(t) *_dev, omap44xx_uart3_fcr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int omap44xx_uart3_fcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_fcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_fcr_t _regval = _dev->fcr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcr (FIFO control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fifo_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fifo_en_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_fifo_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_clear =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fifo_clear_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_rx_fifo_clear_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_clear =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_fifo_clear_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_tx_fifo_clear_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_fcr_dma_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This register is considered ifUART_SCR[0] = 0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_trig =\t%" PRIx8 "\t(Sets the trigger level for the TX FIFO: If UART_SCR[6] = 0 and UART_TLR[3:0] = 0000: 00: 8 spaces 01: 16 spaces 10: 32 spaces 11: 56 spaces If UART_SCR[6] = 0 and UART_TLR[3:0] != 0000, TX_FIFO_TRIG is not considered. If UART_SCR[6] = 1, TX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1)\n", omap44xx_uart3_fcr_tx_fifo_trig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig =\t%" PRIx8 "\t(Sets the trigger level for the RX FIFO: If UART_SCR[7] = 0 and UART_TLR[7:4] = 0000: 00: 8 characters 01: 16 characters 10: 56 characters 11: 60 characters If UART_SCR[7] = 0 and UART_TLR[7:4] != 0000, RX_FIFO_TRIG is not considered. If UART_SCR[7] = 1, RX_FIFO_TRIG is 2 LSBs of the trigger level (1-63 on 6 bits) with the granularity 1.)\n", omap44xx_uart3_fcr_rx_fifo_trig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_fcr_fifo_en_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_fcr_fifo_en_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_fcr_fifo_en_extract(_dev->fcr_shadow));
}

static inline omap44xx_uart3_rx_fifo_clear_status_t omap44xx_uart3_fcr_rx_fifo_clear_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fifo_clear_status_t omap44xx_uart3_fcr_rx_fifo_clear_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_fcr_rx_fifo_clear_extract(_dev->fcr_shadow));
}

static inline omap44xx_uart3_tx_fifo_clear_status_t omap44xx_uart3_fcr_tx_fifo_clear_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_fifo_clear_status_t omap44xx_uart3_fcr_tx_fifo_clear_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_fcr_tx_fifo_clear_extract(_dev->fcr_shadow));
}

static inline omap44xx_uart3_dma_mode_status_t omap44xx_uart3_fcr_dma_mode_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_mode_status_t omap44xx_uart3_fcr_dma_mode_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_fcr_dma_mode_extract(_dev->fcr_shadow));
}

static inline uint8_t omap44xx_uart3_fcr_tx_fifo_trig_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_fcr_tx_fifo_trig_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_fcr_tx_fifo_trig_extract(_dev->fcr_shadow));
}

static inline uint8_t omap44xx_uart3_fcr_rx_fifo_trig_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_fcr_rx_fifo_trig_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_fcr_rx_fifo_trig_extract(_dev->fcr_shadow));
}

static inline void omap44xx_uart3_fcr_fifo_en_wrf(__DN(t) *_dev, omap44xx_uart3_fifo_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_fifo_en_wrf(__DN(t) *_dev, omap44xx_uart3_fifo_en_status_t _fieldval)
{
    omap44xx_uart3_fcr_t _regval = 0x1 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 0);
    // No pre-read of register required
    _regval = (_regval | (0xfe & (_dev->fcr_shadow)));
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void omap44xx_uart3_fcr_rx_fifo_clear_wrf(__DN(t) *_dev, omap44xx_uart3_rx_fifo_clear_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_rx_fifo_clear_wrf(__DN(t) *_dev, omap44xx_uart3_rx_fifo_clear_status_t _fieldval)
{
    omap44xx_uart3_fcr_t _regval = 0x2 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 1);
    // No pre-read of register required
    _regval = (_regval | (0xfd & (_dev->fcr_shadow)));
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void omap44xx_uart3_fcr_tx_fifo_clear_wrf(__DN(t) *_dev, omap44xx_uart3_tx_fifo_clear_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_tx_fifo_clear_wrf(__DN(t) *_dev, omap44xx_uart3_tx_fifo_clear_status_t _fieldval)
{
    omap44xx_uart3_fcr_t _regval = 0x4 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 2);
    // No pre-read of register required
    _regval = (_regval | (0xfb & (_dev->fcr_shadow)));
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void omap44xx_uart3_fcr_dma_mode_wrf(__DN(t) *_dev, omap44xx_uart3_dma_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_dma_mode_wrf(__DN(t) *_dev, omap44xx_uart3_dma_mode_status_t _fieldval)
{
    omap44xx_uart3_fcr_t _regval = 0x8 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 3);
    // No pre-read of register required
    _regval = (_regval | (0xf7 & (_dev->fcr_shadow)));
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void omap44xx_uart3_fcr_tx_fifo_trig_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_tx_fifo_trig_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_fcr_t _regval = 0x30 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 4);
    // No pre-read of register required
    _regval = (_regval | (0xcf & (_dev->fcr_shadow)));
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void omap44xx_uart3_fcr_rx_fifo_trig_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_fcr_rx_fifo_trig_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_fcr_t _regval = 0xc0 & (((omap44xx_uart3_fcr_t )(_fieldval)) << 6);
    // No pre-read of register required
    _regval = (_regval | (0x3f & (_dev->fcr_shadow)));
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    _dev->fcr_shadow = _regval;
}

/*
 * Register iir: Interrupt identification register.
 * Type: omap44xx_uart3.iir (Implicit type of Interrupt identification register. register)
 *   it_pending	(size 1, offset 0, init 0):	RO	Read 0x0: An interrupt is pending.
 *   it_type	(size 5, offset 1, init 0):	RO	Read 0x0: Modem interrupt. Priority = 4
 *   fcr_mirror	(size 2, offset 6, init 0):	RO	Mirror the contents ofUART_FCR[0] on both bits.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_iir_t omap44xx_uart3_iir_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_uart3_iir_rawwr(__DN(t) *_dev, omap44xx_uart3_iir_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_iir_rawwr(__DN(t) *_dev, omap44xx_uart3_iir_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

// Register iir is not writeable
static inline int omap44xx_uart3_iir_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_iir_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_iir_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register iir (Interrupt identification register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " it_pending =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_it_pending_status_prtval(_s + _r, _avail, omap44xx_uart3_iir_it_pending_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: An interrupt is pending.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " it_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_it_type_status_prtval(_s + _r, _avail, omap44xx_uart3_iir_it_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Modem interrupt. Priority = 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcr_mirror =\t%" PRIx8 "\t(Mirror the contents ofUART_FCR[0] on both bits.)\n", omap44xx_uart3_iir_fcr_mirror_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_it_pending_status_t omap44xx_uart3_iir_it_pending_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_it_pending_status_t omap44xx_uart3_iir_it_pending_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_iir_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_iir_it_pending_extract(_regval));
}

static inline omap44xx_uart3_it_type_status_t omap44xx_uart3_iir_it_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_it_type_status_t omap44xx_uart3_iir_it_type_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_iir_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_iir_it_type_extract(_regval));
}

static inline uint8_t omap44xx_uart3_iir_fcr_mirror_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_iir_fcr_mirror_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_iir_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_uart3_iir_fcr_mirror_extract(_regval));
}

/*
 * Register lcr: Line control register
 * Type: omap44xx_uart3.lcr (Implicit type of Line control register register)
 *   char_length	(size 2, offset 0, init 0):	RW	Specifies the word length to be transmitted or received
 *   nb_stop	(size 1, offset 2, init 0):	RW	Specifies the number of stop-bits
 *   parity_en	(size 1, offset 3, init 0):	RW	0x0: No parity
 *   parity_type1	(size 1, offset 4, init 0):	RW	
 *   parity_type2	(size 1, offset 5, init 0):	RW	Selects the forced parity format (ifUART_LCR[3] = 1). If UART_LCR[5] = 1 and UART_LCR[4] = 0, the parity bit is forced to 1 in the transmitted and received data. If UART_LCR[5] = 1 and UART_LCR[4] = 1, the parity bit is forced to 0 in the transmitted and received data.
 *   break_en	(size 1, offset 6, init 0):	RW	Break control bit
 *   div_en	(size 1, offset 7, init 0):	RW	
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_lcr_t omap44xx_uart3_lcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void omap44xx_uart3_lcr_rawwr(__DN(t) *_dev, omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_rawwr(__DN(t) *_dev, omap44xx_uart3_lcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void omap44xx_uart3_lcr_wr(__DN(t) *_dev, omap44xx_uart3_lcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_wr(__DN(t) *_dev, omap44xx_uart3_lcr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int omap44xx_uart3_lcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_lcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lcr (Line control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " char_length =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_char_length_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_char_length_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Specifies the word length to be transmitted or received)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nb_stop =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_nb_stop_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_nb_stop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Specifies the number of stop-bits)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_parity_en_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_parity_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: No parity)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_type1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_parity_type1_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_parity_type1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_type2 =\t%" PRIx8 "\t(Selects the forced parity format (ifUART_LCR[3] = 1). If UART_LCR[5] = 1 and UART_LCR[4] = 0, the parity bit is forced to 1 in the transmitted and received data. If UART_LCR[5] = 1 and UART_LCR[4] = 1, the parity bit is forced to 0 in the transmitted and received data.)\n", omap44xx_uart3_lcr_parity_type2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " break_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_break_en_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_break_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Break control bit)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " div_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_div_en_status_prtval(_s + _r, _avail, omap44xx_uart3_lcr_div_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_char_length_status_t omap44xx_uart3_lcr_char_length_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_char_length_status_t omap44xx_uart3_lcr_char_length_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_char_length_extract(_regval));
}

static inline omap44xx_uart3_nb_stop_status_t omap44xx_uart3_lcr_nb_stop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_nb_stop_status_t omap44xx_uart3_lcr_nb_stop_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_nb_stop_extract(_regval));
}

static inline omap44xx_uart3_parity_en_status_t omap44xx_uart3_lcr_parity_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_parity_en_status_t omap44xx_uart3_lcr_parity_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_parity_en_extract(_regval));
}

static inline omap44xx_uart3_parity_type1_status_t omap44xx_uart3_lcr_parity_type1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_parity_type1_status_t omap44xx_uart3_lcr_parity_type1_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_parity_type1_extract(_regval));
}

static inline uint8_t omap44xx_uart3_lcr_parity_type2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_lcr_parity_type2_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_parity_type2_extract(_regval));
}

static inline omap44xx_uart3_break_en_status_t omap44xx_uart3_lcr_break_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_break_en_status_t omap44xx_uart3_lcr_break_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_break_en_extract(_regval));
}

static inline omap44xx_uart3_div_en_status_t omap44xx_uart3_lcr_div_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_div_en_status_t omap44xx_uart3_lcr_div_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lcr_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(omap44xx_uart3_lcr_div_en_extract(_regval));
}

static inline void omap44xx_uart3_lcr_char_length_wrf(__DN(t) *_dev, omap44xx_uart3_char_length_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_char_length_wrf(__DN(t) *_dev, omap44xx_uart3_char_length_status_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x3 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfc & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_lcr_nb_stop_wrf(__DN(t) *_dev, omap44xx_uart3_nb_stop_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_nb_stop_wrf(__DN(t) *_dev, omap44xx_uart3_nb_stop_status_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x4 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_lcr_parity_en_wrf(__DN(t) *_dev, omap44xx_uart3_parity_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_parity_en_wrf(__DN(t) *_dev, omap44xx_uart3_parity_en_status_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x8 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_lcr_parity_type1_wrf(__DN(t) *_dev, omap44xx_uart3_parity_type1_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_parity_type1_wrf(__DN(t) *_dev, omap44xx_uart3_parity_type1_status_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x10 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_lcr_parity_type2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_parity_type2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x20 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_lcr_break_en_wrf(__DN(t) *_dev, omap44xx_uart3_break_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_break_en_wrf(__DN(t) *_dev, omap44xx_uart3_break_en_status_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x40 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_lcr_div_en_wrf(__DN(t) *_dev, omap44xx_uart3_div_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lcr_div_en_wrf(__DN(t) *_dev, omap44xx_uart3_div_en_status_t _fieldval)
{
    omap44xx_uart3_lcr_t _regval = 0x80 & (((omap44xx_uart3_lcr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register mcr: Modem control register
 * Type: omap44xx_uart3.mcr (Implicit type of Modem control register register)
 *   dtr	(size 1, offset 0, init 0):	RW	0x0: Force DTR* output to inactive (high).
 *   rts	(size 1, offset 1, init 0):	RW	In loopback, controls theUART_MSR[4] bit. If auto-RTS is enabled, the RTS* output is controlled by hardware flow control.
 *   ri_sts_ch	(size 1, offset 2, init 0):	RW	0x0: In loopback, forces RI* input high
 *   cd_sts_ch	(size 1, offset 3, init 0):	RW	0x0: In loopback, forces DCD* input high and IRQ outputs to inactive state
 *   loopback_en	(size 1, offset 4, init 0):	RW	0x0: Normal operating mode
 *   xon_en	(size 1, offset 5, init 0):	RW	0x0: Disable XON any function.
 *   tcr_tlr	(size 1, offset 6, init 0):	RW	0x0: No action
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mcr_t omap44xx_uart3_mcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_uart3_mcr_rawwr(__DN(t) *_dev, omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_rawwr(__DN(t) *_dev, omap44xx_uart3_mcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_uart3_mcr_wr(__DN(t) *_dev, omap44xx_uart3_mcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_wr(__DN(t) *_dev, omap44xx_uart3_mcr_t _regval)
{
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_uart3_mcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mcr (Modem control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dtr_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_dtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Force DTR* output to inactive (high).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rts_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_rts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(In loopback, controls theUART_MSR[4] bit. If auto-RTS is enabled, the RTS* output is controlled by hardware flow control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri_sts_ch =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ri_sts_ch_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_ri_sts_ch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: In loopback, forces RI* input high)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cd_sts_ch =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cd_sts_ch_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_cd_sts_ch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: In loopback, forces DCD* input high and IRQ outputs to inactive state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loopback_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_loopback_en_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_loopback_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Normal operating mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xon_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xon_en_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_xon_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disable XON any function.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcr_tlr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tcr_tlr_status_prtval(_s + _r, _avail, omap44xx_uart3_mcr_tcr_tlr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: No action)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_dtr_status_t omap44xx_uart3_mcr_dtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dtr_status_t omap44xx_uart3_mcr_dtr_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_dtr_extract(_regval));
}

static inline omap44xx_uart3_rts_status_t omap44xx_uart3_mcr_rts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rts_status_t omap44xx_uart3_mcr_rts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_rts_extract(_regval));
}

static inline omap44xx_uart3_ri_sts_ch_status_t omap44xx_uart3_mcr_ri_sts_ch_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ri_sts_ch_status_t omap44xx_uart3_mcr_ri_sts_ch_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_ri_sts_ch_extract(_regval));
}

static inline omap44xx_uart3_cd_sts_ch_status_t omap44xx_uart3_mcr_cd_sts_ch_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_cd_sts_ch_status_t omap44xx_uart3_mcr_cd_sts_ch_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_cd_sts_ch_extract(_regval));
}

static inline omap44xx_uart3_loopback_en_status_t omap44xx_uart3_mcr_loopback_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_loopback_en_status_t omap44xx_uart3_mcr_loopback_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_loopback_en_extract(_regval));
}

static inline omap44xx_uart3_xon_en_status_t omap44xx_uart3_mcr_xon_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon_en_status_t omap44xx_uart3_mcr_xon_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_xon_en_extract(_regval));
}

static inline omap44xx_uart3_tcr_tlr_status_t omap44xx_uart3_mcr_tcr_tlr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tcr_tlr_status_t omap44xx_uart3_mcr_tcr_tlr_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mcr_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_mcr_tcr_tlr_extract(_regval));
}

static inline void omap44xx_uart3_mcr_dtr_wrf(__DN(t) *_dev, omap44xx_uart3_dtr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_dtr_wrf(__DN(t) *_dev, omap44xx_uart3_dtr_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x1 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7e & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mcr_rts_wrf(__DN(t) *_dev, omap44xx_uart3_rts_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_rts_wrf(__DN(t) *_dev, omap44xx_uart3_rts_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x2 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x7d & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mcr_ri_sts_ch_wrf(__DN(t) *_dev, omap44xx_uart3_ri_sts_ch_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_ri_sts_ch_wrf(__DN(t) *_dev, omap44xx_uart3_ri_sts_ch_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x4 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0x7b & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mcr_cd_sts_ch_wrf(__DN(t) *_dev, omap44xx_uart3_cd_sts_ch_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_cd_sts_ch_wrf(__DN(t) *_dev, omap44xx_uart3_cd_sts_ch_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x8 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x77 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mcr_loopback_en_wrf(__DN(t) *_dev, omap44xx_uart3_loopback_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_loopback_en_wrf(__DN(t) *_dev, omap44xx_uart3_loopback_en_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x10 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0x6f & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mcr_xon_en_wrf(__DN(t) *_dev, omap44xx_uart3_xon_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_xon_en_wrf(__DN(t) *_dev, omap44xx_uart3_xon_en_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x20 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0x5f & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mcr_tcr_tlr_wrf(__DN(t) *_dev, omap44xx_uart3_tcr_tlr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mcr_tcr_tlr_wrf(__DN(t) *_dev, omap44xx_uart3_tcr_tlr_status_t _fieldval)
{
    omap44xx_uart3_mcr_t _regval = 0x40 & (((omap44xx_uart3_mcr_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3f & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register xon1_addr1: UART mode: XON1 character, IrDA mode: ADDR1 address
 * Type: omap44xx_uart3.xon1_addr1 (Implicit type of UART mode: XON1 character, IrDA mode: ADDR1 address register)
 *   xon_word1	(size 8, offset 0, init 0):	RW	Stores the 8-bit XON1 character in UART modes and ADDR1 address 1 for IrDA modes
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_xon1_addr1_t omap44xx_uart3_xon1_addr1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon1_addr1_t omap44xx_uart3_xon1_addr1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_uart3_xon1_addr1_t omap44xx_uart3_xon1_addr1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon1_addr1_t omap44xx_uart3_xon1_addr1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_uart3_xon1_addr1_rawwr(__DN(t) *_dev, omap44xx_uart3_xon1_addr1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xon1_addr1_rawwr(__DN(t) *_dev, omap44xx_uart3_xon1_addr1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_uart3_xon1_addr1_wr(__DN(t) *_dev, omap44xx_uart3_xon1_addr1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xon1_addr1_wr(__DN(t) *_dev, omap44xx_uart3_xon1_addr1_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_uart3_xon1_addr1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xon1_addr1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_xon1_addr1_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xon1_addr1 (UART mode: XON1 character, IrDA mode: ADDR1 address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xon_word1 =\t%" PRIx8 "\t(Stores the 8-bit XON1 character in UART modes and ADDR1 address 1 for IrDA modes)\n", omap44xx_uart3_xon1_addr1_xon_word1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_xon1_addr1_xon_word1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xon1_addr1_xon_word1_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_xon1_addr1_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_uart3_xon1_addr1_xon_word1_extract(_regval));
}

static inline void omap44xx_uart3_xon1_addr1_xon_word1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xon1_addr1_xon_word1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_xon1_addr1_t _regval = 0xff & (((omap44xx_uart3_xon1_addr1_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register lsr: Line status register
 * Type: omap44xx_uart3.lsr (Implicit type of Line status register register)
 *   rx_fifo_e	(size 1, offset 0, init 0):	RO	Read 0x0: No data in the RX FIFO
 *   rx_oe	(size 1, offset 1, init 0):	RO	Read 0x0: No overrun error
 *   rx_pe	(size 1, offset 2, init 0):	RO	Read 0x0: No parity error in data from RX FIFO
 *   rx_fe	(size 1, offset 3, init 0):	RO	Read 0x0: No framing error in data RX FIFO
 *   rx_bi	(size 1, offset 4, init 0):	RO	Read 0x0: No break condition
 *   tx_fifo_e	(size 1, offset 5, init 0):	RO	Read 0x0: Transmit hold register (TX FIFO) is not empty.
 *   tx_sr_e	(size 1, offset 6, init 0):	RO	Read 0x0: Transmitter hold (TX FIFO) and shift registers are not empty.
 *   rx_fifo_sts	(size 1, offset 7, init 0):	RO	Read 0x0: Normal operation
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_lsr_t omap44xx_uart3_lsr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_uart3_lsr_rawwr(__DN(t) *_dev, omap44xx_uart3_lsr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_lsr_rawwr(__DN(t) *_dev, omap44xx_uart3_lsr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

// Register lsr is not writeable
static inline int omap44xx_uart3_lsr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_lsr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lsr (Line status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_e =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_fifo_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No data in the RX FIFO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_oe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_oe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No overrun error)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_pe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_pe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No parity error in data from RX FIFO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fe_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No framing error in data RX FIFO)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_bi =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_bi_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_bi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No break condition)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_e =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_sr_e_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_tx_fifo_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Transmit hold register (TX FIFO) is not empty.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_sr_e =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_sr_e_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_tx_sr_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Transmitter hold (TX FIFO) and shift registers are not empty.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_fifo_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_lsr_rx_fifo_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: Normal operation)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fifo_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fifo_e_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_rx_fifo_e_extract(_regval));
}

static inline omap44xx_uart3_rx_oe_status_t omap44xx_uart3_lsr_rx_oe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_oe_status_t omap44xx_uart3_lsr_rx_oe_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_rx_oe_extract(_regval));
}

static inline omap44xx_uart3_rx_pe_status_t omap44xx_uart3_lsr_rx_pe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_pe_status_t omap44xx_uart3_lsr_rx_pe_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_rx_pe_extract(_regval));
}

static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fe_status_t omap44xx_uart3_lsr_rx_fe_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_rx_fe_extract(_regval));
}

static inline omap44xx_uart3_rx_bi_status_t omap44xx_uart3_lsr_rx_bi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_bi_status_t omap44xx_uart3_lsr_rx_bi_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_rx_bi_extract(_regval));
}

static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_fifo_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_fifo_e_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_tx_fifo_e_extract(_regval));
}

static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_sr_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_sr_e_status_t omap44xx_uart3_lsr_tx_sr_e_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_tx_sr_e_extract(_regval));
}

static inline omap44xx_uart3_rx_fifo_sts_status_t omap44xx_uart3_lsr_rx_fifo_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_fifo_sts_status_t omap44xx_uart3_lsr_rx_fifo_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_lsr_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_lsr_rx_fifo_sts_extract(_regval));
}

/*
 * Register xon2_addr2: Stores the 8-bit XON2 character in UART moldes and ADDR2 address 2 for IrDA modes
 * Type: omap44xx_uart3.xon2_addr2 (Implicit type of Stores the 8-bit XON2 character in UART moldes and ADDR2 address 2 for IrDA modes register)
 *   xon_word2	(size 8, offset 0, init 0):	RW	Stores the 8-bit XON2 character in UART modes and ADDR2 address 2 for IrDA modes
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_xon2_addr2_t omap44xx_uart3_xon2_addr2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon2_addr2_t omap44xx_uart3_xon2_addr2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_uart3_xon2_addr2_t omap44xx_uart3_xon2_addr2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xon2_addr2_t omap44xx_uart3_xon2_addr2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_uart3_xon2_addr2_rawwr(__DN(t) *_dev, omap44xx_uart3_xon2_addr2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xon2_addr2_rawwr(__DN(t) *_dev, omap44xx_uart3_xon2_addr2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void omap44xx_uart3_xon2_addr2_wr(__DN(t) *_dev, omap44xx_uart3_xon2_addr2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xon2_addr2_wr(__DN(t) *_dev, omap44xx_uart3_xon2_addr2_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int omap44xx_uart3_xon2_addr2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xon2_addr2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_xon2_addr2_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xon2_addr2 (Stores the 8-bit XON2 character in UART moldes and ADDR2 address 2 for IrDA modes): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xon_word2 =\t%" PRIx8 "\t(Stores the 8-bit XON2 character in UART modes and ADDR2 address 2 for IrDA modes)\n", omap44xx_uart3_xon2_addr2_xon_word2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_xon2_addr2_xon_word2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xon2_addr2_xon_word2_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_xon2_addr2_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_uart3_xon2_addr2_xon_word2_extract(_regval));
}

static inline void omap44xx_uart3_xon2_addr2_xon_word2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xon2_addr2_xon_word2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_xon2_addr2_t _regval = 0xff & (((omap44xx_uart3_xon2_addr2_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register msr: Modem status register. UART mode only.
 * Type: omap44xx_uart3.msr (Implicit type of Modem status register. UART mode only. register)
 *   cts_sts	(size 1, offset 0, init 0):	RO	
 *   dsr_sts	(size 1, offset 1, init 0):	RO	
 *   ri_sts	(size 1, offset 2, init 0):	RO	Indicates that RI* input (orUART_MCR[2] in loopback) changed state from low to high. Cleared on a read.
 *   dcd_sts	(size 1, offset 3, init 0):	RO	Indicates that DCD* input (orUART_MCR[3] in loopback) changed. Cleared on a read.
 *   ncts_sts	(size 1, offset 4, init 0):	RO	This bit is the complement of the CTS* input. In loopback mode, it is equivalent toUART_MCR[1].
 *   ndsr_sts	(size 1, offset 5, init 0):	RO	This bit is the complement of the DSR* input. In loopback mode, it is equivalent toUART_MCR[0].
 *   nri_sts	(size 1, offset 6, init 0):	RO	This bit is the complement of the RI* input. In loopback mode, it is equivalent toUART_MCR[2].
 *   ncd_sts	(size 1, offset 7, init 0):	RO	This bit is the complement of the DCD* input. In loopback mode, it is equivalent toUART_MCR[3].
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_msr_t omap44xx_uart3_msr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void omap44xx_uart3_msr_rawwr(__DN(t) *_dev, omap44xx_uart3_msr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_msr_rawwr(__DN(t) *_dev, omap44xx_uart3_msr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

// Register msr is not writeable
static inline int omap44xx_uart3_msr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_msr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register msr (Modem status register. UART mode only.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_auto_cts_en_status_prtval(_s + _r, _avail, omap44xx_uart3_msr_cts_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dsr_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_msr_dsr_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri_sts =\t%" PRIx8 "\t(Indicates that RI* input (orUART_MCR[2] in loopback) changed state from low to high. Cleared on a read.)\n", omap44xx_uart3_msr_ri_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcd_sts =\t%" PRIx8 "\t(Indicates that DCD* input (orUART_MCR[3] in loopback) changed. Cleared on a read.)\n", omap44xx_uart3_msr_dcd_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ncts_sts =\t%" PRIx8 "\t(This bit is the complement of the CTS* input. In loopback mode, it is equivalent toUART_MCR[1].)\n", omap44xx_uart3_msr_ncts_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ndsr_sts =\t%" PRIx8 "\t(This bit is the complement of the DSR* input. In loopback mode, it is equivalent toUART_MCR[0].)\n", omap44xx_uart3_msr_ndsr_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nri_sts =\t%" PRIx8 "\t(This bit is the complement of the RI* input. In loopback mode, it is equivalent toUART_MCR[2].)\n", omap44xx_uart3_msr_nri_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ncd_sts =\t%" PRIx8 "\t(This bit is the complement of the DCD* input. In loopback mode, it is equivalent toUART_MCR[3].)\n", omap44xx_uart3_msr_ncd_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_msr_cts_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_auto_cts_en_status_t omap44xx_uart3_msr_cts_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_cts_sts_extract(_regval));
}

static inline omap44xx_uart3_dsr_sts_status_t omap44xx_uart3_msr_dsr_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dsr_sts_status_t omap44xx_uart3_msr_dsr_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_dsr_sts_extract(_regval));
}

static inline uint8_t omap44xx_uart3_msr_ri_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ri_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_ri_sts_extract(_regval));
}

static inline uint8_t omap44xx_uart3_msr_dcd_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_dcd_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_dcd_sts_extract(_regval));
}

static inline uint8_t omap44xx_uart3_msr_ncts_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ncts_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_ncts_sts_extract(_regval));
}

static inline uint8_t omap44xx_uart3_msr_ndsr_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ndsr_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_ndsr_sts_extract(_regval));
}

static inline uint8_t omap44xx_uart3_msr_nri_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_nri_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_nri_sts_extract(_regval));
}

static inline uint8_t omap44xx_uart3_msr_ncd_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_msr_ncd_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_msr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_msr_ncd_sts_extract(_regval));
}

/*
 * Register tcr: Transmission control register
 * Type: omap44xx_uart3.tcr (Implicit type of Transmission control register register)
 *   rx_fifo_trig_halt	(size 4, offset 0, init 0):	RW	RX FIFO trigger level to HALT transmission (0 - 60)
 *   rx_fifo_trig_start	(size 4, offset 4, init 0):	RW	RX FIFO trigger level to RESTORE transmission (0 - 60)
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tcr_t omap44xx_uart3_tcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void omap44xx_uart3_tcr_rawwr(__DN(t) *_dev, omap44xx_uart3_tcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tcr_rawwr(__DN(t) *_dev, omap44xx_uart3_tcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void omap44xx_uart3_tcr_wr(__DN(t) *_dev, omap44xx_uart3_tcr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tcr_wr(__DN(t) *_dev, omap44xx_uart3_tcr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int omap44xx_uart3_tcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_tcr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tcr (Transmission control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig_halt =\t%" PRIx8 "\t(RX FIFO trigger level to HALT transmission (0 - 60))\n", omap44xx_uart3_tcr_rx_fifo_trig_halt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig_start =\t%" PRIx8 "\t(RX FIFO trigger level to RESTORE transmission (0 - 60))\n", omap44xx_uart3_tcr_rx_fifo_trig_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_halt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_halt_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_tcr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_tcr_rx_fifo_trig_halt_extract(_regval));
}

static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tcr_rx_fifo_trig_start_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_tcr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_tcr_rx_fifo_trig_start_extract(_regval));
}

static inline void omap44xx_uart3_tcr_rx_fifo_trig_halt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tcr_rx_fifo_trig_halt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_tcr_t _regval = 0xf & (((omap44xx_uart3_tcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_tcr_rx_fifo_trig_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tcr_rx_fifo_trig_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_tcr_t _regval = 0xf0 & (((omap44xx_uart3_tcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register xoff1: UART mode XOFF1 character
 * Type: omap44xx_uart3.xoff1 (Implicit type of UART mode XOFF1 character register)
 *   xoff_word1	(size 8, offset 0, init 0):	RW	Stores the 8-bit XOFF1 character used in UART modes
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_xoff1_t omap44xx_uart3_xoff1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff1_t omap44xx_uart3_xoff1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline omap44xx_uart3_xoff1_t omap44xx_uart3_xoff1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff1_t omap44xx_uart3_xoff1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void omap44xx_uart3_xoff1_rawwr(__DN(t) *_dev, omap44xx_uart3_xoff1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xoff1_rawwr(__DN(t) *_dev, omap44xx_uart3_xoff1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void omap44xx_uart3_xoff1_wr(__DN(t) *_dev, omap44xx_uart3_xoff1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xoff1_wr(__DN(t) *_dev, omap44xx_uart3_xoff1_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int omap44xx_uart3_xoff1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xoff1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_xoff1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xoff1 (UART mode XOFF1 character): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xoff_word1 =\t%" PRIx8 "\t(Stores the 8-bit XOFF1 character used in UART modes)\n", omap44xx_uart3_xoff1_xoff_word1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_xoff1_xoff_word1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xoff1_xoff_word1_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_xoff1_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_uart3_xoff1_xoff_word1_extract(_regval));
}

static inline void omap44xx_uart3_xoff1_xoff_word1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xoff1_xoff_word1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_xoff1_t _regval = 0xff & (((omap44xx_uart3_xoff1_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register spr: Scratchpad register
 * Type: omap44xx_uart3.spr (Implicit type of Scratchpad register register)
 *   spr_word	(size 8, offset 0, init 0):	RW	Scratchpad register
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_spr_t omap44xx_uart3_spr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_spr_t omap44xx_uart3_spr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline omap44xx_uart3_spr_t omap44xx_uart3_spr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_spr_t omap44xx_uart3_spr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void omap44xx_uart3_spr_rawwr(__DN(t) *_dev, omap44xx_uart3_spr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_spr_rawwr(__DN(t) *_dev, omap44xx_uart3_spr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void omap44xx_uart3_spr_wr(__DN(t) *_dev, omap44xx_uart3_spr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_spr_wr(__DN(t) *_dev, omap44xx_uart3_spr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int omap44xx_uart3_spr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_spr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_spr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register spr (Scratchpad register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spr_word =\t%" PRIx8 "\t(Scratchpad register)\n", omap44xx_uart3_spr_spr_word_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_spr_spr_word_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_spr_spr_word_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_spr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_uart3_spr_spr_word_extract(_regval));
}

static inline void omap44xx_uart3_spr_spr_word_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_spr_spr_word_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_spr_t _regval = 0xff & (((omap44xx_uart3_spr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register tlr: Trigger level register
 * Type: omap44xx_uart3.tlr (Implicit type of Trigger level register register)
 *   tx_fifo_trig_dma	(size 4, offset 0, init 0):	RW	Transmit FIFO trigger level
 *   rx_fifo_trig_dma	(size 4, offset 4, init 0):	RW	Receive FIFO trigger level
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tlr_t omap44xx_uart3_tlr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void omap44xx_uart3_tlr_rawwr(__DN(t) *_dev, omap44xx_uart3_tlr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tlr_rawwr(__DN(t) *_dev, omap44xx_uart3_tlr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void omap44xx_uart3_tlr_wr(__DN(t) *_dev, omap44xx_uart3_tlr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tlr_wr(__DN(t) *_dev, omap44xx_uart3_tlr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int omap44xx_uart3_tlr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tlr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_tlr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tlr (Trigger level register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_trig_dma =\t%" PRIx8 "\t(Transmit FIFO trigger level)\n", omap44xx_uart3_tlr_tx_fifo_trig_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifo_trig_dma =\t%" PRIx8 "\t(Receive FIFO trigger level)\n", omap44xx_uart3_tlr_rx_fifo_trig_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_tlr_tx_fifo_trig_dma_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tlr_tx_fifo_trig_dma_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_tlr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_uart3_tlr_tx_fifo_trig_dma_extract(_regval));
}

static inline uint8_t omap44xx_uart3_tlr_rx_fifo_trig_dma_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tlr_rx_fifo_trig_dma_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_tlr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_uart3_tlr_rx_fifo_trig_dma_extract(_regval));
}

static inline void omap44xx_uart3_tlr_tx_fifo_trig_dma_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tlr_tx_fifo_trig_dma_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_tlr_t _regval = 0xf & (((omap44xx_uart3_tlr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_tlr_rx_fifo_trig_dma_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tlr_rx_fifo_trig_dma_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_tlr_t _regval = 0xf0 & (((omap44xx_uart3_tlr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register xoff2: UART mode XOFF2 character
 * Type: omap44xx_uart3.xoff2 (Implicit type of UART mode XOFF2 character register)
 *   xoff_word2	(size 8, offset 0, init 0):	RW	Stores the 8-bit XOFF2 character used in UART modes.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_xoff2_t omap44xx_uart3_xoff2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff2_t omap44xx_uart3_xoff2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline omap44xx_uart3_xoff2_t omap44xx_uart3_xoff2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xoff2_t omap44xx_uart3_xoff2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void omap44xx_uart3_xoff2_rawwr(__DN(t) *_dev, omap44xx_uart3_xoff2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xoff2_rawwr(__DN(t) *_dev, omap44xx_uart3_xoff2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void omap44xx_uart3_xoff2_wr(__DN(t) *_dev, omap44xx_uart3_xoff2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xoff2_wr(__DN(t) *_dev, omap44xx_uart3_xoff2_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int omap44xx_uart3_xoff2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_xoff2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_xoff2_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xoff2 (UART mode XOFF2 character): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xoff_word2 =\t%" PRIx8 "\t(Stores the 8-bit XOFF2 character used in UART modes.)\n", omap44xx_uart3_xoff2_xoff_word2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_xoff2_xoff_word2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_xoff2_xoff_word2_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_xoff2_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_uart3_xoff2_xoff_word2_extract(_regval));
}

static inline void omap44xx_uart3_xoff2_xoff_word2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_xoff2_xoff_word2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_xoff2_t _regval = 0xff & (((omap44xx_uart3_xoff2_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register mdr1: Mode definition register 1
 * Type: omap44xx_uart3.mdr1 (Implicit type of Mode definition register 1 register)
 *   mode_select	(size 3, offset 0, init 0):	RW	0x0: UART 16x mode
 *   ir_sleep	(size 1, offset 3, init 0):	RW	0x0: IrDA/CIR sleep mode disabled
 *   set_txir	(size 1, offset 4, init 0):	RW	Used to configure the infrared transceiver
 *   sct	(size 1, offset 5, init 0):	RW	Store and control the transmission.
 *   sip_mode	(size 1, offset 6, init 0):	RW	MIR/FIR modes only
 *   frame_end_mode	(size 1, offset 7, init 0):	RW	IrDA mode only
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr1_t omap44xx_uart3_mdr1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void omap44xx_uart3_mdr1_rawwr(__DN(t) *_dev, omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_rawwr(__DN(t) *_dev, omap44xx_uart3_mdr1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void omap44xx_uart3_mdr1_wr(__DN(t) *_dev, omap44xx_uart3_mdr1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_wr(__DN(t) *_dev, omap44xx_uart3_mdr1_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int omap44xx_uart3_mdr1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mdr1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mdr1 (Mode definition register 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mode_select =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mode_select_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_mode_select_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: UART 16x mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ir_sleep =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ir_sleep_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_ir_sleep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: IrDA/CIR sleep mode disabled)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set_txir =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_set_txir_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_set_txir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to configure the infrared transceiver)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sct =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sct_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_sct_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Store and control the transmission.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sip_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sip_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_sip_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MIR/FIR modes only)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frame_end_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_frame_end_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr1_frame_end_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IrDA mode only)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_mode_select_status_t omap44xx_uart3_mdr1_mode_select_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mode_select_status_t omap44xx_uart3_mdr1_mode_select_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_uart3_mdr1_mode_select_extract(_regval));
}

static inline omap44xx_uart3_ir_sleep_status_t omap44xx_uart3_mdr1_ir_sleep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ir_sleep_status_t omap44xx_uart3_mdr1_ir_sleep_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_uart3_mdr1_ir_sleep_extract(_regval));
}

static inline omap44xx_uart3_set_txir_status_t omap44xx_uart3_mdr1_set_txir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_set_txir_status_t omap44xx_uart3_mdr1_set_txir_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_uart3_mdr1_set_txir_extract(_regval));
}

static inline omap44xx_uart3_sct_status_t omap44xx_uart3_mdr1_sct_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sct_status_t omap44xx_uart3_mdr1_sct_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_uart3_mdr1_sct_extract(_regval));
}

static inline omap44xx_uart3_sip_mode_status_t omap44xx_uart3_mdr1_sip_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sip_mode_status_t omap44xx_uart3_mdr1_sip_mode_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_uart3_mdr1_sip_mode_extract(_regval));
}

static inline omap44xx_uart3_frame_end_mode_status_t omap44xx_uart3_mdr1_frame_end_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_frame_end_mode_status_t omap44xx_uart3_mdr1_frame_end_mode_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr1_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_uart3_mdr1_frame_end_mode_extract(_regval));
}

static inline void omap44xx_uart3_mdr1_mode_select_wrf(__DN(t) *_dev, omap44xx_uart3_mode_select_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_mode_select_wrf(__DN(t) *_dev, omap44xx_uart3_mode_select_status_t _fieldval)
{
    omap44xx_uart3_mdr1_t _regval = 0x7 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf8 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr1_ir_sleep_wrf(__DN(t) *_dev, omap44xx_uart3_ir_sleep_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_ir_sleep_wrf(__DN(t) *_dev, omap44xx_uart3_ir_sleep_status_t _fieldval)
{
    omap44xx_uart3_mdr1_t _regval = 0x8 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr1_set_txir_wrf(__DN(t) *_dev, omap44xx_uart3_set_txir_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_set_txir_wrf(__DN(t) *_dev, omap44xx_uart3_set_txir_status_t _fieldval)
{
    omap44xx_uart3_mdr1_t _regval = 0x10 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr1_sct_wrf(__DN(t) *_dev, omap44xx_uart3_sct_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_sct_wrf(__DN(t) *_dev, omap44xx_uart3_sct_status_t _fieldval)
{
    omap44xx_uart3_mdr1_t _regval = 0x20 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr1_sip_mode_wrf(__DN(t) *_dev, omap44xx_uart3_sip_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_sip_mode_wrf(__DN(t) *_dev, omap44xx_uart3_sip_mode_status_t _fieldval)
{
    omap44xx_uart3_mdr1_t _regval = 0x40 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr1_frame_end_mode_wrf(__DN(t) *_dev, omap44xx_uart3_frame_end_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr1_frame_end_mode_wrf(__DN(t) *_dev, omap44xx_uart3_frame_end_mode_status_t _fieldval)
{
    omap44xx_uart3_mdr1_t _regval = 0x80 & (((omap44xx_uart3_mdr1_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register mdr2: Mode definition register 2
 * Type: omap44xx_uart3.mdr2 (Implicit type of Mode definition register 2 register)
 *   irtx_underrun	(size 1, offset 0, init 0):	RO	IrDA transmission status interrupt. When theUART_IIR[5] interrupt occurs, the meaning of the interrupt is:
 *   sts_fifo_trig	(size 2, offset 1, init 0):	RW	IR-IrDA mode only. Frame status FIFO threshold select:
 *   pulse	(size 1, offset 3, init 0):	RW	UART mode only. Allows pulse shaping in UART mode.
 *   cir_pulse_mode	(size 2, offset 4, init 0):	RW	CIR pulse modulation definition. Defines high level of the pulse width associated with a digit:
 *   irrxinvert	(size 1, offset 6, init 0):	RW	IR mode only (IrDA and CIR). Invert RX pin in the module before the voting or sampling system logic of the infrared block. This does not affect the RX path in UART modem modes.
 *   set_txir_alt	(size 1, offset 7, init 0):	RO	Provide alternate function for MDR1[4] (SET_TXIR).
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr2_t omap44xx_uart3_mdr2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void omap44xx_uart3_mdr2_rawwr(__DN(t) *_dev, omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr2_rawwr(__DN(t) *_dev, omap44xx_uart3_mdr2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void omap44xx_uart3_mdr2_wr(__DN(t) *_dev, omap44xx_uart3_mdr2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr2_wr(__DN(t) *_dev, omap44xx_uart3_mdr2_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int omap44xx_uart3_mdr2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mdr2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mdr2 (Mode definition register 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irtx_underrun =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_modem_sts_it_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_irtx_underrun_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IrDA transmission status interrupt. When theUART_IIR[5] interrupt occurs, the meaning of the interrupt is:)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts_fifo_trig =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sts_fifo_trig_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_sts_fifo_trig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IR-IrDA mode only. Frame status FIFO threshold select:)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pulse =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_pulse_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_pulse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(UART mode only. Allows pulse shaping in UART mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cir_pulse_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cir_pulse_mode_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_cir_pulse_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(CIR pulse modulation definition. Defines high level of the pulse width associated with a digit:)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irrxinvert =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_irrxinvert_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_irrxinvert_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IR mode only (IrDA and CIR). Invert RX pin in the module before the voting or sampling system logic of the infrared block. This does not affect the RX path in UART modem modes.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set_txir_alt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_set_txir_alt_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr2_set_txir_alt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Provide alternate function for MDR1[4] (SET_TXIR).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_mdr2_irtx_underrun_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_modem_sts_it_status_t omap44xx_uart3_mdr2_irtx_underrun_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_uart3_mdr2_irtx_underrun_extract(_regval));
}

static inline omap44xx_uart3_sts_fifo_trig_status_t omap44xx_uart3_mdr2_sts_fifo_trig_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sts_fifo_trig_status_t omap44xx_uart3_mdr2_sts_fifo_trig_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_uart3_mdr2_sts_fifo_trig_extract(_regval));
}

static inline omap44xx_uart3_pulse_status_t omap44xx_uart3_mdr2_pulse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_pulse_status_t omap44xx_uart3_mdr2_pulse_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_uart3_mdr2_pulse_extract(_regval));
}

static inline omap44xx_uart3_cir_pulse_mode_status_t omap44xx_uart3_mdr2_cir_pulse_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_cir_pulse_mode_status_t omap44xx_uart3_mdr2_cir_pulse_mode_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_uart3_mdr2_cir_pulse_mode_extract(_regval));
}

static inline omap44xx_uart3_irrxinvert_status_t omap44xx_uart3_mdr2_irrxinvert_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_irrxinvert_status_t omap44xx_uart3_mdr2_irrxinvert_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_uart3_mdr2_irrxinvert_extract(_regval));
}

static inline omap44xx_uart3_set_txir_alt_status_t omap44xx_uart3_mdr2_set_txir_alt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_set_txir_alt_status_t omap44xx_uart3_mdr2_set_txir_alt_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr2_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_uart3_mdr2_set_txir_alt_extract(_regval));
}

static inline void omap44xx_uart3_mdr2_sts_fifo_trig_wrf(__DN(t) *_dev, omap44xx_uart3_sts_fifo_trig_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr2_sts_fifo_trig_wrf(__DN(t) *_dev, omap44xx_uart3_sts_fifo_trig_status_t _fieldval)
{
    omap44xx_uart3_mdr2_t _regval = 0x6 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 1);
    _regval = (_regval | (0x78 & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr2_pulse_wrf(__DN(t) *_dev, omap44xx_uart3_pulse_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr2_pulse_wrf(__DN(t) *_dev, omap44xx_uart3_pulse_status_t _fieldval)
{
    omap44xx_uart3_mdr2_t _regval = 0x8 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 3);
    _regval = (_regval | (0x76 & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr2_cir_pulse_mode_wrf(__DN(t) *_dev, omap44xx_uart3_cir_pulse_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr2_cir_pulse_mode_wrf(__DN(t) *_dev, omap44xx_uart3_cir_pulse_mode_status_t _fieldval)
{
    omap44xx_uart3_mdr2_t _regval = 0x30 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 4);
    _regval = (_regval | (0x4e & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr2_irrxinvert_wrf(__DN(t) *_dev, omap44xx_uart3_irrxinvert_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr2_irrxinvert_wrf(__DN(t) *_dev, omap44xx_uart3_irrxinvert_status_t _fieldval)
{
    omap44xx_uart3_mdr2_t _regval = 0x40 & (((omap44xx_uart3_mdr2_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3e & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register sflsr: Status FIFO line status register
 * Type: omap44xx_uart3.sflsr (Implicit type of Status FIFO line status register register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   crc_error	(size 1, offset 1, init 0):	RO	Read 0x1: CRC error in frame at top of RX FIFO
 *   abort_detect	(size 1, offset 2, init 0):	RO	Read 0x1: Abort pattern detected in frame at top of RX FIFO
 *   frame_too_long_error	(size 1, offset 3, init 0):	RO	Read 0x1: Frame-length too long error in frame at top of RX FIFO
 *   oe_error	(size 1, offset 4, init 0):	RO	Read 0x1: Overrun error in RX FIFO when frame at top of RX FIFO was received Top of RX FIFO = Next frame to be read from RX FIFO
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sflsr_t omap44xx_uart3_sflsr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_uart3_sflsr_rawwr(__DN(t) *_dev, omap44xx_uart3_sflsr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sflsr_rawwr(__DN(t) *_dev, omap44xx_uart3_sflsr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

// Register sflsr is not writeable
static inline int omap44xx_uart3_sflsr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sflsr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_sflsr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sflsr (Status FIFO line status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc_error =\t%" PRIx8 "\t(Read 0x1: CRC error in frame at top of RX FIFO)\n", omap44xx_uart3_sflsr_crc_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abort_detect =\t%" PRIx8 "\t(Read 0x1: Abort pattern detected in frame at top of RX FIFO)\n", omap44xx_uart3_sflsr_abort_detect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frame_too_long_error =\t%" PRIx8 "\t(Read 0x1: Frame-length too long error in frame at top of RX FIFO)\n", omap44xx_uart3_sflsr_frame_too_long_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe_error =\t%" PRIx8 "\t(Read 0x1: Overrun error in RX FIFO when frame at top of RX FIFO was received Top of RX FIFO = Next frame to be read from RX FIFO)\n", omap44xx_uart3_sflsr_oe_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_sflsr_crc_error_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_crc_error_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sflsr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_uart3_sflsr_crc_error_extract(_regval));
}

static inline uint8_t omap44xx_uart3_sflsr_abort_detect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_abort_detect_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sflsr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_uart3_sflsr_abort_detect_extract(_regval));
}

static inline uint8_t omap44xx_uart3_sflsr_frame_too_long_error_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_frame_too_long_error_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sflsr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_uart3_sflsr_frame_too_long_error_extract(_regval));
}

static inline uint8_t omap44xx_uart3_sflsr_oe_error_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sflsr_oe_error_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sflsr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_uart3_sflsr_oe_error_extract(_regval));
}

/*
 * Register txfll: Transmit frame length register low
 * Type: omap44xx_uart3.txfll (Implicit type of Transmit frame length register low register)
 *   txfll	(size 8, offset 0, init 0):	WO	LSB register used to specify the frame length
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_txfll_t omap44xx_uart3_txfll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfll_t omap44xx_uart3_txfll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_uart3_txfll_t omap44xx_uart3_txfll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfll_t omap44xx_uart3_txfll_rd(__DN(t) *_dev)
{
    return(_dev->txfll_shadow);
}

static inline void omap44xx_uart3_txfll_rawwr(__DN(t) *_dev, omap44xx_uart3_txfll_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txfll_rawwr(__DN(t) *_dev, omap44xx_uart3_txfll_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_uart3_txfll_wr(__DN(t) *_dev, omap44xx_uart3_txfll_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txfll_wr(__DN(t) *_dev, omap44xx_uart3_txfll_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_uart3_txfll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txfll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_txfll_t _regval = _dev->txfll_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register txfll (Transmit frame length register low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfll =\t%" PRIx8 "\t(LSB register used to specify the frame length)\n", omap44xx_uart3_txfll_txfll_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_txfll_txfll_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_txfll_txfll_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_txfll_txfll_extract(_dev->txfll_shadow));
}

static inline void omap44xx_uart3_txfll_txfll_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txfll_txfll_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_txfll_t _regval = 0xff & (((omap44xx_uart3_txfll_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    _dev->txfll_shadow = _regval;
}

/*
 * Register resume: IR-IrDA and IR-CIR modes only. This register is used to clear internal flags, which halt transmission/reception when an underrun/overrun error occurs. Reading this register resumes the halted operation. This register does not physically exist and reads always as 0x00.
 * Type: omap44xx_uart3.resume (Implicit type of IR-IrDA and IR-CIR modes only. This register is used to clear internal flags, which halt transmission/reception when an underrun/overrun error occurs. Reading this register resumes the halted operation. This register does not physically exist and reads always as 0x00. register)
 *   resume	(size 8, offset 0, init 0):	RO	Dummy read to restart the TX or RX
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_resume_t omap44xx_uart3_resume_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_resume_t omap44xx_uart3_resume_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline omap44xx_uart3_resume_t omap44xx_uart3_resume_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_resume_t omap44xx_uart3_resume_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void omap44xx_uart3_resume_rawwr(__DN(t) *_dev, omap44xx_uart3_resume_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_resume_rawwr(__DN(t) *_dev, omap44xx_uart3_resume_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

// Register resume is not writeable
static inline int omap44xx_uart3_resume_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_resume_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_resume_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register resume (IR-IrDA and IR-CIR modes only. This register is used to clear internal flags, which halt transmission/reception when an underrun/overrun error occurs. Reading this register resumes the halted operation. This register does not physically exist and reads always as 0x00.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resume =\t%" PRIx8 "\t(Dummy read to restart the TX or RX)\n", omap44xx_uart3_resume_resume_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_resume_resume_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_resume_resume_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_resume_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_uart3_resume_resume_extract(_regval));
}

/*
 * Register txflh: Transmit frame length register high
 * Type: omap44xx_uart3.txflh (Implicit type of Transmit frame length register high register)
 *   txflh	(size 5, offset 0, init 0):	WO	MSB register used to specify the frame length
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_txflh_t omap44xx_uart3_txflh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txflh_t omap44xx_uart3_txflh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline omap44xx_uart3_txflh_t omap44xx_uart3_txflh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txflh_t omap44xx_uart3_txflh_rd(__DN(t) *_dev)
{
    return(_dev->txflh_shadow);
}

static inline void omap44xx_uart3_txflh_rawwr(__DN(t) *_dev, omap44xx_uart3_txflh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txflh_rawwr(__DN(t) *_dev, omap44xx_uart3_txflh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void omap44xx_uart3_txflh_wr(__DN(t) *_dev, omap44xx_uart3_txflh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txflh_wr(__DN(t) *_dev, omap44xx_uart3_txflh_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int omap44xx_uart3_txflh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txflh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_txflh_t _regval = _dev->txflh_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register txflh (Transmit frame length register high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txflh =\t%" PRIx8 "\t(MSB register used to specify the frame length)\n", omap44xx_uart3_txflh_txflh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_txflh_txflh_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_txflh_txflh_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_txflh_txflh_extract(_dev->txflh_shadow));
}

static inline void omap44xx_uart3_txflh_txflh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txflh_txflh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_txflh_t _regval = 0x1f & (((omap44xx_uart3_txflh_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    _dev->txflh_shadow = _regval;
}

/*
 * Register rxfll: Received frame length register low
 * Type: omap44xx_uart3.rxfll (Implicit type of Received frame length register low register)
 *   rxfll	(size 8, offset 0, init 0):	WO	LSB register used to specify the frame length in reception
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_rxfll_t omap44xx_uart3_rxfll_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfll_t omap44xx_uart3_rxfll_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_uart3_rxfll_t omap44xx_uart3_rxfll_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfll_t omap44xx_uart3_rxfll_rd(__DN(t) *_dev)
{
    return(_dev->rxfll_shadow);
}

static inline void omap44xx_uart3_rxfll_rawwr(__DN(t) *_dev, omap44xx_uart3_rxfll_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxfll_rawwr(__DN(t) *_dev, omap44xx_uart3_rxfll_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_uart3_rxfll_wr(__DN(t) *_dev, omap44xx_uart3_rxfll_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxfll_wr(__DN(t) *_dev, omap44xx_uart3_rxfll_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_uart3_rxfll_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxfll_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_rxfll_t _regval = _dev->rxfll_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxfll (Received frame length register low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfll =\t%" PRIx8 "\t(LSB register used to specify the frame length in reception)\n", omap44xx_uart3_rxfll_rxfll_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_rxfll_rxfll_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rxfll_rxfll_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_rxfll_rxfll_extract(_dev->rxfll_shadow));
}

static inline void omap44xx_uart3_rxfll_rxfll_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxfll_rxfll_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_rxfll_t _regval = 0xff & (((omap44xx_uart3_rxfll_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    _dev->rxfll_shadow = _regval;
}

/*
 * Register sfregl: Status FIFO register low
 * Type: omap44xx_uart3.sfregl (Implicit type of Status FIFO register low register)
 *   sfregl	(size 8, offset 0, init 0):	RO	LSB part of the frame length
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_sfregl_t omap44xx_uart3_sfregl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sfregl_t omap44xx_uart3_sfregl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_uart3_sfregl_t omap44xx_uart3_sfregl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sfregl_t omap44xx_uart3_sfregl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_uart3_sfregl_rawwr(__DN(t) *_dev, omap44xx_uart3_sfregl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sfregl_rawwr(__DN(t) *_dev, omap44xx_uart3_sfregl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

// Register sfregl is not writeable
static inline int omap44xx_uart3_sfregl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sfregl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_sfregl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sfregl (Status FIFO register low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfregl =\t%" PRIx8 "\t(LSB part of the frame length)\n", omap44xx_uart3_sfregl_sfregl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_sfregl_sfregl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sfregl_sfregl_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sfregl_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_uart3_sfregl_sfregl_extract(_regval));
}

/*
 * Register rxflh: Received frame length register high
 * Type: omap44xx_uart3.rxflh (Implicit type of Received frame length register high register)
 *   rxflh	(size 4, offset 0, init 0):	WO	MSB register used to specify the frame length in reception
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_rxflh_t omap44xx_uart3_rxflh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxflh_t omap44xx_uart3_rxflh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline omap44xx_uart3_rxflh_t omap44xx_uart3_rxflh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxflh_t omap44xx_uart3_rxflh_rd(__DN(t) *_dev)
{
    return(_dev->rxflh_shadow);
}

static inline void omap44xx_uart3_rxflh_rawwr(__DN(t) *_dev, omap44xx_uart3_rxflh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxflh_rawwr(__DN(t) *_dev, omap44xx_uart3_rxflh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void omap44xx_uart3_rxflh_wr(__DN(t) *_dev, omap44xx_uart3_rxflh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxflh_wr(__DN(t) *_dev, omap44xx_uart3_rxflh_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int omap44xx_uart3_rxflh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxflh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_rxflh_t _regval = _dev->rxflh_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxflh (Received frame length register high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxflh =\t%" PRIx8 "\t(MSB register used to specify the frame length in reception)\n", omap44xx_uart3_rxflh_rxflh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_rxflh_rxflh_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rxflh_rxflh_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_uart3_rxflh_rxflh_extract(_dev->rxflh_shadow));
}

static inline void omap44xx_uart3_rxflh_rxflh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxflh_rxflh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_rxflh_t _regval = 0xf & (((omap44xx_uart3_rxflh_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    _dev->rxflh_shadow = _regval;
}

/*
 * Register sfregh: Status FIFO register high
 * Type: omap44xx_uart3.sfregh (Implicit type of Status FIFO register high register)
 *   sfregh	(size 4, offset 0, init 0):	RO	MSB part of the frame length
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_sfregh_t omap44xx_uart3_sfregh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sfregh_t omap44xx_uart3_sfregh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline omap44xx_uart3_sfregh_t omap44xx_uart3_sfregh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sfregh_t omap44xx_uart3_sfregh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void omap44xx_uart3_sfregh_rawwr(__DN(t) *_dev, omap44xx_uart3_sfregh_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sfregh_rawwr(__DN(t) *_dev, omap44xx_uart3_sfregh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

// Register sfregh is not writeable
static inline int omap44xx_uart3_sfregh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sfregh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_sfregh_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sfregh (Status FIFO register high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfregh =\t%" PRIx8 "\t(MSB part of the frame length)\n", omap44xx_uart3_sfregh_sfregh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_sfregh_sfregh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_sfregh_sfregh_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sfregh_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_uart3_sfregh_sfregh_extract(_regval));
}

/*
 * Register blr: BOF control register
 * Type: omap44xx_uart3.blr (Implicit type of BOF control register register)
 *   _anon0	(size 6, offset 0, init 0):	MBZ	_
 *   xbof_type	(size 1, offset 6, init 0):	RW	SIR xBOF select
 *   sts_fifo_reset	(size 1, offset 7, init 0):	RW	Status FIFO reset. This bit is self-clearing.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_blr_t omap44xx_uart3_blr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_uart3_blr_rawwr(__DN(t) *_dev, omap44xx_uart3_blr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_blr_rawwr(__DN(t) *_dev, omap44xx_uart3_blr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void omap44xx_uart3_blr_wr(__DN(t) *_dev, omap44xx_uart3_blr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_blr_wr(__DN(t) *_dev, omap44xx_uart3_blr_t _regval)
{
    _regval = (_regval & 0xc0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int omap44xx_uart3_blr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_blr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_blr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register blr (BOF control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xbof_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xbof_type_status_prtval(_s + _r, _avail, omap44xx_uart3_blr_xbof_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SIR xBOF select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts_fifo_reset =\t%" PRIx8 "\t(Status FIFO reset. This bit is self-clearing.)\n", omap44xx_uart3_blr_sts_fifo_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_xbof_type_status_t omap44xx_uart3_blr_xbof_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_xbof_type_status_t omap44xx_uart3_blr_xbof_type_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_blr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_uart3_blr_xbof_type_extract(_regval));
}

static inline uint8_t omap44xx_uart3_blr_sts_fifo_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_blr_sts_fifo_reset_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_blr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_uart3_blr_sts_fifo_reset_extract(_regval));
}

static inline void omap44xx_uart3_blr_xbof_type_wrf(__DN(t) *_dev, omap44xx_uart3_xbof_type_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_blr_xbof_type_wrf(__DN(t) *_dev, omap44xx_uart3_xbof_type_status_t _fieldval)
{
    omap44xx_uart3_blr_t _regval = 0x40 & (((omap44xx_uart3_blr_t )(_fieldval)) << 6);
    _regval = (_regval | (0x80 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0xc0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_blr_sts_fifo_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_blr_sts_fifo_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_blr_t _regval = 0x80 & (((omap44xx_uart3_blr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x40 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0xc0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register uasr: UART autobauding status register
 * Type: omap44xx_uart3.uasr (Implicit type of UART autobauding status register register)
 *   speed	(size 5, offset 0, init 0):	RO	Used to report the speed identified
 *   bit_by_char	(size 1, offset 5, init 0):	RO	Read 0x0: 7-bit character identified
 *   parity_type	(size 2, offset 6, init 0):	RO	Read 0x0: No parity identified
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_uasr_t omap44xx_uart3_uasr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_uart3_uasr_rawwr(__DN(t) *_dev, omap44xx_uart3_uasr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_uasr_rawwr(__DN(t) *_dev, omap44xx_uart3_uasr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

// Register uasr is not writeable
static inline int omap44xx_uart3_uasr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_uasr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_uasr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register uasr (UART autobauding status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_speed_status_prtval(_s + _r, _avail, omap44xx_uart3_uasr_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to report the speed identified)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit_by_char =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_bit_by_char_status_prtval(_s + _r, _avail, omap44xx_uart3_uasr_bit_by_char_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: 7-bit character identified)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " parity_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_parity_type_status_prtval(_s + _r, _avail, omap44xx_uart3_uasr_parity_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No parity identified)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_speed_status_t omap44xx_uart3_uasr_speed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_speed_status_t omap44xx_uart3_uasr_speed_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_uasr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_uart3_uasr_speed_extract(_regval));
}

static inline omap44xx_uart3_bit_by_char_status_t omap44xx_uart3_uasr_bit_by_char_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_bit_by_char_status_t omap44xx_uart3_uasr_bit_by_char_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_uasr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_uart3_uasr_bit_by_char_extract(_regval));
}

static inline omap44xx_uart3_parity_type_status_t omap44xx_uart3_uasr_parity_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_parity_type_status_t omap44xx_uart3_uasr_parity_type_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_uasr_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_uart3_uasr_parity_type_extract(_regval));
}

/*
 * Register acreg: Auxiliary control register. IR-IrDA and IR-CIR modes only.
 * Type: omap44xx_uart3.acreg (Implicit type of Auxiliary control register. IR-IrDA and IR-CIR modes only. register)
 *   eot_en	(size 1, offset 0, init 0):	RW	EOT (end of transmission) bit. The LH writes 1 to this bit just before it writes the last byte to the TX FIFO in set-EOT bit frame closing method. This bit is cleared automatically when the LH writes to the THR (TX FIFO).
 *   abort_en	(size 1, offset 1, init 0):	RW	Frame abort. The LH can intentionally abort transmission of a frame by writing 1 to this bit. Neither the end flag nor the CRC bits are appended to the frame. If TX FIFO is not empty and MDR1[5] = 1, UART IrDA starts a new transfer with data of the previous frame when the abort frame is sent. Therefore, TX FIFO must be reset before sending an abort frame.
 *   sctx_en	(size 1, offset 2, init 0):	RW	Store and controlled TX start. When MDR1[5] = 1 and the LH writes 1 to this bit, the TX state-machine starts frame transmission. This bit is self-clearing.
 *   send_sip	(size 1, offset 3, init 0):	RW	MIR/FIR modes only. Send serial infrared interaction pulse (SIP). If this bit is set during an MIR/FIR transmission, the SIP is sent at the end of it. This bit is cleared automatically at the end of the SIP transmission.
 *   dis_tx_underrun	(size 1, offset 4, init 0):	RW	It is recommended to disable TX FIFO underrun capability by masking corresponding underrun interrupt. When disabling underrun by setting ACREG[4] = 1, garbage data is sent over TX line.
 *   dis_ir_rx	(size 1, offset 5, init 0):	RW	0x0: Normal operation (RX input automatically disabled during transmit but enabled outside of transmit operation)
 *   sd_mod	(size 1, offset 6, init 0):	RW	Primary output used to configure transceivers. Connected to the SD/MODE input pin of IrDA transceivers.
 *   pulse_type	(size 1, offset 7, init 0):	RW	SIR pulse width select
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_acreg_t omap44xx_uart3_acreg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void omap44xx_uart3_acreg_rawwr(__DN(t) *_dev, omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_rawwr(__DN(t) *_dev, omap44xx_uart3_acreg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline void omap44xx_uart3_acreg_wr(__DN(t) *_dev, omap44xx_uart3_acreg_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_wr(__DN(t) *_dev, omap44xx_uart3_acreg_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline int omap44xx_uart3_acreg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_acreg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register acreg (Auxiliary control register. IR-IrDA and IR-CIR modes only.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eot_en =\t%" PRIx8 "\t(EOT (end of transmission) bit. The LH writes 1 to this bit just before it writes the last byte to the TX FIFO in set-EOT bit frame closing method. This bit is cleared automatically when the LH writes to the THR (TX FIFO).)\n", omap44xx_uart3_acreg_eot_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abort_en =\t%" PRIx8 "\t(Frame abort. The LH can intentionally abort transmission of a frame by writing 1 to this bit. Neither the end flag nor the CRC bits are appended to the frame. If TX FIFO is not empty and MDR1[5] = 1, UART IrDA starts a new transfer with data of the previous frame when the abort frame is sent. Therefore, TX FIFO must be reset before sending an abort frame.)\n", omap44xx_uart3_acreg_abort_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sctx_en =\t%" PRIx8 "\t(Store and controlled TX start. When MDR1[5] = 1 and the LH writes 1 to this bit, the TX state-machine starts frame transmission. This bit is self-clearing.)\n", omap44xx_uart3_acreg_sctx_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " send_sip =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_send_sip_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_send_sip_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MIR/FIR modes only. Send serial infrared interaction pulse (SIP). If this bit is set during an MIR/FIR transmission, the SIP is sent at the end of it. This bit is cleared automatically at the end of the SIP transmission.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_tx_underrun =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dis_tx_underrun_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_dis_tx_underrun_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(It is recommended to disable TX FIFO underrun capability by masking corresponding underrun interrupt. When disabling underrun by setting ACREG[4] = 1, garbage data is sent over TX line.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_ir_rx =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fifo_en_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_dis_ir_rx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Normal operation (RX input automatically disabled during transmit but enabled outside of transmit operation))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sd_mod =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sd_mod_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_sd_mod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Primary output used to configure transceivers. Connected to the SD/MODE input pin of IrDA transceivers.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pulse_type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_pulse_type_status_prtval(_s + _r, _avail, omap44xx_uart3_acreg_pulse_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SIR pulse width select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_acreg_eot_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_acreg_eot_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_eot_en_extract(_regval));
}

static inline uint8_t omap44xx_uart3_acreg_abort_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_acreg_abort_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_abort_en_extract(_regval));
}

static inline uint8_t omap44xx_uart3_acreg_sctx_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_acreg_sctx_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_sctx_en_extract(_regval));
}

static inline omap44xx_uart3_send_sip_status_t omap44xx_uart3_acreg_send_sip_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_send_sip_status_t omap44xx_uart3_acreg_send_sip_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_send_sip_extract(_regval));
}

static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_acreg_dis_tx_underrun_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_acreg_dis_tx_underrun_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_dis_tx_underrun_extract(_regval));
}

static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_acreg_dis_ir_rx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_acreg_dis_ir_rx_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_dis_ir_rx_extract(_regval));
}

static inline omap44xx_uart3_sd_mod_status_t omap44xx_uart3_acreg_sd_mod_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sd_mod_status_t omap44xx_uart3_acreg_sd_mod_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_sd_mod_extract(_regval));
}

static inline omap44xx_uart3_pulse_type_status_t omap44xx_uart3_acreg_pulse_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_pulse_type_status_t omap44xx_uart3_acreg_pulse_type_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_acreg_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_uart3_acreg_pulse_type_extract(_regval));
}

static inline void omap44xx_uart3_acreg_eot_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_eot_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x1 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_abort_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_abort_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x2 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_sctx_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_sctx_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x4 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_send_sip_wrf(__DN(t) *_dev, omap44xx_uart3_send_sip_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_send_sip_wrf(__DN(t) *_dev, omap44xx_uart3_send_sip_status_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x8 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_dis_tx_underrun_wrf(__DN(t) *_dev, omap44xx_uart3_dis_tx_underrun_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_dis_tx_underrun_wrf(__DN(t) *_dev, omap44xx_uart3_dis_tx_underrun_status_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x10 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_dis_ir_rx_wrf(__DN(t) *_dev, omap44xx_uart3_fifo_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_dis_ir_rx_wrf(__DN(t) *_dev, omap44xx_uart3_fifo_en_status_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x20 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_sd_mod_wrf(__DN(t) *_dev, omap44xx_uart3_sd_mod_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_sd_mod_wrf(__DN(t) *_dev, omap44xx_uart3_sd_mod_status_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x40 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_acreg_pulse_type_wrf(__DN(t) *_dev, omap44xx_uart3_pulse_type_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_acreg_pulse_type_wrf(__DN(t) *_dev, omap44xx_uart3_pulse_type_status_t _fieldval)
{
    omap44xx_uart3_acreg_t _regval = 0x80 & (((omap44xx_uart3_acreg_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

/*
 * Register scr: Supplementary control register
 * Type: omap44xx_uart3.scr (Implicit type of Supplementary control register register)
 *   dma_mode_ctl	(size 1, offset 0, init 0):	RW	0x0: The DMA_MODE is set withUART_FCR[3].
 *   dma_mode_2	(size 2, offset 1, init 0):	RW	Used to specify the DMA mode valid if theUART_SCR[0] bit = 1
 *   tx_empty_ctl_it	(size 1, offset 3, init 0):	RW	0x0: Normal mode for THR interrupt (see UART mode interrupts table)
 *   rx_cts_dsr_wake_up_enable	(size 1, offset 4, init 0):	RW	0x0: Disables the wake-up interrupt and clears SSR[1]
 *   dsr_it	(size 1, offset 5, init 0):	RW	0x0: Disables DSR* interrupt
 *   tx_trig_granu1	(size 1, offset 6, init 0):	RW	0x0: Disables the granularity of 1 for trigger TX level
 *   rx_trig_granu1	(size 1, offset 7, init 0):	RW	0x0: Disables the granularity of 1 for trigger RX level
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_scr_t omap44xx_uart3_scr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_uart3_scr_rawwr(__DN(t) *_dev, omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_rawwr(__DN(t) *_dev, omap44xx_uart3_scr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_uart3_scr_wr(__DN(t) *_dev, omap44xx_uart3_scr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_wr(__DN(t) *_dev, omap44xx_uart3_scr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_uart3_scr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_scr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register scr (Supplementary control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode_ctl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_mode_ctl_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_dma_mode_ctl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: The DMA_MODE is set withUART_FCR[3].)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode_2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_mode_2_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_dma_mode_2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to specify the DMA mode valid if theUART_SCR[0] bit = 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_empty_ctl_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_empty_ctl_it_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_tx_empty_ctl_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Normal mode for THR interrupt (see UART mode interrupts table))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_cts_dsr_wake_up_enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables the wake-up interrupt and clears SSR[1])\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr_it =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dsr_it_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_dsr_it_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables DSR* interrupt)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_trig_granu1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dis_tx_underrun_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_tx_trig_granu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables the granularity of 1 for trigger TX level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_trig_granu1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fifo_en_status_prtval(_s + _r, _avail, omap44xx_uart3_scr_rx_trig_granu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Disables the granularity of 1 for trigger RX level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_dma_mode_ctl_status_t omap44xx_uart3_scr_dma_mode_ctl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_mode_ctl_status_t omap44xx_uart3_scr_dma_mode_ctl_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_dma_mode_ctl_extract(_regval));
}

static inline omap44xx_uart3_dma_mode_2_status_t omap44xx_uart3_scr_dma_mode_2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_mode_2_status_t omap44xx_uart3_scr_dma_mode_2_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_dma_mode_2_extract(_regval));
}

static inline omap44xx_uart3_tx_empty_ctl_it_status_t omap44xx_uart3_scr_tx_empty_ctl_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_empty_ctl_it_status_t omap44xx_uart3_scr_tx_empty_ctl_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_tx_empty_ctl_it_extract(_regval));
}

static inline omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_extract(_regval));
}

static inline omap44xx_uart3_dsr_it_status_t omap44xx_uart3_scr_dsr_it_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dsr_it_status_t omap44xx_uart3_scr_dsr_it_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_dsr_it_extract(_regval));
}

static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_scr_tx_trig_granu1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dis_tx_underrun_status_t omap44xx_uart3_scr_tx_trig_granu1_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_tx_trig_granu1_extract(_regval));
}

static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_scr_rx_trig_granu1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_fifo_en_status_t omap44xx_uart3_scr_rx_trig_granu1_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_scr_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_uart3_scr_rx_trig_granu1_extract(_regval));
}

static inline void omap44xx_uart3_scr_dma_mode_ctl_wrf(__DN(t) *_dev, omap44xx_uart3_dma_mode_ctl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_dma_mode_ctl_wrf(__DN(t) *_dev, omap44xx_uart3_dma_mode_ctl_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x1 & (((omap44xx_uart3_scr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_scr_dma_mode_2_wrf(__DN(t) *_dev, omap44xx_uart3_dma_mode_2_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_dma_mode_2_wrf(__DN(t) *_dev, omap44xx_uart3_dma_mode_2_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x6 & (((omap44xx_uart3_scr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf9 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_scr_tx_empty_ctl_it_wrf(__DN(t) *_dev, omap44xx_uart3_tx_empty_ctl_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_tx_empty_ctl_it_wrf(__DN(t) *_dev, omap44xx_uart3_tx_empty_ctl_it_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x8 & (((omap44xx_uart3_scr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_wrf(__DN(t) *_dev, omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_rx_cts_dsr_wake_up_enable_wrf(__DN(t) *_dev, omap44xx_uart3_rx_cts_dsr_wake_up_enable_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x10 & (((omap44xx_uart3_scr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_scr_dsr_it_wrf(__DN(t) *_dev, omap44xx_uart3_dsr_it_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_dsr_it_wrf(__DN(t) *_dev, omap44xx_uart3_dsr_it_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x20 & (((omap44xx_uart3_scr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_scr_tx_trig_granu1_wrf(__DN(t) *_dev, omap44xx_uart3_dis_tx_underrun_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_tx_trig_granu1_wrf(__DN(t) *_dev, omap44xx_uart3_dis_tx_underrun_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x40 & (((omap44xx_uart3_scr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_scr_rx_trig_granu1_wrf(__DN(t) *_dev, omap44xx_uart3_fifo_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_scr_rx_trig_granu1_wrf(__DN(t) *_dev, omap44xx_uart3_fifo_en_status_t _fieldval)
{
    omap44xx_uart3_scr_t _regval = 0x80 & (((omap44xx_uart3_scr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register ssr: Supplementary status register
 * Type: omap44xx_uart3.ssr (Implicit type of Supplementary status register register)
 *   tx_fifo_full	(size 1, offset 0, init 0):	RO	Read 0x0: TX FIFO is not full.
 *   rx_cts_dsr_wake_up_sts	(size 1, offset 1, init 0):	RO	Read 0x0: No falling edge event on RX, CTS*, and DSR*
 *   dma_counter_rst	(size 1, offset 2, init 0):	RW	0x0: The DMA counter will not be reset if the corresponding FIFO is reset (through FCR[1] or FCR[2]).
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ssr_t omap44xx_uart3_ssr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void omap44xx_uart3_ssr_rawwr(__DN(t) *_dev, omap44xx_uart3_ssr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ssr_rawwr(__DN(t) *_dev, omap44xx_uart3_ssr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void omap44xx_uart3_ssr_wr(__DN(t) *_dev, omap44xx_uart3_ssr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ssr_wr(__DN(t) *_dev, omap44xx_uart3_ssr_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int omap44xx_uart3_ssr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ssr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_ssr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ssr (Supplementary status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifo_full =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_fifo_full_status_prtval(_s + _r, _avail, omap44xx_uart3_ssr_tx_fifo_full_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: TX FIFO is not full.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_cts_dsr_wake_up_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Read 0x0: No falling edge event on RX, CTS*, and DSR*)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_counter_rst =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dma_counter_rst_status_prtval(_s + _r, _avail, omap44xx_uart3_ssr_dma_counter_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: The DMA counter will not be reset if the corresponding FIFO is reset (through FCR[1] or FCR[2]).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_tx_fifo_full_status_t omap44xx_uart3_ssr_tx_fifo_full_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_fifo_full_status_t omap44xx_uart3_ssr_tx_fifo_full_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ssr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_uart3_ssr_tx_fifo_full_extract(_regval));
}

static inline omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rx_cts_dsr_wake_up_sts_status_t omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ssr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_uart3_ssr_rx_cts_dsr_wake_up_sts_extract(_regval));
}

static inline omap44xx_uart3_dma_counter_rst_status_t omap44xx_uart3_ssr_dma_counter_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_dma_counter_rst_status_t omap44xx_uart3_ssr_dma_counter_rst_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ssr_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_uart3_ssr_dma_counter_rst_extract(_regval));
}

static inline void omap44xx_uart3_ssr_dma_counter_rst_wrf(__DN(t) *_dev, omap44xx_uart3_dma_counter_rst_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ssr_dma_counter_rst_wrf(__DN(t) *_dev, omap44xx_uart3_dma_counter_rst_status_t _fieldval)
{
    omap44xx_uart3_ssr_t _regval = 0x4 & (((omap44xx_uart3_ssr_t )(_fieldval)) << 2);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register eblr: BOF length register
 * Type: omap44xx_uart3.eblr (Implicit type of BOF length register register)
 *   eblr	(size 8, offset 0, init 0):	RW	IR-IrDA mode: This register allows definition of up to 176 xBOFs, the maximum required by IrDA specification.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_eblr_t omap44xx_uart3_eblr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_eblr_t omap44xx_uart3_eblr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline omap44xx_uart3_eblr_t omap44xx_uart3_eblr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_eblr_t omap44xx_uart3_eblr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void omap44xx_uart3_eblr_rawwr(__DN(t) *_dev, omap44xx_uart3_eblr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_eblr_rawwr(__DN(t) *_dev, omap44xx_uart3_eblr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void omap44xx_uart3_eblr_wr(__DN(t) *_dev, omap44xx_uart3_eblr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_eblr_wr(__DN(t) *_dev, omap44xx_uart3_eblr_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int omap44xx_uart3_eblr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_eblr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_eblr_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eblr (BOF length register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eblr =\t%" PRIx8 "\t(IR-IrDA mode: This register allows definition of up to 176 xBOFs, the maximum required by IrDA specification.)\n", omap44xx_uart3_eblr_eblr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_eblr_eblr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_eblr_eblr_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_eblr_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_uart3_eblr_eblr_extract(_regval));
}

static inline void omap44xx_uart3_eblr_eblr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_eblr_eblr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_eblr_t _regval = 0xff & (((omap44xx_uart3_eblr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

/*
 * Register mvr: Module version register
 * Type: omap44xx_uart3.uint32 (primitive type)
 */
static inline uint32_t omap44xx_uart3_mvr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_uart3_mvr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline uint32_t omap44xx_uart3_mvr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_uart3_mvr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void omap44xx_uart3_mvr_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mvr_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

// Register mvr is not writeable
static inline int omap44xx_uart3_mvr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mvr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mvr (Module version register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sysc: System configuration register
 * Type: omap44xx_uart3.sysc (Implicit type of System configuration register register)
 *   autoidle	(size 1, offset 0, init 0):	RW	Internal OCP clock gating strategy
 *   softreset	(size 1, offset 1, init 0):	RW	Software reset. Set this bit to 1 to trigger a module reset. This bit is automatically reset by the hardware. Read returns 0.
 *   enawakeup	(size 1, offset 2, init 0):	RW	Wake-up feature control
 *   idlemode	(size 2, offset 3, init 0):	RW	Power management req/ack control ref: OCP Design Guidelines Version 1.1
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_sysc_t omap44xx_uart3_sysc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline void omap44xx_uart3_sysc_rawwr(__DN(t) *_dev, omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sysc_rawwr(__DN(t) *_dev, omap44xx_uart3_sysc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline void omap44xx_uart3_sysc_wr(__DN(t) *_dev, omap44xx_uart3_sysc_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sysc_wr(__DN(t) *_dev, omap44xx_uart3_sysc_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline int omap44xx_uart3_sysc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_sysc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_sysc_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sysc (System configuration register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " autoidle =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_autoidle_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_autoidle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal OCP clock gating strategy)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softreset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_softreset_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_softreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Software reset. Set this bit to 1 to trigger a module reset. This bit is automatically reset by the hardware. Read returns 0.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enawakeup =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_enawakeup_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_enawakeup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake-up feature control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idlemode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_idlemode_status_prtval(_s + _r, _avail, omap44xx_uart3_sysc_idlemode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power management req/ack control ref: OCP Design Guidelines Version 1.1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_autoidle_status_t omap44xx_uart3_sysc_autoidle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_autoidle_status_t omap44xx_uart3_sysc_autoidle_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sysc_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_uart3_sysc_autoidle_extract(_regval));
}

static inline omap44xx_uart3_softreset_status_t omap44xx_uart3_sysc_softreset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_softreset_status_t omap44xx_uart3_sysc_softreset_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sysc_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_uart3_sysc_softreset_extract(_regval));
}

static inline omap44xx_uart3_enawakeup_status_t omap44xx_uart3_sysc_enawakeup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_enawakeup_status_t omap44xx_uart3_sysc_enawakeup_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sysc_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_uart3_sysc_enawakeup_extract(_regval));
}

static inline omap44xx_uart3_idlemode_status_t omap44xx_uart3_sysc_idlemode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_idlemode_status_t omap44xx_uart3_sysc_idlemode_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_sysc_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_uart3_sysc_idlemode_extract(_regval));
}

static inline void omap44xx_uart3_sysc_autoidle_wrf(__DN(t) *_dev, omap44xx_uart3_autoidle_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sysc_autoidle_wrf(__DN(t) *_dev, omap44xx_uart3_autoidle_status_t _fieldval)
{
    omap44xx_uart3_sysc_t _regval = 0x1 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_sysc_softreset_wrf(__DN(t) *_dev, omap44xx_uart3_softreset_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sysc_softreset_wrf(__DN(t) *_dev, omap44xx_uart3_softreset_status_t _fieldval)
{
    omap44xx_uart3_sysc_t _regval = 0x2 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_sysc_enawakeup_wrf(__DN(t) *_dev, omap44xx_uart3_enawakeup_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sysc_enawakeup_wrf(__DN(t) *_dev, omap44xx_uart3_enawakeup_status_t _fieldval)
{
    omap44xx_uart3_sysc_t _regval = 0x4 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 2);
    _regval = (_regval | (0x1b & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_sysc_idlemode_wrf(__DN(t) *_dev, omap44xx_uart3_idlemode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_sysc_idlemode_wrf(__DN(t) *_dev, omap44xx_uart3_idlemode_status_t _fieldval)
{
    omap44xx_uart3_sysc_t _regval = 0x18 & (((omap44xx_uart3_sysc_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7 & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

/*
 * Register syss: System status register
 * Type: omap44xx_uart3.syss (Implicit type of System status register register)
 *   resetdone	(size 1, offset 0, init 0):	RO	Internal reset monitoring
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_syss_t omap44xx_uart3_syss_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_syss_t omap44xx_uart3_syss_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline omap44xx_uart3_syss_t omap44xx_uart3_syss_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_syss_t omap44xx_uart3_syss_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline void omap44xx_uart3_syss_rawwr(__DN(t) *_dev, omap44xx_uart3_syss_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_syss_rawwr(__DN(t) *_dev, omap44xx_uart3_syss_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

// Register syss is not writeable
static inline int omap44xx_uart3_syss_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_syss_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_syss_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register syss (System status register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resetdone =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_resetdone_status_prtval(_s + _r, _avail, omap44xx_uart3_syss_resetdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Internal reset monitoring)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_resetdone_status_t omap44xx_uart3_syss_resetdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_resetdone_status_t omap44xx_uart3_syss_resetdone_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_syss_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_uart3_syss_resetdone_extract(_regval));
}

/*
 * Register wer: Wake-up enable register
 * Type: omap44xx_uart3.wer (Implicit type of Wake-up enable register register)
 *   event_0_cts_activity	(size 1, offset 0, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_1_dsr_activity	(size 1, offset 1, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_2_ri_activity	(size 1, offset 2, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_3_dcd_cd_activity	(size 1, offset 3, init 0):	RW	0x0: Event is not allowed to wake up the system
 *   event_4_rx_activity	(size 1, offset 4, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_5_rhr_interrupt	(size 1, offset 5, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   event_6_receiver_line_status_interrupt	(size 1, offset 6, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   tx_wakeup_en	(size 1, offset 7, init 0):	RW	0x0: Event is not allowed to wake up the system.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_wer_t omap44xx_uart3_wer_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline void omap44xx_uart3_wer_rawwr(__DN(t) *_dev, omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_rawwr(__DN(t) *_dev, omap44xx_uart3_wer_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

static inline void omap44xx_uart3_wer_wr(__DN(t) *_dev, omap44xx_uart3_wer_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_wr(__DN(t) *_dev, omap44xx_uart3_wer_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

static inline int omap44xx_uart3_wer_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_wer_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wer (Wake-up enable register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_0_cts_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_0_cts_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_1_dsr_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_1_dsr_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_2_ri_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_2_ri_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_3_dcd_cd_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_3_dcd_cd_activity_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_3_dcd_cd_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_4_rx_activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_4_rx_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_5_rhr_interrupt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_5_rhr_interrupt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_6_receiver_line_status_interrupt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_event_6_receiver_line_status_interrupt_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_wakeup_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_wakeup_en_status_prtval(_s + _r, _avail, omap44xx_uart3_wer_tx_wakeup_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(0x0: Event is not allowed to wake up the system.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_0_cts_activity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_0_cts_activity_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_0_cts_activity_extract(_regval));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_1_dsr_activity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_1_dsr_activity_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_1_dsr_activity_extract(_regval));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_2_ri_activity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_2_ri_activity_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_2_ri_activity_extract(_regval));
}

static inline omap44xx_uart3_event_3_dcd_cd_activity_status_t omap44xx_uart3_wer_event_3_dcd_cd_activity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_3_dcd_cd_activity_status_t omap44xx_uart3_wer_event_3_dcd_cd_activity_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_3_dcd_cd_activity_extract(_regval));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_4_rx_activity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_4_rx_activity_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_4_rx_activity_extract(_regval));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_5_rhr_interrupt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_5_rhr_interrupt_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_5_rhr_interrupt_extract(_regval));
}

static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_extract(_regval));
}

static inline omap44xx_uart3_tx_wakeup_en_status_t omap44xx_uart3_wer_tx_wakeup_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_wakeup_en_status_t omap44xx_uart3_wer_tx_wakeup_en_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_wer_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_uart3_wer_tx_wakeup_en_extract(_regval));
}

static inline void omap44xx_uart3_wer_event_0_cts_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_0_cts_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x1 & (((omap44xx_uart3_wer_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_event_1_dsr_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_1_dsr_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x2 & (((omap44xx_uart3_wer_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_event_2_ri_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_2_ri_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x4 & (((omap44xx_uart3_wer_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_event_3_dcd_cd_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_3_dcd_cd_activity_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_3_dcd_cd_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_3_dcd_cd_activity_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x8 & (((omap44xx_uart3_wer_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_event_4_rx_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_4_rx_activity_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x10 & (((omap44xx_uart3_wer_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_event_5_rhr_interrupt_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_5_rhr_interrupt_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x20 & (((omap44xx_uart3_wer_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_event_6_receiver_line_status_interrupt_wrf(__DN(t) *_dev, omap44xx_uart3_event_6_receiver_line_status_interrupt_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x40 & (((omap44xx_uart3_wer_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_wer_tx_wakeup_en_wrf(__DN(t) *_dev, omap44xx_uart3_tx_wakeup_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_wer_tx_wakeup_en_wrf(__DN(t) *_dev, omap44xx_uart3_tx_wakeup_en_status_t _fieldval)
{
    omap44xx_uart3_wer_t _regval = 0x80 & (((omap44xx_uart3_wer_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

/*
 * Register cfps: Carrier frequency prescaler
 * Type: omap44xx_uart3.cfps (Implicit type of Carrier frequency prescaler register)
 *   cfps	(size 8, offset 0, init 0):	RW	System clock frequency prescaler at (12x multiple). Examples for CFPS values:Target Freq (kHz) CFPS (decimal) Actual Freq (kHz) . 30 133 30.08 . 32.75 122 32.79 . 36 111 36.04 . 36.7 109 36.69 . 38* 105 38.1 . 40 100 40 . 56.8 70 57.14 . *configured at reset to this value . Note:CFPS = 0 is not supported. .
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_cfps_t omap44xx_uart3_cfps_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_cfps_t omap44xx_uart3_cfps_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline omap44xx_uart3_cfps_t omap44xx_uart3_cfps_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_cfps_t omap44xx_uart3_cfps_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline void omap44xx_uart3_cfps_rawwr(__DN(t) *_dev, omap44xx_uart3_cfps_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_cfps_rawwr(__DN(t) *_dev, omap44xx_uart3_cfps_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline void omap44xx_uart3_cfps_wr(__DN(t) *_dev, omap44xx_uart3_cfps_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_cfps_wr(__DN(t) *_dev, omap44xx_uart3_cfps_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline int omap44xx_uart3_cfps_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_cfps_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_cfps_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cfps (Carrier frequency prescaler): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfps =\t%" PRIx8 "\t(System clock frequency prescaler at (12x multiple). Examples for CFPS values:Target Freq (kHz) CFPS (decimal) Actual Freq (kHz) . 30 133 30.08 . 32.75 122 32.79 . 36 111 36.04 . 36.7 109 36.69 . 38* 105 38.1 . 40 100 40 . 56.8 70 57.14 . *configured at reset to this value . Note:CFPS = 0 is not supported. .)\n", omap44xx_uart3_cfps_cfps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_cfps_cfps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_cfps_cfps_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_cfps_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_uart3_cfps_cfps_extract(_regval));
}

static inline void omap44xx_uart3_cfps_cfps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_cfps_cfps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_cfps_t _regval = 0xff & (((omap44xx_uart3_cfps_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register rxfifo_lvl: Level of the RX FIFO
 * Type: omap44xx_uart3.rxfifo_lvl (Implicit type of Level of the RX FIFO register)
 *   rxfifo_lvl	(size 8, offset 0, init 0):	RO	Shows the number of received bytes in the RX FIFO
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_rxfifo_lvl_t omap44xx_uart3_rxfifo_lvl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfifo_lvl_t omap44xx_uart3_rxfifo_lvl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline omap44xx_uart3_rxfifo_lvl_t omap44xx_uart3_rxfifo_lvl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfifo_lvl_t omap44xx_uart3_rxfifo_lvl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline void omap44xx_uart3_rxfifo_lvl_rawwr(__DN(t) *_dev, omap44xx_uart3_rxfifo_lvl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_rxfifo_lvl_rawwr(__DN(t) *_dev, omap44xx_uart3_rxfifo_lvl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
}

// Register rxfifo_lvl is not writeable
static inline int omap44xx_uart3_rxfifo_lvl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_rxfifo_lvl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_rxfifo_lvl_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxfifo_lvl (Level of the RX FIFO): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_lvl =\t%" PRIx8 "\t(Shows the number of received bytes in the RX FIFO)\n", omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_rxfifo_lvl_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_uart3_rxfifo_lvl_rxfifo_lvl_extract(_regval));
}

/*
 * Register txfifo_lvl: Level of the TX FIFO
 * Type: omap44xx_uart3.txfifo_lvl (Implicit type of Level of the TX FIFO register)
 *   txfifo_lvl	(size 8, offset 0, init 0):	RO	Shows the number of written bytes in the TX FIFO
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_txfifo_lvl_t omap44xx_uart3_txfifo_lvl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfifo_lvl_t omap44xx_uart3_txfifo_lvl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline omap44xx_uart3_txfifo_lvl_t omap44xx_uart3_txfifo_lvl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfifo_lvl_t omap44xx_uart3_txfifo_lvl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline void omap44xx_uart3_txfifo_lvl_rawwr(__DN(t) *_dev, omap44xx_uart3_txfifo_lvl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_txfifo_lvl_rawwr(__DN(t) *_dev, omap44xx_uart3_txfifo_lvl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

// Register txfifo_lvl is not writeable
static inline int omap44xx_uart3_txfifo_lvl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_txfifo_lvl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_txfifo_lvl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register txfifo_lvl (Level of the TX FIFO): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_lvl =\t%" PRIx8 "\t(Shows the number of written bytes in the TX FIFO)\n", omap44xx_uart3_txfifo_lvl_txfifo_lvl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_txfifo_lvl_txfifo_lvl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_txfifo_lvl_txfifo_lvl_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_txfifo_lvl_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_uart3_txfifo_lvl_txfifo_lvl_extract(_regval));
}

/*
 * Register ier2: Enables RX/TX FIFOs empty corresponding interrupts
 * Type: omap44xx_uart3.ier2 (Implicit type of Enables RX/TX FIFOs empty corresponding interrupts register)
 *   en_rxfifo_empty	(size 1, offset 0, init 0):	RW	Enables RX FIFO empty corresponding interrupt
 *   en_txfifo_empty	(size 1, offset 1, init 0):	RW	Enables TX FIFO empty corresponding interrupt
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c));
}

static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_ier2_t omap44xx_uart3_ier2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c));
}

static inline void omap44xx_uart3_ier2_rawwr(__DN(t) *_dev, omap44xx_uart3_ier2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier2_rawwr(__DN(t) *_dev, omap44xx_uart3_ier2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
}

static inline void omap44xx_uart3_ier2_wr(__DN(t) *_dev, omap44xx_uart3_ier2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier2_wr(__DN(t) *_dev, omap44xx_uart3_ier2_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
}

static inline int omap44xx_uart3_ier2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_ier2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_ier2_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ier2 (Enables RX/TX FIFOs empty corresponding interrupts): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_rxfifo_empty =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_en_rxfifo_empty_status_prtval(_s + _r, _avail, omap44xx_uart3_ier2_en_rxfifo_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enables RX FIFO empty corresponding interrupt)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_txfifo_empty =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_en_txfifo_empty_status_prtval(_s + _r, _avail, omap44xx_uart3_ier2_en_txfifo_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enables TX FIFO empty corresponding interrupt)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_uart3_en_rxfifo_empty_status_t omap44xx_uart3_ier2_en_rxfifo_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_en_rxfifo_empty_status_t omap44xx_uart3_ier2_en_rxfifo_empty_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier2_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_uart3_ier2_en_rxfifo_empty_extract(_regval));
}

static inline omap44xx_uart3_en_txfifo_empty_status_t omap44xx_uart3_ier2_en_txfifo_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_en_txfifo_empty_status_t omap44xx_uart3_ier2_en_txfifo_empty_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_ier2_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_uart3_ier2_en_txfifo_empty_extract(_regval));
}

static inline void omap44xx_uart3_ier2_en_rxfifo_empty_wrf(__DN(t) *_dev, omap44xx_uart3_en_rxfifo_empty_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier2_en_rxfifo_empty_wrf(__DN(t) *_dev, omap44xx_uart3_en_rxfifo_empty_status_t _fieldval)
{
    omap44xx_uart3_ier2_t _regval = 0x1 & (((omap44xx_uart3_ier2_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_ier2_en_txfifo_empty_wrf(__DN(t) *_dev, omap44xx_uart3_en_txfifo_empty_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_ier2_en_txfifo_empty_wrf(__DN(t) *_dev, omap44xx_uart3_en_txfifo_empty_status_t _fieldval)
{
    omap44xx_uart3_ier2_t _regval = 0x2 & (((omap44xx_uart3_ier2_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

/*
 * Register isr2: Status of RX/TX FIFOs empty corresponding interrupts
 * Type: omap44xx_uart3.isr2 (Implicit type of Status of RX/TX FIFOs empty corresponding interrupts register)
 *   rxfifo_empty_sts	(size 1, offset 0, init 0):	RW	Used to generate interrupt if the RX_FIFO is empty (software flow control)
 *   txfifo_empty_sts	(size 1, offset 1, init 0):	RW	Used to generate interrupt if the TX_FIFO is empty (software flow control)
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_isr2_t omap44xx_uart3_isr2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline void omap44xx_uart3_isr2_rawwr(__DN(t) *_dev, omap44xx_uart3_isr2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_isr2_rawwr(__DN(t) *_dev, omap44xx_uart3_isr2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline void omap44xx_uart3_isr2_wr(__DN(t) *_dev, omap44xx_uart3_isr2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_isr2_wr(__DN(t) *_dev, omap44xx_uart3_isr2_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline int omap44xx_uart3_isr2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_isr2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_isr2_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register isr2 (Status of RX/TX FIFOs empty corresponding interrupts): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_empty_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rxfifo_empty_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_isr2_rxfifo_empty_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to generate interrupt if the RX_FIFO is empty (software flow control))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_empty_sts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_txfifo_empty_sts_status_prtval(_s + _r, _avail, omap44xx_uart3_isr2_txfifo_empty_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to generate interrupt if the TX_FIFO is empty (software flow control))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_uart3_rxfifo_empty_sts_status_t omap44xx_uart3_isr2_rxfifo_empty_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_rxfifo_empty_sts_status_t omap44xx_uart3_isr2_rxfifo_empty_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_isr2_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_uart3_isr2_rxfifo_empty_sts_extract(_regval));
}

static inline omap44xx_uart3_txfifo_empty_sts_status_t omap44xx_uart3_isr2_txfifo_empty_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_txfifo_empty_sts_status_t omap44xx_uart3_isr2_txfifo_empty_sts_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_isr2_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_uart3_isr2_txfifo_empty_sts_extract(_regval));
}

static inline void omap44xx_uart3_isr2_rxfifo_empty_sts_wrf(__DN(t) *_dev, omap44xx_uart3_rxfifo_empty_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_isr2_rxfifo_empty_sts_wrf(__DN(t) *_dev, omap44xx_uart3_rxfifo_empty_sts_status_t _fieldval)
{
    omap44xx_uart3_isr2_t _regval = 0x1 & (((omap44xx_uart3_isr2_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_isr2_txfifo_empty_sts_wrf(__DN(t) *_dev, omap44xx_uart3_txfifo_empty_sts_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_isr2_txfifo_empty_sts_wrf(__DN(t) *_dev, omap44xx_uart3_txfifo_empty_sts_status_t _fieldval)
{
    omap44xx_uart3_isr2_t _regval = 0x2 & (((omap44xx_uart3_isr2_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

/*
 * Register freq_sel: Sample per bit selector
 * Type: omap44xx_uart3.freq_sel (Implicit type of Sample per bit selector register)
 *   freq_sel	(size 8, offset 0, init 0):	RW	Sets the sample per bit if nondefault frequency is used. MDR3[1] must be set to 1 after this value is set. Must be equal to or higher then 6.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_uart3_freq_sel_t omap44xx_uart3_freq_sel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_freq_sel_t omap44xx_uart3_freq_sel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x74));
}

static inline omap44xx_uart3_freq_sel_t omap44xx_uart3_freq_sel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_freq_sel_t omap44xx_uart3_freq_sel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x74));
}

static inline void omap44xx_uart3_freq_sel_rawwr(__DN(t) *_dev, omap44xx_uart3_freq_sel_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_freq_sel_rawwr(__DN(t) *_dev, omap44xx_uart3_freq_sel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
}

static inline void omap44xx_uart3_freq_sel_wr(__DN(t) *_dev, omap44xx_uart3_freq_sel_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_freq_sel_wr(__DN(t) *_dev, omap44xx_uart3_freq_sel_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
}

static inline int omap44xx_uart3_freq_sel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_freq_sel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_freq_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register freq_sel (Sample per bit selector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freq_sel =\t%" PRIx8 "\t(Sets the sample per bit if nondefault frequency is used. MDR3[1] must be set to 1 after this value is set. Must be equal to or higher then 6.)\n", omap44xx_uart3_freq_sel_freq_sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_freq_sel_freq_sel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_freq_sel_freq_sel_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_freq_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x74);
    return(omap44xx_uart3_freq_sel_freq_sel_extract(_regval));
}

static inline void omap44xx_uart3_freq_sel_freq_sel_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_freq_sel_freq_sel_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_freq_sel_t _regval = 0xff & (((omap44xx_uart3_freq_sel_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x74, _regval);
    // No shadow register to write to
}

/*
 * Register mdr3: Mode definition register 3
 * Type: omap44xx_uart3.mdr3 (Implicit type of Mode definition register 3 register)
 *   disable_cir_rx_demod	(size 1, offset 0, init 0):	RW	Used to enable CIR RX demodulation.
 *   nondefault_freq	(size 1, offset 1, init 0):	RW	Used to enable the NONDEFAULT fclk frequencies.
 *   set_dma_tx_threshold	(size 1, offset 2, init 0):	RW	Enable to set different TXDMA threshold inUART_TX_DMA_THRESHOLD register.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_mdr3_t omap44xx_uart3_mdr3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline void omap44xx_uart3_mdr3_rawwr(__DN(t) *_dev, omap44xx_uart3_mdr3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr3_rawwr(__DN(t) *_dev, omap44xx_uart3_mdr3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline void omap44xx_uart3_mdr3_wr(__DN(t) *_dev, omap44xx_uart3_mdr3_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr3_wr(__DN(t) *_dev, omap44xx_uart3_mdr3_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline int omap44xx_uart3_mdr3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_mdr3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_mdr3_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mdr3 (Mode definition register 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " disable_cir_rx_demod =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_disable_cir_rx_demod_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr3_disable_cir_rx_demod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to enable CIR RX demodulation.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nondefault_freq =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_nondefault_freq_status_prtval(_s + _r, _avail, omap44xx_uart3_mdr3_nondefault_freq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Used to enable the NONDEFAULT fclk frequencies.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set_dma_tx_threshold =\t%" PRIx8 "\t(Enable to set different TXDMA threshold inUART_TX_DMA_THRESHOLD register.)\n", omap44xx_uart3_mdr3_set_dma_tx_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_uart3_disable_cir_rx_demod_status_t omap44xx_uart3_mdr3_disable_cir_rx_demod_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_disable_cir_rx_demod_status_t omap44xx_uart3_mdr3_disable_cir_rx_demod_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr3_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(omap44xx_uart3_mdr3_disable_cir_rx_demod_extract(_regval));
}

static inline omap44xx_uart3_nondefault_freq_status_t omap44xx_uart3_mdr3_nondefault_freq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_nondefault_freq_status_t omap44xx_uart3_mdr3_nondefault_freq_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr3_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(omap44xx_uart3_mdr3_nondefault_freq_extract(_regval));
}

static inline uint8_t omap44xx_uart3_mdr3_set_dma_tx_threshold_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_mdr3_set_dma_tx_threshold_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_mdr3_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(omap44xx_uart3_mdr3_set_dma_tx_threshold_extract(_regval));
}

static inline void omap44xx_uart3_mdr3_disable_cir_rx_demod_wrf(__DN(t) *_dev, omap44xx_uart3_disable_cir_rx_demod_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr3_disable_cir_rx_demod_wrf(__DN(t) *_dev, omap44xx_uart3_disable_cir_rx_demod_status_t _fieldval)
{
    omap44xx_uart3_mdr3_t _regval = 0x1 & (((omap44xx_uart3_mdr3_t )(_fieldval)) << 0);
    _regval = (_regval | (0x6 & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr3_nondefault_freq_wrf(__DN(t) *_dev, omap44xx_uart3_nondefault_freq_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr3_nondefault_freq_wrf(__DN(t) *_dev, omap44xx_uart3_nondefault_freq_status_t _fieldval)
{
    omap44xx_uart3_mdr3_t _regval = 0x2 & (((omap44xx_uart3_mdr3_t )(_fieldval)) << 1);
    _regval = (_regval | (0x5 & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

static inline void omap44xx_uart3_mdr3_set_dma_tx_threshold_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_mdr3_set_dma_tx_threshold_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_mdr3_t _regval = 0x4 & (((omap44xx_uart3_mdr3_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

/*
 * Register tx_dma_threshold: Use to manually set the TX DMA threshold level. [2] SET_TX_DMA_THRESHOLD must be 1 and must be value + tx_trigger_level = 64 (TX FIFO size). If not, 64-tx_trigger_level will be used without modifying the value of this register.
 * Type: omap44xx_uart3.tx_dma_threshold (Implicit type of Use to manually set the TX DMA threshold level. [2] SET_TX_DMA_THRESHOLD must be 1 and must be value + tx_trigger_level = 64 (TX FIFO size). If not, 64-tx_trigger_level will be used without modifying the value of this register. register)
 *   tx_dma_threshold	(size 6, offset 0, init 0):	RW	Used to manually set the TX DMA threshold level
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
static inline omap44xx_uart3_tx_dma_threshold_t omap44xx_uart3_tx_dma_threshold_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_dma_threshold_t omap44xx_uart3_tx_dma_threshold_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x84));
}

static inline omap44xx_uart3_tx_dma_threshold_t omap44xx_uart3_tx_dma_threshold_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_uart3_tx_dma_threshold_t omap44xx_uart3_tx_dma_threshold_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x84));
}

static inline void omap44xx_uart3_tx_dma_threshold_rawwr(__DN(t) *_dev, omap44xx_uart3_tx_dma_threshold_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tx_dma_threshold_rawwr(__DN(t) *_dev, omap44xx_uart3_tx_dma_threshold_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
}

static inline void omap44xx_uart3_tx_dma_threshold_wr(__DN(t) *_dev, omap44xx_uart3_tx_dma_threshold_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tx_dma_threshold_wr(__DN(t) *_dev, omap44xx_uart3_tx_dma_threshold_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
}

static inline int omap44xx_uart3_tx_dma_threshold_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_tx_dma_threshold_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_uart3_tx_dma_threshold_t _regval = mackerel_read_addr_32(_dev->base, 0x84);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tx_dma_threshold (Use to manually set the TX DMA threshold level. [2] SET_TX_DMA_THRESHOLD must be 1 and must be value + tx_trigger_level = 64 (TX FIFO size). If not, 64-tx_trigger_level will be used without modifying the value of this register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_dma_threshold =\t%" PRIx8 "\t(Used to manually set the TX DMA threshold level)\n", omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_rdf(__DN(t) *_dev)
{
    omap44xx_uart3_tx_dma_threshold_t _regval = mackerel_read_addr_32(_dev->base, 0x84);
    return(omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_extract(_regval));
}

static inline void omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_uart3_tx_dma_threshold_tx_dma_threshold_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_uart3_tx_dma_threshold_t _regval = 0x3f & (((omap44xx_uart3_tx_dma_threshold_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
    // No shadow register to write to
}

static inline int omap44xx_uart3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_uart3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_uart3 ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rhr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_thr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_dlh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ier_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_efr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_fcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_iir_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_lcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xon1_addr1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_lsr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xon2_addr2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_msr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xoff1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_spr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tlr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_xoff2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mdr1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mdr2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sflsr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_txfll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_resume_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_txflh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rxfll_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sfregl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rxflh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sfregh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_blr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_uasr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_acreg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_scr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ssr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_eblr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mvr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_sysc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_syss_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_wer_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_cfps_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_rxfifo_lvl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_txfifo_lvl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_ier2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_isr2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_freq_sel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_mdr3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_uart3_tx_dma_threshold_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_uart3\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_uart3_DEV_H
