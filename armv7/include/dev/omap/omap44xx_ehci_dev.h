#ifndef __omap44xx_ehci_DEV_H
#define __omap44xx_ehci_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_ehci ## _ ## x
/*
 * Constants defn: omap44xx_ehci.p_indicator_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_p_indicator_status_t;
#define omap44xx_ehci_P_INDICATOR_1 ((omap44xx_ehci_p_indicator_status_t)0x1)

static inline char *omap44xx_ehci_p_indicator_status_describe(omap44xx_ehci_p_indicator_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_p_indicator_status_describe(omap44xx_ehci_p_indicator_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_P_INDICATOR_1:
        return("P_INDICATOR_1: The port status and control registers include a read/write field for controlling the state of the port indicator.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_p_indicator_status_prtval(char *_s, size_t _size, omap44xx_ehci_p_indicator_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_p_indicator_status_prtval(char *_s, size_t _size, omap44xx_ehci_p_indicator_status_t _e)
{
    char *d = omap44xx_ehci_p_indicator_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_p_indicator_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.n_cc_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_ehci_n_cc_status_t;
#define omap44xx_ehci_N_CC_0 ((omap44xx_ehci_n_cc_status_t)0x0)

static inline char *omap44xx_ehci_n_cc_status_describe(omap44xx_ehci_n_cc_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_n_cc_status_describe(omap44xx_ehci_n_cc_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_N_CC_0:
        return("N_CC_0: There are no companion host controllers. Port-ownership hand-off is not supported. Only high-speed devices are supported on the host controller root ports.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_n_cc_status_prtval(char *_s, size_t _size, omap44xx_ehci_n_cc_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_n_cc_status_prtval(char *_s, size_t _size, omap44xx_ehci_n_cc_status_t _e)
{
    char *d = omap44xx_ehci_n_cc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_n_cc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.ppc_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_ppc_status_t;
#define omap44xx_ehci_PPC_0 ((omap44xx_ehci_ppc_status_t)0x0)
#define omap44xx_ehci_PPC_1 ((omap44xx_ehci_ppc_status_t)0x1)

static inline char *omap44xx_ehci_ppc_status_describe(omap44xx_ehci_ppc_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_ppc_status_describe(omap44xx_ehci_ppc_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PPC_0:
        return("PPC_0: The ports do not have port power switches.");
    case omap44xx_ehci_PPC_1:
        return("PPC_1: The ports have port power switches.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_ppc_status_prtval(char *_s, size_t _size, omap44xx_ehci_ppc_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_ppc_status_prtval(char *_s, size_t _size, omap44xx_ehci_ppc_status_t _e)
{
    char *d = omap44xx_ehci_ppc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_ppc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.lpm_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_lpm_status_t;
#define omap44xx_ehci_LPM_0 ((omap44xx_ehci_lpm_status_t)0x0)
#define omap44xx_ehci_LPM_1 ((omap44xx_ehci_lpm_status_t)0x1)

static inline char *omap44xx_ehci_lpm_status_describe(omap44xx_ehci_lpm_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_lpm_status_describe(omap44xx_ehci_lpm_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_LPM_0:
        return("LPM_0: Link power management not supported");
    case omap44xx_ehci_LPM_1:
        return("LPM_1: Link power management supported");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_lpm_status_prtval(char *_s, size_t _size, omap44xx_ehci_lpm_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_lpm_status_prtval(char *_s, size_t _size, omap44xx_ehci_lpm_status_t _e)
{
    char *d = omap44xx_ehci_lpm_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_lpm_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.pflf_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_pflf_status_t;
#define omap44xx_ehci_PFLF_0 ((omap44xx_ehci_pflf_status_t)0x0)
#define omap44xx_ehci_PFLF_1 ((omap44xx_ehci_pflf_status_t)0x1)

static inline char *omap44xx_ehci_pflf_status_describe(omap44xx_ehci_pflf_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_pflf_status_describe(omap44xx_ehci_pflf_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PFLF_0:
        return("PFLF_0: System software must use a frame list length of 1024 elements with this host controller.");
    case omap44xx_ehci_PFLF_1:
        return("PFLF_1: System software can specify and use a smaller frame list and configure the host controller through the USBHOST.[3:2] FLS bit field. The frame list must always be aligned on a 4-K page boundary.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_pflf_status_prtval(char *_s, size_t _size, omap44xx_ehci_pflf_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_pflf_status_prtval(char *_s, size_t _size, omap44xx_ehci_pflf_status_t _e)
{
    char *d = omap44xx_ehci_pflf_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_pflf_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.bit64ac_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_bit64ac_status_t;
#define omap44xx_ehci_BIT64AC_0 ((omap44xx_ehci_bit64ac_status_t)0x0)
#define omap44xx_ehci_BIT64AC_1 ((omap44xx_ehci_bit64ac_status_t)0x1)

static inline char *omap44xx_ehci_bit64ac_status_describe(omap44xx_ehci_bit64ac_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_bit64ac_status_describe(omap44xx_ehci_bit64ac_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_BIT64AC_0:
        return("BIT64AC_0: Data structures using 32-bit address memory pointers");
    case omap44xx_ehci_BIT64AC_1:
        return("BIT64AC_1: Data structures using 64-bit address memory pointers");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_bit64ac_status_prtval(char *_s, size_t _size, omap44xx_ehci_bit64ac_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_bit64ac_status_prtval(char *_s, size_t _size, omap44xx_ehci_bit64ac_status_t _e)
{
    char *d = omap44xx_ehci_bit64ac_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_bit64ac_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.hird_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_ehci_hird_status_t;
#define omap44xx_ehci_HIRD_0 ((omap44xx_ehci_hird_status_t)0x0)

static inline char *omap44xx_ehci_hird_status_describe(omap44xx_ehci_hird_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_hird_status_describe(omap44xx_ehci_hird_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_HIRD_0:
        return("HIRD_0: 50 us");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_hird_status_prtval(char *_s, size_t _size, omap44xx_ehci_hird_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hird_status_prtval(char *_s, size_t _size, omap44xx_ehci_hird_status_t _e)
{
    char *d = omap44xx_ehci_hird_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_hird_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.itc_status ()
 *  - width 8 bits
 */
typedef uint8_t omap44xx_ehci_itc_status_t;
#define omap44xx_ehci_ITC_0 ((omap44xx_ehci_itc_status_t)0x0)
#define omap44xx_ehci_ITC_1 ((omap44xx_ehci_itc_status_t)0x1)
#define omap44xx_ehci_ITC_2 ((omap44xx_ehci_itc_status_t)0x2)
#define omap44xx_ehci_ITC_4 ((omap44xx_ehci_itc_status_t)0x4)
#define omap44xx_ehci_ITC_8 ((omap44xx_ehci_itc_status_t)0x8)
#define omap44xx_ehci_ITC_16 ((omap44xx_ehci_itc_status_t)0x10)
#define omap44xx_ehci_ITC_32 ((omap44xx_ehci_itc_status_t)0x20)
#define omap44xx_ehci_ITC_64 ((omap44xx_ehci_itc_status_t)0x40)

static inline char *omap44xx_ehci_itc_status_describe(omap44xx_ehci_itc_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_itc_status_describe(omap44xx_ehci_itc_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_ITC_0:
        return("ITC_0: Reserved");
    case omap44xx_ehci_ITC_1:
        return("ITC_1: 1 microframe");
    case omap44xx_ehci_ITC_2:
        return("ITC_2: 2 microframes");
    case omap44xx_ehci_ITC_4:
        return("ITC_4: 4 microframes");
    case omap44xx_ehci_ITC_8:
        return("ITC_8: 8 microframes (default, equates to 1 ms)");
    case omap44xx_ehci_ITC_16:
        return("ITC_16: 16 microframes (2 ms)");
    case omap44xx_ehci_ITC_32:
        return("ITC_32: 32 microframes (4 ms)");
    case omap44xx_ehci_ITC_64:
        return("ITC_64: 64 microframes (8 ms)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_itc_status_prtval(char *_s, size_t _size, omap44xx_ehci_itc_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_itc_status_prtval(char *_s, size_t _size, omap44xx_ehci_itc_status_t _e)
{
    char *d = omap44xx_ehci_itc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_itc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.aspme_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_aspme_status_t;
#define omap44xx_ehci_ASPME_0 ((omap44xx_ehci_aspme_status_t)0x0)
#define omap44xx_ehci_ASPME_1 ((omap44xx_ehci_aspme_status_t)0x1)

static inline char *omap44xx_ehci_aspme_status_describe(omap44xx_ehci_aspme_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_aspme_status_describe(omap44xx_ehci_aspme_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_ASPME_0:
        return("ASPME_0: Park mode is disabled.");
    case omap44xx_ehci_ASPME_1:
        return("ASPME_1: Park mode is enabled.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_aspme_status_prtval(char *_s, size_t _size, omap44xx_ehci_aspme_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_aspme_status_prtval(char *_s, size_t _size, omap44xx_ehci_aspme_status_t _e)
{
    char *d = omap44xx_ehci_aspme_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_aspme_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.iaad_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_iaad_status_t;
#define omap44xx_ehci_IAAD_1_w ((omap44xx_ehci_iaad_status_t)0x1)

static inline char *omap44xx_ehci_iaad_status_describe(omap44xx_ehci_iaad_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_iaad_status_describe(omap44xx_ehci_iaad_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_IAAD_1_w:
        return("IAAD_1_w: Ring the doorbell.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_iaad_status_prtval(char *_s, size_t _size, omap44xx_ehci_iaad_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_iaad_status_prtval(char *_s, size_t _size, omap44xx_ehci_iaad_status_t _e)
{
    char *d = omap44xx_ehci_iaad_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_iaad_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.ase_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_ase_status_t;
#define omap44xx_ehci_ASE_0 ((omap44xx_ehci_ase_status_t)0x0)
#define omap44xx_ehci_ASE_1 ((omap44xx_ehci_ase_status_t)0x1)

static inline char *omap44xx_ehci_ase_status_describe(omap44xx_ehci_ase_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_ase_status_describe(omap44xx_ehci_ase_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_ASE_0:
        return("ASE_0: Do not process the asynchronous schedule");
    case omap44xx_ehci_ASE_1:
        return("ASE_1: Use the USBHOST. register to access the asynchronous schedule.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_ase_status_prtval(char *_s, size_t _size, omap44xx_ehci_ase_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_ase_status_prtval(char *_s, size_t _size, omap44xx_ehci_ase_status_t _e)
{
    char *d = omap44xx_ehci_ase_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_ase_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.pse_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_pse_status_t;
#define omap44xx_ehci_PSE_0 ((omap44xx_ehci_pse_status_t)0x0)
#define omap44xx_ehci_PSE_1 ((omap44xx_ehci_pse_status_t)0x1)

static inline char *omap44xx_ehci_pse_status_describe(omap44xx_ehci_pse_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_pse_status_describe(omap44xx_ehci_pse_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PSE_0:
        return("PSE_0: Do not process the periodic schedule");
    case omap44xx_ehci_PSE_1:
        return("PSE_1: Use the USBHOST. register to access the periodic schedule.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_pse_status_prtval(char *_s, size_t _size, omap44xx_ehci_pse_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_pse_status_prtval(char *_s, size_t _size, omap44xx_ehci_pse_status_t _e)
{
    char *d = omap44xx_ehci_pse_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_pse_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.fls_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_ehci_fls_status_t;
#define omap44xx_ehci_FLS_0 ((omap44xx_ehci_fls_status_t)0x0)
#define omap44xx_ehci_FLS_1 ((omap44xx_ehci_fls_status_t)0x1)
#define omap44xx_ehci_FLS_2 ((omap44xx_ehci_fls_status_t)0x2)
#define omap44xx_ehci_FLS_3 ((omap44xx_ehci_fls_status_t)0x3)

static inline char *omap44xx_ehci_fls_status_describe(omap44xx_ehci_fls_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_fls_status_describe(omap44xx_ehci_fls_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_FLS_0:
        return("FLS_0: 1024 elements (4096 bytes)");
    case omap44xx_ehci_FLS_1:
        return("FLS_1: 512 elements (2048 bytes)");
    case omap44xx_ehci_FLS_2:
        return("FLS_2: 256 elements (1024 bytes), for resource-constrained environments");
    case omap44xx_ehci_FLS_3:
        return("FLS_3: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_fls_status_prtval(char *_s, size_t _size, omap44xx_ehci_fls_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_fls_status_prtval(char *_s, size_t _size, omap44xx_ehci_fls_status_t _e)
{
    char *d = omap44xx_ehci_fls_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_fls_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.hcr_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_hcr_status_t;
#define omap44xx_ehci_HCR_1 ((omap44xx_ehci_hcr_status_t)0x1)

static inline char *omap44xx_ehci_hcr_status_describe(omap44xx_ehci_hcr_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_hcr_status_describe(omap44xx_ehci_hcr_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_HCR_1:
        return("HCR_1: Reset the host controller, the PCI configuration registers are not affected by this reset and all operational registers are set to their initial values.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_hcr_status_prtval(char *_s, size_t _size, omap44xx_ehci_hcr_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hcr_status_prtval(char *_s, size_t _size, omap44xx_ehci_hcr_status_t _e)
{
    char *d = omap44xx_ehci_hcr_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_hcr_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.rs_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_rs_status_t;
#define omap44xx_ehci_RS_1 ((omap44xx_ehci_rs_status_t)0x1)
#define omap44xx_ehci_RS_0 ((omap44xx_ehci_rs_status_t)0x0)

static inline char *omap44xx_ehci_rs_status_describe(omap44xx_ehci_rs_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_rs_status_describe(omap44xx_ehci_rs_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_RS_1:
        return("RS_1: Run, the host controller proceeds with execution of the schedule. The host controller continues execution as long as this bit is set to 1.");
    case omap44xx_ehci_RS_0:
        return("RS_0: Stop, the host controller completes the current and any actively pipelined transactions on the USB and then halts.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_rs_status_prtval(char *_s, size_t _size, omap44xx_ehci_rs_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_rs_status_prtval(char *_s, size_t _size, omap44xx_ehci_rs_status_t _e)
{
    char *d = omap44xx_ehci_rs_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_rs_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.iaae_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_iaae_status_t;
#define omap44xx_ehci_IAAE_1 ((omap44xx_ehci_iaae_status_t)0x1)

static inline char *omap44xx_ehci_iaae_status_describe(omap44xx_ehci_iaae_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_iaae_status_describe(omap44xx_ehci_iaae_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_IAAE_1:
        return("IAAE_1: When the[5] IAA bit is 1, the host controller issues an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the [5] IAA bit.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_iaae_status_prtval(char *_s, size_t _size, omap44xx_ehci_iaae_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_iaae_status_prtval(char *_s, size_t _size, omap44xx_ehci_iaae_status_t _e)
{
    char *d = omap44xx_ehci_iaae_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_iaae_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.hsee_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_hsee_status_t;
#define omap44xx_ehci_HSEE_1 ((omap44xx_ehci_hsee_status_t)0x1)

static inline char *omap44xx_ehci_hsee_status_describe(omap44xx_ehci_hsee_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_hsee_status_describe(omap44xx_ehci_hsee_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_HSEE_1:
        return("HSEE_1: When the[4] HSE bit is 1, the host controller issues an interrupt. The interrupt is acknowledged by software clearing the [4] HSE bit.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_hsee_status_prtval(char *_s, size_t _size, omap44xx_ehci_hsee_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hsee_status_prtval(char *_s, size_t _size, omap44xx_ehci_hsee_status_t _e)
{
    char *d = omap44xx_ehci_hsee_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_hsee_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.flre_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_flre_status_t;
#define omap44xx_ehci_FLRE_1 ((omap44xx_ehci_flre_status_t)0x1)

static inline char *omap44xx_ehci_flre_status_describe(omap44xx_ehci_flre_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_flre_status_describe(omap44xx_ehci_flre_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_FLRE_1:
        return("FLRE_1: When the[3] FLR bit is 1, the host controller issues an interrupt. The interrupt is acknowledged by software clearing the [3] FLR bit.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_flre_status_prtval(char *_s, size_t _size, omap44xx_ehci_flre_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_flre_status_prtval(char *_s, size_t _size, omap44xx_ehci_flre_status_t _e)
{
    char *d = omap44xx_ehci_flre_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_flre_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.pcie_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_pcie_status_t;
#define omap44xx_ehci_PCIE_1 ((omap44xx_ehci_pcie_status_t)0x1)

static inline char *omap44xx_ehci_pcie_status_describe(omap44xx_ehci_pcie_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_pcie_status_describe(omap44xx_ehci_pcie_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PCIE_1:
        return("PCIE_1: When the[2] PCD bit is 1, the host controller issues an interrupt. The interrupt is acknowledged by software clearing the [3] FLR bit.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_pcie_status_prtval(char *_s, size_t _size, omap44xx_ehci_pcie_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_pcie_status_prtval(char *_s, size_t _size, omap44xx_ehci_pcie_status_t _e)
{
    char *d = omap44xx_ehci_pcie_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_pcie_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.usbeie_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_usbeie_status_t;
#define omap44xx_ehci_USBEIE_1 ((omap44xx_ehci_usbeie_status_t)0x1)

static inline char *omap44xx_ehci_usbeie_status_describe(omap44xx_ehci_usbeie_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_usbeie_status_describe(omap44xx_ehci_usbeie_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_USBEIE_1:
        return("USBEIE_1: When the[1] USBEI bit is 1, the host controller issues an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the [1] USBEI bit.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_usbeie_status_prtval(char *_s, size_t _size, omap44xx_ehci_usbeie_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbeie_status_prtval(char *_s, size_t _size, omap44xx_ehci_usbeie_status_t _e)
{
    char *d = omap44xx_ehci_usbeie_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_usbeie_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.usbie_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_usbie_status_t;
#define omap44xx_ehci_USBIE_1 ((omap44xx_ehci_usbie_status_t)0x1)

static inline char *omap44xx_ehci_usbie_status_describe(omap44xx_ehci_usbie_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_usbie_status_describe(omap44xx_ehci_usbie_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_USBIE_1:
        return("USBIE_1: When the[0] USBI bit is 1, the host controller issues an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the [0] USBI bit.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_usbie_status_prtval(char *_s, size_t _size, omap44xx_ehci_usbie_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbie_status_prtval(char *_s, size_t _size, omap44xx_ehci_usbie_status_t _e)
{
    char *d = omap44xx_ehci_usbie_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_usbie_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.suspendstatus_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_ehci_suspendstatus_status_t;
#define omap44xx_ehci_SUSPENDSTATUS_0 ((omap44xx_ehci_suspendstatus_status_t)0x0)
#define omap44xx_ehci_SUSPENDSTATUS_1 ((omap44xx_ehci_suspendstatus_status_t)0x1)
#define omap44xx_ehci_SUSPENDSTATUS_2 ((omap44xx_ehci_suspendstatus_status_t)0x2)
#define omap44xx_ehci_SUSPENDSTATUS_3 ((omap44xx_ehci_suspendstatus_status_t)0x3)

static inline char *omap44xx_ehci_suspendstatus_status_describe(omap44xx_ehci_suspendstatus_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_suspendstatus_status_describe(omap44xx_ehci_suspendstatus_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_SUSPENDSTATUS_0:
        return("SUSPENDSTATUS_0: Success");
    case omap44xx_ehci_SUSPENDSTATUS_1:
        return("SUSPENDSTATUS_1: Not yet");
    case omap44xx_ehci_SUSPENDSTATUS_2:
        return("SUSPENDSTATUS_2: Not supported");
    case omap44xx_ehci_SUSPENDSTATUS_3:
        return("SUSPENDSTATUS_3: Time-out/error");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_suspendstatus_status_prtval(char *_s, size_t _size, omap44xx_ehci_suspendstatus_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_suspendstatus_status_prtval(char *_s, size_t _size, omap44xx_ehci_suspendstatus_status_t _e)
{
    char *d = omap44xx_ehci_suspendstatus_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_suspendstatus_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.ptc_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_ehci_ptc_status_t;
#define omap44xx_ehci_PTC_0 ((omap44xx_ehci_ptc_status_t)0x0)
#define omap44xx_ehci_PTC_1 ((omap44xx_ehci_ptc_status_t)0x1)
#define omap44xx_ehci_PTC_2 ((omap44xx_ehci_ptc_status_t)0x2)
#define omap44xx_ehci_PTC_3 ((omap44xx_ehci_ptc_status_t)0x3)
#define omap44xx_ehci_PTC_4 ((omap44xx_ehci_ptc_status_t)0x4)
#define omap44xx_ehci_PTC_5 ((omap44xx_ehci_ptc_status_t)0x5)

static inline char *omap44xx_ehci_ptc_status_describe(omap44xx_ehci_ptc_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_ptc_status_describe(omap44xx_ehci_ptc_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PTC_0:
        return("PTC_0: Test mode not enabled");
    case omap44xx_ehci_PTC_1:
        return("PTC_1: Test J_STATE");
    case omap44xx_ehci_PTC_2:
        return("PTC_2: Test K_STATE");
    case omap44xx_ehci_PTC_3:
        return("PTC_3: Test SE0_NAK");
    case omap44xx_ehci_PTC_4:
        return("PTC_4: Test Packet");
    case omap44xx_ehci_PTC_5:
        return("PTC_5: Test FORCE_ENABLE");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_ptc_status_prtval(char *_s, size_t _size, omap44xx_ehci_ptc_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_ptc_status_prtval(char *_s, size_t _size, omap44xx_ehci_ptc_status_t _e)
{
    char *d = omap44xx_ehci_ptc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_ptc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.po_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_po_status_t;
#define omap44xx_ehci_PO_1 ((omap44xx_ehci_po_status_t)0x1)

static inline char *omap44xx_ehci_po_status_describe(omap44xx_ehci_po_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_po_status_describe(omap44xx_ehci_po_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PO_1:
        return("PO_1: A companion host controller owns and controls the port.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_po_status_prtval(char *_s, size_t _size, omap44xx_ehci_po_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_po_status_prtval(char *_s, size_t _size, omap44xx_ehci_po_status_t _e)
{
    char *d = omap44xx_ehci_po_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_po_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.suspendl1_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_suspendl1_status_t;
#define omap44xx_ehci_SUSPENDL1_0 ((omap44xx_ehci_suspendl1_status_t)0x0)
#define omap44xx_ehci_SUSPENDL1_1 ((omap44xx_ehci_suspendl1_status_t)0x1)

static inline char *omap44xx_ehci_suspendl1_status_describe(omap44xx_ehci_suspendl1_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_suspendl1_status_describe(omap44xx_ehci_suspendl1_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_SUSPENDL1_0:
        return("SUSPENDL1_0: Suspend using L2");
    case omap44xx_ehci_SUSPENDL1_1:
        return("SUSPENDL1_1: Suspend using L1 (LPM)");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_suspendl1_status_prtval(char *_s, size_t _size, omap44xx_ehci_suspendl1_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_suspendl1_status_prtval(char *_s, size_t _size, omap44xx_ehci_suspendl1_status_t _e)
{
    char *d = omap44xx_ehci_suspendl1_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_suspendl1_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.pr_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_pr_status_t;
#define omap44xx_ehci_PR_0 ((omap44xx_ehci_pr_status_t)0x0)
#define omap44xx_ehci_PR_1 ((omap44xx_ehci_pr_status_t)0x1)

static inline char *omap44xx_ehci_pr_status_describe(omap44xx_ehci_pr_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_pr_status_describe(omap44xx_ehci_pr_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PR_0:
        return("PR_0: Port is not in reset. / Terminate the bus reset sequence.");
    case omap44xx_ehci_PR_1:
        return("PR_1: Port is in reset.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_pr_status_prtval(char *_s, size_t _size, omap44xx_ehci_pr_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_pr_status_prtval(char *_s, size_t _size, omap44xx_ehci_pr_status_t _e)
{
    char *d = omap44xx_ehci_pr_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_pr_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.sus_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_sus_status_t;
#define omap44xx_ehci_SUS_0 ((omap44xx_ehci_sus_status_t)0x0)

static inline char *omap44xx_ehci_sus_status_describe(omap44xx_ehci_sus_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_sus_status_describe(omap44xx_ehci_sus_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_SUS_0:
        return("SUS_0: Port disabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_sus_status_prtval(char *_s, size_t _size, omap44xx_ehci_sus_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_sus_status_prtval(char *_s, size_t _size, omap44xx_ehci_sus_status_t _e)
{
    char *d = omap44xx_ehci_sus_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_sus_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.fpr_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_fpr_status_t;
#define omap44xx_ehci_FPR_0 ((omap44xx_ehci_fpr_status_t)0x0)
#define omap44xx_ehci_FPR_1 ((omap44xx_ehci_fpr_status_t)0x1)

static inline char *omap44xx_ehci_fpr_status_describe(omap44xx_ehci_fpr_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_fpr_status_describe(omap44xx_ehci_fpr_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_FPR_0:
        return("FPR_0: No resume (K-state) detected/driven on port");
    case omap44xx_ehci_FPR_1:
        return("FPR_1: Resume detected/driven on port");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_fpr_status_prtval(char *_s, size_t _size, omap44xx_ehci_fpr_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_fpr_status_prtval(char *_s, size_t _size, omap44xx_ehci_fpr_status_t _e)
{
    char *d = omap44xx_ehci_fpr_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_fpr_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.pedc_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_pedc_status_t;
#define omap44xx_ehci_PEDC_0_r ((omap44xx_ehci_pedc_status_t)0x0)
#define omap44xx_ehci_PEDC_1_r ((omap44xx_ehci_pedc_status_t)0x1)

static inline char *omap44xx_ehci_pedc_status_describe(omap44xx_ehci_pedc_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_pedc_status_describe(omap44xx_ehci_pedc_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PEDC_0_r:
        return("PEDC_0_r: No change.");
    case omap44xx_ehci_PEDC_1_r:
        return("PEDC_1_r: Port enabled/disabled status has changed.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_pedc_status_prtval(char *_s, size_t _size, omap44xx_ehci_pedc_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_pedc_status_prtval(char *_s, size_t _size, omap44xx_ehci_pedc_status_t _e)
{
    char *d = omap44xx_ehci_pedc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_pedc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.ped_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_ped_status_t;
#define omap44xx_ehci_PED_0 ((omap44xx_ehci_ped_status_t)0x0)
#define omap44xx_ehci_PED_1 ((omap44xx_ehci_ped_status_t)0x1)

static inline char *omap44xx_ehci_ped_status_describe(omap44xx_ehci_ped_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_ped_status_describe(omap44xx_ehci_ped_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PED_0:
        return("PED_0: Disable");
    case omap44xx_ehci_PED_1:
        return("PED_1: Enable");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_ped_status_prtval(char *_s, size_t _size, omap44xx_ehci_ped_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_ped_status_prtval(char *_s, size_t _size, omap44xx_ehci_ped_status_t _e)
{
    char *d = omap44xx_ehci_ped_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_ped_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.csc_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_csc_status_t;
#define omap44xx_ehci_CSC_0_r ((omap44xx_ehci_csc_status_t)0x0)
#define omap44xx_ehci_CSC_1_r ((omap44xx_ehci_csc_status_t)0x1)

static inline char *omap44xx_ehci_csc_status_describe(omap44xx_ehci_csc_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_csc_status_describe(omap44xx_ehci_csc_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_CSC_0_r:
        return("CSC_0_r: No change");
    case omap44xx_ehci_CSC_1_r:
        return("CSC_1_r: Change in current connect status");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_csc_status_prtval(char *_s, size_t _size, omap44xx_ehci_csc_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_csc_status_prtval(char *_s, size_t _size, omap44xx_ehci_csc_status_t _e)
{
    char *d = omap44xx_ehci_csc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_csc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.ccs_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_ccs_status_t;
#define omap44xx_ehci_CCS_0 ((omap44xx_ehci_ccs_status_t)0x0)
#define omap44xx_ehci_CCS_1 ((omap44xx_ehci_ccs_status_t)0x1)

static inline char *omap44xx_ehci_ccs_status_describe(omap44xx_ehci_ccs_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_ccs_status_describe(omap44xx_ehci_ccs_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_CCS_0:
        return("CCS_0: No device is present.");
    case omap44xx_ehci_CCS_1:
        return("CCS_1: Device is present on port.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_ccs_status_prtval(char *_s, size_t _size, omap44xx_ehci_ccs_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_ccs_status_prtval(char *_s, size_t _size, omap44xx_ehci_ccs_status_t _e)
{
    char *d = omap44xx_ehci_ccs_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_ccs_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.brk_mem_trsf_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_brk_mem_trsf_status_t;
#define omap44xx_ehci_BRK_MEM_TRSF_0 ((omap44xx_ehci_brk_mem_trsf_status_t)0x0)
#define omap44xx_ehci_BRK_MEM_TRSF_1 ((omap44xx_ehci_brk_mem_trsf_status_t)0x1)

static inline char *omap44xx_ehci_brk_mem_trsf_status_describe(omap44xx_ehci_brk_mem_trsf_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_brk_mem_trsf_status_describe(omap44xx_ehci_brk_mem_trsf_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_BRK_MEM_TRSF_0:
        return("BRK_MEM_TRSF_0: Disabled");
    case omap44xx_ehci_BRK_MEM_TRSF_1:
        return("BRK_MEM_TRSF_1: Enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_brk_mem_trsf_status_prtval(char *_s, size_t _size, omap44xx_ehci_brk_mem_trsf_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_brk_mem_trsf_status_prtval(char *_s, size_t _size, omap44xx_ehci_brk_mem_trsf_status_t _e)
{
    char *d = omap44xx_ehci_brk_mem_trsf_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_brk_mem_trsf_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.control_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_control_status_t;
#define omap44xx_ehci_CONTROL_0 ((omap44xx_ehci_control_status_t)0x0)
#define omap44xx_ehci_CONTROL_1 ((omap44xx_ehci_control_status_t)0x1)

static inline char *omap44xx_ehci_control_status_describe(omap44xx_ehci_control_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_control_status_describe(omap44xx_ehci_control_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_CONTROL_0:
        return("CONTROL_0: ULPI access done");
    case omap44xx_ehci_CONTROL_1:
        return("CONTROL_1: Start ULPI access");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_control_status_prtval(char *_s, size_t _size, omap44xx_ehci_control_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_control_status_prtval(char *_s, size_t _size, omap44xx_ehci_control_status_t _e)
{
    char *d = omap44xx_ehci_control_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_control_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.portsel_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_ehci_portsel_status_t;
#define omap44xx_ehci_PORTSEL_1 ((omap44xx_ehci_portsel_status_t)0x1)
#define omap44xx_ehci_PORTSEL_2 ((omap44xx_ehci_portsel_status_t)0x2)

static inline char *omap44xx_ehci_portsel_status_describe(omap44xx_ehci_portsel_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_portsel_status_describe(omap44xx_ehci_portsel_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_PORTSEL_1:
        return("PORTSEL_1: Port 1 selected for register access");
    case omap44xx_ehci_PORTSEL_2:
        return("PORTSEL_2: Port 2 selected for register access");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_portsel_status_prtval(char *_s, size_t _size, omap44xx_ehci_portsel_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsel_status_prtval(char *_s, size_t _size, omap44xx_ehci_portsel_status_t _e)
{
    char *d = omap44xx_ehci_portsel_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_portsel_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.opsel_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_ehci_opsel_status_t;
#define omap44xx_ehci_OPSEL_2 ((omap44xx_ehci_opsel_status_t)0x2)
#define omap44xx_ehci_OPSEL_3 ((omap44xx_ehci_opsel_status_t)0x3)

static inline char *omap44xx_ehci_opsel_status_describe(omap44xx_ehci_opsel_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_opsel_status_describe(omap44xx_ehci_opsel_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_OPSEL_2:
        return("OPSEL_2: Register access is write.");
    case omap44xx_ehci_OPSEL_3:
        return("OPSEL_3: Register access is read.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_opsel_status_prtval(char *_s, size_t _size, omap44xx_ehci_opsel_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_opsel_status_prtval(char *_s, size_t _size, omap44xx_ehci_opsel_status_t _e)
{
    char *d = omap44xx_ehci_opsel_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_opsel_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.regadd_status ()
 *  - width 6 bits
 */
typedef uint8_t omap44xx_ehci_regadd_status_t;
#define omap44xx_ehci_REGADD_47 ((omap44xx_ehci_regadd_status_t)0x2f)

static inline char *omap44xx_ehci_regadd_status_describe(omap44xx_ehci_regadd_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_regadd_status_describe(omap44xx_ehci_regadd_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_REGADD_47:
        return("REGADD_47: Triggers an extended address");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_regadd_status_prtval(char *_s, size_t _size, omap44xx_ehci_regadd_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_regadd_status_prtval(char *_s, size_t _size, omap44xx_ehci_regadd_status_t _e)
{
    char *d = omap44xx_ehci_regadd_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_regadd_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.vbusy_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_vbusy_status_t;
#define omap44xx_ehci_VBUSY_0_r ((omap44xx_ehci_vbusy_status_t)0x0)
#define omap44xx_ehci_VBUSY_1_r ((omap44xx_ehci_vbusy_status_t)0x1)

static inline char *omap44xx_ehci_vbusy_status_describe(omap44xx_ehci_vbusy_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_vbusy_status_describe(omap44xx_ehci_vbusy_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_VBUSY_0_r:
        return("VBUSY_0_r: Vendor interface is done/inactive");
    case omap44xx_ehci_VBUSY_1_r:
        return("VBUSY_1_r: Vendor interface is busy");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_vbusy_status_prtval(char *_s, size_t _size, omap44xx_ehci_vbusy_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_vbusy_status_prtval(char *_s, size_t _size, omap44xx_ehci_vbusy_status_t _e)
{
    char *d = omap44xx_ehci_vbusy_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_vbusy_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.vport_status ()
 *  - width 4 bits
 */
typedef uint8_t omap44xx_ehci_vport_status_t;
#define omap44xx_ehci_VPORT_1 ((omap44xx_ehci_vport_status_t)0x1)
#define omap44xx_ehci_VPORT_2 ((omap44xx_ehci_vport_status_t)0x2)

static inline char *omap44xx_ehci_vport_status_describe(omap44xx_ehci_vport_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_vport_status_describe(omap44xx_ehci_vport_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_VPORT_1:
        return("VPORT_1: Port 1 vendor interface selected");
    case omap44xx_ehci_VPORT_2:
        return("VPORT_2: Port 2 vendor interface selected");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_vport_status_prtval(char *_s, size_t _size, omap44xx_ehci_vport_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_vport_status_prtval(char *_s, size_t _size, omap44xx_ehci_vport_status_t _e)
{
    char *d = omap44xx_ehci_vport_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_vport_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.vcontrolloadm_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_vcontrolloadm_status_t;
#define omap44xx_ehci_VCONTROLLOADM_0 ((omap44xx_ehci_vcontrolloadm_status_t)0x0)
#define omap44xx_ehci_VCONTROLLOADM_1 ((omap44xx_ehci_vcontrolloadm_status_t)0x1)

static inline char *omap44xx_ehci_vcontrolloadm_status_describe(omap44xx_ehci_vcontrolloadm_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_vcontrolloadm_status_describe(omap44xx_ehci_vcontrolloadm_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_VCONTROLLOADM_0:
        return("VCONTROLLOADM_0: Load Vcontrol value into PHY");
    case omap44xx_ehci_VCONTROLLOADM_1:
        return("VCONTROLLOADM_1: No Action");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_vcontrolloadm_status_prtval(char *_s, size_t _size, omap44xx_ehci_vcontrolloadm_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_vcontrolloadm_status_prtval(char *_s, size_t _size, omap44xx_ehci_vcontrolloadm_status_t _e)
{
    char *d = omap44xx_ehci_vcontrolloadm_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_vcontrolloadm_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ehci.errorcap_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ehci_errorcap_status_t;
#define omap44xx_ehci_ERRORCAP_0_w ((omap44xx_ehci_errorcap_status_t)0x0)
#define omap44xx_ehci_ERRORCAP_1_r ((omap44xx_ehci_errorcap_status_t)0x1)

static inline char *omap44xx_ehci_errorcap_status_describe(omap44xx_ehci_errorcap_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ehci_errorcap_status_describe(omap44xx_ehci_errorcap_status_t _e)
{
    switch (_e) {
    case omap44xx_ehci_ERRORCAP_0_w:
        return("ERRORCAP_0_w: Clear pending error");
    case omap44xx_ehci_ERRORCAP_1_r:
        return("ERRORCAP_1_r: Error pending");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ehci_errorcap_status_prtval(char *_s, size_t _size, omap44xx_ehci_errorcap_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ehci_errorcap_status_prtval(char *_s, size_t _size, omap44xx_ehci_errorcap_status_t _e)
{
    char *d = omap44xx_ehci_errorcap_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ehci_errorcap_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_ehci_hccapbase_t
 * Description: Implicit type of Host controller capability register register
 * Fields:
 *   caplength	(size 8, offset 0, init 0):	RO	Capability register length
 *   _anon8	(size 8, offset 8, init 0):	MBZ	_
 *   hciversion	(size 16, offset 16, init 0):	RO	Interface version number. It contains a BCD encoding of the EHCI revision number supported by this host controller.[7:4] Major revision . [3:0] Minor revision .
 */
typedef uint32_t omap44xx_ehci_hccapbase_t;
#define omap44xx_ehci_hccapbase_default 0x0
static inline uint8_t omap44xx_ehci_hccapbase_caplength_extract(omap44xx_ehci_hccapbase_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hccapbase_caplength_extract(omap44xx_ehci_hccapbase_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_caplength_insert(omap44xx_ehci_hccapbase_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_caplength_insert(omap44xx_ehci_hccapbase_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_ehci_hccapbase_t )(_fieldval)) << 0)));
}

static inline uint16_t omap44xx_ehci_hccapbase_hciversion_extract(omap44xx_ehci_hccapbase_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_hccapbase_hciversion_extract(omap44xx_ehci_hccapbase_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_hciversion_insert(omap44xx_ehci_hccapbase_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_hciversion_insert(omap44xx_ehci_hccapbase_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((omap44xx_ehci_hccapbase_t )(_fieldval)) << 16)));
}

static inline int omap44xx_ehci_hccapbase_prtval(char *_s, size_t _size, omap44xx_ehci_hccapbase_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hccapbase_prtval(char *_s, size_t _size, omap44xx_ehci_hccapbase_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " caplength =\t%" PRIx8 "\t(Capability register length)\n", omap44xx_ehci_hccapbase_caplength_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hciversion =\t%" PRIx16 "\t(Interface version number. It contains a BCD encoding of the EHCI revision number supported by this host controller.[7:4] Major revision . [3:0] Minor revision .)\n", omap44xx_ehci_hccapbase_hciversion_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_hcsparams_t
 * Description: Implicit type of Host controller structural parameters register
 * Fields:
 *   n_ports	(size 4, offset 0, init 0):	RO	Number of downstream portsThis field specifies the number of physical downstream ports implemented on this host controller. .
 *   ppc	(size 1, offset 4, init 0):	RO	Port power controlThis field indicates whether the host controller implementation includes port power control. .
 *   _anon5	(size 2, offset 5, init 0):	MBZ	_
 *   prr	(size 1, offset 7, init 0):	RO	Port routing rulesThe first N_PCC ports are routed to the lowest-numbered function companion host controller, the next N_PCC ports are routed to the next lowest-function companion controller, and so on. .
 *   n_pcc	(size 4, offset 8, init 0):	RO	Number of ports per companion controllerThis field indicates the number of ports supported per companion host controller. It is used to indicate the port routing configuration to system software. . For example, if N_PORTS has a value of 6 and N_CC has a value of 2, then N_PCC can have a value of 3. . The convention is that the first N_PCC ports are assumed to be routed to companion controller 1, the next N_PCC ports to companion controller 2, etc. . The number in this field must be consistent with N_PORTS and N_CC. .
 *   n_cc	(size 4, offset 12, init 0):	RO	Number of companion controllersThis field indicates the number of companion controllers associated with this USB 2.0 host controller. . Others: There are companion USB 1.1 host controller(s). Port-ownership hand-off is supported. High-, full-, and low-speed devices are supported on the host controller root ports. .
 *   p_indicator	(size 1, offset 16, init 0):	RO	Port indicator support indicationThis bit indicates whether the ports support port indicator control. .
 *   _anon17	(size 3, offset 17, init 0):	MBZ	_
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_hcsparams_t;
#define omap44xx_ehci_hcsparams_default 0x0
static inline uint8_t omap44xx_ehci_hcsparams_n_ports_extract(omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hcsparams_n_ports_extract(omap44xx_ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_n_ports_insert(omap44xx_ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_n_ports_insert(omap44xx_ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_ehci_hcsparams_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_ppc_status_t omap44xx_ehci_hcsparams_ppc_extract(omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ppc_status_t omap44xx_ehci_hcsparams_ppc_extract(omap44xx_ehci_hcsparams_t _regval)
{
    return((omap44xx_ehci_ppc_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_ppc_insert(omap44xx_ehci_hcsparams_t _regval, omap44xx_ehci_ppc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_ppc_insert(omap44xx_ehci_hcsparams_t _regval, omap44xx_ehci_ppc_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_ehci_hcsparams_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_ehci_hcsparams_prr_extract(omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hcsparams_prr_extract(omap44xx_ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_prr_insert(omap44xx_ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_prr_insert(omap44xx_ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_ehci_hcsparams_t )(_fieldval)) << 7)));
}

static inline uint8_t omap44xx_ehci_hcsparams_n_pcc_extract(omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hcsparams_n_pcc_extract(omap44xx_ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_n_pcc_insert(omap44xx_ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_n_pcc_insert(omap44xx_ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((omap44xx_ehci_hcsparams_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hcsparams_n_cc_extract(omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hcsparams_n_cc_extract(omap44xx_ehci_hcsparams_t _regval)
{
    return((omap44xx_ehci_n_cc_status_t )((_regval & 0xf000) >> 12));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_n_cc_insert(omap44xx_ehci_hcsparams_t _regval, omap44xx_ehci_n_cc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_n_cc_insert(omap44xx_ehci_hcsparams_t _regval, omap44xx_ehci_n_cc_status_t _fieldval)
{
    return((_regval & 0xffff0fff) | (0xf000 & (((omap44xx_ehci_hcsparams_t )(_fieldval)) << 12)));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hcsparams_p_indicator_extract(omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hcsparams_p_indicator_extract(omap44xx_ehci_hcsparams_t _regval)
{
    return((omap44xx_ehci_p_indicator_status_t )((_regval & 0x10000) >> 16));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_p_indicator_insert(omap44xx_ehci_hcsparams_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_p_indicator_insert(omap44xx_ehci_hcsparams_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((omap44xx_ehci_hcsparams_t )(_fieldval)) << 16)));
}

static inline int omap44xx_ehci_hcsparams_prtval(char *_s, size_t _size, omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hcsparams_prtval(char *_s, size_t _size, omap44xx_ehci_hcsparams_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_ports =\t%" PRIx8 "\t(Number of downstream portsThis field specifies the number of physical downstream ports implemented on this host controller. .)\n", omap44xx_ehci_hcsparams_n_ports_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ppc_status_prtval(_s + _r, _avail, omap44xx_ehci_hcsparams_ppc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port power controlThis field indicates whether the host controller implementation includes port power control. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prr =\t%" PRIx8 "\t(Port routing rulesThe first N_PCC ports are routed to the lowest-numbered function companion host controller, the next N_PCC ports are routed to the next lowest-function companion controller, and so on. .)\n", omap44xx_ehci_hcsparams_prr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_pcc =\t%" PRIx8 "\t(Number of ports per companion controllerThis field indicates the number of ports supported per companion host controller. It is used to indicate the port routing configuration to system software. . For example, if N_PORTS has a value of 6 and N_CC has a value of 2, then N_PCC can have a value of 3. . The convention is that the first N_PCC ports are assumed to be routed to companion controller 1, the next N_PCC ports to companion controller 2, etc. . The number in this field must be consistent with N_PORTS and N_CC. .)\n", omap44xx_ehci_hcsparams_n_pcc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_cc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_n_cc_status_prtval(_s + _r, _avail, omap44xx_ehci_hcsparams_n_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Number of companion controllersThis field indicates the number of companion controllers associated with this USB 2.0 host controller. . Others: There are companion USB 1.1 host controller(s). Port-ownership hand-off is supported. High-, full-, and low-speed devices are supported on the host controller root ports. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_indicator =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_hcsparams_p_indicator_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port indicator support indicationThis bit indicates whether the ports support port indicator control. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_hccparams_t
 * Description: Implicit type of Host controller capability parameters register
 * Fields:
 *   bit64ac	(size 1, offset 0, init 0):	RO	64-bit addressing capabilityThis field documents the addressing range capability of this implementation. .
 *   pflf	(size 1, offset 1, init 0):	RO	Programmable frame list flag
 *   aspc	(size 1, offset 2, init 0):	RO	Asynchronous schedule park capabilityThe feature can be disabled or enabled and set to a specific level by using the USBHOST.[11]ASPME bit and the USBHOST.[9:8] ASPMC bit field. .
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   ist	(size 4, offset 4, init 0):	RO	Isochronous scheduling thresholdThis field indicates where software can reliably update the isochronous schedule in relation to the current position of the executing host controller. . The host controller can hold one microframe of isochronous data structures before flushing the state. .
 *   eecp	(size 8, offset 8, init 0):	RO	EHCI extended capabilities pointerThis field indicates the existence of a capabilities list. . Others: The offset in PCI configuration space of the first EHCI extended capability. .
 *   _anon16	(size 1, offset 16, init 0):	MBZ	_
 *   lpm	(size 1, offset 17, init 0):	RO	Link power management capability
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_hccparams_t;
#define omap44xx_ehci_hccparams_default 0x0
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_hccparams_bit64ac_extract(omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_hccparams_bit64ac_extract(omap44xx_ehci_hccparams_t _regval)
{
    return((omap44xx_ehci_bit64ac_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_bit64ac_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_bit64ac_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_hccparams_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_pflf_status_t omap44xx_ehci_hccparams_pflf_extract(omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pflf_status_t omap44xx_ehci_hccparams_pflf_extract(omap44xx_ehci_hccparams_t _regval)
{
    return((omap44xx_ehci_pflf_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_pflf_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_pflf_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_pflf_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_pflf_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_hccparams_t )(_fieldval)) << 1)));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hccparams_aspc_extract(omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hccparams_aspc_extract(omap44xx_ehci_hccparams_t _regval)
{
    return((omap44xx_ehci_p_indicator_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_aspc_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_aspc_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_hccparams_t )(_fieldval)) << 2)));
}

static inline uint8_t omap44xx_ehci_hccparams_ist_extract(omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hccparams_ist_extract(omap44xx_ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_ist_insert(omap44xx_ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_ist_insert(omap44xx_ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((omap44xx_ehci_hccparams_t )(_fieldval)) << 4)));
}

static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hccparams_eecp_extract(omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hccparams_eecp_extract(omap44xx_ehci_hccparams_t _regval)
{
    return((omap44xx_ehci_n_cc_status_t )((_regval & 0xff00) >> 8));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_eecp_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_n_cc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_eecp_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_n_cc_status_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((omap44xx_ehci_hccparams_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_lpm_status_t omap44xx_ehci_hccparams_lpm_extract(omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_lpm_status_t omap44xx_ehci_hccparams_lpm_extract(omap44xx_ehci_hccparams_t _regval)
{
    return((omap44xx_ehci_lpm_status_t )((_regval & 0x20000) >> 17));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_lpm_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_lpm_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_lpm_insert(omap44xx_ehci_hccparams_t _regval, omap44xx_ehci_lpm_status_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((omap44xx_ehci_hccparams_t )(_fieldval)) << 17)));
}

static inline int omap44xx_ehci_hccparams_prtval(char *_s, size_t _size, omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hccparams_prtval(char *_s, size_t _size, omap44xx_ehci_hccparams_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit64ac =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_bit64ac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(64-bit addressing capabilityThis field documents the addressing range capability of this implementation. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pflf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pflf_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_pflf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Programmable frame list flag)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_aspc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule park capabilityThe feature can be disabled or enabled and set to a specific level by using the USBHOST.[11]ASPME bit and the USBHOST.[9:8] ASPMC bit field. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ist =\t%" PRIx8 "\t(Isochronous scheduling thresholdThis field indicates where software can reliably update the isochronous schedule in relation to the current position of the executing host controller. . The host controller can hold one microframe of isochronous data structures before flushing the state. .)\n", omap44xx_ehci_hccparams_ist_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_n_cc_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_eecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(EHCI extended capabilities pointerThis field indicates the existence of a capabilities list. . Others: The offset in PCI configuration space of the first EHCI extended capability. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_lpm_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_lpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link power management capability)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_usbcmd_t
 * Description: Implicit type of USB command register
 * Fields:
 *   rs	(size 1, offset 0, init 0):	RW	Run/stop
 *   hcr	(size 1, offset 1, init 0):	WO	Host controller resetThis control bit is used by software to reset the host controller. Write . This bit is set to 0 by the host controller when the reset process is complete. .
 *   fls	(size 2, offset 2, init 0):	RW	Frame list sizeThis field specifies the size of the frame list. The size of the frame list controls which bits in the frame index register should be used for the frame list current index. .
 *   pse	(size 1, offset 4, init 0):	RW	Periodic schedule enableThis bit controls whether the host controller skips processing the periodic schedule. .
 *   ase	(size 1, offset 5, init 0):	RW	Asynchronous schedule enableThis bit controls whether the host controller skips processing the asynchronous schedule. .
 *   iaad	(size 1, offset 6, init 0):	RW	Interrupt on async advance doorbellThis bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. . Software must not write 1 to this bit when the asynchronous schedule is disabled. Doing so may yield undefined results. .
 *   lhcr	(size 1, offset 7, init 0):	RW	Light host controller resetIt allows the driver to reset the EHCI controller without affecting the state of the ports or the relationship to the companion host controllers. .
 *   aspmc	(size 2, offset 8, init 0):	RW	Asynchronous schedule park mode countIt contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the asynchronous schedule before continuing traversal of the asynchronous schedule. . Valid values are 0x1 to 0x3. Software must not write 0 to this bit when park mode enable is 1 because this may result in undefined behavior. .
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   aspme	(size 1, offset 11, init 0):	RW	Asynchronous schedule park mode enable
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   itc	(size 8, offset 16, init 0):	RW	Interrupt threshold controlThis field is used by the system software to select the maximum rate at which the host controller issues interrupts. The only valid values are defined below. If software writes an invalid value to this register, the results are undefined. . Others: Undefined .
 *   hird	(size 4, offset 24, init 0):	RW	Host-initiated resume duration.If LPM is enabled, this field is RW; otherwise, it is R. . The minimum for K-state during resume from LPM: . Each increment adds 75 us. .
 *   _anon28	(size 4, offset 28, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_usbcmd_t;
#define omap44xx_ehci_usbcmd_default 0x0
static inline omap44xx_ehci_rs_status_t omap44xx_ehci_usbcmd_rs_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_rs_status_t omap44xx_ehci_usbcmd_rs_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_rs_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_rs_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_rs_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_rs_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_rs_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_hcr_status_t omap44xx_ehci_usbcmd_hcr_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcr_status_t omap44xx_ehci_usbcmd_hcr_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_hcr_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_hcr_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_hcr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_hcr_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_hcr_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 1)));
}

static inline omap44xx_ehci_fls_status_t omap44xx_ehci_usbcmd_fls_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_fls_status_t omap44xx_ehci_usbcmd_fls_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_fls_status_t )((_regval & 0xc) >> 2));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_fls_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_fls_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_fls_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_fls_status_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 2)));
}

static inline omap44xx_ehci_pse_status_t omap44xx_ehci_usbcmd_pse_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pse_status_t omap44xx_ehci_usbcmd_pse_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_pse_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_pse_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_pse_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_pse_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_pse_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 4)));
}

static inline omap44xx_ehci_ase_status_t omap44xx_ehci_usbcmd_ase_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ase_status_t omap44xx_ehci_usbcmd_ase_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_ase_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_ase_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_ase_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_ase_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_ase_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 5)));
}

static inline omap44xx_ehci_iaad_status_t omap44xx_ehci_usbcmd_iaad_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_iaad_status_t omap44xx_ehci_usbcmd_iaad_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_iaad_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_iaad_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_iaad_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_iaad_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_iaad_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 6)));
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbcmd_lhcr_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbcmd_lhcr_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_bit64ac_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_lhcr_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_lhcr_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 7)));
}

static inline uint8_t omap44xx_ehci_usbcmd_aspmc_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbcmd_aspmc_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_aspmc_insert(omap44xx_ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_aspmc_insert(omap44xx_ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_aspme_status_t omap44xx_ehci_usbcmd_aspme_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_aspme_status_t omap44xx_ehci_usbcmd_aspme_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_aspme_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_aspme_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_aspme_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_aspme_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_aspme_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 11)));
}

static inline omap44xx_ehci_itc_status_t omap44xx_ehci_usbcmd_itc_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_itc_status_t omap44xx_ehci_usbcmd_itc_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_itc_status_t )((_regval & 0xff0000) >> 16));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_itc_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_itc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_itc_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_itc_status_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 16)));
}

static inline omap44xx_ehci_hird_status_t omap44xx_ehci_usbcmd_hird_extract(omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hird_status_t omap44xx_ehci_usbcmd_hird_extract(omap44xx_ehci_usbcmd_t _regval)
{
    return((omap44xx_ehci_hird_status_t )((_regval & 0xf000000) >> 24));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_hird_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_hird_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_hird_insert(omap44xx_ehci_usbcmd_t _regval, omap44xx_ehci_hird_status_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 24)));
}

static inline int omap44xx_ehci_usbcmd_prtval(char *_s, size_t _size, omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbcmd_prtval(char *_s, size_t _size, omap44xx_ehci_usbcmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_rs_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Run/stop)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hcr_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host controller resetThis control bit is used by software to reset the host controller. Write . This bit is set to 0 by the host controller when the reset process is complete. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fls_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_fls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list sizeThis field specifies the size of the frame list. The size of the frame list controls which bits in the frame index register should be used for the frame list current index. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pse_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Periodic schedule enableThis bit controls whether the host controller skips processing the periodic schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ase =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ase_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_ase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule enableThis bit controls whether the host controller skips processing the asynchronous schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaad =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_iaad_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_iaad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt on async advance doorbellThis bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. . Software must not write 1 to this bit when the asynchronous schedule is disabled. Doing so may yield undefined results. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lhcr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_lhcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Light host controller resetIt allows the driver to reset the EHCI controller without affecting the state of the ports or the relationship to the companion host controllers. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspmc =\t%" PRIx8 "\t(Asynchronous schedule park mode countIt contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the asynchronous schedule before continuing traversal of the asynchronous schedule. . Valid values are 0x1 to 0x3. Software must not write 0 to this bit when park mode enable is 1 because this may result in undefined behavior. .)\n", omap44xx_ehci_usbcmd_aspmc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspme =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_aspme_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_aspme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule park mode enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_itc_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_itc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt threshold controlThis field is used by the system software to select the maximum rate at which the host controller issues interrupts. The only valid values are defined below. If software writes an invalid value to this register, the results are undefined. . Others: Undefined .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hird =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hird_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_hird_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host-initiated resume duration.If LPM is enabled, this field is RW; otherwise, it is R. . The minimum for K-state during resume from LPM: . Each increment adds 75 us. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_usbsts_t
 * Description: Implicit type of USB status register
 * Fields:
 *   usbi	(size 1, offset 0, init 0):	RW	USB interruptThe host controller sets this bit to 1 on completion of a USB transaction, which results in the retirement of a transfer descriptor that had its IOC bit set. . The host controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes). .
 *   usbei	(size 1, offset 1, init 0):	RW	USB error interruptThe host controller sets this bit to 1 when completion of a USB transaction results in an error condition. .
 *   pcd	(size 1, offset 2, init 0):	RW	Port change detectThe host controller sets this bit to 1 when any port for which the USBHOST.[13] PO bit is set to 0 has a change bit transition from 0 to 1 or a USBHOST.[6] FPR bit transition from 0 to 1. . This bit is also set as a result of the USBHOST.[1] CSC bit being set to 1 after system software has relinquished ownership of a connected port by setting the USBHOST.[13] PO bit to 1. .
 *   flr	(size 1, offset 3, init 0):	RW	Frame list rolloverThe host controller sets this bit to 1 when the USBHOST. rolls over from its maximum value to 0. The exact value at which the rollover occurs depends on the frame list size. .
 *   hse	(size 1, offset 4, init 0):	RW	Host system errorThe host controller sets this bit to 1 when a serious error occurs during a host system access involving the host controller module. .
 *   iaa	(size 1, offset 5, init 0):	RW	Interrupt on async advanceSystem software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by setting the USBHOST.[6] IAAD bit to 1. This status bit indicates the assertion of that interrupt source. .
 *   _anon6	(size 6, offset 6, init 0):	MBZ	_
 *   hch	(size 1, offset 12, init 0):	RO	Host controller haltedThis bit is a 0 whenever the USBHOST.[0] RS bit is a 1. The host controller sets this bit to 1 after it has stopped executing as a result of the RS bit being set to 0, either by software or by the host controller hardware. .
 *   rec	(size 1, offset 13, init 0):	RO	ReclamationIt is used to detect an empty asynchronous schedule. .
 *   pss	(size 1, offset 14, init 0):	RO	Periodic schedule statusThe bit reports the current real status of the periodic schedule. .
 *   ass	(size 1, offset 15, init 0):	RO	Asynchronous schedule statusThe bit reports the current real status of the asynchronous schedule. .
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_usbsts_t;
#define omap44xx_ehci_usbsts_default 0x0
static inline uint8_t omap44xx_ehci_usbsts_usbi_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_usbi_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_usbi_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_usbi_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ehci_usbsts_usbei_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_usbei_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_usbei_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_usbei_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_ehci_usbsts_pcd_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_pcd_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_pcd_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_pcd_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 2)));
}

static inline uint8_t omap44xx_ehci_usbsts_flr_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_flr_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_flr_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_flr_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 3)));
}

static inline uint8_t omap44xx_ehci_usbsts_hse_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_hse_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_hse_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_hse_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_ehci_usbsts_iaa_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_iaa_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_iaa_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_iaa_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 5)));
}

static inline uint8_t omap44xx_ehci_usbsts_hch_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_hch_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_hch_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_hch_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 12)));
}

static inline uint8_t omap44xx_ehci_usbsts_rec_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_rec_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_rec_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_rec_insert(omap44xx_ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 13)));
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_pss_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_pss_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((omap44xx_ehci_bit64ac_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_pss_insert(omap44xx_ehci_usbsts_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_pss_insert(omap44xx_ehci_usbsts_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 14)));
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_ass_extract(omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_ass_extract(omap44xx_ehci_usbsts_t _regval)
{
    return((omap44xx_ehci_bit64ac_status_t )((_regval & 0x8000) >> 15));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_ass_insert(omap44xx_ehci_usbsts_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_ass_insert(omap44xx_ehci_usbsts_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 15)));
}

static inline int omap44xx_ehci_usbsts_prtval(char *_s, size_t _size, omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbsts_prtval(char *_s, size_t _size, omap44xx_ehci_usbsts_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbi =\t%" PRIx8 "\t(USB interruptThe host controller sets this bit to 1 on completion of a USB transaction, which results in the retirement of a transfer descriptor that had its IOC bit set. . The host controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes). .)\n", omap44xx_ehci_usbsts_usbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbei =\t%" PRIx8 "\t(USB error interruptThe host controller sets this bit to 1 when completion of a USB transaction results in an error condition. .)\n", omap44xx_ehci_usbsts_usbei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Port change detectThe host controller sets this bit to 1 when any port for which the USBHOST.[13] PO bit is set to 0 has a change bit transition from 0 to 1 or a USBHOST.[6] FPR bit transition from 0 to 1. . This bit is also set as a result of the USBHOST.[1] CSC bit being set to 1 after system software has relinquished ownership of a connected port by setting the USBHOST.[13] PO bit to 1. .)\n", omap44xx_ehci_usbsts_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr =\t%" PRIx8 "\t(Frame list rolloverThe host controller sets this bit to 1 when the USBHOST. rolls over from its maximum value to 0. The exact value at which the rollover occurs depends on the frame list size. .)\n", omap44xx_ehci_usbsts_flr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hse =\t%" PRIx8 "\t(Host system errorThe host controller sets this bit to 1 when a serious error occurs during a host system access involving the host controller module. .)\n", omap44xx_ehci_usbsts_hse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaa =\t%" PRIx8 "\t(Interrupt on async advanceSystem software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by setting the USBHOST.[6] IAAD bit to 1. This status bit indicates the assertion of that interrupt source. .)\n", omap44xx_ehci_usbsts_iaa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hch =\t%" PRIx8 "\t(Host controller haltedThis bit is a 0 whenever the USBHOST.[0] RS bit is a 1. The host controller sets this bit to 1 after it has stopped executing as a result of the RS bit being set to 0, either by software or by the host controller hardware. .)\n", omap44xx_ehci_usbsts_hch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rec =\t%" PRIx8 "\t(ReclamationIt is used to detect an empty asynchronous schedule. .)\n", omap44xx_ehci_usbsts_rec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_usbsts_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Periodic schedule statusThe bit reports the current real status of the periodic schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_usbsts_ass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule statusThe bit reports the current real status of the asynchronous schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_usbintr_t
 * Description: Implicit type of USB interrupt enable register
 * Fields:
 *   usbie	(size 1, offset 0, init 0):	RW	USB interrupt enable
 *   usbeie	(size 1, offset 1, init 0):	RW	USB error interrupt enable
 *   pcie	(size 1, offset 2, init 0):	RW	Port change interrupt enable
 *   flre	(size 1, offset 3, init 0):	RW	Frame list rollover enable
 *   hsee	(size 1, offset 4, init 0):	RW	Host system error enable
 *   iaae	(size 1, offset 5, init 0):	RW	Interrupt on async advance enable
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_usbintr_t;
#define omap44xx_ehci_usbintr_default 0x0
static inline omap44xx_ehci_usbie_status_t omap44xx_ehci_usbintr_usbie_extract(omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbie_status_t omap44xx_ehci_usbintr_usbie_extract(omap44xx_ehci_usbintr_t _regval)
{
    return((omap44xx_ehci_usbie_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_usbie_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_usbie_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_usbie_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_usbie_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_usbeie_status_t omap44xx_ehci_usbintr_usbeie_extract(omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbeie_status_t omap44xx_ehci_usbintr_usbeie_extract(omap44xx_ehci_usbintr_t _regval)
{
    return((omap44xx_ehci_usbeie_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_usbeie_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_usbeie_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_usbeie_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_usbeie_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 1)));
}

static inline omap44xx_ehci_pcie_status_t omap44xx_ehci_usbintr_pcie_extract(omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pcie_status_t omap44xx_ehci_usbintr_pcie_extract(omap44xx_ehci_usbintr_t _regval)
{
    return((omap44xx_ehci_pcie_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_pcie_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_pcie_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_pcie_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_pcie_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 2)));
}

static inline omap44xx_ehci_flre_status_t omap44xx_ehci_usbintr_flre_extract(omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_flre_status_t omap44xx_ehci_usbintr_flre_extract(omap44xx_ehci_usbintr_t _regval)
{
    return((omap44xx_ehci_flre_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_flre_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_flre_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_flre_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_flre_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 3)));
}

static inline omap44xx_ehci_hsee_status_t omap44xx_ehci_usbintr_hsee_extract(omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_hsee_status_t omap44xx_ehci_usbintr_hsee_extract(omap44xx_ehci_usbintr_t _regval)
{
    return((omap44xx_ehci_hsee_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_hsee_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_hsee_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_hsee_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_hsee_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 4)));
}

static inline omap44xx_ehci_iaae_status_t omap44xx_ehci_usbintr_iaae_extract(omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_iaae_status_t omap44xx_ehci_usbintr_iaae_extract(omap44xx_ehci_usbintr_t _regval)
{
    return((omap44xx_ehci_iaae_status_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_iaae_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_iaae_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_iaae_insert(omap44xx_ehci_usbintr_t _regval, omap44xx_ehci_iaae_status_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 5)));
}

static inline int omap44xx_ehci_usbintr_prtval(char *_s, size_t _size, omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbintr_prtval(char *_s, size_t _size, omap44xx_ehci_usbintr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbie =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbie_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_usbie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB interrupt enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbeie =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbeie_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_usbeie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB error interrupt enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pcie_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_pcie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port change interrupt enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flre =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_flre_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_flre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list rollover enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsee =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hsee_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_hsee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host system error enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaae =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_iaae_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_iaae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt on async advance enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_frindex_t
 * Description: Implicit type of USB frame index register
 * Fields:
 *   fi	(size 14, offset 0, init 0):	RW	Frame indexThe value in this register is incremented at the end of each time frame. .
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_frindex_t;
#define omap44xx_ehci_frindex_default 0x0
static inline uint16_t omap44xx_ehci_frindex_fi_extract(omap44xx_ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_frindex_fi_extract(omap44xx_ehci_frindex_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline omap44xx_ehci_frindex_t omap44xx_ehci_frindex_fi_insert(omap44xx_ehci_frindex_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_frindex_t omap44xx_ehci_frindex_fi_insert(omap44xx_ehci_frindex_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((omap44xx_ehci_frindex_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ehci_frindex_prtval(char *_s, size_t _size, omap44xx_ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_frindex_prtval(char *_s, size_t _size, omap44xx_ehci_frindex_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame indexThe value in this register is incremented at the end of each time frame. .)\n", omap44xx_ehci_frindex_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_periodiclistbase_t
 * Description: Implicit type of Frame list base address register
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   bal	(size 20, offset 12, init 0):	RW	Base address (low)These bits correspond to memory address signals. .
 */
typedef uint32_t omap44xx_ehci_periodiclistbase_t;
#define omap44xx_ehci_periodiclistbase_default 0x0
static inline uint32_t omap44xx_ehci_periodiclistbase_bal_extract(omap44xx_ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_periodiclistbase_bal_extract(omap44xx_ehci_periodiclistbase_t _regval)
{
    return((uint32_t )((_regval & 0xfffff000) >> 12));
}

static inline omap44xx_ehci_periodiclistbase_t omap44xx_ehci_periodiclistbase_bal_insert(omap44xx_ehci_periodiclistbase_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_periodiclistbase_t omap44xx_ehci_periodiclistbase_bal_insert(omap44xx_ehci_periodiclistbase_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff) | (0xfffff000 & (((omap44xx_ehci_periodiclistbase_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ehci_periodiclistbase_prtval(char *_s, size_t _size, omap44xx_ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_periodiclistbase_prtval(char *_s, size_t _size, omap44xx_ehci_periodiclistbase_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bal =\t%" PRIx32 "\t(Base address (low)These bits correspond to memory address signals. .)\n", omap44xx_ehci_periodiclistbase_bal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_asynclistaddr_t
 * Description: Implicit type of Next asynchronous list address register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   lpl	(size 27, offset 5, init 0):	RW	Link pointer lowIt contains the address of the next asynchronous queue head to be executed. .
 */
typedef uint32_t omap44xx_ehci_asynclistaddr_t;
#define omap44xx_ehci_asynclistaddr_default 0x0
static inline uint32_t omap44xx_ehci_asynclistaddr_lpl_extract(omap44xx_ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_asynclistaddr_lpl_extract(omap44xx_ehci_asynclistaddr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffe0) >> 5));
}

static inline omap44xx_ehci_asynclistaddr_t omap44xx_ehci_asynclistaddr_lpl_insert(omap44xx_ehci_asynclistaddr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_asynclistaddr_t omap44xx_ehci_asynclistaddr_lpl_insert(omap44xx_ehci_asynclistaddr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x1f) | (0xffffffe0 & (((omap44xx_ehci_asynclistaddr_t )(_fieldval)) << 5)));
}

static inline int omap44xx_ehci_asynclistaddr_prtval(char *_s, size_t _size, omap44xx_ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_asynclistaddr_prtval(char *_s, size_t _size, omap44xx_ehci_asynclistaddr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpl =\t%" PRIx32 "\t(Link pointer lowIt contains the address of the next asynchronous queue head to be executed. .)\n", omap44xx_ehci_asynclistaddr_lpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_configflag_t
 * Description: Implicit type of Configured flag register register
 * Fields:
 *   cf	(size 1, offset 0, init 0):	RW	Configure flagThis bit controls the default port-routing control logic. .
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_configflag_t;
#define omap44xx_ehci_configflag_default 0x0
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_configflag_cf_extract(omap44xx_ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_configflag_cf_extract(omap44xx_ehci_configflag_t _regval)
{
    return((omap44xx_ehci_bit64ac_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_configflag_t omap44xx_ehci_configflag_cf_insert(omap44xx_ehci_configflag_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_configflag_t omap44xx_ehci_configflag_cf_insert(omap44xx_ehci_configflag_t _regval, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_configflag_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ehci_configflag_prtval(char *_s, size_t _size, omap44xx_ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_configflag_prtval(char *_s, size_t _size, omap44xx_ehci_configflag_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_configflag_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Configure flagThis bit controls the default port-routing control logic. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_portsc_i_0_t
 * Description: Implicit type of Port status/control register
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .
 *   csc	(size 1, offset 1, init 0):	RW	Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .
 *   pedc	(size 1, offset 3, init 0):	RW	Port enabled/disabled changeThis field is 0 if the PP bit is 0. .
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resumeThis field is 0 if the PP bit is 0. .
 *   sus	(size 1, offset 7, init 0):	RW	SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .
 *   pr	(size 1, offset 8, init 0):	RW	Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .
 *   suspendl1	(size 1, offset 9, init 0):	RW	When this bit is set to 1, an LPM token is generated.
 *   ls	(size 2, offset 10, init 0):	RO	Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .
 *   pp	(size 1, offset 12, init 0):	RW	Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .
 *   po	(size 1, offset 13, init 0):	RW	Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .
 *   pic	(size 2, offset 14, init 0):	RO	Port indicator control (not implemented)
 *   ptc	(size 4, offset 16, init 0):	RW	Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .
 *   wce	(size 1, offset 20, init 0):	RW	Wake on connect enableThis field is 0 if the PP bit is 0. .
 *   wde	(size 1, offset 21, init 0):	RW	Wake on disconnect enableThis field is 0 if the PP bit is 0. .
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   suspendstatus	(size 2, offset 23, init 0):	RO	Addition for LPM support.Indicates status of L1 suspend request: .
 *   deviceaddress	(size 7, offset 25, init 0):	RW	The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.
 */
typedef uint32_t omap44xx_ehci_portsc_i_0_t;
#define omap44xx_ehci_portsc_i_0_default 0x0
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_0_ccs_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_0_ccs_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_ccs_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ccs_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_ccs_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ccs_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_ccs_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_0_csc_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_0_csc_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_csc_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_csc_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_csc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_csc_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_csc_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 1)));
}

static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_0_ped_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_0_ped_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_ped_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ped_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_ped_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ped_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_ped_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 2)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_0_pedc_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_0_pedc_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pedc_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pedc_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 3)));
}

static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_0_fpr_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_0_fpr_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_fpr_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_fpr_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_fpr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_fpr_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_fpr_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 6)));
}

static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_0_sus_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_0_sus_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_sus_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_sus_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_sus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_sus_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_sus_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 7)));
}

static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_0_pr_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_0_pr_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_pr_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pr_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_pr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pr_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_pr_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_0_suspendl1_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_0_suspendl1_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_suspendl1_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_suspendl1_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_suspendl1_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_suspendl1_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_suspendl1_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 9)));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_ls_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_ls_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((uint8_t )((_regval & 0xc00) >> 10));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ls_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ls_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 10)));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_pp_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_pp_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pp_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pp_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 12)));
}

static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_0_po_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_0_po_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_po_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_po_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_po_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_po_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_po_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 13)));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_pic_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_pic_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pic_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_pic_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 14)));
}

static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_0_ptc_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_0_ptc_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_ptc_status_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ptc_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_ptc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_ptc_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_ptc_status_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 16)));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wce_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wce_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_p_indicator_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_wce_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_wce_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 20)));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wde_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wde_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_p_indicator_status_t )((_regval & 0x200000) >> 21));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_wde_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_wde_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_p_indicator_status_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 21)));
}

static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_0_suspendstatus_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_0_suspendstatus_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((omap44xx_ehci_suspendstatus_status_t )((_regval & 0x1800000) >> 23));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_suspendstatus_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_suspendstatus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_suspendstatus_insert(omap44xx_ehci_portsc_i_0_t _regval, omap44xx_ehci_suspendstatus_status_t _fieldval)
{
    return((_regval & 0xfe7fffff) | (0x1800000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 23)));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_deviceaddress_extract(omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_deviceaddress_extract(omap44xx_ehci_portsc_i_0_t _regval)
{
    return((uint8_t )((_regval & 0xfe000000) >> 25));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_deviceaddress_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_deviceaddress_insert(omap44xx_ehci_portsc_i_0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1ffffff) | (0xfe000000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 25)));
}

static inline int omap44xx_ehci_portsc_i_0_prtval(char *_s, size_t _size, omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsc_i_0_prtval(char *_s, size_t _size, omap44xx_ehci_portsc_i_0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ccs_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_csc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ped_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabled changeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fpr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force port resumeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_sus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendl1_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_suspendl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(When this bit is set to 1, an LPM token is generated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .)\n", omap44xx_ehci_portsc_i_0_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .)\n", omap44xx_ehci_portsc_i_0_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_po_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t%" PRIx8 "\t(Port indicator control (not implemented))\n", omap44xx_ehci_portsc_i_0_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ptc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_wce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on connect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wde =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_wde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on disconnect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendstatus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendstatus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_suspendstatus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addition for LPM support.Indicates status of L1 suspend request: .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deviceaddress =\t%" PRIx8 "\t(The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.)\n", omap44xx_ehci_portsc_i_0_deviceaddress_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_portsc_i_1_t
 * Description: Implicit type of Port status/control register
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .
 *   csc	(size 1, offset 1, init 0):	RW	Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .
 *   pedc	(size 1, offset 3, init 0):	RW	Port enabled/disabled changeThis field is 0 if the PP bit is 0. .
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resumeThis field is 0 if the PP bit is 0. .
 *   sus	(size 1, offset 7, init 0):	RW	SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .
 *   pr	(size 1, offset 8, init 0):	RW	Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .
 *   suspendl1	(size 1, offset 9, init 0):	RW	When this bit is set to 1, an LPM token is generated.
 *   ls	(size 2, offset 10, init 0):	RO	Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .
 *   pp	(size 1, offset 12, init 0):	RW	Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .
 *   po	(size 1, offset 13, init 0):	RW	Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .
 *   pic	(size 2, offset 14, init 0):	RO	Port indicator control (not implemented)
 *   ptc	(size 4, offset 16, init 0):	RW	Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .
 *   wce	(size 1, offset 20, init 0):	RW	Wake on connect enableThis field is 0 if the PP bit is 0. .
 *   wde	(size 1, offset 21, init 0):	RW	Wake on disconnect enableThis field is 0 if the PP bit is 0. .
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   suspendstatus	(size 2, offset 23, init 0):	RO	Addition for LPM support.Indicates status of L1 suspend request: .
 *   deviceaddress	(size 7, offset 25, init 0):	RW	The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.
 */
typedef uint32_t omap44xx_ehci_portsc_i_1_t;
#define omap44xx_ehci_portsc_i_1_default 0x0
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_1_ccs_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_1_ccs_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_ccs_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ccs_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_ccs_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ccs_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_ccs_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_1_csc_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_1_csc_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_csc_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_csc_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_csc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_csc_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_csc_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 1)));
}

static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_1_ped_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_1_ped_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_ped_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ped_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_ped_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ped_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_ped_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 2)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_pedc_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_pedc_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pedc_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pedc_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 3)));
}

static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_1_fpr_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_1_fpr_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_fpr_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_fpr_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_fpr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_fpr_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_fpr_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 6)));
}

static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_1_sus_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_1_sus_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_sus_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_sus_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_sus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_sus_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_sus_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 7)));
}

static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_1_pr_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_1_pr_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_pr_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pr_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pr_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pr_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_1_suspendl1_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_1_suspendl1_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_suspendl1_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_suspendl1_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_suspendl1_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_suspendl1_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_suspendl1_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 9)));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_ls_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_ls_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((uint8_t )((_regval & 0xc00) >> 10));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ls_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ls_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 10)));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_pp_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_pp_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pp_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pp_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 12)));
}

static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_1_po_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_1_po_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_po_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_po_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_po_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_po_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_po_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 13)));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_pic_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_pic_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pic_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_pic_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 14)));
}

static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_1_ptc_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_1_ptc_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_ptc_status_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ptc_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_ptc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_ptc_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_ptc_status_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 16)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wce_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wce_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_wce_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_wce_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 20)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wde_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wde_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x200000) >> 21));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_wde_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_wde_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 21)));
}

static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_1_suspendstatus_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_1_suspendstatus_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((omap44xx_ehci_suspendstatus_status_t )((_regval & 0x1800000) >> 23));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_suspendstatus_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_suspendstatus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_suspendstatus_insert(omap44xx_ehci_portsc_i_1_t _regval, omap44xx_ehci_suspendstatus_status_t _fieldval)
{
    return((_regval & 0xfe7fffff) | (0x1800000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 23)));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_deviceaddress_extract(omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_deviceaddress_extract(omap44xx_ehci_portsc_i_1_t _regval)
{
    return((uint8_t )((_regval & 0xfe000000) >> 25));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_deviceaddress_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_deviceaddress_insert(omap44xx_ehci_portsc_i_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1ffffff) | (0xfe000000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 25)));
}

static inline int omap44xx_ehci_portsc_i_1_prtval(char *_s, size_t _size, omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsc_i_1_prtval(char *_s, size_t _size, omap44xx_ehci_portsc_i_1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ccs_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_csc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ped_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabled changeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fpr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force port resumeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_sus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendl1_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_suspendl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(When this bit is set to 1, an LPM token is generated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .)\n", omap44xx_ehci_portsc_i_1_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .)\n", omap44xx_ehci_portsc_i_1_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_po_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t%" PRIx8 "\t(Port indicator control (not implemented))\n", omap44xx_ehci_portsc_i_1_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ptc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_wce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on connect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wde =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_wde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on disconnect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendstatus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendstatus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_suspendstatus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addition for LPM support.Indicates status of L1 suspend request: .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deviceaddress =\t%" PRIx8 "\t(The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.)\n", omap44xx_ehci_portsc_i_1_deviceaddress_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_portsc_i_2_t
 * Description: Implicit type of Port status/control register
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .
 *   csc	(size 1, offset 1, init 0):	RW	Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .
 *   pedc	(size 1, offset 3, init 0):	RW	Port enabled/disabled changeThis field is 0 if the PP bit is 0. .
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resumeThis field is 0 if the PP bit is 0. .
 *   sus	(size 1, offset 7, init 0):	RW	SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .
 *   pr	(size 1, offset 8, init 0):	RW	Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .
 *   suspendl1	(size 1, offset 9, init 0):	RW	When this bit is set to 1, an LPM token is generated.
 *   ls	(size 2, offset 10, init 0):	RO	Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .
 *   pp	(size 1, offset 12, init 0):	RW	Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .
 *   po	(size 1, offset 13, init 0):	RW	Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .
 *   pic	(size 2, offset 14, init 0):	RO	Port indicator control (not implemented)
 *   ptc	(size 4, offset 16, init 0):	RW	Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .
 *   wce	(size 1, offset 20, init 0):	RW	Wake on connect enableThis field is 0 if the PP bit is 0. .
 *   wde	(size 1, offset 21, init 0):	RW	Wake on disconnect enableThis field is 0 if the PP bit is 0. .
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   suspendstatus	(size 2, offset 23, init 0):	RO	Addition for LPM support.Indicates status of L1 suspend request: .
 *   deviceaddress	(size 7, offset 25, init 0):	RW	The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.
 */
typedef uint32_t omap44xx_ehci_portsc_i_2_t;
#define omap44xx_ehci_portsc_i_2_default 0x0
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_2_ccs_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_2_ccs_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_ccs_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ccs_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_ccs_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ccs_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_ccs_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 0)));
}

static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_2_csc_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_2_csc_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_csc_status_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_csc_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_csc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_csc_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_csc_status_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 1)));
}

static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_2_ped_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_2_ped_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_ped_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ped_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_ped_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ped_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_ped_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 2)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_pedc_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_pedc_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pedc_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pedc_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 3)));
}

static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_2_fpr_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_2_fpr_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_fpr_status_t )((_regval & 0x40) >> 6));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_fpr_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_fpr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_fpr_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_fpr_status_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 6)));
}

static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_2_sus_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_2_sus_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_sus_status_t )((_regval & 0x80) >> 7));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_sus_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_sus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_sus_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_sus_status_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 7)));
}

static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_2_pr_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_2_pr_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_pr_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pr_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pr_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pr_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pr_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_2_suspendl1_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_2_suspendl1_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_suspendl1_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_suspendl1_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_suspendl1_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_suspendl1_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_suspendl1_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 9)));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_ls_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_ls_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((uint8_t )((_regval & 0xc00) >> 10));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ls_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ls_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 10)));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_pp_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_pp_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pp_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pp_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 12)));
}

static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_2_po_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_2_po_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_po_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_po_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_po_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_po_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_po_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 13)));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_pic_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_pic_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pic_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_pic_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 14)));
}

static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_2_ptc_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_2_ptc_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_ptc_status_t )((_regval & 0xf0000) >> 16));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ptc_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_ptc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_ptc_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_ptc_status_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 16)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wce_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wce_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_wce_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_wce_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 20)));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wde_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wde_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_pedc_status_t )((_regval & 0x200000) >> 21));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_wde_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_wde_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_pedc_status_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 21)));
}

static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_2_suspendstatus_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_2_suspendstatus_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((omap44xx_ehci_suspendstatus_status_t )((_regval & 0x1800000) >> 23));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_suspendstatus_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_suspendstatus_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_suspendstatus_insert(omap44xx_ehci_portsc_i_2_t _regval, omap44xx_ehci_suspendstatus_status_t _fieldval)
{
    return((_regval & 0xfe7fffff) | (0x1800000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 23)));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_deviceaddress_extract(omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_deviceaddress_extract(omap44xx_ehci_portsc_i_2_t _regval)
{
    return((uint8_t )((_regval & 0xfe000000) >> 25));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_deviceaddress_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_deviceaddress_insert(omap44xx_ehci_portsc_i_2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1ffffff) | (0xfe000000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 25)));
}

static inline int omap44xx_ehci_portsc_i_2_prtval(char *_s, size_t _size, omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsc_i_2_prtval(char *_s, size_t _size, omap44xx_ehci_portsc_i_2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ccs_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_csc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ped_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabled changeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fpr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force port resumeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_sus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendl1_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_suspendl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(When this bit is set to 1, an LPM token is generated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .)\n", omap44xx_ehci_portsc_i_2_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .)\n", omap44xx_ehci_portsc_i_2_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_po_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t%" PRIx8 "\t(Port indicator control (not implemented))\n", omap44xx_ehci_portsc_i_2_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ptc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_wce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on connect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wde =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_wde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on disconnect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendstatus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendstatus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_suspendstatus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addition for LPM support.Indicates status of L1 suspend request: .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deviceaddress =\t%" PRIx8 "\t(The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.)\n", omap44xx_ehci_portsc_i_2_deviceaddress_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg00_t
 * Description: Implicit type of Implementation-specific register 0 register
 * Fields:
 *   en	(size 1, offset 0, init 0):	RW	Enable of this register
 *   uframe_cnt	(size 13, offset 1, init 0):	RW	1-microframe length value, to reduce simulation time. SIMULATIONS ONLY, NOT AN ACTUAL REGISTER.
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_insnreg00_t;
#define omap44xx_ehci_insnreg00_default 0x0
static inline uint8_t omap44xx_ehci_insnreg00_en_extract(omap44xx_ehci_insnreg00_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg00_en_extract(omap44xx_ehci_insnreg00_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_en_insert(omap44xx_ehci_insnreg00_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_en_insert(omap44xx_ehci_insnreg00_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_insnreg00_t )(_fieldval)) << 0)));
}

static inline uint16_t omap44xx_ehci_insnreg00_uframe_cnt_extract(omap44xx_ehci_insnreg00_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg00_uframe_cnt_extract(omap44xx_ehci_insnreg00_t _regval)
{
    return((uint16_t )((_regval & 0x3ffe) >> 1));
}

static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_uframe_cnt_insert(omap44xx_ehci_insnreg00_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_uframe_cnt_insert(omap44xx_ehci_insnreg00_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc001) | (0x3ffe & (((omap44xx_ehci_insnreg00_t )(_fieldval)) << 1)));
}

static inline int omap44xx_ehci_insnreg00_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg00_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg00_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg00_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Enable of this register)\n", omap44xx_ehci_insnreg00_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uframe_cnt =\t%" PRIx16 "\t(1-microframe length value, to reduce simulation time. SIMULATIONS ONLY, NOT AN ACTUAL REGISTER.)\n", omap44xx_ehci_insnreg00_uframe_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg01_t
 * Description: Implicit type of Implementation-specific register 1 register
 * Fields:
 *   in_threshold	(size 16, offset 0, init 0):	RW	Programmable input packet buffer threshold, in 32-bit words
 *   out_threshold	(size 16, offset 16, init 0):	RW	Programmable output packet buffer threshold, in 32-bit words
 */
typedef uint32_t omap44xx_ehci_insnreg01_t;
#define omap44xx_ehci_insnreg01_default 0x0
static inline uint16_t omap44xx_ehci_insnreg01_in_threshold_extract(omap44xx_ehci_insnreg01_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg01_in_threshold_extract(omap44xx_ehci_insnreg01_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_in_threshold_insert(omap44xx_ehci_insnreg01_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_in_threshold_insert(omap44xx_ehci_insnreg01_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((omap44xx_ehci_insnreg01_t )(_fieldval)) << 0)));
}

static inline uint16_t omap44xx_ehci_insnreg01_out_threshold_extract(omap44xx_ehci_insnreg01_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg01_out_threshold_extract(omap44xx_ehci_insnreg01_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_out_threshold_insert(omap44xx_ehci_insnreg01_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_out_threshold_insert(omap44xx_ehci_insnreg01_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((omap44xx_ehci_insnreg01_t )(_fieldval)) << 16)));
}

static inline int omap44xx_ehci_insnreg01_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg01_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg01_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg01_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " in_threshold =\t%" PRIx16 "\t(Programmable input packet buffer threshold, in 32-bit words)\n", omap44xx_ehci_insnreg01_in_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out_threshold =\t%" PRIx16 "\t(Programmable output packet buffer threshold, in 32-bit words)\n", omap44xx_ehci_insnreg01_out_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg02_t
 * Description: Implicit type of Implementation-specific register 2 register
 * Fields:
 *   buf_depth	(size 12, offset 0, init 0):	RW	Programmable packet buffer depth, in 32-bit words
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_insnreg02_t;
#define omap44xx_ehci_insnreg02_default 0x0
static inline uint16_t omap44xx_ehci_insnreg02_buf_depth_extract(omap44xx_ehci_insnreg02_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg02_buf_depth_extract(omap44xx_ehci_insnreg02_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline omap44xx_ehci_insnreg02_t omap44xx_ehci_insnreg02_buf_depth_insert(omap44xx_ehci_insnreg02_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg02_t omap44xx_ehci_insnreg02_buf_depth_insert(omap44xx_ehci_insnreg02_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((omap44xx_ehci_insnreg02_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ehci_insnreg02_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg02_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg02_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg02_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " buf_depth =\t%" PRIx16 "\t(Programmable packet buffer depth, in 32-bit words)\n", omap44xx_ehci_insnreg02_buf_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg03_t
 * Description: Implicit type of Implementation-specific register 3 register
 * Fields:
 *   brk_mem_trsf	(size 1, offset 0, init 0):	RW	Break memory transfer, in conjunction withINSNREG01
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_insnreg03_t;
#define omap44xx_ehci_insnreg03_default 0x0
static inline omap44xx_ehci_brk_mem_trsf_status_t omap44xx_ehci_insnreg03_brk_mem_trsf_extract(omap44xx_ehci_insnreg03_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_brk_mem_trsf_status_t omap44xx_ehci_insnreg03_brk_mem_trsf_extract(omap44xx_ehci_insnreg03_t _regval)
{
    return((omap44xx_ehci_brk_mem_trsf_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_insnreg03_t omap44xx_ehci_insnreg03_brk_mem_trsf_insert(omap44xx_ehci_insnreg03_t _regval, omap44xx_ehci_brk_mem_trsf_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg03_t omap44xx_ehci_insnreg03_brk_mem_trsf_insert(omap44xx_ehci_insnreg03_t _regval, omap44xx_ehci_brk_mem_trsf_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_insnreg03_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ehci_insnreg03_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg03_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg03_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg03_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " brk_mem_trsf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_brk_mem_trsf_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg03_brk_mem_trsf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Break memory transfer, in conjunction withINSNREG01)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg04_t
 * Description: Implicit type of Implementation-specific register 4 register
 * Fields:
 *   hcsparams_wre	(size 1, offset 0, init 0):	RW	Make read-onlyHCSPARAMS register writable (debug)
 *   hccparams_wre	(size 1, offset 1, init 0):	RW	Make read-onlyHCCPARAMS register writable (debug)
 *   short_port_enum	(size 1, offset 2, init 0):	RW	Scale down port enumeration time (debug)
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   nak_fix_dis	(size 1, offset 4, init 0):	RW	Disable NAK fix (don't touch)
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_insnreg04_t;
#define omap44xx_ehci_insnreg04_default 0x0
static inline uint8_t omap44xx_ehci_insnreg04_hcsparams_wre_extract(omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_hcsparams_wre_extract(omap44xx_ehci_insnreg04_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_hcsparams_wre_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_hcsparams_wre_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ehci_insnreg04_hccparams_wre_extract(omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_hccparams_wre_extract(omap44xx_ehci_insnreg04_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_hccparams_wre_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_hccparams_wre_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_ehci_insnreg04_short_port_enum_extract(omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_short_port_enum_extract(omap44xx_ehci_insnreg04_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_short_port_enum_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_short_port_enum_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 2)));
}

static inline uint8_t omap44xx_ehci_insnreg04_nak_fix_dis_extract(omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_nak_fix_dis_extract(omap44xx_ehci_insnreg04_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_nak_fix_dis_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_nak_fix_dis_insert(omap44xx_ehci_insnreg04_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 4)));
}

static inline int omap44xx_ehci_insnreg04_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg04_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg04_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcsparams_wre =\t%" PRIx8 "\t(Make read-onlyHCSPARAMS register writable (debug))\n", omap44xx_ehci_insnreg04_hcsparams_wre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hccparams_wre =\t%" PRIx8 "\t(Make read-onlyHCCPARAMS register writable (debug))\n", omap44xx_ehci_insnreg04_hccparams_wre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " short_port_enum =\t%" PRIx8 "\t(Scale down port enumeration time (debug))\n", omap44xx_ehci_insnreg04_short_port_enum_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nak_fix_dis =\t%" PRIx8 "\t(Disable NAK fix (don't touch))\n", omap44xx_ehci_insnreg04_nak_fix_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg05_ulpi_t
 * Description: Implicit type of Implementation-specific register 5. Register functionality for ULPI mode. register
 * Fields:
 *   rdwrdata	(size 8, offset 0, init 0):	RW	Read/write data of (resp. read/write) register access
 *   extregadd	(size 8, offset 8, init 0):	RW	Address for extended register accesses. Don't care for direct accesses.
 *   regadd	(size 6, offset 16, init 0):	RW	ULPI direct register address, for any value different than 0x2F.
 *   opsel	(size 2, offset 22, init 0):	RW	
 *   portsel	(size 4, offset 24, init 0):	RW	
 *   _anon28	(size 3, offset 28, init 0):	MBZ	_
 *   control	(size 1, offset 31, init 0):	RW	Control/status of the ULPI register access
 */
typedef uint32_t omap44xx_ehci_insnreg05_ulpi_t;
#define omap44xx_ehci_insnreg05_ulpi_default 0x0
static inline uint8_t omap44xx_ehci_insnreg05_ulpi_rdwrdata_extract(omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg05_ulpi_rdwrdata_extract(omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_rdwrdata_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_rdwrdata_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ehci_insnreg05_ulpi_extregadd_extract(omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg05_ulpi_extregadd_extract(omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_extregadd_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_extregadd_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 8)));
}

static inline omap44xx_ehci_regadd_status_t omap44xx_ehci_insnreg05_ulpi_regadd_extract(omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_regadd_status_t omap44xx_ehci_insnreg05_ulpi_regadd_extract(omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    return((omap44xx_ehci_regadd_status_t )((_regval & 0x3f0000) >> 16));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_regadd_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_regadd_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_regadd_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_regadd_status_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 16)));
}

static inline omap44xx_ehci_opsel_status_t omap44xx_ehci_insnreg05_ulpi_opsel_extract(omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_opsel_status_t omap44xx_ehci_insnreg05_ulpi_opsel_extract(omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    return((omap44xx_ehci_opsel_status_t )((_regval & 0xc00000) >> 22));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_opsel_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_opsel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_opsel_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_opsel_status_t _fieldval)
{
    return((_regval & 0xff3fffff) | (0xc00000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 22)));
}

static inline omap44xx_ehci_portsel_status_t omap44xx_ehci_insnreg05_ulpi_portsel_extract(omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsel_status_t omap44xx_ehci_insnreg05_ulpi_portsel_extract(omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    return((omap44xx_ehci_portsel_status_t )((_regval & 0xf000000) >> 24));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_portsel_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_portsel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_portsel_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_portsel_status_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 24)));
}

static inline omap44xx_ehci_control_status_t omap44xx_ehci_insnreg05_ulpi_control_extract(omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_control_status_t omap44xx_ehci_insnreg05_ulpi_control_extract(omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    return((omap44xx_ehci_control_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_control_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_control_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_control_insert(omap44xx_ehci_insnreg05_ulpi_t _regval, omap44xx_ehci_control_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 31)));
}

static inline int omap44xx_ehci_insnreg05_ulpi_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg05_ulpi_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdwrdata =\t%" PRIx8 "\t(Read/write data of (resp. read/write) register access)\n", omap44xx_ehci_insnreg05_ulpi_rdwrdata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " extregadd =\t%" PRIx8 "\t(Address for extended register accesses. Don't care for direct accesses.)\n", omap44xx_ehci_insnreg05_ulpi_extregadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " regadd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_regadd_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_regadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ULPI direct register address, for any value different than 0x2F.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " opsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_opsel_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_opsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " portsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_portsel_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_portsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " control =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_control_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_control_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control/status of the ULPI register access)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg06_t
 * Description: Implicit type of AHB error status register
 * Fields:
 *   beatscomp	(size 4, offset 0, init 0):	RO	Number of successfully completed beats in the current burst before the AHB error occurred
 *   beatsexp	(size 5, offset 4, init 0):	RO	Number of beats expected in the burst at which the AHB error occurred. Valid values are 0 to 16.
 *   hburst	(size 3, offset 9, init 0):	RO	HBURST Value of the control phase at which the AHB error occurred
 *   _anon12	(size 19, offset 12, init 0):	MBZ	_
 *   errorcap	(size 1, offset 31, init 0):	RW	Indicator that an AHB error was encountered and values were captured
 */
typedef uint32_t omap44xx_ehci_insnreg06_t;
#define omap44xx_ehci_insnreg06_default 0x0
static inline uint8_t omap44xx_ehci_insnreg06_beatscomp_extract(omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg06_beatscomp_extract(omap44xx_ehci_insnreg06_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_beatscomp_insert(omap44xx_ehci_insnreg06_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_beatscomp_insert(omap44xx_ehci_insnreg06_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((omap44xx_ehci_insnreg06_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ehci_insnreg06_beatsexp_extract(omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg06_beatsexp_extract(omap44xx_ehci_insnreg06_t _regval)
{
    return((uint8_t )((_regval & 0x1f0) >> 4));
}

static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_beatsexp_insert(omap44xx_ehci_insnreg06_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_beatsexp_insert(omap44xx_ehci_insnreg06_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffe0f) | (0x1f0 & (((omap44xx_ehci_insnreg06_t )(_fieldval)) << 4)));
}

static inline uint8_t omap44xx_ehci_insnreg06_hburst_extract(omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg06_hburst_extract(omap44xx_ehci_insnreg06_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_hburst_insert(omap44xx_ehci_insnreg06_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_hburst_insert(omap44xx_ehci_insnreg06_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff1ff) | (0xe00 & (((omap44xx_ehci_insnreg06_t )(_fieldval)) << 9)));
}

static inline omap44xx_ehci_errorcap_status_t omap44xx_ehci_insnreg06_errorcap_extract(omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ehci_errorcap_status_t omap44xx_ehci_insnreg06_errorcap_extract(omap44xx_ehci_insnreg06_t _regval)
{
    return((omap44xx_ehci_errorcap_status_t )((_regval & 0x80000000) >> 31));
}

static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_errorcap_insert(omap44xx_ehci_insnreg06_t _regval, omap44xx_ehci_errorcap_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_errorcap_insert(omap44xx_ehci_insnreg06_t _regval, omap44xx_ehci_errorcap_status_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((omap44xx_ehci_insnreg06_t )(_fieldval)) << 31)));
}

static inline int omap44xx_ehci_insnreg06_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg06_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg06_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beatscomp =\t%" PRIx8 "\t(Number of successfully completed beats in the current burst before the AHB error occurred)\n", omap44xx_ehci_insnreg06_beatscomp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beatsexp =\t%" PRIx8 "\t(Number of beats expected in the burst at which the AHB error occurred. Valid values are 0 to 16.)\n", omap44xx_ehci_insnreg06_beatsexp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hburst =\t%" PRIx8 "\t(HBURST Value of the control phase at which the AHB error occurred)\n", omap44xx_ehci_insnreg06_hburst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " errorcap =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_errorcap_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg06_errorcap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicator that an AHB error was encountered and values were captured)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ehci_insnreg08_t
 * Description: Implicit type of  register
 * Fields:
 *   newbitfield1	(size 16, offset 0, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ehci_insnreg08_t;
#define omap44xx_ehci_insnreg08_default 0x0
static inline uint16_t omap44xx_ehci_insnreg08_newbitfield1_extract(omap44xx_ehci_insnreg08_t _regval) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg08_newbitfield1_extract(omap44xx_ehci_insnreg08_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline omap44xx_ehci_insnreg08_t omap44xx_ehci_insnreg08_newbitfield1_insert(omap44xx_ehci_insnreg08_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg08_t omap44xx_ehci_insnreg08_newbitfield1_insert(omap44xx_ehci_insnreg08_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((omap44xx_ehci_insnreg08_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ehci_insnreg08_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg08_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg08_prtval(char *_s, size_t _size, omap44xx_ehci_insnreg08_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " newbitfield1 =\t%" PRIx16 "\t()\n", omap44xx_ehci_insnreg08_newbitfield1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    omap44xx_ehci_usbcmd_t usbcmd_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_ehci_initials {
    omap44xx_ehci_hccapbase_initial = 0x0,
    omap44xx_ehci_hcsparams_initial = 0x0,
    omap44xx_ehci_hccparams_initial = 0x0,
    omap44xx_ehci_usbcmd_initial = 0x0,
    omap44xx_ehci_usbsts_initial = 0x0,
    omap44xx_ehci_usbintr_initial = 0x0,
    omap44xx_ehci_frindex_initial = 0x0,
    omap44xx_ehci_ctrldssegment_initial = 0x0,
    omap44xx_ehci_periodiclistbase_initial = 0x0,
    omap44xx_ehci_asynclistaddr_initial = 0x0,
    omap44xx_ehci_configflag_initial = 0x0,
    omap44xx_ehci_portsc_i_0_initial = 0x0,
    omap44xx_ehci_portsc_i_1_initial = 0x0,
    omap44xx_ehci_portsc_i_2_initial = 0x0,
    omap44xx_ehci_insnreg00_initial = 0x0,
    omap44xx_ehci_insnreg01_initial = 0x0,
    omap44xx_ehci_insnreg02_initial = 0x0,
    omap44xx_ehci_insnreg03_initial = 0x0,
    omap44xx_ehci_insnreg04_initial = 0x0,
    omap44xx_ehci_insnreg05_ulpi_initial = 0x0,
    omap44xx_ehci_insnreg06_initial = 0x0,
    omap44xx_ehci_insnreg07_initial = 0x0,
    omap44xx_ehci_insnreg08_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_ehci_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_ehci_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register hccapbase: Host controller capability register
 * Type: omap44xx_ehci.hccapbase (Implicit type of Host controller capability register register)
 *   caplength	(size 8, offset 0, init 0):	RO	Capability register length
 *   _anon8	(size 8, offset 8, init 0):	MBZ	_
 *   hciversion	(size 16, offset 16, init 0):	RO	Interface version number. It contains a BCD encoding of the EHCI revision number supported by this host controller.[7:4] Major revision . [3:0] Minor revision .
 */
static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccapbase_t omap44xx_ehci_hccapbase_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_ehci_hccapbase_rawwr(__DN(t) *_dev, omap44xx_ehci_hccapbase_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_hccapbase_rawwr(__DN(t) *_dev, omap44xx_ehci_hccapbase_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register hccapbase is not writeable
static inline int omap44xx_ehci_hccapbase_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hccapbase_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_hccapbase_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hccapbase (Host controller capability register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " caplength =\t%" PRIx8 "\t(Capability register length)\n", omap44xx_ehci_hccapbase_caplength_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hciversion =\t%" PRIx16 "\t(Interface version number. It contains a BCD encoding of the EHCI revision number supported by this host controller.[7:4] Major revision . [3:0] Minor revision .)\n", omap44xx_ehci_hccapbase_hciversion_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_ehci_hccapbase_caplength_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hccapbase_caplength_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccapbase_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_ehci_hccapbase_caplength_extract(_regval));
}

static inline uint16_t omap44xx_ehci_hccapbase_hciversion_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_hccapbase_hciversion_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccapbase_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_ehci_hccapbase_hciversion_extract(_regval));
}

/*
 * Register hcsparams: Host controller structural parameters
 * Type: omap44xx_ehci.hcsparams (Implicit type of Host controller structural parameters register)
 *   n_ports	(size 4, offset 0, init 0):	RO	Number of downstream portsThis field specifies the number of physical downstream ports implemented on this host controller. .
 *   ppc	(size 1, offset 4, init 0):	RO	Port power controlThis field indicates whether the host controller implementation includes port power control. .
 *   _anon5	(size 2, offset 5, init 0):	MBZ	_
 *   prr	(size 1, offset 7, init 0):	RO	Port routing rulesThe first N_PCC ports are routed to the lowest-numbered function companion host controller, the next N_PCC ports are routed to the next lowest-function companion controller, and so on. .
 *   n_pcc	(size 4, offset 8, init 0):	RO	Number of ports per companion controllerThis field indicates the number of ports supported per companion host controller. It is used to indicate the port routing configuration to system software. . For example, if N_PORTS has a value of 6 and N_CC has a value of 2, then N_PCC can have a value of 3. . The convention is that the first N_PCC ports are assumed to be routed to companion controller 1, the next N_PCC ports to companion controller 2, etc. . The number in this field must be consistent with N_PORTS and N_CC. .
 *   n_cc	(size 4, offset 12, init 0):	RO	Number of companion controllersThis field indicates the number of companion controllers associated with this USB 2.0 host controller. . Others: There are companion USB 1.1 host controller(s). Port-ownership hand-off is supported. High-, full-, and low-speed devices are supported on the host controller root ports. .
 *   p_indicator	(size 1, offset 16, init 0):	RO	Port indicator support indicationThis bit indicates whether the ports support port indicator control. .
 *   _anon17	(size 3, offset 17, init 0):	MBZ	_
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcsparams_t omap44xx_ehci_hcsparams_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void omap44xx_ehci_hcsparams_rawwr(__DN(t) *_dev, omap44xx_ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_hcsparams_rawwr(__DN(t) *_dev, omap44xx_ehci_hcsparams_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

// Register hcsparams is not writeable
static inline int omap44xx_ehci_hcsparams_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hcsparams_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcsparams (Host controller structural parameters): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_ports =\t%" PRIx8 "\t(Number of downstream portsThis field specifies the number of physical downstream ports implemented on this host controller. .)\n", omap44xx_ehci_hcsparams_n_ports_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ppc_status_prtval(_s + _r, _avail, omap44xx_ehci_hcsparams_ppc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port power controlThis field indicates whether the host controller implementation includes port power control. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prr =\t%" PRIx8 "\t(Port routing rulesThe first N_PCC ports are routed to the lowest-numbered function companion host controller, the next N_PCC ports are routed to the next lowest-function companion controller, and so on. .)\n", omap44xx_ehci_hcsparams_prr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_pcc =\t%" PRIx8 "\t(Number of ports per companion controllerThis field indicates the number of ports supported per companion host controller. It is used to indicate the port routing configuration to system software. . For example, if N_PORTS has a value of 6 and N_CC has a value of 2, then N_PCC can have a value of 3. . The convention is that the first N_PCC ports are assumed to be routed to companion controller 1, the next N_PCC ports to companion controller 2, etc. . The number in this field must be consistent with N_PORTS and N_CC. .)\n", omap44xx_ehci_hcsparams_n_pcc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_cc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_n_cc_status_prtval(_s + _r, _avail, omap44xx_ehci_hcsparams_n_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Number of companion controllersThis field indicates the number of companion controllers associated with this USB 2.0 host controller. . Others: There are companion USB 1.1 host controller(s). Port-ownership hand-off is supported. High-, full-, and low-speed devices are supported on the host controller root ports. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_indicator =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_hcsparams_p_indicator_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port indicator support indicationThis bit indicates whether the ports support port indicator control. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ehci_hcsparams_n_ports_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hcsparams_n_ports_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_ehci_hcsparams_n_ports_extract(_regval));
}

static inline omap44xx_ehci_ppc_status_t omap44xx_ehci_hcsparams_ppc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ppc_status_t omap44xx_ehci_hcsparams_ppc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_ehci_hcsparams_ppc_extract(_regval));
}

static inline uint8_t omap44xx_ehci_hcsparams_prr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hcsparams_prr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_ehci_hcsparams_prr_extract(_regval));
}

static inline uint8_t omap44xx_ehci_hcsparams_n_pcc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hcsparams_n_pcc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_ehci_hcsparams_n_pcc_extract(_regval));
}

static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hcsparams_n_cc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hcsparams_n_cc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_ehci_hcsparams_n_cc_extract(_regval));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hcsparams_p_indicator_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hcsparams_p_indicator_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(omap44xx_ehci_hcsparams_p_indicator_extract(_regval));
}

/*
 * Register hccparams: Host controller capability parameters
 * Type: omap44xx_ehci.hccparams (Implicit type of Host controller capability parameters register)
 *   bit64ac	(size 1, offset 0, init 0):	RO	64-bit addressing capabilityThis field documents the addressing range capability of this implementation. .
 *   pflf	(size 1, offset 1, init 0):	RO	Programmable frame list flag
 *   aspc	(size 1, offset 2, init 0):	RO	Asynchronous schedule park capabilityThe feature can be disabled or enabled and set to a specific level by using the USBHOST.[11]ASPME bit and the USBHOST.[9:8] ASPMC bit field. .
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   ist	(size 4, offset 4, init 0):	RO	Isochronous scheduling thresholdThis field indicates where software can reliably update the isochronous schedule in relation to the current position of the executing host controller. . The host controller can hold one microframe of isochronous data structures before flushing the state. .
 *   eecp	(size 8, offset 8, init 0):	RO	EHCI extended capabilities pointerThis field indicates the existence of a capabilities list. . Others: The offset in PCI configuration space of the first EHCI extended capability. .
 *   _anon16	(size 1, offset 16, init 0):	MBZ	_
 *   lpm	(size 1, offset 17, init 0):	RO	Link power management capability
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hccparams_t omap44xx_ehci_hccparams_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_ehci_hccparams_rawwr(__DN(t) *_dev, omap44xx_ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_hccparams_rawwr(__DN(t) *_dev, omap44xx_ehci_hccparams_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

// Register hccparams is not writeable
static inline int omap44xx_ehci_hccparams_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_hccparams_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hccparams (Host controller capability parameters): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit64ac =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_bit64ac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(64-bit addressing capabilityThis field documents the addressing range capability of this implementation. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pflf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pflf_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_pflf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Programmable frame list flag)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_aspc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule park capabilityThe feature can be disabled or enabled and set to a specific level by using the USBHOST.[11]ASPME bit and the USBHOST.[9:8] ASPMC bit field. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ist =\t%" PRIx8 "\t(Isochronous scheduling thresholdThis field indicates where software can reliably update the isochronous schedule in relation to the current position of the executing host controller. . The host controller can hold one microframe of isochronous data structures before flushing the state. .)\n", omap44xx_ehci_hccparams_ist_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_n_cc_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_eecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(EHCI extended capabilities pointerThis field indicates the existence of a capabilities list. . Others: The offset in PCI configuration space of the first EHCI extended capability. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_lpm_status_prtval(_s + _r, _avail, omap44xx_ehci_hccparams_lpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link power management capability)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_hccparams_bit64ac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_hccparams_bit64ac_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ehci_hccparams_bit64ac_extract(_regval));
}

static inline omap44xx_ehci_pflf_status_t omap44xx_ehci_hccparams_pflf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pflf_status_t omap44xx_ehci_hccparams_pflf_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ehci_hccparams_pflf_extract(_regval));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hccparams_aspc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_hccparams_aspc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ehci_hccparams_aspc_extract(_regval));
}

static inline uint8_t omap44xx_ehci_hccparams_ist_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_hccparams_ist_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ehci_hccparams_ist_extract(_regval));
}

static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hccparams_eecp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_n_cc_status_t omap44xx_ehci_hccparams_eecp_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ehci_hccparams_eecp_extract(_regval));
}

static inline omap44xx_ehci_lpm_status_t omap44xx_ehci_hccparams_lpm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_lpm_status_t omap44xx_ehci_hccparams_lpm_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ehci_hccparams_lpm_extract(_regval));
}

/*
 * Register usbcmd: USB command
 * Type: omap44xx_ehci.usbcmd (Implicit type of USB command register)
 *   rs	(size 1, offset 0, init 0):	RW	Run/stop
 *   hcr	(size 1, offset 1, init 0):	WO	Host controller resetThis control bit is used by software to reset the host controller. Write . This bit is set to 0 by the host controller when the reset process is complete. .
 *   fls	(size 2, offset 2, init 0):	RW	Frame list sizeThis field specifies the size of the frame list. The size of the frame list controls which bits in the frame index register should be used for the frame list current index. .
 *   pse	(size 1, offset 4, init 0):	RW	Periodic schedule enableThis bit controls whether the host controller skips processing the periodic schedule. .
 *   ase	(size 1, offset 5, init 0):	RW	Asynchronous schedule enableThis bit controls whether the host controller skips processing the asynchronous schedule. .
 *   iaad	(size 1, offset 6, init 0):	RW	Interrupt on async advance doorbellThis bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. . Software must not write 1 to this bit when the asynchronous schedule is disabled. Doing so may yield undefined results. .
 *   lhcr	(size 1, offset 7, init 0):	RW	Light host controller resetIt allows the driver to reset the EHCI controller without affecting the state of the ports or the relationship to the companion host controllers. .
 *   aspmc	(size 2, offset 8, init 0):	RW	Asynchronous schedule park mode countIt contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the asynchronous schedule before continuing traversal of the asynchronous schedule. . Valid values are 0x1 to 0x3. Software must not write 0 to this bit when park mode enable is 1 because this may result in undefined behavior. .
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   aspme	(size 1, offset 11, init 0):	RW	Asynchronous schedule park mode enable
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   itc	(size 8, offset 16, init 0):	RW	Interrupt threshold controlThis field is used by the system software to select the maximum rate at which the host controller issues interrupts. The only valid values are defined below. If software writes an invalid value to this register, the results are undefined. . Others: Undefined .
 *   hird	(size 4, offset 24, init 0):	RW	Host-initiated resume duration.If LPM is enabled, this field is RW; otherwise, it is R. . The minimum for K-state during resume from LPM: . Each increment adds 75 us. .
 *   _anon28	(size 4, offset 28, init 0):	MBZ	_
 */
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbcmd_t omap44xx_ehci_usbcmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_ehci_usbcmd_rawwr(__DN(t) *_dev, omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_rawwr(__DN(t) *_dev, omap44xx_ehci_usbcmd_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_ehci_usbcmd_wr(__DN(t) *_dev, omap44xx_ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_wr(__DN(t) *_dev, omap44xx_ehci_usbcmd_t _regval)
{
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_ehci_usbcmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbcmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbcmd (USB command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_rs_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Run/stop)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hcr_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host controller resetThis control bit is used by software to reset the host controller. Write . This bit is set to 0 by the host controller when the reset process is complete. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fls_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_fls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list sizeThis field specifies the size of the frame list. The size of the frame list controls which bits in the frame index register should be used for the frame list current index. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pse_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Periodic schedule enableThis bit controls whether the host controller skips processing the periodic schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ase =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ase_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_ase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule enableThis bit controls whether the host controller skips processing the asynchronous schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaad =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_iaad_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_iaad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt on async advance doorbellThis bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. . Software must not write 1 to this bit when the asynchronous schedule is disabled. Doing so may yield undefined results. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lhcr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_lhcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Light host controller resetIt allows the driver to reset the EHCI controller without affecting the state of the ports or the relationship to the companion host controllers. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspmc =\t%" PRIx8 "\t(Asynchronous schedule park mode countIt contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the asynchronous schedule before continuing traversal of the asynchronous schedule. . Valid values are 0x1 to 0x3. Software must not write 0 to this bit when park mode enable is 1 because this may result in undefined behavior. .)\n", omap44xx_ehci_usbcmd_aspmc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspme =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_aspme_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_aspme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule park mode enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_itc_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_itc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt threshold controlThis field is used by the system software to select the maximum rate at which the host controller issues interrupts. The only valid values are defined below. If software writes an invalid value to this register, the results are undefined. . Others: Undefined .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hird =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hird_status_prtval(_s + _r, _avail, omap44xx_ehci_usbcmd_hird_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host-initiated resume duration.If LPM is enabled, this field is RW; otherwise, it is R. . The minimum for K-state during resume from LPM: . Each increment adds 75 us. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline omap44xx_ehci_rs_status_t omap44xx_ehci_usbcmd_rs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_rs_status_t omap44xx_ehci_usbcmd_rs_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_rs_extract(_regval));
}

static inline omap44xx_ehci_fls_status_t omap44xx_ehci_usbcmd_fls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_fls_status_t omap44xx_ehci_usbcmd_fls_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_fls_extract(_regval));
}

static inline omap44xx_ehci_pse_status_t omap44xx_ehci_usbcmd_pse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pse_status_t omap44xx_ehci_usbcmd_pse_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_pse_extract(_regval));
}

static inline omap44xx_ehci_ase_status_t omap44xx_ehci_usbcmd_ase_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ase_status_t omap44xx_ehci_usbcmd_ase_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_ase_extract(_regval));
}

static inline omap44xx_ehci_iaad_status_t omap44xx_ehci_usbcmd_iaad_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_iaad_status_t omap44xx_ehci_usbcmd_iaad_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_iaad_extract(_regval));
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbcmd_lhcr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbcmd_lhcr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_lhcr_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbcmd_aspmc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbcmd_aspmc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_aspmc_extract(_regval));
}

static inline omap44xx_ehci_aspme_status_t omap44xx_ehci_usbcmd_aspme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_aspme_status_t omap44xx_ehci_usbcmd_aspme_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_aspme_extract(_regval));
}

static inline omap44xx_ehci_itc_status_t omap44xx_ehci_usbcmd_itc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_itc_status_t omap44xx_ehci_usbcmd_itc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_itc_extract(_regval));
}

static inline omap44xx_ehci_hird_status_t omap44xx_ehci_usbcmd_hird_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hird_status_t omap44xx_ehci_usbcmd_hird_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ehci_usbcmd_hird_extract(_regval));
}

static inline omap44xx_ehci_hcr_status_t omap44xx_ehci_usbcmd_hcr_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hcr_status_t omap44xx_ehci_usbcmd_hcr_rd_shadow(__DN(t) *_dev)
{
    return(omap44xx_ehci_usbcmd_hcr_extract(_dev->usbcmd_shadow));
}

static inline void omap44xx_ehci_usbcmd_rs_wrf(__DN(t) *_dev, omap44xx_ehci_rs_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_rs_wrf(__DN(t) *_dev, omap44xx_ehci_rs_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x1 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfff0bfc & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_hcr_wrf(__DN(t) *_dev, omap44xx_ehci_hcr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_hcr_wrf(__DN(t) *_dev, omap44xx_ehci_hcr_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x2 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfff0bfd & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_fls_wrf(__DN(t) *_dev, omap44xx_ehci_fls_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_fls_wrf(__DN(t) *_dev, omap44xx_ehci_fls_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0xc & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfff0bf1 & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_pse_wrf(__DN(t) *_dev, omap44xx_ehci_pse_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_pse_wrf(__DN(t) *_dev, omap44xx_ehci_pse_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x10 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfff0bed & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_ase_wrf(__DN(t) *_dev, omap44xx_ehci_ase_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_ase_wrf(__DN(t) *_dev, omap44xx_ehci_ase_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x20 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfff0bdd & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_iaad_wrf(__DN(t) *_dev, omap44xx_ehci_iaad_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_iaad_wrf(__DN(t) *_dev, omap44xx_ehci_iaad_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x40 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfff0bbd & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_lhcr_wrf(__DN(t) *_dev, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_lhcr_wrf(__DN(t) *_dev, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x80 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfff0b7d & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_aspmc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_aspmc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x300 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfff08fd & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_aspme_wrf(__DN(t) *_dev, omap44xx_ehci_aspme_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_aspme_wrf(__DN(t) *_dev, omap44xx_ehci_aspme_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0x800 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfff03fd & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_itc_wrf(__DN(t) *_dev, omap44xx_ehci_itc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_itc_wrf(__DN(t) *_dev, omap44xx_ehci_itc_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0xff0000 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf000bfd & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

static inline void omap44xx_ehci_usbcmd_hird_wrf(__DN(t) *_dev, omap44xx_ehci_hird_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbcmd_hird_wrf(__DN(t) *_dev, omap44xx_ehci_hird_status_t _fieldval)
{
    omap44xx_ehci_usbcmd_t _regval = 0xf000000 & (((omap44xx_ehci_usbcmd_t )(_fieldval)) << 24);
    _regval = (_regval | (0xff0bfd & mackerel_read_addr_32(_dev->base, 0x10)));
    _regval = (_regval | (0x2 & (_dev->usbcmd_shadow)));
    _regval = (_regval & 0xfff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    _dev->usbcmd_shadow = _regval;
}

/*
 * Register usbsts: USB status
 * Type: omap44xx_ehci.usbsts (Implicit type of USB status register)
 *   usbi	(size 1, offset 0, init 0):	RW	USB interruptThe host controller sets this bit to 1 on completion of a USB transaction, which results in the retirement of a transfer descriptor that had its IOC bit set. . The host controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes). .
 *   usbei	(size 1, offset 1, init 0):	RW	USB error interruptThe host controller sets this bit to 1 when completion of a USB transaction results in an error condition. .
 *   pcd	(size 1, offset 2, init 0):	RW	Port change detectThe host controller sets this bit to 1 when any port for which the USBHOST.[13] PO bit is set to 0 has a change bit transition from 0 to 1 or a USBHOST.[6] FPR bit transition from 0 to 1. . This bit is also set as a result of the USBHOST.[1] CSC bit being set to 1 after system software has relinquished ownership of a connected port by setting the USBHOST.[13] PO bit to 1. .
 *   flr	(size 1, offset 3, init 0):	RW	Frame list rolloverThe host controller sets this bit to 1 when the USBHOST. rolls over from its maximum value to 0. The exact value at which the rollover occurs depends on the frame list size. .
 *   hse	(size 1, offset 4, init 0):	RW	Host system errorThe host controller sets this bit to 1 when a serious error occurs during a host system access involving the host controller module. .
 *   iaa	(size 1, offset 5, init 0):	RW	Interrupt on async advanceSystem software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by setting the USBHOST.[6] IAAD bit to 1. This status bit indicates the assertion of that interrupt source. .
 *   _anon6	(size 6, offset 6, init 0):	MBZ	_
 *   hch	(size 1, offset 12, init 0):	RO	Host controller haltedThis bit is a 0 whenever the USBHOST.[0] RS bit is a 1. The host controller sets this bit to 1 after it has stopped executing as a result of the RS bit being set to 0, either by software or by the host controller hardware. .
 *   rec	(size 1, offset 13, init 0):	RO	ReclamationIt is used to detect an empty asynchronous schedule. .
 *   pss	(size 1, offset 14, init 0):	RO	Periodic schedule statusThe bit reports the current real status of the periodic schedule. .
 *   ass	(size 1, offset 15, init 0):	RO	Asynchronous schedule statusThe bit reports the current real status of the asynchronous schedule. .
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbsts_t omap44xx_ehci_usbsts_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void omap44xx_ehci_usbsts_rawwr(__DN(t) *_dev, omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_rawwr(__DN(t) *_dev, omap44xx_ehci_usbsts_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void omap44xx_ehci_usbsts_wr(__DN(t) *_dev, omap44xx_ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_wr(__DN(t) *_dev, omap44xx_ehci_usbsts_t _regval)
{
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int omap44xx_ehci_usbsts_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbsts_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbsts (USB status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbi =\t%" PRIx8 "\t(USB interruptThe host controller sets this bit to 1 on completion of a USB transaction, which results in the retirement of a transfer descriptor that had its IOC bit set. . The host controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes). .)\n", omap44xx_ehci_usbsts_usbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbei =\t%" PRIx8 "\t(USB error interruptThe host controller sets this bit to 1 when completion of a USB transaction results in an error condition. .)\n", omap44xx_ehci_usbsts_usbei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Port change detectThe host controller sets this bit to 1 when any port for which the USBHOST.[13] PO bit is set to 0 has a change bit transition from 0 to 1 or a USBHOST.[6] FPR bit transition from 0 to 1. . This bit is also set as a result of the USBHOST.[1] CSC bit being set to 1 after system software has relinquished ownership of a connected port by setting the USBHOST.[13] PO bit to 1. .)\n", omap44xx_ehci_usbsts_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr =\t%" PRIx8 "\t(Frame list rolloverThe host controller sets this bit to 1 when the USBHOST. rolls over from its maximum value to 0. The exact value at which the rollover occurs depends on the frame list size. .)\n", omap44xx_ehci_usbsts_flr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hse =\t%" PRIx8 "\t(Host system errorThe host controller sets this bit to 1 when a serious error occurs during a host system access involving the host controller module. .)\n", omap44xx_ehci_usbsts_hse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaa =\t%" PRIx8 "\t(Interrupt on async advanceSystem software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by setting the USBHOST.[6] IAAD bit to 1. This status bit indicates the assertion of that interrupt source. .)\n", omap44xx_ehci_usbsts_iaa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hch =\t%" PRIx8 "\t(Host controller haltedThis bit is a 0 whenever the USBHOST.[0] RS bit is a 1. The host controller sets this bit to 1 after it has stopped executing as a result of the RS bit being set to 0, either by software or by the host controller hardware. .)\n", omap44xx_ehci_usbsts_hch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rec =\t%" PRIx8 "\t(ReclamationIt is used to detect an empty asynchronous schedule. .)\n", omap44xx_ehci_usbsts_rec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_usbsts_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Periodic schedule statusThe bit reports the current real status of the periodic schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_usbsts_ass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Asynchronous schedule statusThe bit reports the current real status of the asynchronous schedule. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ehci_usbsts_usbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_usbi_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_usbi_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_usbei_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_usbei_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_usbei_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_pcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_pcd_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_pcd_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_flr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_flr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_flr_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_hse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_hse_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_hse_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_iaa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_iaa_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_iaa_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_hch_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_hch_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_hch_extract(_regval));
}

static inline uint8_t omap44xx_ehci_usbsts_rec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_usbsts_rec_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_rec_extract(_regval));
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_pss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_pss_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_pss_extract(_regval));
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_ass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_usbsts_ass_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(omap44xx_ehci_usbsts_ass_extract(_regval));
}

static inline void omap44xx_ehci_usbsts_usbi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_usbi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbsts_t _regval = 0x1 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3e & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbsts_usbei_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_usbei_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbsts_t _regval = 0x2 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 1);
    _regval = (_regval | (0x3d & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbsts_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbsts_t _regval = 0x4 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3b & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbsts_flr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_flr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbsts_t _regval = 0x8 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 3);
    _regval = (_regval | (0x37 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbsts_hse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_hse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbsts_t _regval = 0x10 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 4);
    _regval = (_regval | (0x2f & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbsts_iaa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbsts_iaa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_usbsts_t _regval = 0x20 & (((omap44xx_ehci_usbsts_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register usbintr: USB interrupt enable
 * Type: omap44xx_ehci.usbintr (Implicit type of USB interrupt enable register)
 *   usbie	(size 1, offset 0, init 0):	RW	USB interrupt enable
 *   usbeie	(size 1, offset 1, init 0):	RW	USB error interrupt enable
 *   pcie	(size 1, offset 2, init 0):	RW	Port change interrupt enable
 *   flre	(size 1, offset 3, init 0):	RW	Frame list rollover enable
 *   hsee	(size 1, offset 4, init 0):	RW	Host system error enable
 *   iaae	(size 1, offset 5, init 0):	RW	Interrupt on async advance enable
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbintr_t omap44xx_ehci_usbintr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void omap44xx_ehci_usbintr_rawwr(__DN(t) *_dev, omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_rawwr(__DN(t) *_dev, omap44xx_ehci_usbintr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void omap44xx_ehci_usbintr_wr(__DN(t) *_dev, omap44xx_ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_wr(__DN(t) *_dev, omap44xx_ehci_usbintr_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int omap44xx_ehci_usbintr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_usbintr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbintr (USB interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbie =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbie_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_usbie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB interrupt enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbeie =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbeie_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_usbeie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(USB error interrupt enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pcie_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_pcie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port change interrupt enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flre =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_flre_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_flre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list rollover enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsee =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hsee_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_hsee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host system error enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaae =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_iaae_status_prtval(_s + _r, _avail, omap44xx_ehci_usbintr_iaae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt on async advance enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline omap44xx_ehci_usbie_status_t omap44xx_ehci_usbintr_usbie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbie_status_t omap44xx_ehci_usbintr_usbie_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_ehci_usbintr_usbie_extract(_regval));
}

static inline omap44xx_ehci_usbeie_status_t omap44xx_ehci_usbintr_usbeie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_usbeie_status_t omap44xx_ehci_usbintr_usbeie_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_ehci_usbintr_usbeie_extract(_regval));
}

static inline omap44xx_ehci_pcie_status_t omap44xx_ehci_usbintr_pcie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pcie_status_t omap44xx_ehci_usbintr_pcie_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_ehci_usbintr_pcie_extract(_regval));
}

static inline omap44xx_ehci_flre_status_t omap44xx_ehci_usbintr_flre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_flre_status_t omap44xx_ehci_usbintr_flre_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_ehci_usbintr_flre_extract(_regval));
}

static inline omap44xx_ehci_hsee_status_t omap44xx_ehci_usbintr_hsee_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_hsee_status_t omap44xx_ehci_usbintr_hsee_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_ehci_usbintr_hsee_extract(_regval));
}

static inline omap44xx_ehci_iaae_status_t omap44xx_ehci_usbintr_iaae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_iaae_status_t omap44xx_ehci_usbintr_iaae_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(omap44xx_ehci_usbintr_iaae_extract(_regval));
}

static inline void omap44xx_ehci_usbintr_usbie_wrf(__DN(t) *_dev, omap44xx_ehci_usbie_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_usbie_wrf(__DN(t) *_dev, omap44xx_ehci_usbie_status_t _fieldval)
{
    omap44xx_ehci_usbintr_t _regval = 0x1 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3e & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbintr_usbeie_wrf(__DN(t) *_dev, omap44xx_ehci_usbeie_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_usbeie_wrf(__DN(t) *_dev, omap44xx_ehci_usbeie_status_t _fieldval)
{
    omap44xx_ehci_usbintr_t _regval = 0x2 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x3d & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbintr_pcie_wrf(__DN(t) *_dev, omap44xx_ehci_pcie_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_pcie_wrf(__DN(t) *_dev, omap44xx_ehci_pcie_status_t _fieldval)
{
    omap44xx_ehci_usbintr_t _regval = 0x4 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3b & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbintr_flre_wrf(__DN(t) *_dev, omap44xx_ehci_flre_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_flre_wrf(__DN(t) *_dev, omap44xx_ehci_flre_status_t _fieldval)
{
    omap44xx_ehci_usbintr_t _regval = 0x8 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x37 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbintr_hsee_wrf(__DN(t) *_dev, omap44xx_ehci_hsee_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_hsee_wrf(__DN(t) *_dev, omap44xx_ehci_hsee_status_t _fieldval)
{
    omap44xx_ehci_usbintr_t _regval = 0x10 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 4);
    _regval = (_regval | (0x2f & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_usbintr_iaae_wrf(__DN(t) *_dev, omap44xx_ehci_iaae_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_usbintr_iaae_wrf(__DN(t) *_dev, omap44xx_ehci_iaae_status_t _fieldval)
{
    omap44xx_ehci_usbintr_t _regval = 0x20 & (((omap44xx_ehci_usbintr_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register frindex: USB frame index
 * Type: omap44xx_ehci.frindex (Implicit type of USB frame index register)
 *   fi	(size 14, offset 0, init 0):	RW	Frame indexThe value in this register is incremented at the end of each time frame. .
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline omap44xx_ehci_frindex_t omap44xx_ehci_frindex_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_frindex_t omap44xx_ehci_frindex_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline omap44xx_ehci_frindex_t omap44xx_ehci_frindex_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_frindex_t omap44xx_ehci_frindex_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void omap44xx_ehci_frindex_rawwr(__DN(t) *_dev, omap44xx_ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_frindex_rawwr(__DN(t) *_dev, omap44xx_ehci_frindex_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void omap44xx_ehci_frindex_wr(__DN(t) *_dev, omap44xx_ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_frindex_wr(__DN(t) *_dev, omap44xx_ehci_frindex_t _regval)
{
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int omap44xx_ehci_frindex_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_frindex_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_frindex_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register frindex (USB frame index): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame indexThe value in this register is incremented at the end of each time frame. .)\n", omap44xx_ehci_frindex_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_ehci_frindex_fi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_frindex_fi_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_frindex_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(omap44xx_ehci_frindex_fi_extract(_regval));
}

static inline void omap44xx_ehci_frindex_fi_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_frindex_fi_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_ehci_frindex_t _regval = 0x3fff & (((omap44xx_ehci_frindex_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register ctrldssegment: 4G segment selector
 * Type: omap44xx_ehci.uint32 (primitive type)
 */
static inline uint32_t omap44xx_ehci_ctrldssegment_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_ctrldssegment_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline uint32_t omap44xx_ehci_ctrldssegment_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_ctrldssegment_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void omap44xx_ehci_ctrldssegment_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_ctrldssegment_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

// Register ctrldssegment is not writeable
static inline int omap44xx_ehci_ctrldssegment_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_ctrldssegment_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrldssegment (4G segment selector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register periodiclistbase: Frame list base address
 * Type: omap44xx_ehci.periodiclistbase (Implicit type of Frame list base address register)
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   bal	(size 20, offset 12, init 0):	RW	Base address (low)These bits correspond to memory address signals. .
 */
static inline omap44xx_ehci_periodiclistbase_t omap44xx_ehci_periodiclistbase_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_periodiclistbase_t omap44xx_ehci_periodiclistbase_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline omap44xx_ehci_periodiclistbase_t omap44xx_ehci_periodiclistbase_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_periodiclistbase_t omap44xx_ehci_periodiclistbase_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void omap44xx_ehci_periodiclistbase_rawwr(__DN(t) *_dev, omap44xx_ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_periodiclistbase_rawwr(__DN(t) *_dev, omap44xx_ehci_periodiclistbase_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void omap44xx_ehci_periodiclistbase_wr(__DN(t) *_dev, omap44xx_ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_periodiclistbase_wr(__DN(t) *_dev, omap44xx_ehci_periodiclistbase_t _regval)
{
    _regval = (_regval & 0xfffff000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int omap44xx_ehci_periodiclistbase_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_periodiclistbase_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_periodiclistbase_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register periodiclistbase (Frame list base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bal =\t%" PRIx32 "\t(Base address (low)These bits correspond to memory address signals. .)\n", omap44xx_ehci_periodiclistbase_bal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t omap44xx_ehci_periodiclistbase_bal_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_periodiclistbase_bal_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_periodiclistbase_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_ehci_periodiclistbase_bal_extract(_regval));
}

static inline void omap44xx_ehci_periodiclistbase_bal_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_periodiclistbase_bal_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_ehci_periodiclistbase_t _regval = 0xfffff000 & (((omap44xx_ehci_periodiclistbase_t )(_fieldval)) << 12);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register asynclistaddr: Next asynchronous list address
 * Type: omap44xx_ehci.asynclistaddr (Implicit type of Next asynchronous list address register)
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   lpl	(size 27, offset 5, init 0):	RW	Link pointer lowIt contains the address of the next asynchronous queue head to be executed. .
 */
static inline omap44xx_ehci_asynclistaddr_t omap44xx_ehci_asynclistaddr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_asynclistaddr_t omap44xx_ehci_asynclistaddr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_ehci_asynclistaddr_t omap44xx_ehci_asynclistaddr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_asynclistaddr_t omap44xx_ehci_asynclistaddr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_ehci_asynclistaddr_rawwr(__DN(t) *_dev, omap44xx_ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_asynclistaddr_rawwr(__DN(t) *_dev, omap44xx_ehci_asynclistaddr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_ehci_asynclistaddr_wr(__DN(t) *_dev, omap44xx_ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_asynclistaddr_wr(__DN(t) *_dev, omap44xx_ehci_asynclistaddr_t _regval)
{
    _regval = (_regval & 0xffffffe0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_ehci_asynclistaddr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_asynclistaddr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_asynclistaddr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register asynclistaddr (Next asynchronous list address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpl =\t%" PRIx32 "\t(Link pointer lowIt contains the address of the next asynchronous queue head to be executed. .)\n", omap44xx_ehci_asynclistaddr_lpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t omap44xx_ehci_asynclistaddr_lpl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_asynclistaddr_lpl_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_asynclistaddr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_ehci_asynclistaddr_lpl_extract(_regval));
}

static inline void omap44xx_ehci_asynclistaddr_lpl_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_asynclistaddr_lpl_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_ehci_asynclistaddr_t _regval = 0xffffffe0 & (((omap44xx_ehci_asynclistaddr_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffffffe0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register configflag: Configured flag register
 * Type: omap44xx_ehci.configflag (Implicit type of Configured flag register register)
 *   cf	(size 1, offset 0, init 0):	RW	Configure flagThis bit controls the default port-routing control logic. .
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_ehci_configflag_t omap44xx_ehci_configflag_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_configflag_t omap44xx_ehci_configflag_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline omap44xx_ehci_configflag_t omap44xx_ehci_configflag_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_configflag_t omap44xx_ehci_configflag_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void omap44xx_ehci_configflag_rawwr(__DN(t) *_dev, omap44xx_ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_configflag_rawwr(__DN(t) *_dev, omap44xx_ehci_configflag_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void omap44xx_ehci_configflag_wr(__DN(t) *_dev, omap44xx_ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_configflag_wr(__DN(t) *_dev, omap44xx_ehci_configflag_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int omap44xx_ehci_configflag_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_configflag_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_configflag_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register configflag (Configured flag register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_bit64ac_status_prtval(_s + _r, _avail, omap44xx_ehci_configflag_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Configure flagThis bit controls the default port-routing control logic. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_configflag_cf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_bit64ac_status_t omap44xx_ehci_configflag_cf_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_configflag_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_ehci_configflag_cf_extract(_regval));
}

static inline void omap44xx_ehci_configflag_cf_wrf(__DN(t) *_dev, omap44xx_ehci_bit64ac_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_configflag_cf_wrf(__DN(t) *_dev, omap44xx_ehci_bit64ac_status_t _fieldval)
{
    omap44xx_ehci_configflag_t _regval = 0x1 & (((omap44xx_ehci_configflag_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register portsc_i_0: Port status/control
 * Type: omap44xx_ehci.portsc_i_0 (Implicit type of Port status/control register)
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .
 *   csc	(size 1, offset 1, init 0):	RW	Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .
 *   pedc	(size 1, offset 3, init 0):	RW	Port enabled/disabled changeThis field is 0 if the PP bit is 0. .
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resumeThis field is 0 if the PP bit is 0. .
 *   sus	(size 1, offset 7, init 0):	RW	SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .
 *   pr	(size 1, offset 8, init 0):	RW	Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .
 *   suspendl1	(size 1, offset 9, init 0):	RW	When this bit is set to 1, an LPM token is generated.
 *   ls	(size 2, offset 10, init 0):	RO	Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .
 *   pp	(size 1, offset 12, init 0):	RW	Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .
 *   po	(size 1, offset 13, init 0):	RW	Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .
 *   pic	(size 2, offset 14, init 0):	RO	Port indicator control (not implemented)
 *   ptc	(size 4, offset 16, init 0):	RW	Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .
 *   wce	(size 1, offset 20, init 0):	RW	Wake on connect enableThis field is 0 if the PP bit is 0. .
 *   wde	(size 1, offset 21, init 0):	RW	Wake on disconnect enableThis field is 0 if the PP bit is 0. .
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   suspendstatus	(size 2, offset 23, init 0):	RO	Addition for LPM support.Indicates status of L1 suspend request: .
 *   deviceaddress	(size 7, offset 25, init 0):	RW	The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.
 */
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_0_t omap44xx_ehci_portsc_i_0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x54));
}

static inline void omap44xx_ehci_portsc_i_0_rawwr(__DN(t) *_dev, omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_rawwr(__DN(t) *_dev, omap44xx_ehci_portsc_i_0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline void omap44xx_ehci_portsc_i_0_wr(__DN(t) *_dev, omap44xx_ehci_portsc_i_0_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_wr(__DN(t) *_dev, omap44xx_ehci_portsc_i_0_t _regval)
{
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
}

static inline int omap44xx_ehci_portsc_i_0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsc_i_0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register portsc_i_0 (Port status/control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ccs_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_csc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ped_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabled changeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fpr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force port resumeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_sus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendl1_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_suspendl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(When this bit is set to 1, an LPM token is generated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .)\n", omap44xx_ehci_portsc_i_0_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .)\n", omap44xx_ehci_portsc_i_0_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_po_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t%" PRIx8 "\t(Port indicator control (not implemented))\n", omap44xx_ehci_portsc_i_0_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ptc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_wce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on connect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wde =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_p_indicator_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_wde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on disconnect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendstatus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendstatus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_0_suspendstatus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addition for LPM support.Indicates status of L1 suspend request: .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deviceaddress =\t%" PRIx8 "\t(The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.)\n", omap44xx_ehci_portsc_i_0_deviceaddress_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_0_ccs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_0_ccs_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_ccs_extract(_regval));
}

static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_0_csc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_0_csc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_csc_extract(_regval));
}

static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_0_ped_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_0_ped_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_ped_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_0_pedc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_0_pedc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_pedc_extract(_regval));
}

static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_0_fpr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_0_fpr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_fpr_extract(_regval));
}

static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_0_sus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_0_sus_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_sus_extract(_regval));
}

static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_0_pr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_0_pr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_pr_extract(_regval));
}

static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_0_suspendl1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_0_suspendl1_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_suspendl1_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_ls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_ls_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_ls_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_pp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_pp_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_pp_extract(_regval));
}

static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_0_po_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_0_po_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_po_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_pic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_pic_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_pic_extract(_regval));
}

static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_0_ptc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_0_ptc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_ptc_extract(_regval));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wce_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_wce_extract(_regval));
}

static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_p_indicator_status_t omap44xx_ehci_portsc_i_0_wde_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_wde_extract(_regval));
}

static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_0_suspendstatus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_0_suspendstatus_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_suspendstatus_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_0_deviceaddress_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_0_deviceaddress_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_0_t _regval = mackerel_read_addr_32(_dev->base, 0x54);
    return(omap44xx_ehci_portsc_i_0_deviceaddress_extract(_regval));
}

static inline void omap44xx_ehci_portsc_i_0_csc_wrf(__DN(t) *_dev, omap44xx_ehci_csc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_csc_wrf(__DN(t) *_dev, omap44xx_ehci_csc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x2 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfe3f33cc & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_ped_wrf(__DN(t) *_dev, omap44xx_ehci_ped_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_ped_wrf(__DN(t) *_dev, omap44xx_ehci_ped_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x4 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfe3f33ca & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_pedc_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_pedc_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x8 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfe3f33c6 & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_fpr_wrf(__DN(t) *_dev, omap44xx_ehci_fpr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_fpr_wrf(__DN(t) *_dev, omap44xx_ehci_fpr_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x40 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfe3f338e & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_sus_wrf(__DN(t) *_dev, omap44xx_ehci_sus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_sus_wrf(__DN(t) *_dev, omap44xx_ehci_sus_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x80 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfe3f334e & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_pr_wrf(__DN(t) *_dev, omap44xx_ehci_pr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_pr_wrf(__DN(t) *_dev, omap44xx_ehci_pr_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x100 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfe3f32ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_suspendl1_wrf(__DN(t) *_dev, omap44xx_ehci_suspendl1_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_suspendl1_wrf(__DN(t) *_dev, omap44xx_ehci_suspendl1_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x200 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfe3f31ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_pp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_pp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x1000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfe3f23ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_po_wrf(__DN(t) *_dev, omap44xx_ehci_po_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_po_wrf(__DN(t) *_dev, omap44xx_ehci_po_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x2000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 13);
    _regval = (_regval | (0xfe3f13ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_ptc_wrf(__DN(t) *_dev, omap44xx_ehci_ptc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_ptc_wrf(__DN(t) *_dev, omap44xx_ehci_ptc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0xf0000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfe3033ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_wce_wrf(__DN(t) *_dev, omap44xx_ehci_p_indicator_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_wce_wrf(__DN(t) *_dev, omap44xx_ehci_p_indicator_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x100000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfe2f33ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_wde_wrf(__DN(t) *_dev, omap44xx_ehci_p_indicator_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_wde_wrf(__DN(t) *_dev, omap44xx_ehci_p_indicator_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0x200000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfe1f33ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_0_deviceaddress_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_0_deviceaddress_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_portsc_i_0_t _regval = 0xfe000000 & (((omap44xx_ehci_portsc_i_0_t )(_fieldval)) << 25);
    _regval = (_regval | (0x3f33ce & mackerel_read_addr_32(_dev->base, 0x54)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54, _regval);
    // No shadow register to write to
}

/*
 * Register portsc_i_1: Port status/control
 * Type: omap44xx_ehci.portsc_i_1 (Implicit type of Port status/control register)
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .
 *   csc	(size 1, offset 1, init 0):	RW	Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .
 *   pedc	(size 1, offset 3, init 0):	RW	Port enabled/disabled changeThis field is 0 if the PP bit is 0. .
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resumeThis field is 0 if the PP bit is 0. .
 *   sus	(size 1, offset 7, init 0):	RW	SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .
 *   pr	(size 1, offset 8, init 0):	RW	Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .
 *   suspendl1	(size 1, offset 9, init 0):	RW	When this bit is set to 1, an LPM token is generated.
 *   ls	(size 2, offset 10, init 0):	RO	Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .
 *   pp	(size 1, offset 12, init 0):	RW	Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .
 *   po	(size 1, offset 13, init 0):	RW	Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .
 *   pic	(size 2, offset 14, init 0):	RO	Port indicator control (not implemented)
 *   ptc	(size 4, offset 16, init 0):	RW	Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .
 *   wce	(size 1, offset 20, init 0):	RW	Wake on connect enableThis field is 0 if the PP bit is 0. .
 *   wde	(size 1, offset 21, init 0):	RW	Wake on disconnect enableThis field is 0 if the PP bit is 0. .
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   suspendstatus	(size 2, offset 23, init 0):	RO	Addition for LPM support.Indicates status of L1 suspend request: .
 *   deviceaddress	(size 7, offset 25, init 0):	RW	The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.
 */
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_1_t omap44xx_ehci_portsc_i_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x58));
}

static inline void omap44xx_ehci_portsc_i_1_rawwr(__DN(t) *_dev, omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_rawwr(__DN(t) *_dev, omap44xx_ehci_portsc_i_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

static inline void omap44xx_ehci_portsc_i_1_wr(__DN(t) *_dev, omap44xx_ehci_portsc_i_1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_wr(__DN(t) *_dev, omap44xx_ehci_portsc_i_1_t _regval)
{
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
}

static inline int omap44xx_ehci_portsc_i_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsc_i_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register portsc_i_1 (Port status/control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ccs_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_csc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ped_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabled changeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fpr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force port resumeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_sus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendl1_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_suspendl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(When this bit is set to 1, an LPM token is generated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .)\n", omap44xx_ehci_portsc_i_1_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .)\n", omap44xx_ehci_portsc_i_1_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_po_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t%" PRIx8 "\t(Port indicator control (not implemented))\n", omap44xx_ehci_portsc_i_1_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ptc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_wce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on connect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wde =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_wde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on disconnect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendstatus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendstatus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_1_suspendstatus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addition for LPM support.Indicates status of L1 suspend request: .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deviceaddress =\t%" PRIx8 "\t(The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.)\n", omap44xx_ehci_portsc_i_1_deviceaddress_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_1_ccs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_1_ccs_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_ccs_extract(_regval));
}

static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_1_csc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_1_csc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_csc_extract(_regval));
}

static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_1_ped_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_1_ped_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_ped_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_pedc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_pedc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_pedc_extract(_regval));
}

static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_1_fpr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_1_fpr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_fpr_extract(_regval));
}

static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_1_sus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_1_sus_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_sus_extract(_regval));
}

static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_1_pr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_1_pr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_pr_extract(_regval));
}

static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_1_suspendl1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_1_suspendl1_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_suspendl1_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_ls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_ls_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_ls_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_pp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_pp_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_pp_extract(_regval));
}

static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_1_po_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_1_po_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_po_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_pic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_pic_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_pic_extract(_regval));
}

static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_1_ptc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_1_ptc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_ptc_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wce_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_wce_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_1_wde_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_wde_extract(_regval));
}

static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_1_suspendstatus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_1_suspendstatus_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_suspendstatus_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_1_deviceaddress_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_1_deviceaddress_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_1_t _regval = mackerel_read_addr_32(_dev->base, 0x58);
    return(omap44xx_ehci_portsc_i_1_deviceaddress_extract(_regval));
}

static inline void omap44xx_ehci_portsc_i_1_csc_wrf(__DN(t) *_dev, omap44xx_ehci_csc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_csc_wrf(__DN(t) *_dev, omap44xx_ehci_csc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x2 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfe3f33cc & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_ped_wrf(__DN(t) *_dev, omap44xx_ehci_ped_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_ped_wrf(__DN(t) *_dev, omap44xx_ehci_ped_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x4 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfe3f33ca & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_pedc_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_pedc_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x8 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfe3f33c6 & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_fpr_wrf(__DN(t) *_dev, omap44xx_ehci_fpr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_fpr_wrf(__DN(t) *_dev, omap44xx_ehci_fpr_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x40 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfe3f338e & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_sus_wrf(__DN(t) *_dev, omap44xx_ehci_sus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_sus_wrf(__DN(t) *_dev, omap44xx_ehci_sus_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x80 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfe3f334e & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_pr_wrf(__DN(t) *_dev, omap44xx_ehci_pr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_pr_wrf(__DN(t) *_dev, omap44xx_ehci_pr_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x100 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfe3f32ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_suspendl1_wrf(__DN(t) *_dev, omap44xx_ehci_suspendl1_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_suspendl1_wrf(__DN(t) *_dev, omap44xx_ehci_suspendl1_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x200 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfe3f31ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_pp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_pp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x1000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfe3f23ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_po_wrf(__DN(t) *_dev, omap44xx_ehci_po_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_po_wrf(__DN(t) *_dev, omap44xx_ehci_po_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x2000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 13);
    _regval = (_regval | (0xfe3f13ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_ptc_wrf(__DN(t) *_dev, omap44xx_ehci_ptc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_ptc_wrf(__DN(t) *_dev, omap44xx_ehci_ptc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0xf0000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfe3033ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_wce_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_wce_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x100000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfe2f33ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_wde_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_wde_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0x200000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfe1f33ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_1_deviceaddress_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_1_deviceaddress_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_portsc_i_1_t _regval = 0xfe000000 & (((omap44xx_ehci_portsc_i_1_t )(_fieldval)) << 25);
    _regval = (_regval | (0x3f33ce & mackerel_read_addr_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

/*
 * Register portsc_i_2: Port status/control
 * Type: omap44xx_ehci.portsc_i_2 (Implicit type of Port status/control register)
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .
 *   csc	(size 1, offset 1, init 0):	RW	Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .
 *   pedc	(size 1, offset 3, init 0):	RW	Port enabled/disabled changeThis field is 0 if the PP bit is 0. .
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resumeThis field is 0 if the PP bit is 0. .
 *   sus	(size 1, offset 7, init 0):	RW	SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .
 *   pr	(size 1, offset 8, init 0):	RW	Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .
 *   suspendl1	(size 1, offset 9, init 0):	RW	When this bit is set to 1, an LPM token is generated.
 *   ls	(size 2, offset 10, init 0):	RO	Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .
 *   pp	(size 1, offset 12, init 0):	RW	Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .
 *   po	(size 1, offset 13, init 0):	RW	Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .
 *   pic	(size 2, offset 14, init 0):	RO	Port indicator control (not implemented)
 *   ptc	(size 4, offset 16, init 0):	RW	Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .
 *   wce	(size 1, offset 20, init 0):	RW	Wake on connect enableThis field is 0 if the PP bit is 0. .
 *   wde	(size 1, offset 21, init 0):	RW	Wake on disconnect enableThis field is 0 if the PP bit is 0. .
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   suspendstatus	(size 2, offset 23, init 0):	RO	Addition for LPM support.Indicates status of L1 suspend request: .
 *   deviceaddress	(size 7, offset 25, init 0):	RW	The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.
 */
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsc_i_2_t omap44xx_ehci_portsc_i_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5c));
}

static inline void omap44xx_ehci_portsc_i_2_rawwr(__DN(t) *_dev, omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_rawwr(__DN(t) *_dev, omap44xx_ehci_portsc_i_2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

static inline void omap44xx_ehci_portsc_i_2_wr(__DN(t) *_dev, omap44xx_ehci_portsc_i_2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_wr(__DN(t) *_dev, omap44xx_ehci_portsc_i_2_t _regval)
{
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
}

static inline int omap44xx_ehci_portsc_i_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_portsc_i_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register portsc_i_2 (Port status/control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ccs_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current connect statusThis value reflects the current state of the port, and may not correspond directly to the event that caused the CSC bit to be set. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_csc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Connect status changeIndicates a change has occurred in the port CCS bit. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ped_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabledSoftware cannot enable a port by setting this bit to 1. The host controller only sets this to 1 when the reset sequence determines that the attached device is a high-speed device. . Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. . This field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port enabled/disabled changeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_fpr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Force port resumeThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_sus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(SuspendThis field is 0 if the PP bit is 0. . 0x0 when PED = 0x1: Port enabled . 0x1 when PED = 0x1: Port in suspend state .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pr_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port resetThis field is 0 if the PP bit is 0. . Write 0x1 when at 0x0: The bus reset sequence is started. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendl1_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_suspendl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(When this bit is set to 1, an LPM token is generated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Line statusThese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. This field is valid only when the port enable bit is 0 and the current connect status bit is set to 1. The encoding of the bits is: . Bits[11:10] USB State Interpretation . 0x0 SE0 Not low-speed device, perform EHCI reset. . 0x2 J-state Not low-speed device, perform EHCI reset. . 0x1 K-state Low-speed device, release ownership of port. . 0x3 Undefined Not low-speed device, perform EHCI reset. .)\n", omap44xx_ehci_portsc_i_2_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port powerThe function of this bit depends on the value of the USBHOST.[4] PPC bit. The behavior is as follows: . PPC PP Operation . 0x0 0x0 Forbidden . 0x0 0x1 Host controller does not have port power. control switches. Each port is hardwired to power. . 0x1 0x0 Host controller has port power control switches. Current switch state is off. . 0x1 0x1 Host controller has port power control switches. Current switch state is on. . When an overcurrent condition is detected on a powered port and the USBHOST.[4] PPC bit is a 1, the PP bit in each affected port may be transitioned by the host controller from 1 to 0. .)\n", omap44xx_ehci_portsc_i_2_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_po_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port ownerThis bit unconditionally goes to 0x0 when the USBHOST.[0] CF bit makes a transition from 0 to 1. This bit unconditionally goes to 0 whenever the USBHOST.[0] CF bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t%" PRIx8 "\t(Port indicator control (not implemented))\n", omap44xx_ehci_portsc_i_2_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ptc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test controlThe port is operating in specific test modes as indicated by the specific value. The encoding of the test mode bits are: . Others: Reserved .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_wce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on connect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wde =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_pedc_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_wde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Wake on disconnect enableThis field is 0 if the PP bit is 0. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " suspendstatus =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_suspendstatus_status_prtval(_s + _r, _avail, omap44xx_ehci_portsc_i_2_suspendstatus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Addition for LPM support.Indicates status of L1 suspend request: .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deviceaddress =\t%" PRIx8 "\t(The USB device address for the device attached to and immediately downstream from the associated root port. R/W only if LPM is enabled; otherwise, R.)\n", omap44xx_ehci_portsc_i_2_deviceaddress_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_2_ccs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ccs_status_t omap44xx_ehci_portsc_i_2_ccs_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_ccs_extract(_regval));
}

static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_2_csc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_csc_status_t omap44xx_ehci_portsc_i_2_csc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_csc_extract(_regval));
}

static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_2_ped_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ped_status_t omap44xx_ehci_portsc_i_2_ped_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_ped_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_pedc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_pedc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_pedc_extract(_regval));
}

static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_2_fpr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_fpr_status_t omap44xx_ehci_portsc_i_2_fpr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_fpr_extract(_regval));
}

static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_2_sus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_sus_status_t omap44xx_ehci_portsc_i_2_sus_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_sus_extract(_regval));
}

static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_2_pr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pr_status_t omap44xx_ehci_portsc_i_2_pr_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_pr_extract(_regval));
}

static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_2_suspendl1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendl1_status_t omap44xx_ehci_portsc_i_2_suspendl1_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_suspendl1_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_ls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_ls_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_ls_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_pp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_pp_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_pp_extract(_regval));
}

static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_2_po_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_po_status_t omap44xx_ehci_portsc_i_2_po_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_po_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_pic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_pic_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_pic_extract(_regval));
}

static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_2_ptc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_ptc_status_t omap44xx_ehci_portsc_i_2_ptc_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_ptc_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wce_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_wce_extract(_regval));
}

static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_pedc_status_t omap44xx_ehci_portsc_i_2_wde_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_wde_extract(_regval));
}

static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_2_suspendstatus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_suspendstatus_status_t omap44xx_ehci_portsc_i_2_suspendstatus_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_suspendstatus_extract(_regval));
}

static inline uint8_t omap44xx_ehci_portsc_i_2_deviceaddress_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_portsc_i_2_deviceaddress_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_portsc_i_2_t _regval = mackerel_read_addr_32(_dev->base, 0x5c);
    return(omap44xx_ehci_portsc_i_2_deviceaddress_extract(_regval));
}

static inline void omap44xx_ehci_portsc_i_2_csc_wrf(__DN(t) *_dev, omap44xx_ehci_csc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_csc_wrf(__DN(t) *_dev, omap44xx_ehci_csc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x2 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfe3f33cc & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_ped_wrf(__DN(t) *_dev, omap44xx_ehci_ped_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_ped_wrf(__DN(t) *_dev, omap44xx_ehci_ped_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x4 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfe3f33ca & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_pedc_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_pedc_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x8 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfe3f33c6 & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_fpr_wrf(__DN(t) *_dev, omap44xx_ehci_fpr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_fpr_wrf(__DN(t) *_dev, omap44xx_ehci_fpr_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x40 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfe3f338e & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_sus_wrf(__DN(t) *_dev, omap44xx_ehci_sus_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_sus_wrf(__DN(t) *_dev, omap44xx_ehci_sus_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x80 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfe3f334e & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_pr_wrf(__DN(t) *_dev, omap44xx_ehci_pr_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_pr_wrf(__DN(t) *_dev, omap44xx_ehci_pr_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x100 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfe3f32ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_suspendl1_wrf(__DN(t) *_dev, omap44xx_ehci_suspendl1_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_suspendl1_wrf(__DN(t) *_dev, omap44xx_ehci_suspendl1_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x200 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfe3f31ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_pp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_pp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x1000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfe3f23ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_po_wrf(__DN(t) *_dev, omap44xx_ehci_po_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_po_wrf(__DN(t) *_dev, omap44xx_ehci_po_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x2000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 13);
    _regval = (_regval | (0xfe3f13ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_ptc_wrf(__DN(t) *_dev, omap44xx_ehci_ptc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_ptc_wrf(__DN(t) *_dev, omap44xx_ehci_ptc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0xf0000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfe3033ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_wce_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_wce_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x100000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfe2f33ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_wde_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_wde_wrf(__DN(t) *_dev, omap44xx_ehci_pedc_status_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0x200000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfe1f33ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_portsc_i_2_deviceaddress_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_portsc_i_2_deviceaddress_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_portsc_i_2_t _regval = 0xfe000000 & (((omap44xx_ehci_portsc_i_2_t )(_fieldval)) << 25);
    _regval = (_regval | (0x3f33ce & mackerel_read_addr_32(_dev->base, 0x5c)));
    // No read of register shadow required
    _regval = (_regval & 0xffbfffcf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5c, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg00: Implementation-specific register 0
 * Type: omap44xx_ehci.insnreg00 (Implicit type of Implementation-specific register 0 register)
 *   en	(size 1, offset 0, init 0):	RW	Enable of this register
 *   uframe_cnt	(size 13, offset 1, init 0):	RW	1-microframe length value, to reduce simulation time. SIMULATIONS ONLY, NOT AN ACTUAL REGISTER.
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg00_t omap44xx_ehci_insnreg00_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline void omap44xx_ehci_insnreg00_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg00_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg00_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg00_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
}

static inline void omap44xx_ehci_insnreg00_wr(__DN(t) *_dev, omap44xx_ehci_insnreg00_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg00_wr(__DN(t) *_dev, omap44xx_ehci_insnreg00_t _regval)
{
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
}

static inline int omap44xx_ehci_insnreg00_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg00_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg00_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg00 (Implementation-specific register 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Enable of this register)\n", omap44xx_ehci_insnreg00_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uframe_cnt =\t%" PRIx16 "\t(1-microframe length value, to reduce simulation time. SIMULATIONS ONLY, NOT AN ACTUAL REGISTER.)\n", omap44xx_ehci_insnreg00_uframe_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ehci_insnreg00_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg00_en_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg00_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    return(omap44xx_ehci_insnreg00_en_extract(_regval));
}

static inline uint16_t omap44xx_ehci_insnreg00_uframe_cnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg00_uframe_cnt_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg00_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    return(omap44xx_ehci_insnreg00_uframe_cnt_extract(_regval));
}

static inline void omap44xx_ehci_insnreg00_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg00_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg00_t _regval = 0x1 & (((omap44xx_ehci_insnreg00_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3ffe & mackerel_read_addr_32(_dev->base, 0x90)));
    // No read of register shadow required
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg00_uframe_cnt_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg00_uframe_cnt_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_ehci_insnreg00_t _regval = 0x3ffe & (((omap44xx_ehci_insnreg00_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->base, 0x90)));
    // No read of register shadow required
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg01: Implementation-specific register 1
 * Type: omap44xx_ehci.insnreg01 (Implicit type of Implementation-specific register 1 register)
 *   in_threshold	(size 16, offset 0, init 0):	RW	Programmable input packet buffer threshold, in 32-bit words
 *   out_threshold	(size 16, offset 16, init 0):	RW	Programmable output packet buffer threshold, in 32-bit words
 */
static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x94));
}

static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg01_t omap44xx_ehci_insnreg01_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x94));
}

static inline void omap44xx_ehci_insnreg01_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg01_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg01_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg01_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
}

static inline void omap44xx_ehci_insnreg01_wr(__DN(t) *_dev, omap44xx_ehci_insnreg01_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg01_wr(__DN(t) *_dev, omap44xx_ehci_insnreg01_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
}

static inline int omap44xx_ehci_insnreg01_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg01_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg01_t _regval = mackerel_read_addr_32(_dev->base, 0x94);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg01 (Implementation-specific register 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " in_threshold =\t%" PRIx16 "\t(Programmable input packet buffer threshold, in 32-bit words)\n", omap44xx_ehci_insnreg01_in_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out_threshold =\t%" PRIx16 "\t(Programmable output packet buffer threshold, in 32-bit words)\n", omap44xx_ehci_insnreg01_out_threshold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t omap44xx_ehci_insnreg01_in_threshold_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg01_in_threshold_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg01_t _regval = mackerel_read_addr_32(_dev->base, 0x94);
    return(omap44xx_ehci_insnreg01_in_threshold_extract(_regval));
}

static inline uint16_t omap44xx_ehci_insnreg01_out_threshold_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg01_out_threshold_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg01_t _regval = mackerel_read_addr_32(_dev->base, 0x94);
    return(omap44xx_ehci_insnreg01_out_threshold_extract(_regval));
}

static inline void omap44xx_ehci_insnreg01_in_threshold_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg01_in_threshold_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_ehci_insnreg01_t _regval = 0xffff & (((omap44xx_ehci_insnreg01_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x94)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg01_out_threshold_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg01_out_threshold_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_ehci_insnreg01_t _regval = 0xffff0000 & (((omap44xx_ehci_insnreg01_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x94)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg02: Implementation-specific register 2
 * Type: omap44xx_ehci.insnreg02 (Implicit type of Implementation-specific register 2 register)
 *   buf_depth	(size 12, offset 0, init 0):	RW	Programmable packet buffer depth, in 32-bit words
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
static inline omap44xx_ehci_insnreg02_t omap44xx_ehci_insnreg02_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg02_t omap44xx_ehci_insnreg02_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x98));
}

static inline omap44xx_ehci_insnreg02_t omap44xx_ehci_insnreg02_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg02_t omap44xx_ehci_insnreg02_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x98));
}

static inline void omap44xx_ehci_insnreg02_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg02_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg02_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg02_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
}

static inline void omap44xx_ehci_insnreg02_wr(__DN(t) *_dev, omap44xx_ehci_insnreg02_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg02_wr(__DN(t) *_dev, omap44xx_ehci_insnreg02_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
}

static inline int omap44xx_ehci_insnreg02_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg02_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg02_t _regval = mackerel_read_addr_32(_dev->base, 0x98);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg02 (Implementation-specific register 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " buf_depth =\t%" PRIx16 "\t(Programmable packet buffer depth, in 32-bit words)\n", omap44xx_ehci_insnreg02_buf_depth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_ehci_insnreg02_buf_depth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg02_buf_depth_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg02_t _regval = mackerel_read_addr_32(_dev->base, 0x98);
    return(omap44xx_ehci_insnreg02_buf_depth_extract(_regval));
}

static inline void omap44xx_ehci_insnreg02_buf_depth_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg02_buf_depth_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_ehci_insnreg02_t _regval = 0xfff & (((omap44xx_ehci_insnreg02_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x98, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg03: Implementation-specific register 3
 * Type: omap44xx_ehci.insnreg03 (Implicit type of Implementation-specific register 3 register)
 *   brk_mem_trsf	(size 1, offset 0, init 0):	RW	Break memory transfer, in conjunction withINSNREG01
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_ehci_insnreg03_t omap44xx_ehci_insnreg03_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg03_t omap44xx_ehci_insnreg03_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9c));
}

static inline omap44xx_ehci_insnreg03_t omap44xx_ehci_insnreg03_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg03_t omap44xx_ehci_insnreg03_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9c));
}

static inline void omap44xx_ehci_insnreg03_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg03_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg03_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg03_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
}

static inline void omap44xx_ehci_insnreg03_wr(__DN(t) *_dev, omap44xx_ehci_insnreg03_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg03_wr(__DN(t) *_dev, omap44xx_ehci_insnreg03_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
}

static inline int omap44xx_ehci_insnreg03_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg03_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg03_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg03 (Implementation-specific register 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " brk_mem_trsf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_brk_mem_trsf_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg03_brk_mem_trsf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Break memory transfer, in conjunction withINSNREG01)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_ehci_brk_mem_trsf_status_t omap44xx_ehci_insnreg03_brk_mem_trsf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_brk_mem_trsf_status_t omap44xx_ehci_insnreg03_brk_mem_trsf_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg03_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    return(omap44xx_ehci_insnreg03_brk_mem_trsf_extract(_regval));
}

static inline void omap44xx_ehci_insnreg03_brk_mem_trsf_wrf(__DN(t) *_dev, omap44xx_ehci_brk_mem_trsf_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg03_brk_mem_trsf_wrf(__DN(t) *_dev, omap44xx_ehci_brk_mem_trsf_status_t _fieldval)
{
    omap44xx_ehci_insnreg03_t _regval = 0x1 & (((omap44xx_ehci_insnreg03_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg04: Implementation-specific register 4
 * Type: omap44xx_ehci.insnreg04 (Implicit type of Implementation-specific register 4 register)
 *   hcsparams_wre	(size 1, offset 0, init 0):	RW	Make read-onlyHCSPARAMS register writable (debug)
 *   hccparams_wre	(size 1, offset 1, init 0):	RW	Make read-onlyHCCPARAMS register writable (debug)
 *   short_port_enum	(size 1, offset 2, init 0):	RW	Scale down port enumeration time (debug)
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   nak_fix_dis	(size 1, offset 4, init 0):	RW	Disable NAK fix (don't touch)
 *   _anon5	(size 27, offset 5, init 0):	MBZ	_
 */
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg04_t omap44xx_ehci_insnreg04_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline void omap44xx_ehci_insnreg04_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg04_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg04_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

static inline void omap44xx_ehci_insnreg04_wr(__DN(t) *_dev, omap44xx_ehci_insnreg04_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg04_wr(__DN(t) *_dev, omap44xx_ehci_insnreg04_t _regval)
{
    _regval = (_regval & 0x17);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

static inline int omap44xx_ehci_insnreg04_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg04_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg04_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg04 (Implementation-specific register 4): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcsparams_wre =\t%" PRIx8 "\t(Make read-onlyHCSPARAMS register writable (debug))\n", omap44xx_ehci_insnreg04_hcsparams_wre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hccparams_wre =\t%" PRIx8 "\t(Make read-onlyHCCPARAMS register writable (debug))\n", omap44xx_ehci_insnreg04_hccparams_wre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " short_port_enum =\t%" PRIx8 "\t(Scale down port enumeration time (debug))\n", omap44xx_ehci_insnreg04_short_port_enum_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nak_fix_dis =\t%" PRIx8 "\t(Disable NAK fix (don't touch))\n", omap44xx_ehci_insnreg04_nak_fix_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ehci_insnreg04_hcsparams_wre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_hcsparams_wre_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg04_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ehci_insnreg04_hcsparams_wre_extract(_regval));
}

static inline uint8_t omap44xx_ehci_insnreg04_hccparams_wre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_hccparams_wre_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg04_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ehci_insnreg04_hccparams_wre_extract(_regval));
}

static inline uint8_t omap44xx_ehci_insnreg04_short_port_enum_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_short_port_enum_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg04_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ehci_insnreg04_short_port_enum_extract(_regval));
}

static inline uint8_t omap44xx_ehci_insnreg04_nak_fix_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg04_nak_fix_dis_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg04_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ehci_insnreg04_nak_fix_dis_extract(_regval));
}

static inline void omap44xx_ehci_insnreg04_hcsparams_wre_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg04_hcsparams_wre_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg04_t _regval = 0x1 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 0);
    _regval = (_regval | (0x16 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x17);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg04_hccparams_wre_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg04_hccparams_wre_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg04_t _regval = 0x2 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 1);
    _regval = (_regval | (0x15 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x17);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg04_short_port_enum_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg04_short_port_enum_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg04_t _regval = 0x4 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 2);
    _regval = (_regval | (0x13 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x17);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg04_nak_fix_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg04_nak_fix_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg04_t _regval = 0x10 & (((omap44xx_ehci_insnreg04_t )(_fieldval)) << 4);
    _regval = (_regval | (0x7 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x17);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg05_ulpi: Implementation-specific register 5. Register functionality for ULPI mode.
 * Type: omap44xx_ehci.insnreg05_ulpi (Implicit type of Implementation-specific register 5. Register functionality for ULPI mode. register)
 *   rdwrdata	(size 8, offset 0, init 0):	RW	Read/write data of (resp. read/write) register access
 *   extregadd	(size 8, offset 8, init 0):	RW	Address for extended register accesses. Don't care for direct accesses.
 *   regadd	(size 6, offset 16, init 0):	RW	ULPI direct register address, for any value different than 0x2F.
 *   opsel	(size 2, offset 22, init 0):	RW	
 *   portsel	(size 4, offset 24, init 0):	RW	
 *   _anon28	(size 3, offset 28, init 0):	MBZ	_
 *   control	(size 1, offset 31, init 0):	RW	Control/status of the ULPI register access
 */
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg05_ulpi_t omap44xx_ehci_insnreg05_ulpi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline void omap44xx_ehci_insnreg05_ulpi_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

static inline void omap44xx_ehci_insnreg05_ulpi_wr(__DN(t) *_dev, omap44xx_ehci_insnreg05_ulpi_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_wr(__DN(t) *_dev, omap44xx_ehci_insnreg05_ulpi_t _regval)
{
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

static inline int omap44xx_ehci_insnreg05_ulpi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg05_ulpi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg05_ulpi (Implementation-specific register 5. Register functionality for ULPI mode.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdwrdata =\t%" PRIx8 "\t(Read/write data of (resp. read/write) register access)\n", omap44xx_ehci_insnreg05_ulpi_rdwrdata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " extregadd =\t%" PRIx8 "\t(Address for extended register accesses. Don't care for direct accesses.)\n", omap44xx_ehci_insnreg05_ulpi_extregadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " regadd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_regadd_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_regadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ULPI direct register address, for any value different than 0x2F.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " opsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_opsel_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_opsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " portsel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_portsel_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_portsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t()\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " control =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_control_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg05_ulpi_control_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control/status of the ULPI register access)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_ehci_insnreg05_ulpi_rdwrdata_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg05_ulpi_rdwrdata_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ehci_insnreg05_ulpi_rdwrdata_extract(_regval));
}

static inline uint8_t omap44xx_ehci_insnreg05_ulpi_extregadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg05_ulpi_extregadd_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ehci_insnreg05_ulpi_extregadd_extract(_regval));
}

static inline omap44xx_ehci_regadd_status_t omap44xx_ehci_insnreg05_ulpi_regadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_regadd_status_t omap44xx_ehci_insnreg05_ulpi_regadd_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ehci_insnreg05_ulpi_regadd_extract(_regval));
}

static inline omap44xx_ehci_opsel_status_t omap44xx_ehci_insnreg05_ulpi_opsel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_opsel_status_t omap44xx_ehci_insnreg05_ulpi_opsel_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ehci_insnreg05_ulpi_opsel_extract(_regval));
}

static inline omap44xx_ehci_portsel_status_t omap44xx_ehci_insnreg05_ulpi_portsel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_portsel_status_t omap44xx_ehci_insnreg05_ulpi_portsel_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ehci_insnreg05_ulpi_portsel_extract(_regval));
}

static inline omap44xx_ehci_control_status_t omap44xx_ehci_insnreg05_ulpi_control_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_control_status_t omap44xx_ehci_insnreg05_ulpi_control_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ehci_insnreg05_ulpi_control_extract(_regval));
}

static inline void omap44xx_ehci_insnreg05_ulpi_rdwrdata_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_rdwrdata_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = 0xff & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 0);
    _regval = (_regval | (0x8fffff00 & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg05_ulpi_extregadd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_extregadd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = 0xff00 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 8);
    _regval = (_regval | (0x8fff00ff & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg05_ulpi_regadd_wrf(__DN(t) *_dev, omap44xx_ehci_regadd_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_regadd_wrf(__DN(t) *_dev, omap44xx_ehci_regadd_status_t _fieldval)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = 0x3f0000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 16);
    _regval = (_regval | (0x8fc0ffff & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg05_ulpi_opsel_wrf(__DN(t) *_dev, omap44xx_ehci_opsel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_opsel_wrf(__DN(t) *_dev, omap44xx_ehci_opsel_status_t _fieldval)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = 0xc00000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 22);
    _regval = (_regval | (0x8f3fffff & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg05_ulpi_portsel_wrf(__DN(t) *_dev, omap44xx_ehci_portsel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_portsel_wrf(__DN(t) *_dev, omap44xx_ehci_portsel_status_t _fieldval)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = 0xf000000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 24);
    _regval = (_regval | (0x80ffffff & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ehci_insnreg05_ulpi_control_wrf(__DN(t) *_dev, omap44xx_ehci_control_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg05_ulpi_control_wrf(__DN(t) *_dev, omap44xx_ehci_control_status_t _fieldval)
{
    omap44xx_ehci_insnreg05_ulpi_t _regval = 0x80000000 & (((omap44xx_ehci_insnreg05_ulpi_t )(_fieldval)) << 31);
    _regval = (_regval | (0xfffffff & mackerel_read_addr_32(_dev->base, 0xa4)));
    // No read of register shadow required
    _regval = (_regval & 0x8fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg06: AHB error status
 * Type: omap44xx_ehci.insnreg06 (Implicit type of AHB error status register)
 *   beatscomp	(size 4, offset 0, init 0):	RO	Number of successfully completed beats in the current burst before the AHB error occurred
 *   beatsexp	(size 5, offset 4, init 0):	RO	Number of beats expected in the burst at which the AHB error occurred. Valid values are 0 to 16.
 *   hburst	(size 3, offset 9, init 0):	RO	HBURST Value of the control phase at which the AHB error occurred
 *   _anon12	(size 19, offset 12, init 0):	MBZ	_
 *   errorcap	(size 1, offset 31, init 0):	RW	Indicator that an AHB error was encountered and values were captured
 */
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa8));
}

static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg06_t omap44xx_ehci_insnreg06_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa8));
}

static inline void omap44xx_ehci_insnreg06_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg06_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg06_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
}

static inline void omap44xx_ehci_insnreg06_wr(__DN(t) *_dev, omap44xx_ehci_insnreg06_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg06_wr(__DN(t) *_dev, omap44xx_ehci_insnreg06_t _regval)
{
    _regval = (_regval & 0x80000fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
}

static inline int omap44xx_ehci_insnreg06_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg06_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg06_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg06 (AHB error status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beatscomp =\t%" PRIx8 "\t(Number of successfully completed beats in the current burst before the AHB error occurred)\n", omap44xx_ehci_insnreg06_beatscomp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " beatsexp =\t%" PRIx8 "\t(Number of beats expected in the burst at which the AHB error occurred. Valid values are 0 to 16.)\n", omap44xx_ehci_insnreg06_beatsexp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hburst =\t%" PRIx8 "\t(HBURST Value of the control phase at which the AHB error occurred)\n", omap44xx_ehci_insnreg06_hburst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " errorcap =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_errorcap_status_prtval(_s + _r, _avail, omap44xx_ehci_insnreg06_errorcap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Indicator that an AHB error was encountered and values were captured)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_ehci_insnreg06_beatscomp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg06_beatscomp_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg06_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_ehci_insnreg06_beatscomp_extract(_regval));
}

static inline uint8_t omap44xx_ehci_insnreg06_beatsexp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg06_beatsexp_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg06_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_ehci_insnreg06_beatsexp_extract(_regval));
}

static inline uint8_t omap44xx_ehci_insnreg06_hburst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ehci_insnreg06_hburst_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg06_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_ehci_insnreg06_hburst_extract(_regval));
}

static inline omap44xx_ehci_errorcap_status_t omap44xx_ehci_insnreg06_errorcap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_errorcap_status_t omap44xx_ehci_insnreg06_errorcap_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg06_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_ehci_insnreg06_errorcap_extract(_regval));
}

static inline void omap44xx_ehci_insnreg06_errorcap_wrf(__DN(t) *_dev, omap44xx_ehci_errorcap_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg06_errorcap_wrf(__DN(t) *_dev, omap44xx_ehci_errorcap_status_t _fieldval)
{
    omap44xx_ehci_insnreg06_t _regval = 0x80000000 & (((omap44xx_ehci_insnreg06_t )(_fieldval)) << 31);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x80000fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
    // No shadow register to write to
}

/*
 * Register insnreg07: AHB master error address
 * Type: omap44xx_ehci.uint32 (primitive type)
 */
static inline uint32_t omap44xx_ehci_insnreg07_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_insnreg07_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xac));
}

static inline uint32_t omap44xx_ehci_insnreg07_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ehci_insnreg07_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xac));
}

static inline void omap44xx_ehci_insnreg07_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg07_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
}

// Register insnreg07 is not writeable
static inline int omap44xx_ehci_insnreg07_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg07_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg07 (AHB master error address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register insnreg08: 
 * Type: omap44xx_ehci.insnreg08 (Implicit type of  register)
 *   newbitfield1	(size 16, offset 0, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline omap44xx_ehci_insnreg08_t omap44xx_ehci_insnreg08_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg08_t omap44xx_ehci_insnreg08_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb0));
}

static inline omap44xx_ehci_insnreg08_t omap44xx_ehci_insnreg08_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ehci_insnreg08_t omap44xx_ehci_insnreg08_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb0));
}

static inline void omap44xx_ehci_insnreg08_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg08_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg08_rawwr(__DN(t) *_dev, omap44xx_ehci_insnreg08_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
}

static inline void omap44xx_ehci_insnreg08_wr(__DN(t) *_dev, omap44xx_ehci_insnreg08_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg08_wr(__DN(t) *_dev, omap44xx_ehci_insnreg08_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
}

static inline int omap44xx_ehci_insnreg08_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_insnreg08_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ehci_insnreg08_t _regval = mackerel_read_addr_32(_dev->base, 0xb0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register insnreg08 (): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " newbitfield1 =\t%" PRIx16 "\t()\n", omap44xx_ehci_insnreg08_newbitfield1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t omap44xx_ehci_insnreg08_newbitfield1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t omap44xx_ehci_insnreg08_newbitfield1_rdf(__DN(t) *_dev)
{
    omap44xx_ehci_insnreg08_t _regval = mackerel_read_addr_32(_dev->base, 0xb0);
    return(omap44xx_ehci_insnreg08_newbitfield1_extract(_regval));
}

static inline void omap44xx_ehci_insnreg08_newbitfield1_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ehci_insnreg08_newbitfield1_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    omap44xx_ehci_insnreg08_t _regval = 0xffff & (((omap44xx_ehci_insnreg08_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
    // No shadow register to write to
}

static inline int omap44xx_ehci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ehci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_ehci ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hccapbase_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hcsparams_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_hccparams_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbcmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbsts_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_usbintr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_frindex_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_ctrldssegment_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_periodiclistbase_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_asynclistaddr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_configflag_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_portsc_i_0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_portsc_i_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_portsc_i_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg00_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg01_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg02_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg03_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg04_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg05_ulpi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg06_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg07_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ehci_insnreg08_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_ehci\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_ehci_DEV_H
