#ifndef __omap44xx_ckgen_cm1_DEV_H
#define __omap44xx_ckgen_cm1_DEV_H 1
/*
 * DEVICE DEFINITION: 
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) omap44xx_ckgen_cm1 ## _ ## x
/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_l4_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_l4_status_t;
#define omap44xx_ckgen_cm1_CLKSEL_L4_0 ((omap44xx_ckgen_cm1_clksel_l4_status_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_L4_1 ((omap44xx_ckgen_cm1_clksel_l4_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_clksel_l4_status_describe(omap44xx_ckgen_cm1_clksel_l4_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_l4_status_describe(omap44xx_ckgen_cm1_clksel_l4_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_L4_0:
        return("CLKSEL_L4_0: L4_CLK is L3_CLK divided by 1");
    case omap44xx_ckgen_cm1_CLKSEL_L4_1:
        return("CLKSEL_L4_1: L4_CLK is L3_CLK divided by 2, to be used for OPP100 and OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_l4_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_l4_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_l4_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_l4_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_l4_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_l4_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_l3_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_l3_status_t;
#define omap44xx_ckgen_cm1_CLKSEL_L3_0 ((omap44xx_ckgen_cm1_clksel_l3_status_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_L3_1 ((omap44xx_ckgen_cm1_clksel_l3_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_clksel_l3_status_describe(omap44xx_ckgen_cm1_clksel_l3_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_l3_status_describe(omap44xx_ckgen_cm1_clksel_l3_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_L3_0:
        return("CLKSEL_L3_0: L3_CLK is CORE_CLK divided by 1");
    case omap44xx_ckgen_cm1_CLKSEL_L3_1:
        return("CLKSEL_L3_1: L3_CLK is CORE_CLK divided by 2, to be used for OPP100 and OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_l3_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_l3_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_l3_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_l3_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_l3_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_l3_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_core_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_core_status_t;
#define omap44xx_ckgen_cm1_CLKSEL_CORE_0 ((omap44xx_ckgen_cm1_clksel_core_status_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_CORE_1 ((omap44xx_ckgen_cm1_clksel_core_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_clksel_core_status_describe(omap44xx_ckgen_cm1_clksel_core_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_core_status_describe(omap44xx_ckgen_cm1_clksel_core_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_CORE_0:
        return("CLKSEL_CORE_0: CORE_CLK is CORE_X2_CLK divided by 1, to be used for OPP100 and OPP50");
    case omap44xx_ckgen_cm1_CLKSEL_CORE_1:
        return("CLKSEL_CORE_1: CORE_CLK is CORE_X2_CLK divided by 2");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_core_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_core_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_core_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_core_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_core_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_core_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.slimbus_clk_gate_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_slimbus_clk_gate_status_t;
#define omap44xx_ckgen_cm1_SLIMBUS_CLK_GATE_0 ((omap44xx_ckgen_cm1_slimbus_clk_gate_status_t)0x0)
#define omap44xx_ckgen_cm1_SLIMBUS_CLK_GATE_1 ((omap44xx_ckgen_cm1_slimbus_clk_gate_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_slimbus_clk_gate_status_describe(omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_slimbus_clk_gate_status_describe(omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_SLIMBUS_CLK_GATE_0:
        return("SLIMBUS_CLK_GATE_0: The clock is gated");
    case omap44xx_ckgen_cm1_SLIMBUS_CLK_GATE_1:
        return("SLIMBUS_CLK_GATE_1: The clock is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_slimbus_clk_gate_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_slimbus_clk_gate_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_slimbus_clk_gate_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_slimbus_clk_gate_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_opp_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_opp_status_t;
#define omap44xx_ckgen_cm1_CLKSEL_OPP_0 ((omap44xx_ckgen_cm1_clksel_opp_status_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_OPP_1 ((omap44xx_ckgen_cm1_clksel_opp_status_t)0x1)
#define omap44xx_ckgen_cm1_CLKSEL_OPP_2 ((omap44xx_ckgen_cm1_clksel_opp_status_t)0x2)
#define omap44xx_ckgen_cm1_CLKSEL_OPP_3 ((omap44xx_ckgen_cm1_clksel_opp_status_t)0x3)

static inline char *omap44xx_ckgen_cm1_clksel_opp_status_describe(omap44xx_ckgen_cm1_clksel_opp_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_opp_status_describe(omap44xx_ckgen_cm1_clksel_opp_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_OPP_0:
        return("CLKSEL_OPP_0: ABE_CLK is divide by 1 of DPLL_ABE_X2_CLK, to be used for OPP100");
    case omap44xx_ckgen_cm1_CLKSEL_OPP_1:
        return("CLKSEL_OPP_1: ABE_CLK is divide by 2 of DPLL_ABE_X2_CLK, to be used for OPP50");
    case omap44xx_ckgen_cm1_CLKSEL_OPP_2:
        return("CLKSEL_OPP_2: ABE_CLK is divide by 4 of DPLL_ABE_X2_CLK");
    case omap44xx_ckgen_cm1_CLKSEL_OPP_3:
        return("CLKSEL_OPP_3: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_opp_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_opp_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_opp_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_opp_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_opp_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_opp_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dll_override_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dll_override_status_t;
#define omap44xx_ckgen_cm1_DLL_OVERRIDE_0 ((omap44xx_ckgen_cm1_dll_override_status_t)0x0)
#define omap44xx_ckgen_cm1_DLL_OVERRIDE_1 ((omap44xx_ckgen_cm1_dll_override_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dll_override_status_describe(omap44xx_ckgen_cm1_dll_override_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dll_override_status_describe(omap44xx_ckgen_cm1_dll_override_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DLL_OVERRIDE_0:
        return("DLL_OVERRIDE_0: Lock and code outputs are not overriden");
    case omap44xx_ckgen_cm1_DLL_OVERRIDE_1:
        return("DLL_OVERRIDE_1: Lock output is overriden to 1 and code output is overriden with a value coming from control module.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dll_override_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dll_override_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dll_override_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dll_override_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dll_override_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dll_override_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_ssc_downspread_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t;
#define omap44xx_ckgen_cm1_DPLL_SSC_DOWNSPREAD_0 ((omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_SSC_DOWNSPREAD_1 ((omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_ssc_downspread_status_describe(omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_ssc_downspread_status_describe(omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_SSC_DOWNSPREAD_0:
        return("DPLL_SSC_DOWNSPREAD_0: When SSC is enabled, clock frequency is spread on both sides of the programmed frequency");
    case omap44xx_ckgen_cm1_DPLL_SSC_DOWNSPREAD_1:
        return("DPLL_SSC_DOWNSPREAD_1: When SSC is enabled, clock frequency is spread only on the lower side of the programmed frequency");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_ssc_ack_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_ssc_ack_status_t;
#define omap44xx_ckgen_cm1_DPLL_SSC_ACK_0_r ((omap44xx_ckgen_cm1_dpll_ssc_ack_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_SSC_ACK_1_r ((omap44xx_ckgen_cm1_dpll_ssc_ack_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_ssc_ack_status_describe(omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_ssc_ack_status_describe(omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_SSC_ACK_0_r:
        return("DPLL_SSC_ACK_0_r: SSC has been turned off on PLL o/ps");
    case omap44xx_ckgen_cm1_DPLL_SSC_ACK_1_r:
        return("DPLL_SSC_ACK_1_r: SSC has been turned on on PLL o/ps");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_ssc_ack_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_ssc_ack_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_ssc_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_ssc_en_status_t;
#define omap44xx_ckgen_cm1_DPLL_SSC_EN_0 ((omap44xx_ckgen_cm1_dpll_ssc_en_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_SSC_EN_1 ((omap44xx_ckgen_cm1_dpll_ssc_en_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_ssc_en_status_describe(omap44xx_ckgen_cm1_dpll_ssc_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_ssc_en_status_describe(omap44xx_ckgen_cm1_dpll_ssc_en_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_SSC_EN_0:
        return("DPLL_SSC_EN_0: SSC disabled");
    case omap44xx_ckgen_cm1_DPLL_SSC_EN_1:
        return("DPLL_SSC_EN_1: SSC enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_ssc_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_ssc_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_regm4xen_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_regm4xen_status_t;
#define omap44xx_ckgen_cm1_DPLL_REGM4XEN_0_r ((omap44xx_ckgen_cm1_dpll_regm4xen_status_t)0x0)

static inline char *omap44xx_ckgen_cm1_dpll_regm4xen_status_describe(omap44xx_ckgen_cm1_dpll_regm4xen_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_regm4xen_status_describe(omap44xx_ckgen_cm1_dpll_regm4xen_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_REGM4XEN_0_r:
        return("DPLL_REGM4XEN_0_r: REGM4XEN mode of the DPLL is disabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_regm4xen_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_regm4xen_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_lpmode_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_lpmode_en_status_t;
#define omap44xx_ckgen_cm1_DPLL_LPMODE_EN_0 ((omap44xx_ckgen_cm1_dpll_lpmode_en_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_LPMODE_EN_1 ((omap44xx_ckgen_cm1_dpll_lpmode_en_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_lpmode_en_status_describe(omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_lpmode_en_status_describe(omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_LPMODE_EN_0:
        return("DPLL_LPMODE_EN_0: Low-power mode of the DPLL is disabled");
    case omap44xx_ckgen_cm1_DPLL_LPMODE_EN_1:
        return("DPLL_LPMODE_EN_1: Low-power mode of the DPLL is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_lpmode_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_lpmode_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_driftguard_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_driftguard_en_status_t;
#define omap44xx_ckgen_cm1_DPLL_DRIFTGUARD_EN_0 ((omap44xx_ckgen_cm1_dpll_driftguard_en_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_DRIFTGUARD_EN_1 ((omap44xx_ckgen_cm1_dpll_driftguard_en_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_driftguard_en_status_describe(omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_driftguard_en_status_describe(omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_DRIFTGUARD_EN_0:
        return("DPLL_DRIFTGUARD_EN_0: DRIFTGUARD feature is disabled");
    case omap44xx_ckgen_cm1_DPLL_DRIFTGUARD_EN_1:
        return("DPLL_DRIFTGUARD_EN_1: DRIFTGUARD feature is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_driftguard_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_driftguard_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_en_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_en_status_t;
#define omap44xx_ckgen_cm1_DPLL_EN_0 ((omap44xx_ckgen_cm1_dpll_en_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_EN_1 ((omap44xx_ckgen_cm1_dpll_en_status_t)0x1)
#define omap44xx_ckgen_cm1_DPLL_EN_2 ((omap44xx_ckgen_cm1_dpll_en_status_t)0x2)
#define omap44xx_ckgen_cm1_DPLL_EN_3 ((omap44xx_ckgen_cm1_dpll_en_status_t)0x3)
#define omap44xx_ckgen_cm1_DPLL_EN_MN ((omap44xx_ckgen_cm1_dpll_en_status_t)0x4)
#define omap44xx_ckgen_cm1_DPLL_EN_LP ((omap44xx_ckgen_cm1_dpll_en_status_t)0x5)
#define omap44xx_ckgen_cm1_DPLL_EN_FR ((omap44xx_ckgen_cm1_dpll_en_status_t)0x6)
#define omap44xx_ckgen_cm1_DPLL_EN_LM ((omap44xx_ckgen_cm1_dpll_en_status_t)0x7)

static inline char *omap44xx_ckgen_cm1_dpll_en_status_describe(omap44xx_ckgen_cm1_dpll_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_en_status_describe(omap44xx_ckgen_cm1_dpll_en_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_EN_0:
        return("DPLL_EN_0: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_1:
        return("DPLL_EN_1: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_2:
        return("DPLL_EN_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_3:
        return("DPLL_EN_3: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_MN:
        return("DPLL_EN_MN: Put the DPLL in MN bypass mode. The DPLL_MULT register bits are reset to 0 automatically by putting the DPLL in this mode.");
    case omap44xx_ckgen_cm1_DPLL_EN_LP:
        return("DPLL_EN_LP: Put the DPLL in Idle bypass low-power mode.");
    case omap44xx_ckgen_cm1_DPLL_EN_FR:
        return("DPLL_EN_FR: Put the DPLL in Idle bypass fast-relock mode.");
    case omap44xx_ckgen_cm1_DPLL_EN_LM:
        return("DPLL_EN_LM: Enables the DPLL in lock mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_en_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.st_mn_bypass_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_st_mn_bypass_status_t;
#define omap44xx_ckgen_cm1_ST_MN_BYPASS_1_r ((omap44xx_ckgen_cm1_st_mn_bypass_status_t)0x1)
#define omap44xx_ckgen_cm1_ST_MN_BYPASS_0_r ((omap44xx_ckgen_cm1_st_mn_bypass_status_t)0x0)

static inline char *omap44xx_ckgen_cm1_st_mn_bypass_status_describe(omap44xx_ckgen_cm1_st_mn_bypass_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_st_mn_bypass_status_describe(omap44xx_ckgen_cm1_st_mn_bypass_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_ST_MN_BYPASS_1_r:
        return("ST_MN_BYPASS_1_r: DPLL is in MN_Bypass");
    case omap44xx_ckgen_cm1_ST_MN_BYPASS_0_r:
        return("ST_MN_BYPASS_0_r: DPLL is not in MN_Bypass");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_st_mn_bypass_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_st_mn_bypass_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_st_mn_bypass_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_st_mn_bypass_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.st_dpll_clk_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_st_dpll_clk_status_t;
#define omap44xx_ckgen_cm1_ST_DPLL_CLK_1_r ((omap44xx_ckgen_cm1_st_dpll_clk_status_t)0x1)
#define omap44xx_ckgen_cm1_ST_DPLL_CLK_0_r ((omap44xx_ckgen_cm1_st_dpll_clk_status_t)0x0)

static inline char *omap44xx_ckgen_cm1_st_dpll_clk_status_describe(omap44xx_ckgen_cm1_st_dpll_clk_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_st_dpll_clk_status_describe(omap44xx_ckgen_cm1_st_dpll_clk_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_ST_DPLL_CLK_1_r:
        return("ST_DPLL_CLK_1_r: DPLL is LOCKED");
    case omap44xx_ckgen_cm1_ST_DPLL_CLK_0_r:
        return("ST_DPLL_CLK_0_r: DPLL is either in bypass mode or in stop mode.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_st_dpll_clk_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_st_dpll_clk_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_st_dpll_clk_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_st_dpll_clk_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.auto_dpll_mode_status ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_auto_dpll_mode_status_t;
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_0 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x0)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_1 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x1)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x2)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_3 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x3)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_4 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x4)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_5 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x5)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_6 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x6)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_7 ((omap44xx_ckgen_cm1_auto_dpll_mode_status_t)0x7)

static inline char *omap44xx_ckgen_cm1_auto_dpll_mode_status_describe(omap44xx_ckgen_cm1_auto_dpll_mode_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_auto_dpll_mode_status_describe(omap44xx_ckgen_cm1_auto_dpll_mode_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_0:
        return("AUTO_DPLL_MODE_0: DPLL auto control disabled");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_1:
        return("AUTO_DPLL_MODE_1: The DPLL is automatically put in low-power stop mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_2:
        return("AUTO_DPLL_MODE_2: The DPLL is automatically put in fast-relock stop mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_3:
        return("AUTO_DPLL_MODE_3: Reserved");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_4:
        return("AUTO_DPLL_MODE_4: Reserved");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_5:
        return("AUTO_DPLL_MODE_5: The DPLL is automatically put in idle bypass low-power mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_6:
        return("AUTO_DPLL_MODE_6: The DPLL is automatically put in idle bypass fast-relock mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_7:
        return("AUTO_DPLL_MODE_7: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_auto_dpll_mode_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_auto_dpll_mode_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_clkouthif_clksel_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t;
#define omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_CLKSEL_0 ((omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_CLKSEL_1 ((omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_describe(omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_describe(omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_CLKSEL_0:
        return("DPLL_CLKOUTHIF_CLKSEL_0: CLKOUTHIF is generated from the DPLL oscillator (DCO)");
    case omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_CLKSEL_1:
        return("DPLL_CLKOUTHIF_CLKSEL_1: CLKOUTHIF is generated from CLKINPHIF");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.st_dpll_clkout_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_st_dpll_clkout_status_t;
#define omap44xx_ckgen_cm1_ST_DPLL_CLKOUT_0_r ((omap44xx_ckgen_cm1_st_dpll_clkout_status_t)0x0)
#define omap44xx_ckgen_cm1_ST_DPLL_CLKOUT_1_r ((omap44xx_ckgen_cm1_st_dpll_clkout_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_st_dpll_clkout_status_describe(omap44xx_ckgen_cm1_st_dpll_clkout_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_st_dpll_clkout_status_describe(omap44xx_ckgen_cm1_st_dpll_clkout_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_ST_DPLL_CLKOUT_0_r:
        return("ST_DPLL_CLKOUT_0_r: The clock output is gated");
    case omap44xx_ckgen_cm1_ST_DPLL_CLKOUT_1_r:
        return("ST_DPLL_CLKOUT_1_r: The clock output is enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_st_dpll_clkout_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_st_dpll_clkout_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_clkout_gate_ctrl_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t;
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_GATE_CTRL_0 ((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_GATE_CTRL_1 ((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_describe(omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_describe(omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_GATE_CTRL_0:
        return("DPLL_CLKOUT_GATE_CTRL_0: Automatically gate this clock when there is no dependency for it");
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_GATE_CTRL_1:
        return("DPLL_CLKOUT_GATE_CTRL_1: Force this clock to stay enabled even if there is no request");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_clkout_div_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_clkout_div_status_t;
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_0 ((omap44xx_ckgen_cm1_dpll_clkout_div_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_1 ((omap44xx_ckgen_cm1_dpll_clkout_div_status_t)0x1)
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_2 ((omap44xx_ckgen_cm1_dpll_clkout_div_status_t)0x2)

static inline char *omap44xx_ckgen_cm1_dpll_clkout_div_status_describe(omap44xx_ckgen_cm1_dpll_clkout_div_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_clkout_div_status_describe(omap44xx_ckgen_cm1_dpll_clkout_div_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_0:
        return("DPLL_CLKOUT_DIV_0: Reserved");
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_1:
        return("DPLL_CLKOUT_DIV_1: 1, to be used for OPP100");
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_2:
        return("DPLL_CLKOUT_DIV_2: 2, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_clkout_div_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_clkout_div_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_clkouthif_div_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t;
#define omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_DIV_0 ((omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_DIV_5 ((omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t)0x5)
#define omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_DIV_8 ((omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t)0x8)

static inline char *omap44xx_ckgen_cm1_dpll_clkouthif_div_status_describe(omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_clkouthif_div_status_describe(omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_DIV_0:
        return("DPLL_CLKOUTHIF_DIV_0: Reserved");
    case omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_DIV_5:
        return("DPLL_CLKOUTHIF_DIV_5: 5, to be used for OPP100");
    case omap44xx_ckgen_cm1_DPLL_CLKOUTHIF_DIV_8:
        return("DPLL_CLKOUTHIF_DIV_8: 8, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_clkouthif_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_clkouthif_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_clkouthif_div_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout1_pwdn_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_PWDN_0 ((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_PWDN_1 ((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_PWDN_0:
        return("HSDIVIDER_CLKOUT1_PWDN_0: Divider is powered up");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_PWDN_1:
        return("HSDIVIDER_CLKOUT1_PWDN_1: Divider is powered down");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout1_div_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_0 ((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_8 ((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t)0x8)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_0:
        return("HSDIVIDER_CLKOUT1_DIV_0: Reserved");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_8:
        return("HSDIVIDER_CLKOUT1_DIV_8: 8, to be used for OPP100 and OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout2_div_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_0 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_4 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t)0x4)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_8 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t)0x8)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_0:
        return("HSDIVIDER_CLKOUT2_DIV_0: Reserved");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_4:
        return("HSDIVIDER_CLKOUT2_DIV_4: 4, to be used for OPP100");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_8:
        return("HSDIVIDER_CLKOUT2_DIV_8: 8, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout3_div_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT3_DIV_0 ((omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT3_DIV_6 ((omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t)0x6)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT3_DIV_8 ((omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t)0x8)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT3_DIV_0:
        return("HSDIVIDER_CLKOUT3_DIV_0: Reserved");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT3_DIV_6:
        return("HSDIVIDER_CLKOUT3_DIV_6: 6, to be used for OPP100");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT3_DIV_8:
        return("HSDIVIDER_CLKOUT3_DIV_8: 8, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout4_div_status ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_0 ((omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_6 ((omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t)0x6)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_8 ((omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t)0x8)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_12 ((omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t)0xc)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_16 ((omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t)0x10)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_describe(omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_0:
        return("HSDIVIDER_CLKOUT4_DIV_0: Reserved");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_6:
        return("HSDIVIDER_CLKOUT4_DIV_6: 6, to be used for OPP100 for 266.7-MHz clock output");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_8:
        return("HSDIVIDER_CLKOUT4_DIV_8: 8, to be used for OPP100 for 200-MHz clock output");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_12:
        return("HSDIVIDER_CLKOUT4_DIV_12: 12, to be used for OPP50 for 133.3-MHz clock output");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT4_DIV_16:
        return("HSDIVIDER_CLKOUT4_DIV_16: 16, to be used for OPP50 for 100-MHz clock output");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dcc_en_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dcc_en_status_t;
#define omap44xx_ckgen_cm1_DCC_EN_0 ((omap44xx_ckgen_cm1_dcc_en_status_t)0x0)
#define omap44xx_ckgen_cm1_DCC_EN_1 ((omap44xx_ckgen_cm1_dcc_en_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dcc_en_status_describe(omap44xx_ckgen_cm1_dcc_en_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dcc_en_status_describe(omap44xx_ckgen_cm1_dcc_en_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DCC_EN_0:
        return("DCC_EN_0: DCC disabled");
    case omap44xx_ckgen_cm1_DCC_EN_1:
        return("DCC_EN_1: DCC enabled");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dcc_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dcc_en_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dcc_en_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dcc_en_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dcc_en_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dcc_en_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_clkout_div_status1 ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_clkout_div_status1_t;
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_0_1 ((omap44xx_ckgen_cm1_dpll_clkout_div_status1_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_1_1 ((omap44xx_ckgen_cm1_dpll_clkout_div_status1_t)0x1)
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_2_1 ((omap44xx_ckgen_cm1_dpll_clkout_div_status1_t)0x2)

static inline char *omap44xx_ckgen_cm1_dpll_clkout_div_status1_describe(omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_clkout_div_status1_describe(omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_0_1:
        return("DPLL_CLKOUT_DIV_0_1: Reserved");
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_1_1:
        return("DPLL_CLKOUT_DIV_1_1: 1, to be used for OPP100, OPP_TURBO, OPP_NITRO, and OPP_NITROSB");
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_2_1:
        return("DPLL_CLKOUT_DIV_2_1: 2, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_clkout_div_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_clkout_div_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_clkout_div_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_clkout_div_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_status ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_status_t;
#define omap44xx_ckgen_cm1_CLKSEL_0 ((omap44xx_ckgen_cm1_clksel_status_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_1 ((omap44xx_ckgen_cm1_clksel_status_t)0x1)
#define omap44xx_ckgen_cm1_CLKSEL_2 ((omap44xx_ckgen_cm1_clksel_status_t)0x2)
#define omap44xx_ckgen_cm1_CLKSEL_3 ((omap44xx_ckgen_cm1_clksel_status_t)0x3)

static inline char *omap44xx_ckgen_cm1_clksel_status_describe(omap44xx_ckgen_cm1_clksel_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_status_describe(omap44xx_ckgen_cm1_clksel_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_0:
        return("CLKSEL_0: DPLL_MPU bypass clock is CORE_X2_CLK divided by 1, to be used for OPP100 and OPP50");
    case omap44xx_ckgen_cm1_CLKSEL_1:
        return("CLKSEL_1: DPLL_MPU bypass clock is CORE_X2_CLK divided by 2");
    case omap44xx_ckgen_cm1_CLKSEL_2:
        return("CLKSEL_2: DPLL_MPU bypass clock is CORE_X2_CLK divided by 4");
    case omap44xx_ckgen_cm1_CLKSEL_3:
        return("CLKSEL_3: DPLL_MPU bypass clock is CORE_X2_CLK divided by 8");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_en_status1 ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_en_status1_t;
#define omap44xx_ckgen_cm1_DPLL_EN_0_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_EN_1_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x1)
#define omap44xx_ckgen_cm1_DPLL_EN_2_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x2)
#define omap44xx_ckgen_cm1_DPLL_EN_3_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x3)
#define omap44xx_ckgen_cm1_DPLL_EN_4_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x4)
#define omap44xx_ckgen_cm1_DPLL_EN_5_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x5)
#define omap44xx_ckgen_cm1_DPLL_EN_6_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x6)
#define omap44xx_ckgen_cm1_DPLL_EN_7_2 ((omap44xx_ckgen_cm1_dpll_en_status1_t)0x7)

static inline char *omap44xx_ckgen_cm1_dpll_en_status1_describe(omap44xx_ckgen_cm1_dpll_en_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_en_status1_describe(omap44xx_ckgen_cm1_dpll_en_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_EN_0_2:
        return("DPLL_EN_0_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_1_2:
        return("DPLL_EN_1_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_2_2:
        return("DPLL_EN_2_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_3_2:
        return("DPLL_EN_3_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_4_2:
        return("DPLL_EN_4_2: Put the DPLL in MN bypass mode. The DPLL_MULT register bits are reset to 0 automatically by putting the DPLL in this mode.");
    case omap44xx_ckgen_cm1_DPLL_EN_5_2:
        return("DPLL_EN_5_2: Put the DPLL in idle bypass low-power mode.");
    case omap44xx_ckgen_cm1_DPLL_EN_6_2:
        return("DPLL_EN_6_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_EN_7_2:
        return("DPLL_EN_7_2: Enables the DPLL in lock mode");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_en_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_en_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_en_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_en_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_en_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_en_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.auto_dpll_mode_status1 ()
 *  - width 3 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_auto_dpll_mode_status1_t;
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_0_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x0)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_1_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x1)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_2_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x2)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_3_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x3)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_4_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x4)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_5_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x5)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_6_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x6)
#define omap44xx_ckgen_cm1_AUTO_DPLL_MODE_7_2 ((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t)0x7)

static inline char *omap44xx_ckgen_cm1_auto_dpll_mode_status1_describe(omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_auto_dpll_mode_status1_describe(omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_0_2:
        return("AUTO_DPLL_MODE_0_2: DPLL auto control disabled");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_1_2:
        return("AUTO_DPLL_MODE_1_2: The DPLL is automatically put in low-power stop mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_2_2:
        return("AUTO_DPLL_MODE_2_2: The DPLL is automatically put in fast-relock stop mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_3_2:
        return("AUTO_DPLL_MODE_3_2: Reserved");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_4_2:
        return("AUTO_DPLL_MODE_4_2: Reserved");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_5_2:
        return("AUTO_DPLL_MODE_5_2: The DPLL is automatically put in idle bypass low-power mode when its DPLL generated clocks are not required anymore. It is also restarted automatically.");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_6_2:
        return("AUTO_DPLL_MODE_6_2: Reserved");
    case omap44xx_ckgen_cm1_AUTO_DPLL_MODE_7_2:
        return("AUTO_DPLL_MODE_7_2: Reserved");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_auto_dpll_mode_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_auto_dpll_mode_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_auto_dpll_mode_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_auto_dpll_mode_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout1_div_status1 ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_0_1 ((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_2 ((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t)0x2)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_4 ((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t)0x4)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_8_1 ((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t)0x8)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_describe(omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_describe(omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_0_1:
        return("HSDIVIDER_CLKOUT1_DIV_0_1: Reserved");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_2:
        return("HSDIVIDER_CLKOUT1_DIV_2: 2, to be used for OPP_TURBO and OPP_NITRO");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_4:
        return("HSDIVIDER_CLKOUT1_DIV_4: 4, to be used for OPP100");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT1_DIV_8_1:
        return("HSDIVIDER_CLKOUT1_DIV_8_1: 8, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.hsdivider_clkout2_div_status1 ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t;
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_0_1 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t)0x0)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_2 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t)0x2)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_3 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t)0x3)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_7 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t)0x7)
#define omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_14 ((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t)0xe)

static inline char *omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_describe(omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_describe(omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_0_1:
        return("HSDIVIDER_CLKOUT2_DIV_0_1: Reserved");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_2:
        return("HSDIVIDER_CLKOUT2_DIV_2: 2, to be used for OPP_NITRO");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_3:
        return("HSDIVIDER_CLKOUT2_DIV_3: 3, to be used for OPP_TURBO");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_7:
        return("HSDIVIDER_CLKOUT2_DIV_7: 7, to be used for OPP100");
    case omap44xx_ckgen_cm1_HSDIVIDER_CLKOUT2_DIV_14:
        return("HSDIVIDER_CLKOUT2_DIV_14: 14, to be used for OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_status1 ()
 *  - width 2 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_status1_t;
#define omap44xx_ckgen_cm1_CLKSEL_0_1 ((omap44xx_ckgen_cm1_clksel_status1_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_1_1 ((omap44xx_ckgen_cm1_clksel_status1_t)0x1)
#define omap44xx_ckgen_cm1_CLKSEL_2_1 ((omap44xx_ckgen_cm1_clksel_status1_t)0x2)
#define omap44xx_ckgen_cm1_CLKSEL_3_1 ((omap44xx_ckgen_cm1_clksel_status1_t)0x3)

static inline char *omap44xx_ckgen_cm1_clksel_status1_describe(omap44xx_ckgen_cm1_clksel_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_status1_describe(omap44xx_ckgen_cm1_clksel_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_0_1:
        return("CLKSEL_0_1: DPLL_IVA bypass clock is CORE_X2_CLK divided by 1, to be used for OPP100 and OPP50");
    case omap44xx_ckgen_cm1_CLKSEL_1_1:
        return("CLKSEL_1_1: DPLL_IVA bypass clock is CORE_X2_CLK divided by 2");
    case omap44xx_ckgen_cm1_CLKSEL_2_1:
        return("CLKSEL_2_1: DPLL_IVA bypass clock is CORE_X2_CLK divided by 4");
    case omap44xx_ckgen_cm1_CLKSEL_3_1:
        return("CLKSEL_3_1: DPLL_IVA bypass clock is CORE_X2_CLK divided by 8");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dpll_clkout_div_status2 ()
 *  - width 5 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dpll_clkout_div_status2_t;
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_0_2 ((omap44xx_ckgen_cm1_dpll_clkout_div_status2_t)0x0)
#define omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_1_2 ((omap44xx_ckgen_cm1_dpll_clkout_div_status2_t)0x1)

static inline char *omap44xx_ckgen_cm1_dpll_clkout_div_status2_describe(omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dpll_clkout_div_status2_describe(omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_0_2:
        return("DPLL_CLKOUT_DIV_0_2: Reserved");
    case omap44xx_ckgen_cm1_DPLL_CLKOUT_DIV_1_2:
        return("DPLL_CLKOUT_DIV_1_2: 1, to be used for OPP100 and OPP50");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dpll_clkout_div_status2_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dpll_clkout_div_status2_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _e)
{
    char *d = omap44xx_ckgen_cm1_dpll_clkout_div_status2_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dpll_clkout_div_status2_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.dll_reset_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_dll_reset_status_t;
#define omap44xx_ckgen_cm1_DLL_RESET_0 ((omap44xx_ckgen_cm1_dll_reset_status_t)0x0)
#define omap44xx_ckgen_cm1_DLL_RESET_1 ((omap44xx_ckgen_cm1_dll_reset_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_dll_reset_status_describe(omap44xx_ckgen_cm1_dll_reset_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_dll_reset_status_describe(omap44xx_ckgen_cm1_dll_reset_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_DLL_RESET_0:
        return("DLL_RESET_0: DLL is not reset during the frequency change hardware sequence");
    case omap44xx_ckgen_cm1_DLL_RESET_1:
        return("DLL_RESET_1: DLL is reset automatically during the frequency change hardware sequence");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_dll_reset_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dll_reset_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_dll_reset_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_dll_reset_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_dll_reset_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_dll_reset_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_l3_status1 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_l3_status1_t;
#define omap44xx_ckgen_cm1_CLKSEL_L3_0_1 ((omap44xx_ckgen_cm1_clksel_l3_status1_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_L3_1_1 ((omap44xx_ckgen_cm1_clksel_l3_status1_t)0x1)

static inline char *omap44xx_ckgen_cm1_clksel_l3_status1_describe(omap44xx_ckgen_cm1_clksel_l3_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_l3_status1_describe(omap44xx_ckgen_cm1_clksel_l3_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_L3_0_1:
        return("CLKSEL_L3_0_1: L3_CLK is CORE_CLK divided by 1");
    case omap44xx_ckgen_cm1_CLKSEL_L3_1_1:
        return("CLKSEL_L3_1_1: L3_CLK is CORE_CLK divided by 2");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_l3_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_l3_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_l3_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_l3_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_l3_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_l3_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.clksel_core_status1 ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_clksel_core_status1_t;
#define omap44xx_ckgen_cm1_CLKSEL_CORE_0_1 ((omap44xx_ckgen_cm1_clksel_core_status1_t)0x0)
#define omap44xx_ckgen_cm1_CLKSEL_CORE_1_1 ((omap44xx_ckgen_cm1_clksel_core_status1_t)0x1)

static inline char *omap44xx_ckgen_cm1_clksel_core_status1_describe(omap44xx_ckgen_cm1_clksel_core_status1_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_clksel_core_status1_describe(omap44xx_ckgen_cm1_clksel_core_status1_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_CLKSEL_CORE_0_1:
        return("CLKSEL_CORE_0_1: CORE_CLK is CORE_X2_CLK divided by 1");
    case omap44xx_ckgen_cm1_CLKSEL_CORE_1_1:
        return("CLKSEL_CORE_1_1: CORE_CLK is CORE_X2_CLK divided by 2");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_clksel_core_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_core_status1_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_clksel_core_status1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_clksel_core_status1_t _e)
{
    char *d = omap44xx_ckgen_cm1_clksel_core_status1_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_clksel_core_status1_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: omap44xx_ckgen_cm1.gpmc_freq_update_status ()
 *  - width 1 bits
 */
typedef uint8_t omap44xx_ckgen_cm1_gpmc_freq_update_status_t;
#define omap44xx_ckgen_cm1_GPMC_FREQ_UPDATE_0 ((omap44xx_ckgen_cm1_gpmc_freq_update_status_t)0x0)
#define omap44xx_ckgen_cm1_GPMC_FREQ_UPDATE_1 ((omap44xx_ckgen_cm1_gpmc_freq_update_status_t)0x1)

static inline char *omap44xx_ckgen_cm1_gpmc_freq_update_status_describe(omap44xx_ckgen_cm1_gpmc_freq_update_status_t _e) __attribute__ ((always_inline));
static inline char *omap44xx_ckgen_cm1_gpmc_freq_update_status_describe(omap44xx_ckgen_cm1_gpmc_freq_update_status_t _e)
{
    switch (_e) {
    case omap44xx_ckgen_cm1_GPMC_FREQ_UPDATE_0:
        return("GPMC_FREQ_UPDATE_0: GPMC is not put automatically into idle during frequency change operation.");
    case omap44xx_ckgen_cm1_GPMC_FREQ_UPDATE_1:
        return("GPMC_FREQ_UPDATE_1: GPMC is put automatically into idle during frequency change operation.");
    default:
        return(NULL);
    }
}

static inline int omap44xx_ckgen_cm1_gpmc_freq_update_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_gpmc_freq_update_status_t _e) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_gpmc_freq_update_status_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_gpmc_freq_update_status_t _e)
{
    char *d = omap44xx_ckgen_cm1_gpmc_freq_update_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "omap44xx_ckgen_cm1_gpmc_freq_update_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clksel_core_t
 * Description: Implicit type of CORE module clock selection. register
 * Fields:
 *   clksel_core	(size 1, offset 0, init 0):	RW	Selects CORE_CLK configuration
 *   _anon1	(size 3, offset 1, init 0):	MBZ	_
 *   clksel_l3	(size 1, offset 4, init 0):	RW	Selects L3 interconnect clock (L3_clk)
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   clksel_l4	(size 1, offset 8, init 0):	RW	Selects L4 interconnect clock (L4_clk)
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clksel_core_t;
#define omap44xx_ckgen_cm1_cm_clksel_core_default 0x0
static inline omap44xx_ckgen_cm1_clksel_core_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_extract(omap44xx_ckgen_cm1_cm_clksel_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_core_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_extract(omap44xx_ckgen_cm1_cm_clksel_core_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_core_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_insert(omap44xx_ckgen_cm1_cm_clksel_core_t _regval, omap44xx_ckgen_cm1_clksel_core_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_insert(omap44xx_ckgen_cm1_cm_clksel_core_t _regval, omap44xx_ckgen_cm1_clksel_core_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_clksel_core_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_clksel_l3_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_extract(omap44xx_ckgen_cm1_cm_clksel_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_l3_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_extract(omap44xx_ckgen_cm1_cm_clksel_core_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_l3_status_t )((_regval & 0x10) >> 4));
}

static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_insert(omap44xx_ckgen_cm1_cm_clksel_core_t _regval, omap44xx_ckgen_cm1_clksel_l3_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_insert(omap44xx_ckgen_cm1_cm_clksel_core_t _regval, omap44xx_ckgen_cm1_clksel_l3_status_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((omap44xx_ckgen_cm1_cm_clksel_core_t )(_fieldval)) << 4)));
}

static inline omap44xx_ckgen_cm1_clksel_l4_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_extract(omap44xx_ckgen_cm1_cm_clksel_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_l4_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_extract(omap44xx_ckgen_cm1_cm_clksel_core_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_l4_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_insert(omap44xx_ckgen_cm1_cm_clksel_core_t _regval, omap44xx_ckgen_cm1_clksel_l4_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_insert(omap44xx_ckgen_cm1_cm_clksel_core_t _regval, omap44xx_ckgen_cm1_clksel_l4_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_clksel_core_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_clksel_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_core =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_core_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects CORE_CLK configuration)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_l3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_l3_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects L3 interconnect clock (L3_clk))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_l4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_l4_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects L4 interconnect clock (L4_clk))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clksel_abe_t
 * Description: Implicit type of ABE module clock selection. register
 * Fields:
 *   clksel_opp	(size 2, offset 0, init 0):	RW	Selects the OPP divider ABE domain
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   pad_clks_gate	(size 1, offset 8, init 0):	RW	Gating control for PAD_CLKS clock tree in ABE
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   slimbus_clk_gate	(size 1, offset 10, init 0):	RW	Gating control for SLIMBUS_CLK clock tree in ABE. SLIMbus module always gets the ungated version.
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clksel_abe_t;
#define omap44xx_ckgen_cm1_cm_clksel_abe_default 0x0
static inline omap44xx_ckgen_cm1_clksel_opp_status_t omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_extract(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_opp_status_t omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_extract(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_opp_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_insert(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval, omap44xx_ckgen_cm1_clksel_opp_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_insert(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval, omap44xx_ckgen_cm1_clksel_opp_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_ckgen_cm1_cm_clksel_abe_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_extract(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_extract(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_slimbus_clk_gate_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_insert(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_insert(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_clksel_abe_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_extract(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_extract(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_slimbus_clk_gate_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_insert(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_insert(omap44xx_ckgen_cm1_cm_clksel_abe_t _regval, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_ckgen_cm1_cm_clksel_abe_t )(_fieldval)) << 10)));
}

static inline int omap44xx_ckgen_cm1_cm_clksel_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_opp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_opp_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the OPP divider ABE domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pad_clks_gate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_slimbus_clk_gate_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Gating control for PAD_CLKS clock tree in ABE)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slimbus_clk_gate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_slimbus_clk_gate_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Gating control for SLIMBUS_CLK clock tree in ABE. SLIMbus module always gets the ungated version.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_dll_ctrl_t
 * Description: Implicit type of Special register for DLL control register
 * Fields:
 *   dll_override	(size 1, offset 0, init 0):	RW	Control if DLL lock and code outputs are overriden or not
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_dll_ctrl_t;
#define omap44xx_ckgen_cm1_cm_dll_ctrl_default 0x0
static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_extract(omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_extract(omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval)
{
    return((omap44xx_ckgen_cm1_dll_override_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_dll_ctrl_t omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_insert(omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval, omap44xx_ckgen_cm1_dll_override_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_dll_ctrl_t omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_insert(omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval, omap44xx_ckgen_cm1_dll_override_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_dll_ctrl_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_dll_ctrl_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_dll_ctrl_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_override =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dll_override_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if DLL lock and code outputs are overriden or not)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t
 * Description: Implicit type of This register allows controlling the DPLL modes. register
 * Fields:
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RO	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_clkmode_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_driftguard_en_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_lpmode_en_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 10)));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_regm4xen_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 11)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_en_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 12)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_ack_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 13)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 14)));
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_idlest_dpll_core_t
 * Description: Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register
 * Fields:
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_idlest_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_core_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_mn_bypass_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_core_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t
 * Description: Implicit type of This register provides automatic control over the DPLL activity. register
 * Fields:
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_autoidle_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_auto_dpll_mode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clksel_dpll_core_t
 * Description: Implicit type of This register provides controls over the DPLL. register
 * Fields:
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 1, offset 19, init 0):	MBZ	_
 *   dpll_clkouthif_clksel	(size 1, offset 20, init 0):	RW	Selects the source of the DPLL CLKOUTHIF clock. Same as CLKINPHIFSEL pin on the DPLL
 *   _anon21	(size 2, offset 21, init 0):	MBZ	_
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RW	Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_clksel_dpll_core_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x7ff00) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfff800ff) | (0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t )((_regval & 0x100000) >> 20));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 20)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 23)));
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the DPLL CLKOUTHIF clock. Same as CLKINPHIFSEL pin on the DPLL)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t
 * Description: Implicit type of This register provides controls over the M2 divider of the DPLL. register
 * Fields:
 *   dpll_clkout_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M2, for internal clock generation (1 to 31); Divide value from 1 to 31.
 *   dpll_clkout_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkout_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUT
 *   st_dpll_clkout	(size 1, offset 9, init 0):	RO	DPLL CLKOUT status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_div_m2_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_div_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t )(_fieldval)) << 9)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M2, for internal clock generation (1 to 31); Divide value from 1 to 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUT)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkout =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUT status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t
 * Description: Implicit type of This register provides controls over the M3 divider of the DPLL. register
 * Fields:
 *   dpll_clkouthif_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31
 *   dpll_clkouthif_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkouthif_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUTHIF
 *   st_dpll_clkouthif	(size 1, offset 9, init 0):	RO	DPLL CLKOUTHIF status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_div_m3_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t )(_fieldval)) << 9)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkouthif_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUTHIF)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkouthif =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUTHIF status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t
 * Description: Implicit type of This register provides controls over the CLKOUT1 o/p of the HSDIVIDER. register
 * Fields:
 *   hsdivider_clkout1_div	(size 5, offset 0, init 0):	RW	DPLL M4 post-divider factor (1 to 31).
 *   hsdivider_clkout1_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout1_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT1
 *   st_hsdivider_clkout1	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT1 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout1_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_div_m4_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M4 post-divider factor (1 to 31).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT1 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t
 * Description: Implicit type of This register provides controls over the CLKOUT2 o/p of the HSDIVIDER. register
 * Fields:
 *   hsdivider_clkout2_div	(size 5, offset 0, init 0):	RW	DPLL M5 post-divider factor (1 to 31)
 *   hsdivider_clkout2_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout2_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT2
 *   st_hsdivider_clkout2	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT2 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout2_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_div_m5_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M5 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT2 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t
 * Description: Implicit type of This register provides controls over the CLKOUT3 o/p of the HSDIVIDER. register
 * Fields:
 *   hsdivider_clkout3_div	(size 5, offset 0, init 0):	RW	DPLL M6 post-divider factor (1 to 31)
 *   hsdivider_clkout3_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT3_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout3_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT3
 *   st_hsdivider_clkout3	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT3 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout3_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M6 divider and CLKOUT3 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_div_m6_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m6_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m6_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M6 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT3_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT3 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M6 divider and CLKOUT3 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t
 * Description: Implicit type of This register provides controls over the CLKOUT4 o/p of the HSDIVIDER. register
 * Fields:
 *   hsdivider_clkout4_div	(size 5, offset 0, init 0):	RW	DPLL M7 post-divider factor (1 to 31)
 *   hsdivider_clkout4_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT4_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout4_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT4
 *   st_hsdivider_clkout4	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT4 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout4_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M7 divider and CLKOUT4 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_div_m7_dpll_core_default 0x0
static inline omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m7_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m7_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M7 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT4_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT4 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M7 divider and CLKOUT4 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t
 * Description: Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register
 * Fields:
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_default 0x0
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval)
{
    return((uint32_t )((_regval & 0xfffff) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff00000) | (0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t
 * Description: Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register
 * Fields:
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t
 * Description: Implicit type of This register provides emulation override controls over the CORE DPLL. register
 * Fields:
 *   core_dpll_emu_div	(size 7, offset 0, init 0):	RW	CORE DPLL override divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   core_dpll_emu_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M)
 *   override_enable	(size 1, offset 19, init 0):	RW	This bit allows to enable or disable the emulation override controls
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t;
#define omap44xx_ckgen_cm1_cm_emu_override_dpll_core_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_extract(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_extract(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_insert(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_insert(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_extract(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_extract(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x7ff00) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_insert(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_insert(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfff800ff) | (0x7ff00 & (((omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_extract(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_extract(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x80000) >> 19));
}

static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_insert(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_insert(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t )(_fieldval)) << 19)));
}

static inline int omap44xx_ckgen_cm1_cm_emu_override_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_emu_override_dpll_core_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_dpll_emu_div =\t%" PRIx8 "\t(CORE DPLL override divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_dpll_emu_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " override_enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the emulation override controls)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t
 * Description: Implicit type of This register allows controlling the DPLL modes. register
 * Fields:
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RO	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_default 0x0
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_driftguard_en_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_lpmode_en_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 10)));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_regm4xen_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 11)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_en_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 12)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_ack_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 13)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 14)));
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t
 * Description: Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register
 * Fields:
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_default 0x0
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_st_mn_bypass_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t
 * Description: Implicit type of This register provides automatic control over the DPLL activity. register
 * Fields:
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control;
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_default 0x0
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_auto_dpll_mode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control;)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t
 * Description: Implicit type of This register provides controls over the DPLL. register
 * Fields:
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 3, offset 19, init 0):	MBZ	_
 *   dcc_en	(size 1, offset 22, init 0):	RW	Enable or disable duty cycle correction. Must be enabled only for frequency 1 GHz.When enabled, the CLKOUTHIF output of the DPLL is used after duty cycle correction instead of CLKOUT. The M3 divider is hard-wired to 1 so the lock frequency Fdpll is directly provided to MPU. .
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RO	Only CLKINPULOW bypass clock supported for this PLL
 *   dcc_count_max	(size 8, offset 24, init 0):	RW	The value 'NbCycles' set in this field determines the duration of the clock ramp step during which the output frequency is Fdpll/(2*M2). The duration is computed as 32 x NbCycles of L4 clock cycles (100 MHz). Duration should be 2.5 us to allow enough time for DCC to lock. This bit field is relevant only when DCC_EN = 1.
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x7ff00) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfff800ff) | (0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dcc_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dcc_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dcc_en_status_t )((_regval & 0x400000) >> 22));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dcc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dcc_en_status_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 22)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 23)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 24)));
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dcc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable duty cycle correction. Must be enabled only for frequency 1 GHz.When enabled, the CLKOUTHIF output of the DPLL is used after duty cycle correction instead of CLKOUT. The M3 divider is hard-wired to 1 so the lock frequency Fdpll is directly provided to MPU. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Only CLKINPULOW bypass clock supported for this PLL)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcc_count_max =\t%" PRIx8 "\t(The value 'NbCycles' set in this field determines the duration of the clock ramp step during which the output frequency is Fdpll/(2*M2). The duration is computed as 32 x NbCycles of L4 clock cycles (100 MHz). Duration should be 2.5 us to allow enough time for DCC to lock. This bit field is relevant only when DCC_EN = 1.)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t
 * Description: Implicit type of This register provides controls over the M2 divider of the DPLL. register
 * Fields:
 *   dpll_clkout_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M2, for internal clock generation (1 to 31);Divide value from 1 to 31
 *   dpll_clkout_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkout_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUT
 *   st_dpll_clkout	(size 1, offset 9, init 0):	RO	DPLL CLKOUT status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_default 0x0
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status1_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status1_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_div_status1_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t )(_fieldval)) << 9)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M2, for internal clock generation (1 to 31);Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUT)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkout =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUT status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t
 * Description: Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register
 * Fields:
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_default 0x0
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval)
{
    return((uint32_t )((_regval & 0xfffff) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff00000) | (0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t
 * Description: Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register
 * Fields:
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t
 * Description: Implicit type of Control MPU PLL BYPASS clock. [warm reset insensitive] register
 * Fields:
 *   clksel	(size 2, offset 0, init 0):	RW	Select the DPLL MPU bypass clock
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t;
#define omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_default 0x0
static inline omap44xx_ckgen_cm1_clksel_status_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_extract(omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_status_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_extract(omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_status_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_insert(omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval, omap44xx_ckgen_cm1_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_insert(omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval, omap44xx_ckgen_cm1_clksel_status_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the DPLL MPU bypass clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t
 * Description: Implicit type of This register allows controlling the DPLL modes. register
 * Fields:
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RO	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_default 0x0
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status1_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_driftguard_en_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_lpmode_en_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 10)));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_regm4xen_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 11)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_en_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 12)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_ack_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 13)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 14)));
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t
 * Description: Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register
 * Fields:
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_idlest_dpll_iva_default 0x0
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_st_mn_bypass_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t
 * Description: Implicit type of This register provides automatic control over the DPLL activity. register
 * Fields:
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control;
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_default 0x0
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status1_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status1_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_auto_dpll_mode_status1_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control;)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t
 * Description: Implicit type of This register provides controls over the DPLL. register
 * Fields:
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 4, offset 19, init 0):	MBZ	_
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RW	Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_clksel_dpll_iva_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status1_t )((_regval & 0x7ff00) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval)
{
    return((_regval & 0xfff800ff) | (0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t )(_fieldval)) << 23)));
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t
 * Description: Implicit type of This register provides controls over the CLKOUT1 o/p of the HSDIVIDER. register
 * Fields:
 *   hsdivider_clkout1_div	(size 5, offset 0, init 0):	RW	DPLL M4 post-divider factor (1 to 31)
 *   hsdivider_clkout1_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout1_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT1
 *   st_hsdivider_clkout1	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT1 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout1_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_default 0x0
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M4 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT1 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t
 * Description: Implicit type of This register provides controls over the CLKOUT2 o/p of the HSDIVIDER. register
 * Fields:
 *   hsdivider_clkout2_div	(size 5, offset 0, init 0):	RW	DPLL M5 post-divider factor (1 to 31)
 *   hsdivider_clkout2_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect.
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout2_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT2
 *   st_hsdivider_clkout2	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT2 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout2_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_default 0x0
static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_extract(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_insert(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 12)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M5 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect.)\n", omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT2 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t
 * Description: Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register
 * Fields:
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_default 0x0
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval)
{
    return((uint32_t )((_regval & 0xfffff) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff00000) | (0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t
 * Description: Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register
 * Fields:
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t
 * Description: Implicit type of Control IVA PLL BYPASS clock. [warm reset insensitive] register
 * Fields:
 *   clksel	(size 2, offset 0, init 0):	RW	Select the DPLL IVA bypass clock
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t;
#define omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_default 0x0
static inline omap44xx_ckgen_cm1_clksel_status1_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_extract(omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_status1_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_extract(omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_status1_t )((_regval & 0x3) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_insert(omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval, omap44xx_ckgen_cm1_clksel_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_insert(omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval, omap44xx_ckgen_cm1_clksel_status1_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the DPLL IVA bypass clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t
 * Description: Implicit type of This register allows controlling the DPLL modes. register
 * Fields:
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RW	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_default 0x0
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_driftguard_en_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_lpmode_en_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 10)));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_regm4xen_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 11)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_en_status_t )((_regval & 0x1000) >> 12));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 12)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_ack_status_t )((_regval & 0x2000) >> 13));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_ssc_ack_status_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 13)));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_extract(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t )((_regval & 0x4000) >> 14));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_insert(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 14)));
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t
 * Description: Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register
 * Fields:
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_idlest_dpll_abe_default 0x0
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clk_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clk_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_extract(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_st_mn_bypass_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_insert(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_mn_bypass_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t
 * Description: Implicit type of This register provides automatic control over the DPLL activity. register
 * Fields:
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control;
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_default 0x0
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_extract(omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_auto_dpll_mode_status_t )((_regval & 0x7) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_insert(omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control;)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t
 * Description: Implicit type of This register provides controls over the DPLL. register
 * Fields:
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 4, offset 19, init 0):	MBZ	_
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RO	Only CLKINPULOW bypass clock supported for this PLL
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_clksel_dpll_abe_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status1_t )((_regval & 0x7ff00) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval)
{
    return((_regval & 0xfff800ff) | (0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t )(_fieldval)) << 8)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_extract(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_insert(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t )(_fieldval)) << 23)));
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Only CLKINPULOW bypass clock supported for this PLL)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t
 * Description: Implicit type of This register provides controls over the M2 divider of the DPLL. register
 * Fields:
 *   dpll_clkout_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M2, for internal clock generation (1 to 31). Divide value from 1 to 31
 *   dpll_clkout_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect.
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkout_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUT
 *   st_dpll_clkout	(size 1, offset 9, init 0):	RO	DPLL CLKOUT status
 *   dpll_clkoutx2_gate_ctrl	(size 1, offset 10, init 0):	RW	Control gating of DPLL CLKOUTX2
 *   st_dpll_clkoutx2	(size 1, offset 11, init 0):	RO	DPLL CLKOUTX2 status
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_default 0x0
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_div_status2_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 9)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x400) >> 10));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 10)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_extract(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x800) >> 11));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_insert(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 11)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status2_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M2, for internal clock generation (1 to 31). Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect.)\n", omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUT)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkout =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUT status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkoutx2_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUTX2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkoutx2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUTX2 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t
 * Description: Implicit type of This register provides controls over the M3 divider of the DPLL. register
 * Fields:
 *   dpll_clkouthif_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31
 *   dpll_clkouthif_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect.
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkouthif_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUTHIF
 *   st_dpll_clkouthif	(size 1, offset 9, init 0):	RO	DPLL CLKOUTHIF status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_default 0x0
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_div_status2_t )((_regval & 0x1f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t )(_fieldval)) << 5)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t )((_regval & 0x100) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_extract(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    return((omap44xx_ckgen_cm1_st_dpll_clkout_status_t )((_regval & 0x200) >> 9));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_insert(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval, omap44xx_ckgen_cm1_st_dpll_clkout_status_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t )(_fieldval)) << 9)));
}

static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status2_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect.)\n", omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUTHIF)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkouthif =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUTHIF status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t
 * Description: Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register
 * Fields:
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_default 0x0
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_extract(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval)
{
    return((uint32_t )((_regval & 0xfffff) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_insert(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff00000) | (0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t
 * Description: Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register
 * Fields:
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t;
#define omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_extract(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_insert(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t )(_fieldval)) << 8)));
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_shadow_freq_config1_t
 * Description: Implicit type of Shadow register to program new DPLL configuration affecting EMIF and GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state. register
 * Fields:
 *   freq_update	(size 1, offset 0, init 0):	RW	Writing 1 indicates that a new configuration is available. It is automatically cleared by h/w after the configuration has been applied.
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   dll_override	(size 1, offset 2, init 0):	RW	Shadow register forCM_DLL_CTRL.DLL_OVERRIDE.The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.
 *   dll_reset	(size 1, offset 3, init 0):	RW	Specify if DLL should be reset or not during the frequency change hardware sequence.
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   dpll_core_dpll_en	(size 3, offset 8, init 0):	RW	Shadow register forCM_CLKMODE_DPLL_CORE.DPLL_EN. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.
 *   dpll_core_m2_div	(size 5, offset 11, init 0):	RW	Shadow register forCM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1. Divide value from 1 to 31.
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_t;
#define omap44xx_ckgen_cm1_cm_shadow_freq_config1_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    return((omap44xx_ckgen_cm1_dll_override_status_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dll_override_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dll_override_status_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 2)));
}

static inline omap44xx_ckgen_cm1_dll_reset_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dll_reset_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    return((omap44xx_ckgen_cm1_dll_reset_status_t )((_regval & 0x8) >> 3));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dll_reset_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dll_reset_status_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 3)));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_en_status_t )((_regval & 0x700) >> 8));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 8)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_div_status_t )((_regval & 0xf800) >> 11));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval)
{
    return((_regval & 0xffff07ff) | (0xf800 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 11)));
}

static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config1_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freq_update =\t%" PRIx8 "\t(Writing 1 indicates that a new configuration is available. It is automatically cleared by h/w after the configuration has been applied.)\n", omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_override =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dll_override_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_DLL_CTRL.DLL_OVERRIDE.The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_reset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dll_reset_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Specify if DLL should be reset or not during the frequency change hardware sequence.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_core_dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_CLKMODE_DPLL_CORE.DPLL_EN. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_core_m2_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1. Divide value from 1 to 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_shadow_freq_config2_t
 * Description: Implicit type of Shadow register to program new DPLL configuration affecting GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state. register
 * Fields:
 *   gpmc_freq_update	(size 1, offset 0, init 0):	RW	Controls whether or not GPMC has to be put automatically into idle during the frequency change operation.
 *   clksel_core	(size 1, offset 1, init 0):	RW	Shadow register forCM_CLKSEL_CORE.CLKSEL_CORE. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.
 *   clksel_l3	(size 1, offset 2, init 0):	RW	Shadow register forCM_CLKSEL_CORE.CLKSEL_L3. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.
 *   dpll_core_m5_div	(size 5, offset 3, init 0):	RW	Shadow register forCM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1. Divide value from 1 to 31.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_t;
#define omap44xx_ckgen_cm1_cm_shadow_freq_config2_default 0x0
static inline omap44xx_ckgen_cm1_gpmc_freq_update_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_gpmc_freq_update_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    return((omap44xx_ckgen_cm1_gpmc_freq_update_status_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_gpmc_freq_update_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_gpmc_freq_update_status_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 0)));
}

static inline omap44xx_ckgen_cm1_clksel_core_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_core_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_core_status1_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_clksel_core_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_clksel_core_status1_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 1)));
}

static inline omap44xx_ckgen_cm1_clksel_l3_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_l3_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    return((omap44xx_ckgen_cm1_clksel_l3_status1_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_clksel_l3_status1_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_clksel_l3_status1_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 2)));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_extract(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    return((omap44xx_ckgen_cm1_dpll_clkout_div_status_t )((_regval & 0xf8) >> 3));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_insert(omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval)
{
    return((_regval & 0xffffff07) | (0xf8 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 3)));
}

static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config2_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config2_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpmc_freq_update =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_gpmc_freq_update_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls whether or not GPMC has to be put automatically into idle during the frequency change operation.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_core =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_core_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_CLKSEL_CORE.CLKSEL_CORE. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_l3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_l3_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_CLKSEL_CORE.CLKSEL_L3. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_core_m5_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1. Divide value from 1 to 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t
 * Description: Implicit type of Control the time unit of the sliding window for dynamic dependencies (auto-sleep feature). register
 * Fields:
 *   prescal	(size 6, offset 0, init 0):	RW	Time unit is equal to (PRESCAL + 1) L4 clock cycles.
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t;
#define omap44xx_ckgen_cm1_cm_dyn_dep_prescal_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_extract(omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_extract(omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_insert(omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_insert(omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t )(_fieldval)) << 0)));
}

static inline int omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescal =\t%" PRIx8 "\t(Time unit is equal to (PRESCAL + 1) L4 clock cycles.)\n", omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: omap44xx_ckgen_cm1_cm_restore_st_t
 * Description: Implicit type of Automatic restore status. This register is used by the system DMA to write a predefined value at the end of end automatic restore phase. [warm reset insensitive] register
 * Fields:
 *   phase1_completed	(size 1, offset 0, init 0):	RW	Indicates if restore phase 1 is completed. Must be cleared by software before going to device OFF mode.
 *   phase2a_completed	(size 1, offset 1, init 0):	RW	Indicates if restore phase 2a is completed. Must be cleared by software before going to device OFF mode.
 *   phase2b_completed	(size 1, offset 2, init 0):	RW	Indicates if restore phase 2b is completed. Must be cleared by software before going to device OFF mode.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
typedef uint32_t omap44xx_ckgen_cm1_cm_restore_st_t;
#define omap44xx_ckgen_cm1_cm_restore_st_default 0x0
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_extract(omap44xx_ckgen_cm1_cm_restore_st_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_extract(omap44xx_ckgen_cm1_cm_restore_st_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_insert(omap44xx_ckgen_cm1_cm_restore_st_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_insert(omap44xx_ckgen_cm1_cm_restore_st_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((omap44xx_ckgen_cm1_cm_restore_st_t )(_fieldval)) << 0)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_extract(omap44xx_ckgen_cm1_cm_restore_st_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_extract(omap44xx_ckgen_cm1_cm_restore_st_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_insert(omap44xx_ckgen_cm1_cm_restore_st_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_insert(omap44xx_ckgen_cm1_cm_restore_st_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((omap44xx_ckgen_cm1_cm_restore_st_t )(_fieldval)) << 1)));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_extract(omap44xx_ckgen_cm1_cm_restore_st_t _regval) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_extract(omap44xx_ckgen_cm1_cm_restore_st_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_insert(omap44xx_ckgen_cm1_cm_restore_st_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_insert(omap44xx_ckgen_cm1_cm_restore_st_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((omap44xx_ckgen_cm1_cm_restore_st_t )(_fieldval)) << 2)));
}

static inline int omap44xx_ckgen_cm1_cm_restore_st_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_restore_st_t _regval) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_restore_st_prtval(char *_s, size_t _size, omap44xx_ckgen_cm1_cm_restore_st_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phase1_completed =\t%" PRIx8 "\t(Indicates if restore phase 1 is completed. Must be cleared by software before going to device OFF mode.)\n", omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phase2a_completed =\t%" PRIx8 "\t(Indicates if restore phase 2a is completed. Must be cleared by software before going to device OFF mode.)\n", omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phase2b_completed =\t%" PRIx8 "\t(Indicates if restore phase 2b is completed. Must be cleared by software before going to device OFF mode.)\n", omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum omap44xx_ckgen_cm1_initials {
    omap44xx_ckgen_cm1_cm_clksel_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clksel_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_dll_ctrl_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_idlest_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_autoidle_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_idlest_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_idlest_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_initial = 0x0,
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_initial = 0x0,
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_initial = 0x0,
    omap44xx_ckgen_cm1_cm_dyn_dep_prescal_initial = 0x0,
    omap44xx_ckgen_cm1_cm_restore_st_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void omap44xx_ckgen_cm1_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register cm_clksel_core: CORE module clock selection.
 * Type: omap44xx_ckgen_cm1.cm_clksel_core (Implicit type of CORE module clock selection. register)
 *   clksel_core	(size 1, offset 0, init 0):	RW	Selects CORE_CLK configuration
 *   _anon1	(size 3, offset 1, init 0):	MBZ	_
 *   clksel_l3	(size 1, offset 4, init 0):	RW	Selects L3 interconnect clock (L3_clk)
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   clksel_l4	(size 1, offset 8, init 0):	RW	Selects L4 interconnect clock (L4_clk)
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_core_t omap44xx_ckgen_cm1_cm_clksel_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clksel_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_core_t _regval)
{
    _regval = (_regval & 0x111);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clksel_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clksel_core (CORE module clock selection.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_core =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_core_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects CORE_CLK configuration)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_l3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_l3_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects L3 interconnect clock (L3_clk))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_l4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_l4_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects L4 interconnect clock (L4_clk))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_clksel_core_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_core_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_extract(_regval));
}

static inline omap44xx_ckgen_cm1_clksel_l3_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_l3_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_extract(_regval));
}

static inline omap44xx_ckgen_cm1_clksel_l4_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_l4_status_t omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_core_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_core_clksel_core_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_core_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = 0x1 & (((omap44xx_ckgen_cm1_cm_clksel_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x110 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x111);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_l3_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_core_clksel_l3_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_l3_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = 0x10 & (((omap44xx_ckgen_cm1_cm_clksel_core_t )(_fieldval)) << 4);
    _regval = (_regval | (0x101 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x111);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_l4_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_core_clksel_l4_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_l4_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_clksel_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x11 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x111);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clksel_abe: ABE module clock selection.
 * Type: omap44xx_ckgen_cm1.cm_clksel_abe (Implicit type of ABE module clock selection. register)
 *   clksel_opp	(size 2, offset 0, init 0):	RW	Selects the OPP divider ABE domain
 *   _anon2	(size 6, offset 2, init 0):	MBZ	_
 *   pad_clks_gate	(size 1, offset 8, init 0):	RW	Gating control for PAD_CLKS clock tree in ABE
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   slimbus_clk_gate	(size 1, offset 10, init 0):	RW	Gating control for SLIMBUS_CLK clock tree in ABE. SLIMbus module always gets the ungated version.
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_abe_t omap44xx_ckgen_cm1_cm_clksel_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clksel_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_abe_t _regval)
{
    _regval = (_regval & 0x503);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clksel_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clksel_abe (ABE module clock selection.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_opp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_opp_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the OPP divider ABE domain)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pad_clks_gate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_slimbus_clk_gate_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Gating control for PAD_CLKS clock tree in ABE)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slimbus_clk_gate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_slimbus_clk_gate_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Gating control for SLIMBUS_CLK clock tree in ABE. SLIMbus module always gets the ungated version.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_clksel_opp_status_t omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_opp_status_t omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_extract(_regval));
}

static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_extract(_regval));
}

static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_slimbus_clk_gate_status_t omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_opp_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_abe_clksel_opp_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_opp_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = 0x3 & (((omap44xx_ckgen_cm1_cm_clksel_abe_t )(_fieldval)) << 0);
    _regval = (_regval | (0x500 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x503);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_abe_pad_clks_gate_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_clksel_abe_t )(_fieldval)) << 8);
    _regval = (_regval | (0x403 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x503);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_abe_slimbus_clk_gate_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_slimbus_clk_gate_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_abe_t _regval = 0x400 & (((omap44xx_ckgen_cm1_cm_clksel_abe_t )(_fieldval)) << 10);
    _regval = (_regval | (0x103 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x503);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_dll_ctrl: Special register for DLL control
 * Type: omap44xx_ckgen_cm1.cm_dll_ctrl (Implicit type of Special register for DLL control register)
 *   dll_override	(size 1, offset 0, init 0):	RW	Control if DLL lock and code outputs are overriden or not
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_dll_ctrl_t omap44xx_ckgen_cm1_cm_dll_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_dll_ctrl_t omap44xx_ckgen_cm1_cm_dll_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline omap44xx_ckgen_cm1_cm_dll_ctrl_t omap44xx_ckgen_cm1_cm_dll_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_dll_ctrl_t omap44xx_ckgen_cm1_cm_dll_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void omap44xx_ckgen_cm1_cm_dll_ctrl_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_dll_ctrl_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_dll_ctrl_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_dll_ctrl_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_dll_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_dll_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_dll_ctrl (Special register for DLL control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_override =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dll_override_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if DLL lock and code outputs are overriden or not)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dll_override_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_dll_ctrl_dll_override_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dll_override_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_dll_ctrl_t _regval = 0x1 & (((omap44xx_ckgen_cm1_cm_dll_ctrl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clkmode_dpll_core: This register allows controlling the DPLL modes.
 * Type: omap44xx_ckgen_cm1.cm_clkmode_dpll_core (Implicit type of This register allows controlling the DPLL modes. register)
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RO	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval)
{
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clkmode_dpll_core (This register allows controlling the DPLL modes.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_regm4xen_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_ack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x5500 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x5407 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = 0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 10);
    _regval = (_regval | (0x5107 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 12);
    _regval = (_regval | (0x4507 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_core_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t _regval = 0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_core_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1507 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register cm_idlest_dpll_core: This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_idlest_dpll_core (Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register)
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_core_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

// Register cm_idlest_dpll_core is not writeable
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_idlest_dpll_core (This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_dpll_clk_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_core_st_mn_bypass_extract(_regval));
}

/*
 * Register cm_autoidle_dpll_core: This register provides automatic control over the DPLL activity.
 * Type: omap44xx_ckgen_cm1.cm_autoidle_dpll_core (Implicit type of This register provides automatic control over the DPLL activity. register)
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_autoidle_dpll_core (This register provides automatic control over the DPLL activity.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_core_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_core_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clksel_dpll_core: This register provides controls over the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_clksel_dpll_core (Implicit type of This register provides controls over the DPLL. register)
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 1, offset 19, init 0):	MBZ	_
 *   dpll_clkouthif_clksel	(size 1, offset 20, init 0):	RW	Selects the source of the DPLL CLKOUTHIF clock. Same as CLKINPHIFSEL pin on the DPLL
 *   _anon21	(size 2, offset 21, init 0):	MBZ	_
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RW	Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_core_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval)
{
    _regval = (_regval & 0x97ff7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clksel_dpll_core (This register provides controls over the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Selects the source of the DPLL CLKOUTHIF clock. Same as CLKINPHIFSEL pin on the DPLL)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x97ff00 & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    _regval = (_regval & 0x97ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = 0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x90007f & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    _regval = (_regval & 0x97ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_clkouthif_clksel_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkouthif_clksel_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = 0x100000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 20);
    _regval = (_regval | (0x87ff7f & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    _regval = (_regval & 0x97ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_core_dpll_byp_clksel_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_core_t _regval = 0x800000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_core_t )(_fieldval)) << 23);
    _regval = (_regval | (0x17ff7f & mackerel_read_addr_32(_dev->base, 0x2c)));
    // No read of register shadow required
    _regval = (_regval & 0x97ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m2_dpll_core: This register provides controls over the M2 divider of the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_div_m2_dpll_core (Implicit type of This register provides controls over the M2 divider of the DPLL. register)
 *   dpll_clkout_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M2, for internal clock generation (1 to 31); Divide value from 1 to 31.
 *   dpll_clkout_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkout_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUT
 *   st_dpll_clkout	(size 1, offset 9, init 0):	RO	DPLL CLKOUT status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval)
{
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m2_dpll_core (This register provides controls over the M2 divider of the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M2, for internal clock generation (1 to 31); Divide value from 1 to 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUT)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkout =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUT status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_core_st_dpll_clkout_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_core_dpll_clkout_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m3_dpll_core: This register provides controls over the M3 divider of the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_div_m3_dpll_core (Implicit type of This register provides controls over the M3 divider of the DPLL. register)
 *   dpll_clkouthif_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31
 *   dpll_clkouthif_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkouthif_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUTHIF
 *   st_dpll_clkouthif	(size 1, offset 9, init 0):	RO	DPLL CLKOUTHIF status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval)
{
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m3_dpll_core (This register provides controls over the M3 divider of the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkouthif_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUTHIF)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkouthif =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUTHIF status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_core_st_dpll_clkouthif_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkouthif_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_core_dpll_clkouthif_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m4_dpll_core: This register provides controls over the CLKOUT1 o/p of the HSDIVIDER.
 * Type: omap44xx_ckgen_cm1.cm_div_m4_dpll_core (Implicit type of This register provides controls over the CLKOUT1 o/p of the HSDIVIDER. register)
 *   hsdivider_clkout1_div	(size 5, offset 0, init 0):	RW	DPLL M4 post-divider factor (1 to 31).
 *   hsdivider_clkout1_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout1_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT1
 *   st_hsdivider_clkout1	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT1 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout1_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval)
{
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m4_dpll_core (This register provides controls over the CLKOUT1 o/p of the HSDIVIDER.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M4 post-divider factor (1 to 31).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT1 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_st_hsdivider_clkout1_extract(_regval));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1100 & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x101f & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_core_hsdivider_clkout1_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_core_t )(_fieldval)) << 12);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m5_dpll_core: This register provides controls over the CLKOUT2 o/p of the HSDIVIDER.
 * Type: omap44xx_ckgen_cm1.cm_div_m5_dpll_core (Implicit type of This register provides controls over the CLKOUT2 o/p of the HSDIVIDER. register)
 *   hsdivider_clkout2_div	(size 5, offset 0, init 0):	RW	DPLL M5 post-divider factor (1 to 31)
 *   hsdivider_clkout2_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout2_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT2
 *   st_hsdivider_clkout2	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT2 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout2_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval)
{
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m5_dpll_core (This register provides controls over the CLKOUT2 o/p of the HSDIVIDER.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M5 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT2 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_st_hsdivider_clkout2_extract(_regval));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1100 & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x101f & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_core_hsdivider_clkout2_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_core_t )(_fieldval)) << 12);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m6_dpll_core: This register provides controls over the CLKOUT3 o/p of the HSDIVIDER.
 * Type: omap44xx_ckgen_cm1.cm_div_m6_dpll_core (Implicit type of This register provides controls over the CLKOUT3 o/p of the HSDIVIDER. register)
 *   hsdivider_clkout3_div	(size 5, offset 0, init 0):	RW	DPLL M6 post-divider factor (1 to 31)
 *   hsdivider_clkout3_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT3_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout3_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT3
 *   st_hsdivider_clkout3	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT3 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout3_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M6 divider and CLKOUT3 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval)
{
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m6_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m6_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m6_dpll_core (This register provides controls over the CLKOUT3 o/p of the HSDIVIDER.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M6 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT3_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT3 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout3_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M6 divider and CLKOUT3 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_st_hsdivider_clkout3_extract(_regval));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout3_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1100 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x101f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m6_dpll_core_hsdivider_clkout3_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_div_m6_dpll_core_t )(_fieldval)) << 12);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m7_dpll_core: This register provides controls over the CLKOUT4 o/p of the HSDIVIDER.
 * Type: omap44xx_ckgen_cm1.cm_div_m7_dpll_core (Implicit type of This register provides controls over the CLKOUT4 o/p of the HSDIVIDER. register)
 *   hsdivider_clkout4_div	(size 5, offset 0, init 0):	RW	DPLL M7 post-divider factor (1 to 31)
 *   hsdivider_clkout4_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT4_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout4_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT4
 *   st_hsdivider_clkout4	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT4 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout4_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M7 divider and CLKOUT4 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval)
{
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m7_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m7_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m7_dpll_core (This register provides controls over the CLKOUT4 o/p of the HSDIVIDER.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M7 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT4_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT4 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout4_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M7 divider and CLKOUT4 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_st_hsdivider_clkout4_extract(_regval));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout4_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1100 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x101f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m7_dpll_core_hsdivider_clkout4_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_div_m7_dpll_core_t )(_fieldval)) << 12);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_deltamstep_dpll_core: Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_deltamstep_dpll_core (Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register)
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval)
{
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_deltamstep_dpll_core (Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t _regval = 0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_modfreqdiv_dpll_core: Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_modfreqdiv_dpll_core (Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register)
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval)
{
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_modfreqdiv_dpll_core (Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0x700 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t _regval = 0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_emu_override_dpll_core: This register provides emulation override controls over the CORE DPLL.
 * Type: omap44xx_ckgen_cm1.cm_emu_override_dpll_core (Implicit type of This register provides emulation override controls over the CORE DPLL. register)
 *   core_dpll_emu_div	(size 7, offset 0, init 0):	RW	CORE DPLL override divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   core_dpll_emu_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M)
 *   override_enable	(size 1, offset 19, init 0):	RW	This bit allows to enable or disable the emulation override controls
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval)
{
    _regval = (_regval & 0xfff7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_emu_override_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_emu_override_dpll_core_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_emu_override_dpll_core (This register provides emulation override controls over the CORE DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_dpll_emu_div =\t%" PRIx8 "\t(CORE DPLL override divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_dpll_emu_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " override_enable =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the emulation override controls)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_div_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfff00 & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xfff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_core_dpll_emu_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = 0x7ff00 & (((omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t )(_fieldval)) << 8);
    _regval = (_regval | (0x8007f & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xfff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_emu_override_dpll_core_override_enable_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t _regval = 0x80000 & (((omap44xx_ckgen_cm1_cm_emu_override_dpll_core_t )(_fieldval)) << 19);
    _regval = (_regval | (0x7ff7f & mackerel_read_addr_32(_dev->base, 0x50)));
    // No read of register shadow required
    _regval = (_regval & 0xfff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clkmode_dpll_mpu: This register allows controlling the DPLL modes.
 * Type: omap44xx_ckgen_cm1.cm_clkmode_dpll_mpu (Implicit type of This register allows controlling the DPLL modes. register)
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RO	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval)
{
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clkmode_dpll_mpu (This register allows controlling the DPLL modes.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_regm4xen_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_ack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 0);
    _regval = (_regval | (0x5500 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 8);
    _regval = (_regval | (0x5407 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = 0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 10);
    _regval = (_regval | (0x5107 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 12);
    _regval = (_regval | (0x4507 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t _regval = 0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1507 & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register cm_idlest_dpll_mpu: This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_idlest_dpll_mpu (Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register)
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
}

// Register cm_idlest_dpll_mpu is not writeable
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_idlest_dpll_mpu (This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_dpll_clk_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_st_mn_bypass_extract(_regval));
}

/*
 * Register cm_autoidle_dpll_mpu: This register provides automatic control over the DPLL activity.
 * Type: omap44xx_ckgen_cm1.cm_autoidle_dpll_mpu (Implicit type of This register provides automatic control over the DPLL activity. register)
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control;
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x68));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_autoidle_dpll_mpu (This register provides automatic control over the DPLL activity.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control;)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x68);
    return(omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x68, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clksel_dpll_mpu: This register provides controls over the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_clksel_dpll_mpu (Implicit type of This register provides controls over the DPLL. register)
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 3, offset 19, init 0):	MBZ	_
 *   dcc_en	(size 1, offset 22, init 0):	RW	Enable or disable duty cycle correction. Must be enabled only for frequency 1 GHz.When enabled, the CLKOUTHIF output of the DPLL is used after duty cycle correction instead of CLKOUT. The M3 divider is hard-wired to 1 so the lock frequency Fdpll is directly provided to MPU. .
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RO	Only CLKINPULOW bypass clock supported for this PLL
 *   dcc_count_max	(size 8, offset 24, init 0):	RW	The value 'NbCycles' set in this field determines the duration of the clock ramp step during which the output frequency is Fdpll/(2*M2). The duration is computed as 32 x NbCycles of L4 clock cycles (100 MHz). Duration should be 2.5 us to allow enough time for DCC to lock. This bit field is relevant only when DCC_EN = 1.
 */
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x6c));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval)
{
    _regval = (_regval & 0xffc7ff7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clksel_dpll_mpu (This register provides controls over the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dcc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable duty cycle correction. Must be enabled only for frequency 1 GHz.When enabled, the CLKOUTHIF output of the DPLL is used after duty cycle correction instead of CLKOUT. The M3 divider is hard-wired to 1 so the lock frequency Fdpll is directly provided to MPU. .)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Only CLKINPULOW bypass clock supported for this PLL)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcc_count_max =\t%" PRIx8 "\t(The value 'NbCycles' set in this field determines the duration of the clock ramp step during which the output frequency is Fdpll/(2*M2). The duration is computed as 32 x NbCycles of L4 clock cycles (100 MHz). Duration should be 2.5 us to allow enough time for DCC to lock. This bit field is relevant only when DCC_EN = 1.)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dcc_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dcc_en_status_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_byp_clksel_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x6c);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff47ff00 & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xffc7ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = 0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff40007f & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xffc7ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dcc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dcc_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = 0x400000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 22);
    _regval = (_regval | (0xff07ff7f & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xffc7ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_dcc_count_max_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t _regval = 0xff000000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_t )(_fieldval)) << 24);
    _regval = (_regval | (0x47ff7f & mackerel_read_addr_32(_dev->base, 0x6c)));
    // No read of register shadow required
    _regval = (_regval & 0xffc7ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m2_dpll_mpu: This register provides controls over the M2 divider of the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_div_m2_dpll_mpu (Implicit type of This register provides controls over the M2 divider of the DPLL. register)
 *   dpll_clkout_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M2, for internal clock generation (1 to 31);Divide value from 1 to 31
 *   dpll_clkout_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkout_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUT
 *   st_dpll_clkout	(size 1, offset 9, init 0):	RO	DPLL CLKOUT status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval)
{
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m2_dpll_mpu (This register provides controls over the M2 divider of the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M2, for internal clock generation (1 to 31);Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUT)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkout =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUT status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status1_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status1_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_st_dpll_clkout_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_dpll_clkout_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_deltamstep_dpll_mpu: Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_deltamstep_dpll_mpu (Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register)
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x88));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x88));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval)
{
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_deltamstep_dpll_mpu (Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x88);
    return(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t _regval = 0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x88, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_modfreqdiv_dpll_mpu: Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_modfreqdiv_dpll_mpu (Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register)
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8c));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8c));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval)
{
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_modfreqdiv_dpll_mpu (Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x8c);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t )(_fieldval)) << 0);
    _regval = (_regval | (0x700 & mackerel_read_addr_32(_dev->base, 0x8c)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t _regval = 0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x8c)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_bypclk_dpll_mpu: Control MPU PLL BYPASS clock. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_bypclk_dpll_mpu (Implicit type of Control MPU PLL BYPASS clock. [warm reset insensitive] register)
 *   clksel	(size 2, offset 0, init 0):	RW	Select the DPLL MPU bypass clock
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9c));
}

static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9c));
}

static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_bypclk_dpll_mpu (Control MPU PLL BYPASS clock. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the DPLL MPU bypass clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_clksel_status_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_status_t omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval = mackerel_read_addr_32(_dev->base, 0x9c);
    return(omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_clksel_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t _regval = 0x3 & (((omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clkmode_dpll_iva: This register allows controlling the DPLL modes.
 * Type: omap44xx_ckgen_cm1.cm_clkmode_dpll_iva (Implicit type of This register allows controlling the DPLL modes. register)
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RO	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval)
{
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clkmode_dpll_iva (This register allows controlling the DPLL modes.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_regm4xen_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_ack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 0);
    _regval = (_regval | (0x5500 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 8);
    _regval = (_regval | (0x5407 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = 0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 10);
    _regval = (_regval | (0x5107 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 12);
    _regval = (_regval | (0x4507 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t _regval = 0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1507 & mackerel_read_addr_32(_dev->base, 0xa0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_idlest_dpll_iva: This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_idlest_dpll_iva (Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register)
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

// Register cm_idlest_dpll_iva is not writeable
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_idlest_dpll_iva (This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_dpll_clk_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_iva_st_mn_bypass_extract(_regval));
}

/*
 * Register cm_autoidle_dpll_iva: This register provides automatic control over the DPLL activity.
 * Type: omap44xx_ckgen_cm1.cm_autoidle_dpll_iva (Implicit type of This register provides automatic control over the DPLL activity. register)
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control;
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa8));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa8));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_autoidle_dpll_iva (This register provides automatic control over the DPLL activity.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control;)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_auto_dpll_mode_status1_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status1_t omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xa8);
    return(omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clksel_dpll_iva: This register provides controls over the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_clksel_dpll_iva (Implicit type of This register provides controls over the DPLL. register)
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 4, offset 19, init 0):	MBZ	_
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RW	Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xac));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xac));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval)
{
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clksel_dpll_iva (This register provides controls over the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Allows control of the BYPASS clock of the PLL and the associated HSDIVIDER. Same as ULOWCLKEN on DPLL. In DPLL locked mode, 0 - No impact 1 - No impact In DPLL bypass mode, 0 - CLKINP is selected as the BYPASS clock for CLKOUT/CLKOUTX2 1 - CLKINPULOW is selected as the BYPASS clock for CLKOUT/CLKOUTX2)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xac);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t )(_fieldval)) << 0);
    _regval = (_regval | (0x87ff00 & mackerel_read_addr_32(_dev->base, 0xac)));
    // No read of register shadow required
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = 0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t )(_fieldval)) << 8);
    _regval = (_regval | (0x80007f & mackerel_read_addr_32(_dev->base, 0xac)));
    // No read of register shadow required
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_iva_dpll_byp_clksel_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t _regval = 0x800000 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_iva_t )(_fieldval)) << 23);
    _regval = (_regval | (0x7ff7f & mackerel_read_addr_32(_dev->base, 0xac)));
    // No read of register shadow required
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xac, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m4_dpll_iva: This register provides controls over the CLKOUT1 o/p of the HSDIVIDER.
 * Type: omap44xx_ckgen_cm1.cm_div_m4_dpll_iva (Implicit type of This register provides controls over the CLKOUT1 o/p of the HSDIVIDER. register)
 *   hsdivider_clkout1_div	(size 5, offset 0, init 0):	RW	DPLL M4 post-divider factor (1 to 31)
 *   hsdivider_clkout1_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout1_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT1
 *   st_hsdivider_clkout1	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT1 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout1_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb8));
}

static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb8));
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval)
{
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m4_dpll_iva (This register provides controls over the CLKOUT1 o/p of the HSDIVIDER.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M4 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT1_DIV indicates that the change in divider value has taken effect)\n", omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT1 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout1_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M4 divider and CLKOUT1 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_st_hsdivider_clkout1_extract(_regval));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xb8);
    return(omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_div_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1100 & mackerel_read_addr_32(_dev->base, 0xb8)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 8);
    _regval = (_regval | (0x101f & mackerel_read_addr_32(_dev->base, 0xb8)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_hsdivider_clkout1_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_t )(_fieldval)) << 12);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0xb8)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xb8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m5_dpll_iva: This register provides controls over the CLKOUT2 o/p of the HSDIVIDER.
 * Type: omap44xx_ckgen_cm1.cm_div_m5_dpll_iva (Implicit type of This register provides controls over the CLKOUT2 o/p of the HSDIVIDER. register)
 *   hsdivider_clkout2_div	(size 5, offset 0, init 0):	RW	DPLL M5 post-divider factor (1 to 31)
 *   hsdivider_clkout2_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect.
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hsdivider_clkout2_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of HSDIVIDER CLKOUT2
 *   st_hsdivider_clkout2	(size 1, offset 9, init 0):	RO	HSDIVIDER CLKOUT2 status
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   hsdivider_clkout2_pwdn	(size 1, offset 12, init 0):	RW	Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xbc));
}

static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xbc));
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval)
{
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m5_dpll_iva (This register provides controls over the CLKOUT2 o/p of the HSDIVIDER.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL M5 post-divider factor (1 to 31))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing HSDIVIDER_CLKOUT2_DIV indicates that the change in divider value has taken effect.)\n", omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of HSDIVIDER CLKOUT2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_hsdivider_clkout2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(HSDIVIDER CLKOUT2 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsdivider_clkout2_pwdn =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Direct power down control for HSDIVIDER M5 divider and CLKOUT2 output. Power down should be enabled only when clock is first gated.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_st_hsdivider_clkout2_extract(_regval));
}

static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xbc);
    return(omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout2_div_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1100 & mackerel_read_addr_32(_dev->base, 0xbc)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 8);
    _regval = (_regval | (0x101f & mackerel_read_addr_32(_dev->base, 0xbc)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_hsdivider_clkout2_pwdn_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_hsdivider_clkout1_pwdn_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_t )(_fieldval)) << 12);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0xbc)));
    // No read of register shadow required
    _regval = (_regval & 0x133f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xbc, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_deltamstep_dpll_iva: Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_deltamstep_dpll_iva (Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register)
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc8));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc8));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval)
{
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_deltamstep_dpll_iva (Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xc8);
    return(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t _regval = 0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_modfreqdiv_dpll_iva: Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_modfreqdiv_dpll_iva (Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register)
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval)
{
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_modfreqdiv_dpll_iva (Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xcc);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t )(_fieldval)) << 0);
    _regval = (_regval | (0x700 & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t _regval = 0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0xcc)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc, _regval);
    // No shadow register to write to
}

/*
 * Register cm_bypclk_dpll_iva: Control IVA PLL BYPASS clock. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_bypclk_dpll_iva (Implicit type of Control IVA PLL BYPASS clock. [warm reset insensitive] register)
 *   clksel	(size 2, offset 0, init 0):	RW	Select the DPLL IVA bypass clock
 *   _anon2	(size 30, offset 2, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xdc));
}

static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xdc));
}

static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xdc, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xdc, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xdc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_bypclk_dpll_iva (Control IVA PLL BYPASS clock. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Select the DPLL IVA bypass clock)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_clksel_status1_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_status1_t omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval = mackerel_read_addr_32(_dev->base, 0xdc);
    return(omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_clksel_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t _regval = 0x3 & (((omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xdc, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clkmode_dpll_abe: This register allows controlling the DPLL modes.
 * Type: omap44xx_ckgen_cm1.cm_clkmode_dpll_abe (Implicit type of This register allows controlling the DPLL modes. register)
 *   dpll_en	(size 3, offset 0, init 0):	RW	DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dpll_driftguard_en	(size 1, offset 8, init 0):	RW	This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   dpll_lpmode_en	(size 1, offset 10, init 0):	RW	Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.
 *   dpll_regm4xen	(size 1, offset 11, init 0):	RW	Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.
 *   dpll_ssc_en	(size 1, offset 12, init 0):	RW	Enable or disable Spread Spectrum Clocking
 *   dpll_ssc_ack	(size 1, offset 13, init 0):	RO	Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature
 *   dpll_ssc_downspread	(size 1, offset 14, init 0):	RW	Control if only low frequency spread is required
 *   _anon15	(size 17, offset 15, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval)
{
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clkmode_dpll_abe (This register allows controlling the DPLL modes.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL control. Upon Warm Reset, the PRCM DPLL control state machine updates this register to reflect MN bypass mode.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_driftguard_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_driftguard_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(This bit allows to enable or disable the automatic recalibration feature of the DPLL. The DPLL will automatically start a recalibration process upon assertion of the DPLL's RECAL flag if this bit is set.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_lpmode_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_lpmode_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Set the DPLL in low-power mode. Check the DPLL documentation to see when this can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_regm4xen =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_regm4xen_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable the REGM4XEN mode of the DPLL. Please check the DPLL documentation to check when this mode can be enabled.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Enable or disable Spread Spectrum Clocking)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_ack =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_ack_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Acknowledgement from the DPLL regarding start and stop of Spread Spectrum Clocking feature)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_ssc_downspread =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_ssc_downspread_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control if only low frequency spread is required)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_driftguard_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_lpmode_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_regm4xen_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_en_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_ack_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_ack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 0);
    _regval = (_regval | (0x5d00 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_driftguard_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_driftguard_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 8);
    _regval = (_regval | (0x5c07 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_lpmode_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_lpmode_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = 0x400 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 10);
    _regval = (_regval | (0x5907 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_regm4xen_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_regm4xen_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = 0x800 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 11);
    _regval = (_regval | (0x5507 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = 0x1000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 12);
    _regval = (_regval | (0x4d07 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_dpll_ssc_downspread_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_ssc_downspread_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t _regval = 0x4000 & (((omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1d07 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    _regval = (_regval & 0x7d07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_idlest_dpll_abe: This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_idlest_dpll_abe (Implicit type of This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive] register)
 *   st_dpll_clk	(size 1, offset 0, init 0):	RO	DPLL lock status
 *   _anon1	(size 7, offset 1, init 0):	MBZ	_
 *   st_mn_bypass	(size 1, offset 8, init 0):	RO	DPLL MN_BYPASS status
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe4));
}

static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe4));
}

static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_idlest_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe4, _regval);
}

// Register cm_idlest_dpll_abe is not writeable
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_idlest_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_idlest_dpll_abe (This register allows monitoring DPLL activity. This register is read only and automatically updated. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clk =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clk_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL lock status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_mn_bypass =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_mn_bypass_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL MN_BYPASS status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clk_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_dpll_clk_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_mn_bypass_status_t omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_idlest_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe4);
    return(omap44xx_ckgen_cm1_cm_idlest_dpll_abe_st_mn_bypass_extract(_regval));
}

/*
 * Register cm_autoidle_dpll_abe: This register provides automatic control over the DPLL activity.
 * Type: omap44xx_ckgen_cm1.cm_autoidle_dpll_abe (Implicit type of This register provides automatic control over the DPLL activity. register)
 *   auto_dpll_mode	(size 3, offset 0, init 0):	RW	DPLL automatic control;
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe8));
}

static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe8));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_autoidle_dpll_abe (This register provides automatic control over the DPLL activity.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_dpll_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_auto_dpll_mode_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL automatic control;)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_auto_dpll_mode_status_t omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xe8);
    return(omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_auto_dpll_mode_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_auto_dpll_mode_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t _regval = 0x7 & (((omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe8, _regval);
    // No shadow register to write to
}

/*
 * Register cm_clksel_dpll_abe: This register provides controls over the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_clksel_dpll_abe (Implicit type of This register provides controls over the DPLL. register)
 *   dpll_div	(size 7, offset 0, init 0):	RW	DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   dpll_mult	(size 11, offset 8, init 0):	RW	DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).
 *   _anon19	(size 4, offset 19, init 0):	MBZ	_
 *   dpll_byp_clksel	(size 1, offset 23, init 0):	RO	Only CLKINPULOW bypass clock supported for this PLL
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec));
}

static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval)
{
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xec, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_clksel_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_clksel_dpll_abe (This register provides controls over the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_div =\t%" PRIx8 "\t(DPLL divider factor (0 to 127) (equal to input N of DPLL; actual division factor is N+1).)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_mult =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL multiplier factor (2 to 2047). This register is automatically cleared to 0 when the DPLL_EN field in the *CLKMODE_DPLL* register is set to select MN bypass mode. (equal to input M of DPLL; M=2 to 2047 = DPLL multiplies by M).)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_byp_clksel =\t%" PRIx8 "\t(Only CLKINPULOW bypass clock supported for this PLL)\n", omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xec);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status1_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xec);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xec);
    return(omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_byp_clksel_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_div_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7ff00 & mackerel_read_addr_32(_dev->base, 0xec)));
    // No read of register shadow required
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_clksel_dpll_abe_dpll_mult_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t _regval = 0x7ff00 & (((omap44xx_ckgen_cm1_cm_clksel_dpll_abe_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0xec)));
    // No read of register shadow required
    _regval = (_regval & 0x87ff7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m2_dpll_abe: This register provides controls over the M2 divider of the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_div_m2_dpll_abe (Implicit type of This register provides controls over the M2 divider of the DPLL. register)
 *   dpll_clkout_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M2, for internal clock generation (1 to 31). Divide value from 1 to 31
 *   dpll_clkout_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect.
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkout_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUT
 *   st_dpll_clkout	(size 1, offset 9, init 0):	RO	DPLL CLKOUT status
 *   dpll_clkoutx2_gate_ctrl	(size 1, offset 10, init 0):	RW	Control gating of DPLL CLKOUTX2
 *   st_dpll_clkoutx2	(size 1, offset 11, init 0):	RO	DPLL CLKOUTX2 status
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval)
{
    _regval = (_regval & 0xf3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m2_dpll_abe (This register provides controls over the M2 divider of the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status2_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M2, for internal clock generation (1 to 31). Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUT_DIV indicates that the change in divider value has taken effect.)\n", omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkout_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUT)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkout =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUT status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkoutx2_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUTX2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkoutx2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUTX2 status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkout_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_st_dpll_clkoutx2_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 0);
    _regval = (_regval | (0x500 & mackerel_read_addr_32(_dev->base, 0xf0)));
    // No read of register shadow required
    _regval = (_regval & 0xf3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkout_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 8);
    _regval = (_regval | (0x41f & mackerel_read_addr_32(_dev->base, 0xf0)));
    // No read of register shadow required
    _regval = (_regval & 0xf3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_dpll_clkoutx2_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t _regval = 0x400 & (((omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_t )(_fieldval)) << 10);
    _regval = (_regval | (0x11f & mackerel_read_addr_32(_dev->base, 0xf0)));
    // No read of register shadow required
    _regval = (_regval & 0xf3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

/*
 * Register cm_div_m3_dpll_abe: This register provides controls over the M3 divider of the DPLL.
 * Type: omap44xx_ckgen_cm1.cm_div_m3_dpll_abe (Implicit type of This register provides controls over the M3 divider of the DPLL. register)
 *   dpll_clkouthif_div	(size 5, offset 0, init 0):	RW	DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31
 *   dpll_clkouthif_divchack	(size 1, offset 5, init 0):	RO	Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect.
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   dpll_clkouthif_gate_ctrl	(size 1, offset 8, init 0):	RW	Control gating of DPLL CLKOUTHIF
 *   st_dpll_clkouthif	(size 1, offset 9, init 0):	RO	DPLL CLKOUTHIF status
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf4));
}

static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf4));
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf4, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval)
{
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xf4, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_div_m3_dpll_abe (This register provides controls over the M3 divider of the DPLL.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status2_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL post-divider factor, M3, for internal clock generation (1 to 31). Divide value from 1 to 31)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_divchack =\t%" PRIx8 "\t(Toggle on this status bit after changing DPLL_CLKOUTHIF_DIV indicates that the change in divider value has taken effect.)\n", omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_clkouthif_gate_ctrl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Control gating of DPLL CLKOUTHIF)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st_dpll_clkouthif =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_st_dpll_clkout_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DPLL CLKOUTHIF status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status2_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf4);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf4);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_divchack_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf4);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_extract(_regval));
}

static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_st_dpll_clkout_status_t omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0xf4);
    return(omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_st_dpll_clkouthif_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status2_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = 0x1f & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_addr_32(_dev->base, 0xf4)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf4, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_dpll_clkouthif_gate_ctrl_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_gate_ctrl_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t _regval = 0x100 & (((omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->base, 0xf4)));
    // No read of register shadow required
    _regval = (_regval & 0x33f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf4, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_deltamstep_dpll_abe: Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_deltamstep_dpll_abe (Implicit type of Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive] register)
 *   deltamstep	(size 20, offset 0, init 0):	RW	DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval)
{
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_deltamstep_dpll_abe (Control the DeltaMStep parameter for Spread Spectrum Clocking. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deltamstep =\t%" PRIx32 "\t(DeltaMStep is split into fractional and integer part. For Triangular Spread Spectrum: [19:18] for integer part, [17:0] for fractional part For Square Wave Spread Spectrum [19:14] for integer part, [13:0] for fractional part)\n", omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    return(omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_deltamstep_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t _regval = 0xfffff & (((omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
    // No shadow register to write to
}

/*
 * Register cm_ssc_modfreqdiv_dpll_abe: Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_ssc_modfreqdiv_dpll_abe (Implicit type of Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive] register)
 *   modfreqdiv_mantissa	(size 7, offset 0, init 0):	RW	Set the Mantissa component of MODFREQDIV factor
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   modfreqdiv_exponent	(size 3, offset 8, init 0):	RW	Set the Exponent component of MODFREQDIV factor
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10c));
}

static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10c));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval)
{
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x10c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_ssc_modfreqdiv_dpll_abe (Control the Modulation Frequency (Fm) for Spread Spectrum. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_mantissa =\t%" PRIx8 "\t(Set the Mantissa component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " modfreqdiv_exponent =\t%" PRIx8 "\t(Set the Exponent component of MODFREQDIV factor)\n", omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x10c);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval = mackerel_read_addr_32(_dev->base, 0x10c);
    return(omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_mantissa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval = 0x7f & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t )(_fieldval)) << 0);
    _regval = (_regval | (0x700 & mackerel_read_addr_32(_dev->base, 0x10c)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_modfreqdiv_exponent_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t _regval = 0x700 & (((omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7f & mackerel_read_addr_32(_dev->base, 0x10c)));
    // No read of register shadow required
    _regval = (_regval & 0x77f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
    // No shadow register to write to
}

/*
 * Register cm_shadow_freq_config1: Shadow register to program new DPLL configuration affecting EMIF and GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state.
 * Type: omap44xx_ckgen_cm1.cm_shadow_freq_config1 (Implicit type of Shadow register to program new DPLL configuration affecting EMIF and GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state. register)
 *   freq_update	(size 1, offset 0, init 0):	RW	Writing 1 indicates that a new configuration is available. It is automatically cleared by h/w after the configuration has been applied.
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   dll_override	(size 1, offset 2, init 0):	RW	Shadow register forCM_DLL_CTRL.DLL_OVERRIDE.The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.
 *   dll_reset	(size 1, offset 3, init 0):	RW	Specify if DLL should be reset or not during the frequency change hardware sequence.
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   dpll_core_dpll_en	(size 3, offset 8, init 0):	RW	Shadow register forCM_CLKMODE_DPLL_CORE.DPLL_EN. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.
 *   dpll_core_m2_div	(size 5, offset 11, init 0):	RW	Shadow register forCM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1. Divide value from 1 to 31.
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config1_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x160));
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval)
{
    _regval = (_regval & 0xff0d);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x160)));
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_shadow_freq_config1 (Shadow register to program new DPLL configuration affecting EMIF and GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " freq_update =\t%" PRIx8 "\t(Writing 1 indicates that a new configuration is available. It is automatically cleared by h/w after the configuration has been applied.)\n", omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_override =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dll_override_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_DLL_CTRL.DLL_OVERRIDE.The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dll_reset =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dll_reset_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Specify if DLL should be reset or not during the frequency change hardware sequence.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_core_dpll_en =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_en_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_CLKMODE_DPLL_CORE.DPLL_EN. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_core_m2_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_DIV_M2_DPLL_CORE.DPLL_CLKOUT_DIV. The main register is automatically loaded with the shadow register value after EMIF IDLE if the FREQ_UPDATE field is set to 1. Divide value from 1 to 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dll_override_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dll_reset_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dll_reset_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_en_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = mackerel_read_addr_32(_dev->base, 0x160);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_freq_update_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = 0x1 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff0c & mackerel_read_addr_32(_dev->base, 0x160)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff0d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dll_override_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_override_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dll_override_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = 0x4 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffffff09 & mackerel_read_addr_32(_dev->base, 0x160)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff0d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dll_reset_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dll_reset_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dll_reset_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = 0x8 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffff05 & mackerel_read_addr_32(_dev->base, 0x160)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff0d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_dpll_en_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_en_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = 0x700 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff80d & mackerel_read_addr_32(_dev->base, 0x160)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff0d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config1_dpll_core_m2_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config1_t _regval = 0xf800 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config1_t )(_fieldval)) << 11);
    _regval = (_regval | (0xffff070d & mackerel_read_addr_32(_dev->base, 0x160)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff0d);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x160, _regval);
    // No shadow register to write to
}

/*
 * Register cm_shadow_freq_config2: Shadow register to program new DPLL configuration affecting GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state.
 * Type: omap44xx_ckgen_cm1.cm_shadow_freq_config2 (Implicit type of Shadow register to program new DPLL configuration affecting GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state. register)
 *   gpmc_freq_update	(size 1, offset 0, init 0):	RW	Controls whether or not GPMC has to be put automatically into idle during the frequency change operation.
 *   clksel_core	(size 1, offset 1, init 0):	RW	Shadow register forCM_CLKSEL_CORE.CLKSEL_CORE. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.
 *   clksel_l3	(size 1, offset 2, init 0):	RW	Shadow register forCM_CLKSEL_CORE.CLKSEL_L3. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.
 *   dpll_core_m5_div	(size 5, offset 3, init 0):	RW	Shadow register forCM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1. Divide value from 1 to 31.
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x164));
}

static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_shadow_freq_config2_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x164));
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_shadow_freq_config2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_shadow_freq_config2 (Shadow register to program new DPLL configuration affecting GPMC (L3 clock) functional frequency during DVFS. The PRCM h/w automatically applies the new configuration after EMIF/GPMC have been put in idle state.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpmc_freq_update =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_gpmc_freq_update_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Controls whether or not GPMC has to be put automatically into idle during the frequency change operation.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_core =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_core_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_CLKSEL_CORE.CLKSEL_CORE. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clksel_l3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_clksel_l3_status1_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_CLKSEL_CORE.CLKSEL_L3. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpll_core_m5_div =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_dpll_clkout_div_status_prtval(_s + _r, _avail, omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Shadow register forCM_DIV_M5_DPLL_CORE.HSDIVIDER_CLKOUT2_DIV. The main register is automatically loaded with the shadow register value after GPMC IDLE if the CM_SHADOW_FREQ_CONFIG1.FREQ_UPDATE field is set to 1 and GPMC_FREQ_UPDATE is set to 1. Divide value from 1 to 31.)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline omap44xx_ckgen_cm1_gpmc_freq_update_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_gpmc_freq_update_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_extract(_regval));
}

static inline omap44xx_ckgen_cm1_clksel_core_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_core_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_extract(_regval));
}

static inline omap44xx_ckgen_cm1_clksel_l3_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_clksel_l3_status1_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_extract(_regval));
}

static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_dpll_clkout_div_status_t omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = mackerel_read_addr_32(_dev->base, 0x164);
    return(omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_gpmc_freq_update_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_gpmc_freq_update_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_gpmc_freq_update_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = 0x1 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_32(_dev->base, 0x164)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_core_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_core_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_core_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = 0x2 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_addr_32(_dev->base, 0x164)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_l3_status1_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_clksel_l3_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_clksel_l3_status1_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = 0x4 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_32(_dev->base, 0x164)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_shadow_freq_config2_dpll_core_m5_div_wrf(__DN(t) *_dev, omap44xx_ckgen_cm1_dpll_clkout_div_status_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_shadow_freq_config2_t _regval = 0xf8 & (((omap44xx_ckgen_cm1_cm_shadow_freq_config2_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7 & mackerel_read_addr_32(_dev->base, 0x164)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x164, _regval);
    // No shadow register to write to
}

/*
 * Register cm_dyn_dep_prescal: Control the time unit of the sliding window for dynamic dependencies (auto-sleep feature).
 * Type: omap44xx_ckgen_cm1.cm_dyn_dep_prescal (Implicit type of Control the time unit of the sliding window for dynamic dependencies (auto-sleep feature). register)
 *   prescal	(size 6, offset 0, init 0):	RW	Time unit is equal to (PRESCAL + 1) L4 clock cycles.
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline void omap44xx_ckgen_cm1_cm_dyn_dep_prescal_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_dyn_dep_prescal_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_dyn_dep_prescal_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_dyn_dep_prescal_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_dyn_dep_prescal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_dyn_dep_prescal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval = mackerel_read_addr_32(_dev->base, 0x170);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_dyn_dep_prescal (Control the time unit of the sliding window for dynamic dependencies (auto-sleep feature).): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescal =\t%" PRIx8 "\t(Time unit is equal to (PRESCAL + 1) L4 clock cycles.)\n", omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval = mackerel_read_addr_32(_dev->base, 0x170);
    return(omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_dyn_dep_prescal_prescal_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t _regval = 0x3f & (((omap44xx_ckgen_cm1_cm_dyn_dep_prescal_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
    // No shadow register to write to
}

/*
 * Register cm_restore_st: Automatic restore status. This register is used by the system DMA to write a predefined value at the end of end automatic restore phase. [warm reset insensitive]
 * Type: omap44xx_ckgen_cm1.cm_restore_st (Implicit type of Automatic restore status. This register is used by the system DMA to write a predefined value at the end of end automatic restore phase. [warm reset insensitive] register)
 *   phase1_completed	(size 1, offset 0, init 0):	RW	Indicates if restore phase 1 is completed. Must be cleared by software before going to device OFF mode.
 *   phase2a_completed	(size 1, offset 1, init 0):	RW	Indicates if restore phase 2a is completed. Must be cleared by software before going to device OFF mode.
 *   phase2b_completed	(size 1, offset 2, init 0):	RW	Indicates if restore phase 2b is completed. Must be cleared by software before going to device OFF mode.
 *   _anon3	(size 29, offset 3, init 0):	MBZ	_
 */
static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline omap44xx_ckgen_cm1_cm_restore_st_t omap44xx_ckgen_cm1_cm_restore_st_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline void omap44xx_ckgen_cm1_cm_restore_st_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_restore_st_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_restore_st_rawwr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_restore_st_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline void omap44xx_ckgen_cm1_cm_restore_st_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_restore_st_t _regval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_restore_st_wr(__DN(t) *_dev, omap44xx_ckgen_cm1_cm_restore_st_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

static inline int omap44xx_ckgen_cm1_cm_restore_st_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_cm_restore_st_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cm_restore_st (Automatic restore status. This register is used by the system DMA to write a predefined value at the end of end automatic restore phase. [warm reset insensitive]): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phase1_completed =\t%" PRIx8 "\t(Indicates if restore phase 1 is completed. Must be cleared by software before going to device OFF mode.)\n", omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phase2a_completed =\t%" PRIx8 "\t(Indicates if restore phase 2a is completed. Must be cleared by software before going to device OFF mode.)\n", omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phase2b_completed =\t%" PRIx8 "\t(Indicates if restore phase 2b is completed. Must be cleared by software before going to device OFF mode.)\n", omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_extract(_regval));
}

static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_rdf(__DN(t) *_dev)
{
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_extract(_regval));
}

static inline void omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_restore_st_phase1_completed_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = 0x1 & (((omap44xx_ckgen_cm1_cm_restore_st_t )(_fieldval)) << 0);
    _regval = (_regval | (0x6 & mackerel_read_addr_32(_dev->base, 0x180)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_restore_st_phase2a_completed_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = 0x2 & (((omap44xx_ckgen_cm1_cm_restore_st_t )(_fieldval)) << 1);
    _regval = (_regval | (0x5 & mackerel_read_addr_32(_dev->base, 0x180)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
    // No shadow register to write to
}

static inline void omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void omap44xx_ckgen_cm1_cm_restore_st_phase2b_completed_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    omap44xx_ckgen_cm1_cm_restore_st_t _regval = 0x4 & (((omap44xx_ckgen_cm1_cm_restore_st_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x180)));
    // No read of register shadow required
    _regval = (_regval & 0x7);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
    // No shadow register to write to
}

static inline int omap44xx_ckgen_cm1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int omap44xx_ckgen_cm1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device omap44xx_ckgen_cm1 ():\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clksel_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clksel_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_dll_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clkmode_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_idlest_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_autoidle_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clksel_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m2_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m3_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m4_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m5_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m6_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m7_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_emu_override_dpll_core_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clkmode_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_idlest_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_autoidle_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clksel_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m2_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_bypclk_dpll_mpu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clkmode_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_idlest_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_autoidle_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clksel_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m4_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m5_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_bypclk_dpll_iva_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clkmode_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_idlest_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_autoidle_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_clksel_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m2_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_div_m3_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_deltamstep_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_ssc_modfreqdiv_dpll_abe_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_shadow_freq_config1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_shadow_freq_config2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_dyn_dep_prescal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = omap44xx_ckgen_cm1_cm_restore_st_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device omap44xx_ckgen_cm1\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __omap44xx_ckgen_cm1_DEV_H
