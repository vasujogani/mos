#ifndef __arm_DEV_H
#define __arm_DEV_H 1
/*
 * DEVICE DEFINITION: ARM architecture
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) arm ## _ ## x
/*
 * Constants defn: arm.cpu_mode (CPU mode bits)
 *  - no width specified
 */
typedef uint8_t arm_cpu_mode_t;
#define arm_user ((arm_cpu_mode_t)0x10)
#define arm_fiq ((arm_cpu_mode_t)0x11)
#define arm_irq ((arm_cpu_mode_t)0x12)
#define arm_super ((arm_cpu_mode_t)0x13)
#define arm_abort ((arm_cpu_mode_t)0x17)
#define arm_undef ((arm_cpu_mode_t)0x1b)
#define arm_system ((arm_cpu_mode_t)0x1f)

static inline char *arm_cpu_mode_describe(arm_cpu_mode_t _e) __attribute__ ((always_inline));
static inline char *arm_cpu_mode_describe(arm_cpu_mode_t _e)
{
    switch (_e) {
    case arm_user:
        return("user: User");
    case arm_fiq:
        return("fiq: FIQ");
    case arm_irq:
        return("irq: IRQ");
    case arm_super:
        return("super: Supervisor");
    case arm_abort:
        return("abort: Abort");
    case arm_undef:
        return("undef: Undefined");
    case arm_system:
        return("system: System");
    default:
        return(NULL);
    }
}

static inline int arm_cpu_mode_prtval(char *_s, size_t _size, arm_cpu_mode_t _e) __attribute__ ((always_inline));
static inline int arm_cpu_mode_prtval(char *_s, size_t _size, arm_cpu_mode_t _e)
{
    char *d = arm_cpu_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "arm_cpu_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: arm.exc_vector (Exception vector addresses)
 *  - no width specified
 */
typedef uint8_t arm_exc_vector_t;
#define arm_vec_reset ((arm_exc_vector_t)0x0)
#define arm_vec_undef ((arm_exc_vector_t)0x4)
#define arm_vec_swi ((arm_exc_vector_t)0x8)
#define arm_vec_pref_abort ((arm_exc_vector_t)0xc)
#define arm_vec_data_abort ((arm_exc_vector_t)0x10)
#define arm_vec_irq ((arm_exc_vector_t)0x18)
#define arm_vec_fiq ((arm_exc_vector_t)0x1c)

static inline char *arm_exc_vector_describe(arm_exc_vector_t _e) __attribute__ ((always_inline));
static inline char *arm_exc_vector_describe(arm_exc_vector_t _e)
{
    switch (_e) {
    case arm_vec_reset:
        return("vec_reset: Reset");
    case arm_vec_undef:
        return("vec_undef: Undefined instruction");
    case arm_vec_swi:
        return("vec_swi: Software interrupt");
    case arm_vec_pref_abort:
        return("vec_pref_abort: Prefetch abort");
    case arm_vec_data_abort:
        return("vec_data_abort: Data abort");
    case arm_vec_irq:
        return("vec_irq: Interrupt");
    case arm_vec_fiq:
        return("vec_fiq: Fast interrupt");
    default:
        return(NULL);
    }
}

static inline int arm_exc_vector_prtval(char *_s, size_t _size, arm_exc_vector_t _e) __attribute__ ((always_inline));
static inline int arm_exc_vector_prtval(char *_s, size_t _size, arm_exc_vector_t _e)
{
    char *d = arm_exc_vector_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "arm_exc_vector_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: arm.fault_type (Faulting access type)
 *  - no width specified
 */
typedef uint8_t arm_fault_type_t;
#define arm_terminal ((arm_fault_type_t)0x2)
#define arm_vector ((arm_fault_type_t)0x0)
#define arm_alignment ((arm_fault_type_t)0x1)
#define arm_alignment_2 ((arm_fault_type_t)0x3)
#define arm_l1extabort ((arm_fault_type_t)0xc)
#define arm_l2extabort ((arm_fault_type_t)0xe)
#define arm_sec_trans ((arm_fault_type_t)0x5)
#define arm_page_trans ((arm_fault_type_t)0x7)
#define arm_sec_dom ((arm_fault_type_t)0x9)
#define arm_page_dom ((arm_fault_type_t)0xb)
#define arm_sec_perm ((arm_fault_type_t)0xd)
#define arm_page_perm ((arm_fault_type_t)0xf)
#define arm_sec_linef ((arm_fault_type_t)0x4)
#define arm_page_linef ((arm_fault_type_t)0x6)
#define arm_sec_nlinef ((arm_fault_type_t)0x8)
#define arm_page_nlinef ((arm_fault_type_t)0xa)

static inline char *arm_fault_type_describe(arm_fault_type_t _e) __attribute__ ((always_inline));
static inline char *arm_fault_type_describe(arm_fault_type_t _e)
{
    switch (_e) {
    case arm_terminal:
        return("terminal: Terminal exception");
    case arm_vector:
        return("vector: Vector exception");
    case arm_alignment:
        return("alignment: Alignment");
    case arm_alignment_2:
        return("alignment_2: Alternate alignment");
    case arm_l1extabort:
        return("l1extabort: Level 1 external abort on translation");
    case arm_l2extabort:
        return("l2extabort: Level 2 external abort on translation");
    case arm_sec_trans:
        return("sec_trans: Section translation");
    case arm_page_trans:
        return("page_trans: Page transation");
    case arm_sec_dom:
        return("sec_dom: Section domain");
    case arm_page_dom:
        return("page_dom: Page domain");
    case arm_sec_perm:
        return("sec_perm: Section permissions");
    case arm_page_perm:
        return("page_perm: Page permissions");
    case arm_sec_linef:
        return("sec_linef: Section external abort on linefetch");
    case arm_page_linef:
        return("page_linef: Page external abort on linefetch");
    case arm_sec_nlinef:
        return("sec_nlinef: Section external abort on non-linefetch");
    case arm_page_nlinef:
        return("page_nlinef: Page external abort on non-linefetch");
    default:
        return(NULL);
    }
}

static inline int arm_fault_type_prtval(char *_s, size_t _size, arm_fault_type_t _e) __attribute__ ((always_inline));
static inline int arm_fault_type_prtval(char *_s, size_t _size, arm_fault_type_t _e)
{
    char *d = arm_fault_type_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "arm_fault_type_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: arm_status_t
 * Description: Status register
 * Fields:
 *   m	(size 5, offset 0, init 0):	NOATTR	Mode
 *   t	(size 1, offset 5, init 0):	NOATTR	Thumb mode
 *   f	(size 1, offset 6, init 0):	NOATTR	FIQ disable
 *   i	(size 1, offset 7, init 0):	NOATTR	IRQ disable
 *   _anon8	(size 19, offset 8, init 0):	RSVD	_
 *   q	(size 1, offset 27, init 0):	NOATTR	DSP overflow
 *   v	(size 1, offset 28, init 0):	NOATTR	Overflow
 *   c	(size 1, offset 29, init 0):	NOATTR	Carry
 *   z	(size 1, offset 30, init 0):	NOATTR	Zero result
 *   n	(size 1, offset 31, init 0):	NOATTR	Negative result
 */
typedef uint32_t arm_status_t;
#define arm_status_default 0x0
static inline arm_cpu_mode_t arm_status_m_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline arm_cpu_mode_t arm_status_m_extract(arm_status_t _regval)
{
    return((arm_cpu_mode_t )((_regval & 0x1f) >> 0));
}

static inline arm_status_t arm_status_m_insert(arm_status_t _regval, arm_cpu_mode_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_m_insert(arm_status_t _regval, arm_cpu_mode_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((arm_status_t )(_fieldval)) << 0)));
}

static inline uint8_t arm_status_t_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_t_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline arm_status_t arm_status_t_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_t_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((arm_status_t )(_fieldval)) << 5)));
}

static inline uint8_t arm_status_f_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_f_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline arm_status_t arm_status_f_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_f_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((arm_status_t )(_fieldval)) << 6)));
}

static inline uint8_t arm_status_i_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_i_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline arm_status_t arm_status_i_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_i_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((arm_status_t )(_fieldval)) << 7)));
}

static inline uint8_t arm_status_q_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_q_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline arm_status_t arm_status_q_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_q_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((arm_status_t )(_fieldval)) << 27)));
}

static inline uint8_t arm_status_v_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_v_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline arm_status_t arm_status_v_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_v_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((arm_status_t )(_fieldval)) << 28)));
}

static inline uint8_t arm_status_c_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_c_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline arm_status_t arm_status_c_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_c_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((arm_status_t )(_fieldval)) << 29)));
}

static inline uint8_t arm_status_z_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_z_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline arm_status_t arm_status_z_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_z_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((arm_status_t )(_fieldval)) << 30)));
}

static inline uint8_t arm_status_n_extract(arm_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_status_n_extract(arm_status_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline arm_status_t arm_status_n_insert(arm_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_status_t arm_status_n_insert(arm_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((arm_status_t )(_fieldval)) << 31)));
}

static inline int arm_status_prtval(char *_s, size_t _size, arm_status_t _regval) __attribute__ ((always_inline));
static inline int arm_status_prtval(char *_s, size_t _size, arm_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_cpu_mode_prtval(_s + _r, _avail, arm_status_m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(Thumb mode)\n", arm_status_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f =\t%" PRIx8 "\t(FIQ disable)\n", arm_status_f_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(IRQ disable)\n", arm_status_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " q =\t%" PRIx8 "\t(DSP overflow)\n", arm_status_q_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v =\t%" PRIx8 "\t(Overflow)\n", arm_status_v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c =\t%" PRIx8 "\t(Carry)\n", arm_status_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " z =\t%" PRIx8 "\t(Zero result)\n", arm_status_z_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n =\t%" PRIx8 "\t(Negative result)\n", arm_status_n_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: arm_control_t
 * Description: Implicit type of CP15 control register register
 * Fields:
 *   m	(size 1, offset 0, init 0):	RW	MMU enable
 *   a	(size 1, offset 1, init 0):	RW	Alignment fault checking enable
 *   c	(size 1, offset 2, init 0):	RW	Data or unified cache enable
 *   w	(size 1, offset 3, init 0):	RW	Write buffer enable
 *   p	(size 1, offset 4, init 0):	RW	26/32-bit exception handler mode
 *   d	(size 1, offset 5, init 0):	RW	26-bit address exception checking
 *   l	(size 1, offset 6, init 0):	RW	Late abort model
 *   b	(size 1, offset 7, init 0):	RW	Big endian
 *   s	(size 1, offset 8, init 0):	RW	System protection bit
 *   r	(size 1, offset 9, init 0):	RW	ROM protection bit
 *   f	(size 1, offset 10, init 0):	RW	Implementation defined
 *   z	(size 1, offset 11, init 0):	RW	Branch prediction enable
 *   i	(size 1, offset 12, init 0):	RW	Instruction cache enable
 *   v	(size 1, offset 13, init 0):	RW	High exception vectors enable
 *   rr	(size 1, offset 14, init 0):	RW	Predictable cache replacement strategy
 *   l4	(size 1, offset 15, init 0):	RW	Backwards compatible loads
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t arm_control_t;
#define arm_control_default 0x0
static inline uint8_t arm_control_m_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_m_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline arm_control_t arm_control_m_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_m_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((arm_control_t )(_fieldval)) << 0)));
}

static inline uint8_t arm_control_a_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_a_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline arm_control_t arm_control_a_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_a_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((arm_control_t )(_fieldval)) << 1)));
}

static inline uint8_t arm_control_c_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_c_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline arm_control_t arm_control_c_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_c_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((arm_control_t )(_fieldval)) << 2)));
}

static inline uint8_t arm_control_w_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_w_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline arm_control_t arm_control_w_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_w_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((arm_control_t )(_fieldval)) << 3)));
}

static inline uint8_t arm_control_p_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_p_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline arm_control_t arm_control_p_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_p_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((arm_control_t )(_fieldval)) << 4)));
}

static inline uint8_t arm_control_d_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_d_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline arm_control_t arm_control_d_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_d_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((arm_control_t )(_fieldval)) << 5)));
}

static inline uint8_t arm_control_l_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_l_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline arm_control_t arm_control_l_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_l_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((arm_control_t )(_fieldval)) << 6)));
}

static inline uint8_t arm_control_b_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_b_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline arm_control_t arm_control_b_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_b_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((arm_control_t )(_fieldval)) << 7)));
}

static inline uint8_t arm_control_s_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_s_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline arm_control_t arm_control_s_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_s_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((arm_control_t )(_fieldval)) << 8)));
}

static inline uint8_t arm_control_r_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_r_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline arm_control_t arm_control_r_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_r_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((arm_control_t )(_fieldval)) << 9)));
}

static inline uint8_t arm_control_f_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_f_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline arm_control_t arm_control_f_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_f_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((arm_control_t )(_fieldval)) << 10)));
}

static inline uint8_t arm_control_z_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_z_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline arm_control_t arm_control_z_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_z_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((arm_control_t )(_fieldval)) << 11)));
}

static inline uint8_t arm_control_i_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_i_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline arm_control_t arm_control_i_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_i_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((arm_control_t )(_fieldval)) << 12)));
}

static inline uint8_t arm_control_v_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_v_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline arm_control_t arm_control_v_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_v_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((arm_control_t )(_fieldval)) << 13)));
}

static inline uint8_t arm_control_rr_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_rr_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline arm_control_t arm_control_rr_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_rr_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((arm_control_t )(_fieldval)) << 14)));
}

static inline uint8_t arm_control_l4_extract(arm_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_control_l4_extract(arm_control_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline arm_control_t arm_control_l4_insert(arm_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_control_t arm_control_l4_insert(arm_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((arm_control_t )(_fieldval)) << 15)));
}

static inline int arm_control_prtval(char *_s, size_t _size, arm_control_t _regval) __attribute__ ((always_inline));
static inline int arm_control_prtval(char *_s, size_t _size, arm_control_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m =\t%" PRIx8 "\t(MMU enable)\n", arm_control_m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a =\t%" PRIx8 "\t(Alignment fault checking enable)\n", arm_control_a_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c =\t%" PRIx8 "\t(Data or unified cache enable)\n", arm_control_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " w =\t%" PRIx8 "\t(Write buffer enable)\n", arm_control_w_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(26/32-bit exception handler mode)\n", arm_control_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " d =\t%" PRIx8 "\t(26-bit address exception checking)\n", arm_control_d_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l =\t%" PRIx8 "\t(Late abort model)\n", arm_control_l_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " b =\t%" PRIx8 "\t(Big endian)\n", arm_control_b_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " s =\t%" PRIx8 "\t(System protection bit)\n", arm_control_s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx8 "\t(ROM protection bit)\n", arm_control_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f =\t%" PRIx8 "\t(Implementation defined)\n", arm_control_f_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " z =\t%" PRIx8 "\t(Branch prediction enable)\n", arm_control_z_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(Instruction cache enable)\n", arm_control_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v =\t%" PRIx8 "\t(High exception vectors enable)\n", arm_control_v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rr =\t%" PRIx8 "\t(Predictable cache replacement strategy)\n", arm_control_rr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4 =\t%" PRIx8 "\t(Backwards compatible loads)\n", arm_control_l4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: arm_ttbase_t
 * Description: Implicit type of Translation table base register
 * Fields:
 *   _anon0	(size 14, offset 0, init 0):	MBZ	_
 *   base	(size 18, offset 14, init 0):	RW	Base address high bits
 */
typedef uint32_t arm_ttbase_t;
#define arm_ttbase_default 0x0
static inline uint32_t arm_ttbase_base_extract(arm_ttbase_t _regval) __attribute__ ((always_inline));
static inline uint32_t arm_ttbase_base_extract(arm_ttbase_t _regval)
{
    return((uint32_t )((_regval & 0xffffc000) >> 14));
}

static inline arm_ttbase_t arm_ttbase_base_insert(arm_ttbase_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline arm_ttbase_t arm_ttbase_base_insert(arm_ttbase_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3fff) | (0xffffc000 & (((arm_ttbase_t )(_fieldval)) << 14)));
}

static inline int arm_ttbase_prtval(char *_s, size_t _size, arm_ttbase_t _regval) __attribute__ ((always_inline));
static inline int arm_ttbase_prtval(char *_s, size_t _size, arm_ttbase_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(Base address high bits)\n", arm_ttbase_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: arm_faultstat_t
 * Description: Implicit type of Fault status register
 * Fields:
 *   status	(size 4, offset 0, init 0):	RW	Access type
 *   domain	(size 4, offset 4, init 0):	RW	Faulting domain
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t arm_faultstat_t;
#define arm_faultstat_default 0x0
static inline arm_fault_type_t arm_faultstat_status_extract(arm_faultstat_t _regval) __attribute__ ((always_inline));
static inline arm_fault_type_t arm_faultstat_status_extract(arm_faultstat_t _regval)
{
    return((arm_fault_type_t )((_regval & 0xf) >> 0));
}

static inline arm_faultstat_t arm_faultstat_status_insert(arm_faultstat_t _regval, arm_fault_type_t _fieldval) __attribute__ ((always_inline));
static inline arm_faultstat_t arm_faultstat_status_insert(arm_faultstat_t _regval, arm_fault_type_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((arm_faultstat_t )(_fieldval)) << 0)));
}

static inline uint8_t arm_faultstat_domain_extract(arm_faultstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_faultstat_domain_extract(arm_faultstat_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline arm_faultstat_t arm_faultstat_domain_insert(arm_faultstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_faultstat_t arm_faultstat_domain_insert(arm_faultstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((arm_faultstat_t )(_fieldval)) << 4)));
}

static inline int arm_faultstat_prtval(char *_s, size_t _size, arm_faultstat_t _regval) __attribute__ ((always_inline));
static inline int arm_faultstat_prtval(char *_s, size_t _size, arm_faultstat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_fault_type_prtval(_s + _r, _avail, arm_faultstat_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Access type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " domain =\t%" PRIx8 "\t(Faulting domain)\n", arm_faultstat_domain_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: arm_tlblock_t
 * Description: Implicit type of TLB lockdown register
 * Fields:
 *   p	(size 1, offset 0, init 0):	RW	Protected from CP8 invalidates
 *   entry	(size 31, offset 1, init 0):	RW	Base and victim (variable width)
 */
typedef uint32_t arm_tlblock_t;
#define arm_tlblock_default 0x0
static inline uint8_t arm_tlblock_p_extract(arm_tlblock_t _regval) __attribute__ ((always_inline));
static inline uint8_t arm_tlblock_p_extract(arm_tlblock_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline arm_tlblock_t arm_tlblock_p_insert(arm_tlblock_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline arm_tlblock_t arm_tlblock_p_insert(arm_tlblock_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((arm_tlblock_t )(_fieldval)) << 0)));
}

static inline uint32_t arm_tlblock_entry_extract(arm_tlblock_t _regval) __attribute__ ((always_inline));
static inline uint32_t arm_tlblock_entry_extract(arm_tlblock_t _regval)
{
    return((uint32_t )((_regval & 0xfffffffe) >> 1));
}

static inline arm_tlblock_t arm_tlblock_entry_insert(arm_tlblock_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline arm_tlblock_t arm_tlblock_entry_insert(arm_tlblock_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x1) | (0xfffffffe & (((arm_tlblock_t )(_fieldval)) << 1)));
}

static inline int arm_tlblock_prtval(char *_s, size_t _size, arm_tlblock_t _regval) __attribute__ ((always_inline));
static inline int arm_tlblock_prtval(char *_s, size_t _size, arm_tlblock_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(Protected from CP8 invalidates)\n", arm_tlblock_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry =\t%" PRIx32 "\t(Base and victim (variable width))\n", arm_tlblock_entry_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    uint32_t tlbfunc_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum arm_initials {
    arm_control_initial = 0x0,
    arm_ttbase_initial = 0x0,
    arm_domacc_initial = 0x0,
    arm_faultstat_initial = 0x0,
    arm_faultaddr_initial = 0x0,
    arm_tlbfunc_initial = 0x0,
    arm_tlblock_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void arm_initialize(__DN(t) *_dev) __attribute__ ((always_inline));
static inline void arm_initialize(__DN(t) *_dev)
{
}

/*
 * Register control: CP15 control register
 * Type: arm.control (Implicit type of CP15 control register register)
 *   m	(size 1, offset 0, init 0):	RW	MMU enable
 *   a	(size 1, offset 1, init 0):	RW	Alignment fault checking enable
 *   c	(size 1, offset 2, init 0):	RW	Data or unified cache enable
 *   w	(size 1, offset 3, init 0):	RW	Write buffer enable
 *   p	(size 1, offset 4, init 0):	RW	26/32-bit exception handler mode
 *   d	(size 1, offset 5, init 0):	RW	26-bit address exception checking
 *   l	(size 1, offset 6, init 0):	RW	Late abort model
 *   b	(size 1, offset 7, init 0):	RW	Big endian
 *   s	(size 1, offset 8, init 0):	RW	System protection bit
 *   r	(size 1, offset 9, init 0):	RW	ROM protection bit
 *   f	(size 1, offset 10, init 0):	RW	Implementation defined
 *   z	(size 1, offset 11, init 0):	RW	Branch prediction enable
 *   i	(size 1, offset 12, init 0):	RW	Instruction cache enable
 *   v	(size 1, offset 13, init 0):	RW	High exception vectors enable
 *   rr	(size 1, offset 14, init 0):	RW	Predictable cache replacement strategy
 *   l4	(size 1, offset 15, init 0):	RW	Backwards compatible loads
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline arm_control_t arm_control_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_control_t arm_control_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x1));
}

static inline arm_control_t arm_control_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_control_t arm_control_rd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x1));
}

static inline void arm_control_rawwr(__DN(t) *_dev, arm_control_t _regval) __attribute__ ((always_inline));
static inline void arm_control_rawwr(__DN(t) *_dev, arm_control_t _regval)
{
    __DN(cp15_write_32)(_dev, 0x1, _regval);
}

static inline void arm_control_wr(__DN(t) *_dev, arm_control_t _regval) __attribute__ ((always_inline));
static inline void arm_control_wr(__DN(t) *_dev, arm_control_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0x1, _regval);
}

static inline int arm_control_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_control_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control (CP15 control register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m =\t%" PRIx8 "\t(MMU enable)\n", arm_control_m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a =\t%" PRIx8 "\t(Alignment fault checking enable)\n", arm_control_a_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c =\t%" PRIx8 "\t(Data or unified cache enable)\n", arm_control_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " w =\t%" PRIx8 "\t(Write buffer enable)\n", arm_control_w_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(26/32-bit exception handler mode)\n", arm_control_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " d =\t%" PRIx8 "\t(26-bit address exception checking)\n", arm_control_d_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l =\t%" PRIx8 "\t(Late abort model)\n", arm_control_l_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " b =\t%" PRIx8 "\t(Big endian)\n", arm_control_b_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " s =\t%" PRIx8 "\t(System protection bit)\n", arm_control_s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx8 "\t(ROM protection bit)\n", arm_control_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f =\t%" PRIx8 "\t(Implementation defined)\n", arm_control_f_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " z =\t%" PRIx8 "\t(Branch prediction enable)\n", arm_control_z_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(Instruction cache enable)\n", arm_control_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v =\t%" PRIx8 "\t(High exception vectors enable)\n", arm_control_v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rr =\t%" PRIx8 "\t(Predictable cache replacement strategy)\n", arm_control_rr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4 =\t%" PRIx8 "\t(Backwards compatible loads)\n", arm_control_l4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t arm_control_m_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_m_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_m_extract(_regval));
}

static inline uint8_t arm_control_a_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_a_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_a_extract(_regval));
}

static inline uint8_t arm_control_c_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_c_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_c_extract(_regval));
}

static inline uint8_t arm_control_w_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_w_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_w_extract(_regval));
}

static inline uint8_t arm_control_p_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_p_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_p_extract(_regval));
}

static inline uint8_t arm_control_d_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_d_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_d_extract(_regval));
}

static inline uint8_t arm_control_l_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_l_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_l_extract(_regval));
}

static inline uint8_t arm_control_b_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_b_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_b_extract(_regval));
}

static inline uint8_t arm_control_s_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_s_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_s_extract(_regval));
}

static inline uint8_t arm_control_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_r_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_r_extract(_regval));
}

static inline uint8_t arm_control_f_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_f_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_f_extract(_regval));
}

static inline uint8_t arm_control_z_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_z_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_z_extract(_regval));
}

static inline uint8_t arm_control_i_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_i_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_i_extract(_regval));
}

static inline uint8_t arm_control_v_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_v_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_v_extract(_regval));
}

static inline uint8_t arm_control_rr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_rr_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_rr_extract(_regval));
}

static inline uint8_t arm_control_l4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_control_l4_rdf(__DN(t) *_dev)
{
    arm_control_t _regval = __DN(cp15_read_32)(_dev, 0x1);
    return(arm_control_l4_extract(_regval));
}

static inline void arm_control_m_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_m_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x1 & (((arm_control_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffe & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_a_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_a_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x2 & (((arm_control_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffd & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_c_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_c_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x4 & (((arm_control_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffb & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_w_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_w_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x8 & (((arm_control_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfff7 & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_p_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_p_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x10 & (((arm_control_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffef & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_d_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_d_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x20 & (((arm_control_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffdf & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_l_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_l_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x40 & (((arm_control_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffbf & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_b_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_b_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x80 & (((arm_control_t )(_fieldval)) << 7);
    _regval = (_regval | (0xff7f & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_s_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_s_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x100 & (((arm_control_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfeff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_r_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_r_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x200 & (((arm_control_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfdff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_f_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_f_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x400 & (((arm_control_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfbff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_z_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_z_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x800 & (((arm_control_t )(_fieldval)) << 11);
    _regval = (_regval | (0xf7ff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_i_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_i_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x1000 & (((arm_control_t )(_fieldval)) << 12);
    _regval = (_regval | (0xefff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_v_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_v_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x2000 & (((arm_control_t )(_fieldval)) << 13);
    _regval = (_regval | (0xdfff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_rr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_rr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x4000 & (((arm_control_t )(_fieldval)) << 14);
    _regval = (_regval | (0xbfff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void arm_control_l4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_control_l4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_control_t _regval = 0x8000 & (((arm_control_t )(_fieldval)) << 15);
    _regval = (_regval | (0x7fff & __DN(cp15_read_32)(_dev, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x1, _regval);
    // No shadow register to write to
}

/*
 * Register ttbase: Translation table base
 * Type: arm.ttbase (Implicit type of Translation table base register)
 *   _anon0	(size 14, offset 0, init 0):	MBZ	_
 *   base	(size 18, offset 14, init 0):	RW	Base address high bits
 */
static inline arm_ttbase_t arm_ttbase_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_ttbase_t arm_ttbase_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x2));
}

static inline arm_ttbase_t arm_ttbase_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_ttbase_t arm_ttbase_rd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x2));
}

static inline void arm_ttbase_rawwr(__DN(t) *_dev, arm_ttbase_t _regval) __attribute__ ((always_inline));
static inline void arm_ttbase_rawwr(__DN(t) *_dev, arm_ttbase_t _regval)
{
    __DN(cp15_write_32)(_dev, 0x2, _regval);
}

static inline void arm_ttbase_wr(__DN(t) *_dev, arm_ttbase_t _regval) __attribute__ ((always_inline));
static inline void arm_ttbase_wr(__DN(t) *_dev, arm_ttbase_t _regval)
{
    _regval = (_regval & 0xffffc000);
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0x2, _regval);
}

static inline int arm_ttbase_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_ttbase_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    arm_ttbase_t _regval = __DN(cp15_read_32)(_dev, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ttbase (Translation table base): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(Base address high bits)\n", arm_ttbase_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t arm_ttbase_base_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_ttbase_base_rdf(__DN(t) *_dev)
{
    arm_ttbase_t _regval = __DN(cp15_read_32)(_dev, 0x2);
    return(arm_ttbase_base_extract(_regval));
}

static inline void arm_ttbase_base_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void arm_ttbase_base_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    arm_ttbase_t _regval = 0xffffc000 & (((arm_ttbase_t )(_fieldval)) << 14);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffffc000);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x2, _regval);
    // No shadow register to write to
}

/*
 * Register domacc: Domain access control
 * Type: arm.uint32 (primitive type)
 */
static inline uint32_t arm_domacc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_domacc_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x3));
}

static inline uint32_t arm_domacc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_domacc_rd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x3));
}

static inline void arm_domacc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void arm_domacc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    __DN(cp15_write_32)(_dev, 0x3, _regval);
}

static inline void arm_domacc_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void arm_domacc_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0x3, _regval);
}

static inline int arm_domacc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_domacc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = __DN(cp15_read_32)(_dev, 0x3);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register domacc (Domain access control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register faultstat: Fault status
 * Type: arm.faultstat (Implicit type of Fault status register)
 *   status	(size 4, offset 0, init 0):	RW	Access type
 *   domain	(size 4, offset 4, init 0):	RW	Faulting domain
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline arm_faultstat_t arm_faultstat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_faultstat_t arm_faultstat_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x5));
}

static inline arm_faultstat_t arm_faultstat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_faultstat_t arm_faultstat_rd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x5));
}

static inline void arm_faultstat_rawwr(__DN(t) *_dev, arm_faultstat_t _regval) __attribute__ ((always_inline));
static inline void arm_faultstat_rawwr(__DN(t) *_dev, arm_faultstat_t _regval)
{
    __DN(cp15_write_32)(_dev, 0x5, _regval);
}

static inline void arm_faultstat_wr(__DN(t) *_dev, arm_faultstat_t _regval) __attribute__ ((always_inline));
static inline void arm_faultstat_wr(__DN(t) *_dev, arm_faultstat_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0x5, _regval);
}

static inline int arm_faultstat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_faultstat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    arm_faultstat_t _regval = __DN(cp15_read_32)(_dev, 0x5);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register faultstat (Fault status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_fault_type_prtval(_s + _r, _avail, arm_faultstat_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Access type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " domain =\t%" PRIx8 "\t(Faulting domain)\n", arm_faultstat_domain_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    // _anon9 is anonymous
    return(_r);
}

static inline arm_fault_type_t arm_faultstat_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_fault_type_t arm_faultstat_status_rdf(__DN(t) *_dev)
{
    arm_faultstat_t _regval = __DN(cp15_read_32)(_dev, 0x5);
    return(arm_faultstat_status_extract(_regval));
}

static inline uint8_t arm_faultstat_domain_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_faultstat_domain_rdf(__DN(t) *_dev)
{
    arm_faultstat_t _regval = __DN(cp15_read_32)(_dev, 0x5);
    return(arm_faultstat_domain_extract(_regval));
}

static inline void arm_faultstat_status_wrf(__DN(t) *_dev, arm_fault_type_t _fieldval) __attribute__ ((always_inline));
static inline void arm_faultstat_status_wrf(__DN(t) *_dev, arm_fault_type_t _fieldval)
{
    arm_faultstat_t _regval = 0xf & (((arm_faultstat_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0 & __DN(cp15_read_32)(_dev, 0x5)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x5, _regval);
    // No shadow register to write to
}

static inline void arm_faultstat_domain_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_faultstat_domain_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_faultstat_t _regval = 0xf0 & (((arm_faultstat_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf & __DN(cp15_read_32)(_dev, 0x5)));
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0x5, _regval);
    // No shadow register to write to
}

/*
 * Register faultaddr: Fault address
 * Type: arm.uint32 (primitive type)
 */
static inline uint32_t arm_faultaddr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_faultaddr_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x6));
}

static inline uint32_t arm_faultaddr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_faultaddr_rd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x6));
}

static inline void arm_faultaddr_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void arm_faultaddr_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    __DN(cp15_write_32)(_dev, 0x6, _regval);
}

static inline void arm_faultaddr_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void arm_faultaddr_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0x6, _regval);
}

static inline int arm_faultaddr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_faultaddr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = __DN(cp15_read_32)(_dev, 0x6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register faultaddr (Fault address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tlbfunc: TLB functions
 * Type: arm.uint32 (primitive type)
 */
static inline uint32_t arm_tlbfunc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_tlbfunc_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0x8));
}

static inline uint32_t arm_tlbfunc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_tlbfunc_rd(__DN(t) *_dev)
{
    return(_dev->tlbfunc_shadow);
}

static inline void arm_tlbfunc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void arm_tlbfunc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    __DN(cp15_write_32)(_dev, 0x8, _regval);
}

static inline void arm_tlbfunc_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void arm_tlbfunc_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0x8, _regval);
}

static inline int arm_tlbfunc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_tlbfunc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = _dev->tlbfunc_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tlbfunc (TLB functions): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tlblock: TLB lockdown
 * Type: arm.tlblock (Implicit type of TLB lockdown register)
 *   p	(size 1, offset 0, init 0):	RW	Protected from CP8 invalidates
 *   entry	(size 31, offset 1, init 0):	RW	Base and victim (variable width)
 */
static inline arm_tlblock_t arm_tlblock_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_tlblock_t arm_tlblock_rawrd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0xa));
}

static inline arm_tlblock_t arm_tlblock_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline arm_tlblock_t arm_tlblock_rd(__DN(t) *_dev)
{
    return(__DN(cp15_read_32)(_dev, 0xa));
}

static inline void arm_tlblock_rawwr(__DN(t) *_dev, arm_tlblock_t _regval) __attribute__ ((always_inline));
static inline void arm_tlblock_rawwr(__DN(t) *_dev, arm_tlblock_t _regval)
{
    __DN(cp15_write_32)(_dev, 0xa, _regval);
}

static inline void arm_tlblock_wr(__DN(t) *_dev, arm_tlblock_t _regval) __attribute__ ((always_inline));
static inline void arm_tlblock_wr(__DN(t) *_dev, arm_tlblock_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(cp15_write_32)(_dev, 0xa, _regval);
}

static inline int arm_tlblock_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_tlblock_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    arm_tlblock_t _regval = __DN(cp15_read_32)(_dev, 0xa);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tlblock (TLB lockdown): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(Protected from CP8 invalidates)\n", arm_tlblock_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry =\t%" PRIx32 "\t(Base and victim (variable width))\n", arm_tlblock_entry_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t arm_tlblock_p_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t arm_tlblock_p_rdf(__DN(t) *_dev)
{
    arm_tlblock_t _regval = __DN(cp15_read_32)(_dev, 0xa);
    return(arm_tlblock_p_extract(_regval));
}

static inline uint32_t arm_tlblock_entry_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t arm_tlblock_entry_rdf(__DN(t) *_dev)
{
    arm_tlblock_t _regval = __DN(cp15_read_32)(_dev, 0xa);
    return(arm_tlblock_entry_extract(_regval));
}

static inline void arm_tlblock_p_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void arm_tlblock_p_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    arm_tlblock_t _regval = 0x1 & (((arm_tlblock_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & __DN(cp15_read_32)(_dev, 0xa)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0xa, _regval);
    // No shadow register to write to
}

static inline void arm_tlblock_entry_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void arm_tlblock_entry_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    arm_tlblock_t _regval = 0xfffffffe & (((arm_tlblock_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1 & __DN(cp15_read_32)(_dev, 0xa)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(cp15_write_32)(_dev, 0xa, _regval);
    // No shadow register to write to
}

static inline int arm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int arm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device arm (ARM architecture):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_control_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_ttbase_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_domacc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_faultstat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_faultaddr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_tlbfunc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = arm_tlblock_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device arm\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __arm_DEV_H
