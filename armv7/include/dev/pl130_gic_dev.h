#ifndef __pl130_gic_DEV_H
#define __pl130_gic_DEV_H 1
/*
 * DEVICE DEFINITION: PrimeCell PL130 Generic Interrupt Controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) pl130_gic ## _ ## x
/*
 * Register type: pl130_gic_ICDDCR_t
 * Description: Implicit type of Distributor Control register
 * Fields:
 *   enable	(size 1, offset 0, init 0):	RW	enable forwarding to CPU interface
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICDDCR_t;
#define pl130_gic_ICDDCR_default 0x0
static inline uint8_t pl130_gic_ICDDCR_enable_extract(pl130_gic_ICDDCR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDDCR_enable_extract(pl130_gic_ICDDCR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl130_gic_ICDDCR_t pl130_gic_ICDDCR_enable_insert(pl130_gic_ICDDCR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDDCR_t pl130_gic_ICDDCR_enable_insert(pl130_gic_ICDDCR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl130_gic_ICDDCR_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_ICDDCR_prtval(char *_s, size_t _size, pl130_gic_ICDDCR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICDDCR_prtval(char *_s, size_t _size, pl130_gic_ICDDCR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(enable forwarding to CPU interface)\n", pl130_gic_ICDDCR_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICDICTR_t
 * Description: Implicit type of Interrupt Controller Type register
 * Fields:
 *   it_lines_num	(size 5, offset 0, init 0):	RO	max. num. (N) interrupts supported 32(N+1)
 *   cpu_number	(size 3, offset 5, init 0):	RO	number of implemented CPU interfaces
 *   _anon8	(size 2, offset 8, init 0):	RSVD	_
 *   TZ	(size 1, offset 10, init 0):	RO	GIC implements Security Extensions
 *   LSPI	(size 5, offset 11, init 0):	RO	maximum number of lockable SPIs
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICDICTR_t;
#define pl130_gic_ICDICTR_default 0x0
static inline uint8_t pl130_gic_ICDICTR_it_lines_num_extract(pl130_gic_ICDICTR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_it_lines_num_extract(pl130_gic_ICDICTR_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_it_lines_num_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_it_lines_num_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((pl130_gic_ICDICTR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_ICDICTR_cpu_number_extract(pl130_gic_ICDICTR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_cpu_number_extract(pl130_gic_ICDICTR_t _regval)
{
    return((uint8_t )((_regval & 0xe0) >> 5));
}

static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_cpu_number_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_cpu_number_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff1f) | (0xe0 & (((pl130_gic_ICDICTR_t )(_fieldval)) << 5)));
}

static inline uint8_t pl130_gic_ICDICTR_TZ_extract(pl130_gic_ICDICTR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_TZ_extract(pl130_gic_ICDICTR_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_TZ_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_TZ_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((pl130_gic_ICDICTR_t )(_fieldval)) << 10)));
}

static inline uint8_t pl130_gic_ICDICTR_LSPI_extract(pl130_gic_ICDICTR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_LSPI_extract(pl130_gic_ICDICTR_t _regval)
{
    return((uint8_t )((_regval & 0xf800) >> 11));
}

static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_LSPI_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_LSPI_insert(pl130_gic_ICDICTR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff07ff) | (0xf800 & (((pl130_gic_ICDICTR_t )(_fieldval)) << 11)));
}

static inline int pl130_gic_ICDICTR_prtval(char *_s, size_t _size, pl130_gic_ICDICTR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICTR_prtval(char *_s, size_t _size, pl130_gic_ICDICTR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " it_lines_num =\t%" PRIx8 "\t(max. num. (N) interrupts supported 32(N+1))\n", pl130_gic_ICDICTR_it_lines_num_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_number =\t%" PRIx8 "\t(number of implemented CPU interfaces)\n", pl130_gic_ICDICTR_cpu_number_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TZ =\t%" PRIx8 "\t(GIC implements Security Extensions)\n", pl130_gic_ICDICTR_TZ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LSPI =\t%" PRIx8 "\t(maximum number of lockable SPIs)\n", pl130_gic_ICDICTR_LSPI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICDIIDR_t
 * Description: Implicit type of Distributor Implementer Ident. register
 * Fields:
 *   implementer	(size 12, offset 0, init 0):	RO	JEP106 code of implementing company
 *   rev_num	(size 12, offset 12, init 0):	RO	Revision number
 *   product_id	(size 8, offset 24, init 0):	RO	Product identifier
 */
typedef uint32_t pl130_gic_ICDIIDR_t;
#define pl130_gic_ICDIIDR_default 0x0
static inline uint16_t pl130_gic_ICDIIDR_implementer_extract(pl130_gic_ICDIIDR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICDIIDR_implementer_extract(pl130_gic_ICDIIDR_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_implementer_insert(pl130_gic_ICDIIDR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_implementer_insert(pl130_gic_ICDIIDR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((pl130_gic_ICDIIDR_t )(_fieldval)) << 0)));
}

static inline uint16_t pl130_gic_ICDIIDR_rev_num_extract(pl130_gic_ICDIIDR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICDIIDR_rev_num_extract(pl130_gic_ICDIIDR_t _regval)
{
    return((uint16_t )((_regval & 0xfff000) >> 12));
}

static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_rev_num_insert(pl130_gic_ICDIIDR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_rev_num_insert(pl130_gic_ICDIIDR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xff000fff) | (0xfff000 & (((pl130_gic_ICDIIDR_t )(_fieldval)) << 12)));
}

static inline uint8_t pl130_gic_ICDIIDR_product_id_extract(pl130_gic_ICDIIDR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIIDR_product_id_extract(pl130_gic_ICDIIDR_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_product_id_insert(pl130_gic_ICDIIDR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_product_id_insert(pl130_gic_ICDIIDR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((pl130_gic_ICDIIDR_t )(_fieldval)) << 24)));
}

static inline int pl130_gic_ICDIIDR_prtval(char *_s, size_t _size, pl130_gic_ICDIIDR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICDIIDR_prtval(char *_s, size_t _size, pl130_gic_ICDIIDR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " implementer =\t%" PRIx16 "\t(JEP106 code of implementing company)\n", pl130_gic_ICDIIDR_implementer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev_num =\t%" PRIx16 "\t(Revision number)\n", pl130_gic_ICDIIDR_rev_num_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " product_id =\t%" PRIx8 "\t(Product identifier)\n", pl130_gic_ICDIIDR_product_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_priority_reg_t
 * Description: Interrupt priority register
 * Fields:
 *   prio_off0	(size 8, offset 0, init 0):	RW	Priority, byte offset 0
 *   prio_off1	(size 8, offset 8, init 0):	RW	Priority, byte offset 1
 *   prio_off2	(size 8, offset 16, init 0):	RW	Priority, byte offset 2
 *   prio_off3	(size 8, offset 24, init 0):	RW	Priority, byte offset 3
 */
typedef uint32_t pl130_gic_priority_reg_t;
#define pl130_gic_priority_reg_default 0x0
static inline uint8_t pl130_gic_priority_reg_prio_off0_extract(pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_priority_reg_prio_off0_extract(pl130_gic_priority_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off0_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off0_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_priority_reg_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_priority_reg_prio_off1_extract(pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_priority_reg_prio_off1_extract(pl130_gic_priority_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off1_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off1_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((pl130_gic_priority_reg_t )(_fieldval)) << 8)));
}

static inline uint8_t pl130_gic_priority_reg_prio_off2_extract(pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_priority_reg_prio_off2_extract(pl130_gic_priority_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off2_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off2_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((pl130_gic_priority_reg_t )(_fieldval)) << 16)));
}

static inline uint8_t pl130_gic_priority_reg_prio_off3_extract(pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_priority_reg_prio_off3_extract(pl130_gic_priority_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off3_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_priority_reg_t pl130_gic_priority_reg_prio_off3_insert(pl130_gic_priority_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((pl130_gic_priority_reg_t )(_fieldval)) << 24)));
}

static inline int pl130_gic_priority_reg_prtval(char *_s, size_t _size, pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_priority_reg_prtval(char *_s, size_t _size, pl130_gic_priority_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off0 =\t%" PRIx8 "\t(Priority, byte offset 0)\n", pl130_gic_priority_reg_prio_off0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off1 =\t%" PRIx8 "\t(Priority, byte offset 1)\n", pl130_gic_priority_reg_prio_off1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off2 =\t%" PRIx8 "\t(Priority, byte offset 2)\n", pl130_gic_priority_reg_prio_off2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off3 =\t%" PRIx8 "\t(Priority, byte offset 3)\n", pl130_gic_priority_reg_prio_off3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_cpu_targets_reg_t
 * Description: CPU targets
 * Fields:
 *   targets_off0	(size 8, offset 0, init 0):	RW	CPU targets, byte offset 0
 *   targets_off1	(size 8, offset 8, init 0):	RW	CPU targets, byte offset 1
 *   targets_off2	(size 8, offset 16, init 0):	RW	CPU targets, byte offset 2
 *   targets_off3	(size 8, offset 24, init 0):	RW	CPU targets, byte offset 3
 */
typedef uint32_t pl130_gic_cpu_targets_reg_t;
#define pl130_gic_cpu_targets_reg_default 0x0
static inline uint8_t pl130_gic_cpu_targets_reg_targets_off0_extract(pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_cpu_targets_reg_targets_off0_extract(pl130_gic_cpu_targets_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off0_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off0_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_cpu_targets_reg_targets_off1_extract(pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_cpu_targets_reg_targets_off1_extract(pl130_gic_cpu_targets_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off1_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off1_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 8)));
}

static inline uint8_t pl130_gic_cpu_targets_reg_targets_off2_extract(pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_cpu_targets_reg_targets_off2_extract(pl130_gic_cpu_targets_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off2_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off2_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 16)));
}

static inline uint8_t pl130_gic_cpu_targets_reg_targets_off3_extract(pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_cpu_targets_reg_targets_off3_extract(pl130_gic_cpu_targets_reg_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off3_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_cpu_targets_reg_t pl130_gic_cpu_targets_reg_targets_off3_insert(pl130_gic_cpu_targets_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 24)));
}

static inline int pl130_gic_cpu_targets_reg_prtval(char *_s, size_t _size, pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_cpu_targets_reg_prtval(char *_s, size_t _size, pl130_gic_cpu_targets_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off0 =\t%" PRIx8 "\t(CPU targets, byte offset 0)\n", pl130_gic_cpu_targets_reg_targets_off0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off1 =\t%" PRIx8 "\t(CPU targets, byte offset 1)\n", pl130_gic_cpu_targets_reg_targets_off1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off2 =\t%" PRIx8 "\t(CPU targets, byte offset 2)\n", pl130_gic_cpu_targets_reg_targets_off2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off3 =\t%" PRIx8 "\t(CPU targets, byte offset 3)\n", pl130_gic_cpu_targets_reg_targets_off3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_conf_reg_t
 * Description: Configuration registers
 * Fields:
 *   conf0	(size 2, offset 0, init 0):	NOATTR	Configuration 0
 *   conf1	(size 2, offset 2, init 0):	NOATTR	Configuration 1
 *   conf2	(size 2, offset 4, init 0):	NOATTR	Configuration 2
 *   conf3	(size 2, offset 6, init 0):	NOATTR	Configuration 3
 *   conf4	(size 2, offset 8, init 0):	NOATTR	Configuration 4
 *   conf5	(size 2, offset 10, init 0):	NOATTR	Configuration 5
 *   conf6	(size 2, offset 12, init 0):	NOATTR	Configuration 6
 *   conf7	(size 2, offset 14, init 0):	NOATTR	Configuration 7
 *   conf8	(size 2, offset 16, init 0):	NOATTR	Configuration 8
 *   conf9	(size 2, offset 18, init 0):	NOATTR	Configuration 9
 *   conf10	(size 2, offset 20, init 0):	NOATTR	Configuration 10
 *   conf11	(size 2, offset 22, init 0):	NOATTR	Configuration 11
 *   conf12	(size 2, offset 24, init 0):	NOATTR	Configuration 12
 *   conf13	(size 2, offset 26, init 0):	NOATTR	Configuration 13
 *   conf14	(size 2, offset 28, init 0):	NOATTR	Configuration 14
 *   conf15	(size 2, offset 30, init 0):	NOATTR	Configuration 15
 */
typedef uint32_t pl130_gic_conf_reg_t;
#define pl130_gic_conf_reg_default 0x0
static inline uint8_t pl130_gic_conf_reg_conf0_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf0_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf0_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf0_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((pl130_gic_conf_reg_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_conf_reg_conf1_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf1_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc) >> 2));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf1_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf1_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((pl130_gic_conf_reg_t )(_fieldval)) << 2)));
}

static inline uint8_t pl130_gic_conf_reg_conf2_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf2_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x30) >> 4));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf2_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf2_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((pl130_gic_conf_reg_t )(_fieldval)) << 4)));
}

static inline uint8_t pl130_gic_conf_reg_conf3_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf3_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc0) >> 6));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf3_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf3_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((pl130_gic_conf_reg_t )(_fieldval)) << 6)));
}

static inline uint8_t pl130_gic_conf_reg_conf4_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf4_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf4_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf4_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((pl130_gic_conf_reg_t )(_fieldval)) << 8)));
}

static inline uint8_t pl130_gic_conf_reg_conf5_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf5_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc00) >> 10));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf5_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf5_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((pl130_gic_conf_reg_t )(_fieldval)) << 10)));
}

static inline uint8_t pl130_gic_conf_reg_conf6_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf6_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x3000) >> 12));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf6_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf6_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 12)));
}

static inline uint8_t pl130_gic_conf_reg_conf7_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf7_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf7_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf7_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 14)));
}

static inline uint8_t pl130_gic_conf_reg_conf8_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf8_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x30000) >> 16));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf8_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf8_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 16)));
}

static inline uint8_t pl130_gic_conf_reg_conf9_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf9_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc0000) >> 18));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf9_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf9_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 18)));
}

static inline uint8_t pl130_gic_conf_reg_conf10_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf10_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x300000) >> 20));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf10_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf10_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffcfffff) | (0x300000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 20)));
}

static inline uint8_t pl130_gic_conf_reg_conf11_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf11_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc00000) >> 22));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf11_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf11_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff3fffff) | (0xc00000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 22)));
}

static inline uint8_t pl130_gic_conf_reg_conf12_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf12_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x3000000) >> 24));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf12_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf12_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 24)));
}

static inline uint8_t pl130_gic_conf_reg_conf13_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf13_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc000000) >> 26));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf13_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf13_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 26)));
}

static inline uint8_t pl130_gic_conf_reg_conf14_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf14_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0x30000000) >> 28));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf14_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf14_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 28)));
}

static inline uint8_t pl130_gic_conf_reg_conf15_extract(pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_conf_reg_conf15_extract(pl130_gic_conf_reg_t _regval)
{
    return((uint8_t )((_regval & 0xc0000000) >> 30));
}

static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf15_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_conf_reg_conf15_insert(pl130_gic_conf_reg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x3fffffff) | (0xc0000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 30)));
}

static inline int pl130_gic_conf_reg_prtval(char *_s, size_t _size, pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_conf_reg_prtval(char *_s, size_t _size, pl130_gic_conf_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf0 =\t%" PRIx8 "\t(Configuration 0)\n", pl130_gic_conf_reg_conf0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf1 =\t%" PRIx8 "\t(Configuration 1)\n", pl130_gic_conf_reg_conf1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf2 =\t%" PRIx8 "\t(Configuration 2)\n", pl130_gic_conf_reg_conf2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf3 =\t%" PRIx8 "\t(Configuration 3)\n", pl130_gic_conf_reg_conf3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf4 =\t%" PRIx8 "\t(Configuration 4)\n", pl130_gic_conf_reg_conf4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf5 =\t%" PRIx8 "\t(Configuration 5)\n", pl130_gic_conf_reg_conf5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf6 =\t%" PRIx8 "\t(Configuration 6)\n", pl130_gic_conf_reg_conf6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf7 =\t%" PRIx8 "\t(Configuration 7)\n", pl130_gic_conf_reg_conf7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf8 =\t%" PRIx8 "\t(Configuration 8)\n", pl130_gic_conf_reg_conf8_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf9 =\t%" PRIx8 "\t(Configuration 9)\n", pl130_gic_conf_reg_conf9_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf10 =\t%" PRIx8 "\t(Configuration 10)\n", pl130_gic_conf_reg_conf10_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf11 =\t%" PRIx8 "\t(Configuration 11)\n", pl130_gic_conf_reg_conf11_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf12 =\t%" PRIx8 "\t(Configuration 12)\n", pl130_gic_conf_reg_conf12_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf13 =\t%" PRIx8 "\t(Configuration 13)\n", pl130_gic_conf_reg_conf13_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf14 =\t%" PRIx8 "\t(Configuration 14)\n", pl130_gic_conf_reg_conf14_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf15 =\t%" PRIx8 "\t(Configuration 15)\n", pl130_gic_conf_reg_conf15_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_PPI_STATUS_t
 * Description: Implicit type of PPI Status register
 * Fields:
 *   ppi_status	(size 16, offset 0, init 0):	RO	Status of PPI0 - PPI15
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_PPI_STATUS_t;
#define pl130_gic_PPI_STATUS_default 0x0
static inline uint16_t pl130_gic_PPI_STATUS_ppi_status_extract(pl130_gic_PPI_STATUS_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_PPI_STATUS_ppi_status_extract(pl130_gic_PPI_STATUS_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline pl130_gic_PPI_STATUS_t pl130_gic_PPI_STATUS_ppi_status_insert(pl130_gic_PPI_STATUS_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_PPI_STATUS_t pl130_gic_PPI_STATUS_ppi_status_insert(pl130_gic_PPI_STATUS_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((pl130_gic_PPI_STATUS_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_PPI_STATUS_prtval(char *_s, size_t _size, pl130_gic_PPI_STATUS_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_PPI_STATUS_prtval(char *_s, size_t _size, pl130_gic_PPI_STATUS_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppi_status =\t%" PRIx16 "\t(Status of PPI0 - PPI15)\n", pl130_gic_PPI_STATUS_ppi_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICDSGIR_t
 * Description: Implicit type of Software Generated Interrupt register
 * Fields:
 *   SGIINTID	(size 4, offset 0, init 0):	WO	SGI Interrupt ID
 *   _anon4	(size 11, offset 4, init 0):	MBZ	_
 *   SATT	(size 1, offset 15, init 0):	WO	Secure Access Bit
 *   cpu_target_list	(size 8, offset 16, init 0):	WO	CPU Target List
 *   target_list_filter	(size 2, offset 24, init 0):	WO	Target List Filter
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
typedef uint32_t pl130_gic_ICDSGIR_t;
#define pl130_gic_ICDSGIR_default 0x0
static inline uint8_t pl130_gic_ICDSGIR_SGIINTID_extract(pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_SGIINTID_extract(pl130_gic_ICDSGIR_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_SGIINTID_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_SGIINTID_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_ICDSGIR_SATT_extract(pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_SATT_extract(pl130_gic_ICDSGIR_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_SATT_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_SATT_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 15)));
}

static inline uint8_t pl130_gic_ICDSGIR_cpu_target_list_extract(pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_cpu_target_list_extract(pl130_gic_ICDSGIR_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_cpu_target_list_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_cpu_target_list_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 16)));
}

static inline uint8_t pl130_gic_ICDSGIR_target_list_filter_extract(pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_target_list_filter_extract(pl130_gic_ICDSGIR_t _regval)
{
    return((uint8_t )((_regval & 0x3000000) >> 24));
}

static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_target_list_filter_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_target_list_filter_insert(pl130_gic_ICDSGIR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 24)));
}

static inline int pl130_gic_ICDSGIR_prtval(char *_s, size_t _size, pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICDSGIR_prtval(char *_s, size_t _size, pl130_gic_ICDSGIR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SGIINTID =\t%" PRIx8 "\t(SGI Interrupt ID)\n", pl130_gic_ICDSGIR_SGIINTID_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SATT =\t%" PRIx8 "\t(Secure Access Bit)\n", pl130_gic_ICDSGIR_SATT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_target_list =\t%" PRIx8 "\t(CPU Target List)\n", pl130_gic_ICDSGIR_cpu_target_list_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " target_list_filter =\t%" PRIx8 "\t(Target List Filter)\n", pl130_gic_ICDSGIR_target_list_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID0_t
 * Description: Implicit type of Peripheral Ident. 0 register
 * Fields:
 *   part_number_0	(size 8, offset 0, init 0):	RO	Part Number 0
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID0_t;
#define pl130_gic_DIST_PERIPH_ID0_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID0_part_number_0_extract(pl130_gic_DIST_PERIPH_ID0_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID0_part_number_0_extract(pl130_gic_DIST_PERIPH_ID0_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID0_t pl130_gic_DIST_PERIPH_ID0_part_number_0_insert(pl130_gic_DIST_PERIPH_ID0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID0_t pl130_gic_DIST_PERIPH_ID0_part_number_0_insert(pl130_gic_DIST_PERIPH_ID0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_DIST_PERIPH_ID0_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_DIST_PERIPH_ID0_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID0_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID0_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " part_number_0 =\t%" PRIx8 "\t(Part Number 0)\n", pl130_gic_DIST_PERIPH_ID0_part_number_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID1_t
 * Description: Implicit type of Peripheral Ident. 1 register
 * Fields:
 *   part_number_1	(size 4, offset 0, init 0):	RO	Part Number 1
 *   jep106_id_3_0	(size 4, offset 4, init 0):	RO	JEP106 identity code [3:0]
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID1_t;
#define pl130_gic_DIST_PERIPH_ID1_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID1_part_number_1_extract(pl130_gic_DIST_PERIPH_ID1_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID1_part_number_1_extract(pl130_gic_DIST_PERIPH_ID1_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_part_number_1_insert(pl130_gic_DIST_PERIPH_ID1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_part_number_1_insert(pl130_gic_DIST_PERIPH_ID1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_DIST_PERIPH_ID1_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_extract(pl130_gic_DIST_PERIPH_ID1_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_extract(pl130_gic_DIST_PERIPH_ID1_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_insert(pl130_gic_DIST_PERIPH_ID1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_insert(pl130_gic_DIST_PERIPH_ID1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((pl130_gic_DIST_PERIPH_ID1_t )(_fieldval)) << 4)));
}

static inline int pl130_gic_DIST_PERIPH_ID1_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID1_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID1_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " part_number_1 =\t%" PRIx8 "\t(Part Number 1)\n", pl130_gic_DIST_PERIPH_ID1_part_number_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jep106_id_3_0 =\t%" PRIx8 "\t(JEP106 identity code [3:0])\n", pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID2_t
 * Description: Implicit type of Peripheral Ident. 2 register
 * Fields:
 *   jep106_id_6_4	(size 3, offset 0, init 0):	RO	JEP106 identity code [6:4]
 *   jedec_used	(size 1, offset 3, init 0):	RO	is ID allocated by JEDEC
 *   architecure	(size 4, offset 4, init 0):	RO	Architecture vers. of GIC
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID2_t;
#define pl130_gic_DIST_PERIPH_ID2_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_extract(pl130_gic_DIST_PERIPH_ID2_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_extract(pl130_gic_DIST_PERIPH_ID2_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_insert(pl130_gic_DIST_PERIPH_ID2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_insert(pl130_gic_DIST_PERIPH_ID2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((pl130_gic_DIST_PERIPH_ID2_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jedec_used_extract(pl130_gic_DIST_PERIPH_ID2_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jedec_used_extract(pl130_gic_DIST_PERIPH_ID2_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_jedec_used_insert(pl130_gic_DIST_PERIPH_ID2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_jedec_used_insert(pl130_gic_DIST_PERIPH_ID2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((pl130_gic_DIST_PERIPH_ID2_t )(_fieldval)) << 3)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID2_architecure_extract(pl130_gic_DIST_PERIPH_ID2_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_architecure_extract(pl130_gic_DIST_PERIPH_ID2_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_architecure_insert(pl130_gic_DIST_PERIPH_ID2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_architecure_insert(pl130_gic_DIST_PERIPH_ID2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((pl130_gic_DIST_PERIPH_ID2_t )(_fieldval)) << 4)));
}

static inline int pl130_gic_DIST_PERIPH_ID2_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID2_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID2_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jep106_id_6_4 =\t%" PRIx8 "\t(JEP106 identity code [6:4])\n", pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jedec_used =\t%" PRIx8 "\t(is ID allocated by JEDEC)\n", pl130_gic_DIST_PERIPH_ID2_jedec_used_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " architecure =\t%" PRIx8 "\t(Architecture vers. of GIC)\n", pl130_gic_DIST_PERIPH_ID2_architecure_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID3_t
 * Description: Implicit type of Peripheral Ident. 3 register
 * Fields:
 *   mod_number	(size 4, offset 0, init 0):	RO	Modification Number
 *   rev_and	(size 4, offset 4, init 0):	RO	Revision of AND Gates
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID3_t;
#define pl130_gic_DIST_PERIPH_ID3_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID3_mod_number_extract(pl130_gic_DIST_PERIPH_ID3_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID3_mod_number_extract(pl130_gic_DIST_PERIPH_ID3_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_mod_number_insert(pl130_gic_DIST_PERIPH_ID3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_mod_number_insert(pl130_gic_DIST_PERIPH_ID3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_DIST_PERIPH_ID3_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID3_rev_and_extract(pl130_gic_DIST_PERIPH_ID3_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID3_rev_and_extract(pl130_gic_DIST_PERIPH_ID3_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_rev_and_insert(pl130_gic_DIST_PERIPH_ID3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_rev_and_insert(pl130_gic_DIST_PERIPH_ID3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((pl130_gic_DIST_PERIPH_ID3_t )(_fieldval)) << 4)));
}

static inline int pl130_gic_DIST_PERIPH_ID3_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID3_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID3_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mod_number =\t%" PRIx8 "\t(Modification Number)\n", pl130_gic_DIST_PERIPH_ID3_mod_number_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev_and =\t%" PRIx8 "\t(Revision of AND Gates)\n", pl130_gic_DIST_PERIPH_ID3_rev_and_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID4_t
 * Description: Implicit type of Peripheral Ident. 4 register
 * Fields:
 *   jep106_c_code	(size 4, offset 0, init 0):	RO	JEP106 continuation code
 *   page_count	(size 4, offset 4, init 0):	RO	# of 4KB blocks needed
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID4_t;
#define pl130_gic_DIST_PERIPH_ID4_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID4_jep106_c_code_extract(pl130_gic_DIST_PERIPH_ID4_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID4_jep106_c_code_extract(pl130_gic_DIST_PERIPH_ID4_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_jep106_c_code_insert(pl130_gic_DIST_PERIPH_ID4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_jep106_c_code_insert(pl130_gic_DIST_PERIPH_ID4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_DIST_PERIPH_ID4_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID4_page_count_extract(pl130_gic_DIST_PERIPH_ID4_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID4_page_count_extract(pl130_gic_DIST_PERIPH_ID4_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_page_count_insert(pl130_gic_DIST_PERIPH_ID4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_page_count_insert(pl130_gic_DIST_PERIPH_ID4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((pl130_gic_DIST_PERIPH_ID4_t )(_fieldval)) << 4)));
}

static inline int pl130_gic_DIST_PERIPH_ID4_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID4_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID4_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID4_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jep106_c_code =\t%" PRIx8 "\t(JEP106 continuation code)\n", pl130_gic_DIST_PERIPH_ID4_jep106_c_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " page_count =\t%" PRIx8 "\t(# of 4KB blocks needed)\n", pl130_gic_DIST_PERIPH_ID4_page_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID5_t
 * Description: Implicit type of Peripheral Ident. 5 register
 * Fields:
 *   sgi_number	(size 4, offset 0, init 0):	RO	# of SGIs in GIC
 *   ppi_number_0	(size 4, offset 4, init 0):	RO	LSBs of # of PPIs in FIC
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID5_t;
#define pl130_gic_DIST_PERIPH_ID5_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID5_sgi_number_extract(pl130_gic_DIST_PERIPH_ID5_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID5_sgi_number_extract(pl130_gic_DIST_PERIPH_ID5_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_sgi_number_insert(pl130_gic_DIST_PERIPH_ID5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_sgi_number_insert(pl130_gic_DIST_PERIPH_ID5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_DIST_PERIPH_ID5_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID5_ppi_number_0_extract(pl130_gic_DIST_PERIPH_ID5_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID5_ppi_number_0_extract(pl130_gic_DIST_PERIPH_ID5_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_ppi_number_0_insert(pl130_gic_DIST_PERIPH_ID5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_ppi_number_0_insert(pl130_gic_DIST_PERIPH_ID5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((pl130_gic_DIST_PERIPH_ID5_t )(_fieldval)) << 4)));
}

static inline int pl130_gic_DIST_PERIPH_ID5_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID5_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID5_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID5_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgi_number =\t%" PRIx8 "\t(# of SGIs in GIC)\n", pl130_gic_DIST_PERIPH_ID5_sgi_number_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppi_number_0 =\t%" PRIx8 "\t(LSBs of # of PPIs in FIC)\n", pl130_gic_DIST_PERIPH_ID5_ppi_number_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID6_t
 * Description: Implicit type of Peripheral Ident. 6 register
 * Fields:
 *   ppi_number_1	(size 4, offset 0, init 0):	RO	MSBs of #PPIs GIC provides
 *   spi_number_0	(size 4, offset 4, init 0):	RO	LSBs of #SPIs GIC provides
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID6_t;
#define pl130_gic_DIST_PERIPH_ID6_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID6_ppi_number_1_extract(pl130_gic_DIST_PERIPH_ID6_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID6_ppi_number_1_extract(pl130_gic_DIST_PERIPH_ID6_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_ppi_number_1_insert(pl130_gic_DIST_PERIPH_ID6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_ppi_number_1_insert(pl130_gic_DIST_PERIPH_ID6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_DIST_PERIPH_ID6_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID6_spi_number_0_extract(pl130_gic_DIST_PERIPH_ID6_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID6_spi_number_0_extract(pl130_gic_DIST_PERIPH_ID6_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_spi_number_0_insert(pl130_gic_DIST_PERIPH_ID6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_spi_number_0_insert(pl130_gic_DIST_PERIPH_ID6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((pl130_gic_DIST_PERIPH_ID6_t )(_fieldval)) << 4)));
}

static inline int pl130_gic_DIST_PERIPH_ID6_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID6_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID6_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID6_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppi_number_1 =\t%" PRIx8 "\t(MSBs of #PPIs GIC provides)\n", pl130_gic_DIST_PERIPH_ID6_ppi_number_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spi_number_0 =\t%" PRIx8 "\t(LSBs of #SPIs GIC provides)\n", pl130_gic_DIST_PERIPH_ID6_spi_number_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID7_t
 * Description: Implicit type of Peripheral Ident. 7 register
 * Fields:
 *   spi_number_1	(size 4, offset 0, init 0):	RO	MSBs of # SPIs GIC provides
 *   priority	(size 3, offset 4, init 0):	RO	# priority lvls GIC provides
 *   tz	(size 1, offset 7, init 0):	RO	# secure states
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID7_t;
#define pl130_gic_DIST_PERIPH_ID7_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_spi_number_1_extract(pl130_gic_DIST_PERIPH_ID7_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_spi_number_1_extract(pl130_gic_DIST_PERIPH_ID7_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_spi_number_1_insert(pl130_gic_DIST_PERIPH_ID7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_spi_number_1_insert(pl130_gic_DIST_PERIPH_ID7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((pl130_gic_DIST_PERIPH_ID7_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID7_priority_extract(pl130_gic_DIST_PERIPH_ID7_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_priority_extract(pl130_gic_DIST_PERIPH_ID7_t _regval)
{
    return((uint8_t )((_regval & 0x70) >> 4));
}

static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_priority_insert(pl130_gic_DIST_PERIPH_ID7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_priority_insert(pl130_gic_DIST_PERIPH_ID7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff8f) | (0x70 & (((pl130_gic_DIST_PERIPH_ID7_t )(_fieldval)) << 4)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID7_tz_extract(pl130_gic_DIST_PERIPH_ID7_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_tz_extract(pl130_gic_DIST_PERIPH_ID7_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_tz_insert(pl130_gic_DIST_PERIPH_ID7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_tz_insert(pl130_gic_DIST_PERIPH_ID7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl130_gic_DIST_PERIPH_ID7_t )(_fieldval)) << 7)));
}

static inline int pl130_gic_DIST_PERIPH_ID7_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID7_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID7_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID7_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spi_number_1 =\t%" PRIx8 "\t(MSBs of # SPIs GIC provides)\n", pl130_gic_DIST_PERIPH_ID7_spi_number_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(# priority lvls GIC provides)\n", pl130_gic_DIST_PERIPH_ID7_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tz =\t%" PRIx8 "\t(# secure states)\n", pl130_gic_DIST_PERIPH_ID7_tz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_PERIPH_ID8_t
 * Description: Implicit type of Peripheral Ident. 8 register
 * Fields:
 *   irq_legacy	(size 1, offset 0, init 0):	RO	Legacy IRQ signals supported
 *   fiq_legacy	(size 1, offset 1, init 0):	RO	Legacy FIQ signals supported
 *   cpu_if	(size 3, offset 2, init 0):	RO	# of CPU interfaces
 *   if_type	(size 2, offset 5, init 0):	RO	AMBA protocoll
 *   identifier	(size 1, offset 7, init 0):	RO	AMBA interface ID
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_PERIPH_ID8_t;
#define pl130_gic_DIST_PERIPH_ID8_default 0x0
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_irq_legacy_extract(pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_irq_legacy_extract(pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_irq_legacy_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_irq_legacy_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl130_gic_DIST_PERIPH_ID8_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_fiq_legacy_extract(pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_fiq_legacy_extract(pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_fiq_legacy_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_fiq_legacy_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((pl130_gic_DIST_PERIPH_ID8_t )(_fieldval)) << 1)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_cpu_if_extract(pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_cpu_if_extract(pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    return((uint8_t )((_regval & 0x1c) >> 2));
}

static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_cpu_if_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_cpu_if_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((pl130_gic_DIST_PERIPH_ID8_t )(_fieldval)) << 2)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_if_type_extract(pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_if_type_extract(pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    return((uint8_t )((_regval & 0x60) >> 5));
}

static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_if_type_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_if_type_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff9f) | (0x60 & (((pl130_gic_DIST_PERIPH_ID8_t )(_fieldval)) << 5)));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_identifier_extract(pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_identifier_extract(pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_identifier_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_identifier_insert(pl130_gic_DIST_PERIPH_ID8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((pl130_gic_DIST_PERIPH_ID8_t )(_fieldval)) << 7)));
}

static inline int pl130_gic_DIST_PERIPH_ID8_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID8_prtval(char *_s, size_t _size, pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irq_legacy =\t%" PRIx8 "\t(Legacy IRQ signals supported)\n", pl130_gic_DIST_PERIPH_ID8_irq_legacy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fiq_legacy =\t%" PRIx8 "\t(Legacy FIQ signals supported)\n", pl130_gic_DIST_PERIPH_ID8_fiq_legacy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_if =\t%" PRIx8 "\t(# of CPU interfaces)\n", pl130_gic_DIST_PERIPH_ID8_cpu_if_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " if_type =\t%" PRIx8 "\t(AMBA protocoll)\n", pl130_gic_DIST_PERIPH_ID8_if_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " identifier =\t%" PRIx8 "\t(AMBA interface ID)\n", pl130_gic_DIST_PERIPH_ID8_identifier_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_COMPONENT_ID0_t
 * Description: Implicit type of PrimeCell Ident. 0 register
 * Fields:
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_COMPONENT_ID0_t;
#define pl130_gic_DIST_COMPONENT_ID0_default 0x0
static inline uint8_t pl130_gic_DIST_COMPONENT_ID0_component_id_extract(pl130_gic_DIST_COMPONENT_ID0_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID0_component_id_extract(pl130_gic_DIST_COMPONENT_ID0_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_DIST_COMPONENT_ID0_t pl130_gic_DIST_COMPONENT_ID0_component_id_insert(pl130_gic_DIST_COMPONENT_ID0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID0_t pl130_gic_DIST_COMPONENT_ID0_component_id_insert(pl130_gic_DIST_COMPONENT_ID0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_DIST_COMPONENT_ID0_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_DIST_COMPONENT_ID0_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID0_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID0_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID0_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_COMPONENT_ID1_t
 * Description: Implicit type of PrimeCell Ident. 1 register
 * Fields:
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_COMPONENT_ID1_t;
#define pl130_gic_DIST_COMPONENT_ID1_default 0x0
static inline uint8_t pl130_gic_DIST_COMPONENT_ID1_component_id_extract(pl130_gic_DIST_COMPONENT_ID1_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID1_component_id_extract(pl130_gic_DIST_COMPONENT_ID1_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_DIST_COMPONENT_ID1_t pl130_gic_DIST_COMPONENT_ID1_component_id_insert(pl130_gic_DIST_COMPONENT_ID1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID1_t pl130_gic_DIST_COMPONENT_ID1_component_id_insert(pl130_gic_DIST_COMPONENT_ID1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_DIST_COMPONENT_ID1_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_DIST_COMPONENT_ID1_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID1_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID1_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID1_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_COMPONENT_ID2_t
 * Description: Implicit type of PrimeCell Ident. 2 register
 * Fields:
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_COMPONENT_ID2_t;
#define pl130_gic_DIST_COMPONENT_ID2_default 0x0
static inline uint8_t pl130_gic_DIST_COMPONENT_ID2_component_id_extract(pl130_gic_DIST_COMPONENT_ID2_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID2_component_id_extract(pl130_gic_DIST_COMPONENT_ID2_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_DIST_COMPONENT_ID2_t pl130_gic_DIST_COMPONENT_ID2_component_id_insert(pl130_gic_DIST_COMPONENT_ID2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID2_t pl130_gic_DIST_COMPONENT_ID2_component_id_insert(pl130_gic_DIST_COMPONENT_ID2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_DIST_COMPONENT_ID2_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_DIST_COMPONENT_ID2_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID2_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID2_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID2_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_DIST_COMPONENT_ID3_t
 * Description: Implicit type of PrimeCell Ident. 3 register
 * Fields:
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_DIST_COMPONENT_ID3_t;
#define pl130_gic_DIST_COMPONENT_ID3_default 0x0
static inline uint8_t pl130_gic_DIST_COMPONENT_ID3_component_id_extract(pl130_gic_DIST_COMPONENT_ID3_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID3_component_id_extract(pl130_gic_DIST_COMPONENT_ID3_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_DIST_COMPONENT_ID3_t pl130_gic_DIST_COMPONENT_ID3_component_id_insert(pl130_gic_DIST_COMPONENT_ID3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID3_t pl130_gic_DIST_COMPONENT_ID3_component_id_insert(pl130_gic_DIST_COMPONENT_ID3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_DIST_COMPONENT_ID3_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_DIST_COMPONENT_ID3_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID3_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID3_prtval(char *_s, size_t _size, pl130_gic_DIST_COMPONENT_ID3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID3_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCICR_t
 * Description: Implicit type of CPU Interface Control register
 * Fields:
 *   enable	(size 1, offset 0, init 0):	RW	en. fwding to connected processors
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCICR_t;
#define pl130_gic_ICCICR_default 0x0
static inline uint8_t pl130_gic_ICCICR_enable_extract(pl130_gic_ICCICR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCICR_enable_extract(pl130_gic_ICCICR_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pl130_gic_ICCICR_t pl130_gic_ICCICR_enable_insert(pl130_gic_ICCICR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCICR_t pl130_gic_ICCICR_enable_insert(pl130_gic_ICCICR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((pl130_gic_ICCICR_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_ICCICR_prtval(char *_s, size_t _size, pl130_gic_ICCICR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCICR_prtval(char *_s, size_t _size, pl130_gic_ICCICR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(en. fwding to connected processors)\n", pl130_gic_ICCICR_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCPMR_t
 * Description: Implicit type of Interrupt Priority Mask register
 * Fields:
 *   priority	(size 8, offset 0, init 0):	RW	Priority mask level for CPU Interface
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCPMR_t;
#define pl130_gic_ICCPMR_default 0x0
static inline uint8_t pl130_gic_ICCPMR_priority_extract(pl130_gic_ICCPMR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCPMR_priority_extract(pl130_gic_ICCPMR_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_ICCPMR_t pl130_gic_ICCPMR_priority_insert(pl130_gic_ICCPMR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCPMR_t pl130_gic_ICCPMR_priority_insert(pl130_gic_ICCPMR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_ICCPMR_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_ICCPMR_prtval(char *_s, size_t _size, pl130_gic_ICCPMR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCPMR_prtval(char *_s, size_t _size, pl130_gic_ICCPMR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority mask level for CPU Interface)\n", pl130_gic_ICCPMR_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCBPR_t
 * Description: Implicit type of Binary Point register
 * Fields:
 *   binary_point	(size 3, offset 0, init 0):	RW	Split Group- and subpriority
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCBPR_t;
#define pl130_gic_ICCBPR_default 0x0
static inline uint8_t pl130_gic_ICCBPR_binary_point_extract(pl130_gic_ICCBPR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCBPR_binary_point_extract(pl130_gic_ICCBPR_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline pl130_gic_ICCBPR_t pl130_gic_ICCBPR_binary_point_insert(pl130_gic_ICCBPR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCBPR_t pl130_gic_ICCBPR_binary_point_insert(pl130_gic_ICCBPR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((pl130_gic_ICCBPR_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_ICCBPR_prtval(char *_s, size_t _size, pl130_gic_ICCBPR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCBPR_prtval(char *_s, size_t _size, pl130_gic_ICCBPR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " binary_point =\t%" PRIx8 "\t(Split Group- and subpriority)\n", pl130_gic_ICCBPR_binary_point_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCIAR_t
 * Description: Implicit type of Interrupt Acknowledge register
 * Fields:
 *   ack_int_id	(size 10, offset 0, init 0):	RO	Interrupt ID
 *   cpu_id	(size 3, offset 10, init 0):	RO	Processor ID of interrupting processor
 *   _anon13	(size 19, offset 13, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCIAR_t;
#define pl130_gic_ICCIAR_default 0x0
static inline uint16_t pl130_gic_ICCIAR_ack_int_id_extract(pl130_gic_ICCIAR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCIAR_ack_int_id_extract(pl130_gic_ICCIAR_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_ack_int_id_insert(pl130_gic_ICCIAR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_ack_int_id_insert(pl130_gic_ICCIAR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((pl130_gic_ICCIAR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_ICCIAR_cpu_id_extract(pl130_gic_ICCIAR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCIAR_cpu_id_extract(pl130_gic_ICCIAR_t _regval)
{
    return((uint8_t )((_regval & 0x1c00) >> 10));
}

static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_cpu_id_insert(pl130_gic_ICCIAR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_cpu_id_insert(pl130_gic_ICCIAR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe3ff) | (0x1c00 & (((pl130_gic_ICCIAR_t )(_fieldval)) << 10)));
}

static inline int pl130_gic_ICCIAR_prtval(char *_s, size_t _size, pl130_gic_ICCIAR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCIAR_prtval(char *_s, size_t _size, pl130_gic_ICCIAR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack_int_id =\t%" PRIx16 "\t(Interrupt ID)\n", pl130_gic_ICCIAR_ack_int_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_id =\t%" PRIx8 "\t(Processor ID of interrupting processor)\n", pl130_gic_ICCIAR_cpu_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCEOIR_t
 * Description: Implicit type of End of Interrupt register
 * Fields:
 *   eoi_int_id	(size 10, offset 0, init 0):	WO	ACKINTID of ICCIAR access
 *   cpu_id	(size 3, offset 10, init 0):	WO	Proc ID of ICCIAR access
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
typedef uint32_t pl130_gic_ICCEOIR_t;
#define pl130_gic_ICCEOIR_default 0x0
static inline uint16_t pl130_gic_ICCEOIR_eoi_int_id_extract(pl130_gic_ICCEOIR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCEOIR_eoi_int_id_extract(pl130_gic_ICCEOIR_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_eoi_int_id_insert(pl130_gic_ICCEOIR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_eoi_int_id_insert(pl130_gic_ICCEOIR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((pl130_gic_ICCEOIR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_ICCEOIR_cpu_id_extract(pl130_gic_ICCEOIR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCEOIR_cpu_id_extract(pl130_gic_ICCEOIR_t _regval)
{
    return((uint8_t )((_regval & 0x1c00) >> 10));
}

static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_cpu_id_insert(pl130_gic_ICCEOIR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_cpu_id_insert(pl130_gic_ICCEOIR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe3ff) | (0x1c00 & (((pl130_gic_ICCEOIR_t )(_fieldval)) << 10)));
}

static inline int pl130_gic_ICCEOIR_prtval(char *_s, size_t _size, pl130_gic_ICCEOIR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCEOIR_prtval(char *_s, size_t _size, pl130_gic_ICCEOIR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eoi_int_id =\t%" PRIx16 "\t(ACKINTID of ICCIAR access)\n", pl130_gic_ICCEOIR_eoi_int_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_id =\t%" PRIx8 "\t(Proc ID of ICCIAR access)\n", pl130_gic_ICCEOIR_cpu_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCRPR_t
 * Description: Implicit type of Running Priority register
 * Fields:
 *   priority	(size 8, offset 0, init 0):	RO	Highest priority active interrupt
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCRPR_t;
#define pl130_gic_ICCRPR_default 0x0
static inline uint8_t pl130_gic_ICCRPR_priority_extract(pl130_gic_ICCRPR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCRPR_priority_extract(pl130_gic_ICCRPR_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline pl130_gic_ICCRPR_t pl130_gic_ICCRPR_priority_insert(pl130_gic_ICCRPR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCRPR_t pl130_gic_ICCRPR_priority_insert(pl130_gic_ICCRPR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((pl130_gic_ICCRPR_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_ICCRPR_prtval(char *_s, size_t _size, pl130_gic_ICCRPR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCRPR_prtval(char *_s, size_t _size, pl130_gic_ICCRPR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Highest priority active interrupt)\n", pl130_gic_ICCRPR_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCHPIR_t
 * Description: Implicit type of Highest Pending Interrupt register
 * Fields:
 *   pend_int_id	(size 10, offset 0, init 0):	RO	ID of highest pri. pending int.
 *   cpu_id	(size 3, offset 10, init 0):	RO	ID of interrupting processor
 *   _anon13	(size 19, offset 13, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCHPIR_t;
#define pl130_gic_ICCHPIR_default 0x0
static inline uint16_t pl130_gic_ICCHPIR_pend_int_id_extract(pl130_gic_ICCHPIR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCHPIR_pend_int_id_extract(pl130_gic_ICCHPIR_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_pend_int_id_insert(pl130_gic_ICCHPIR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_pend_int_id_insert(pl130_gic_ICCHPIR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((pl130_gic_ICCHPIR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_ICCHPIR_cpu_id_extract(pl130_gic_ICCHPIR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCHPIR_cpu_id_extract(pl130_gic_ICCHPIR_t _regval)
{
    return((uint8_t )((_regval & 0x1c00) >> 10));
}

static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_cpu_id_insert(pl130_gic_ICCHPIR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_cpu_id_insert(pl130_gic_ICCHPIR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe3ff) | (0x1c00 & (((pl130_gic_ICCHPIR_t )(_fieldval)) << 10)));
}

static inline int pl130_gic_ICCHPIR_prtval(char *_s, size_t _size, pl130_gic_ICCHPIR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCHPIR_prtval(char *_s, size_t _size, pl130_gic_ICCHPIR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pend_int_id =\t%" PRIx16 "\t(ID of highest pri. pending int.)\n", pl130_gic_ICCHPIR_pend_int_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_id =\t%" PRIx8 "\t(ID of interrupting processor)\n", pl130_gic_ICCHPIR_cpu_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCABPR_t
 * Description: Implicit type of Aliased Binary Point register
 * Fields:
 *   binary_point	(size 3, offset 0, init 0):	RW	Split Group- and subpriority
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t pl130_gic_ICCABPR_t;
#define pl130_gic_ICCABPR_default 0x0
static inline uint8_t pl130_gic_ICCABPR_binary_point_extract(pl130_gic_ICCABPR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCABPR_binary_point_extract(pl130_gic_ICCABPR_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline pl130_gic_ICCABPR_t pl130_gic_ICCABPR_binary_point_insert(pl130_gic_ICCABPR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCABPR_t pl130_gic_ICCABPR_binary_point_insert(pl130_gic_ICCABPR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((pl130_gic_ICCABPR_t )(_fieldval)) << 0)));
}

static inline int pl130_gic_ICCABPR_prtval(char *_s, size_t _size, pl130_gic_ICCABPR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCABPR_prtval(char *_s, size_t _size, pl130_gic_ICCABPR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " binary_point =\t%" PRIx8 "\t(Split Group- and subpriority)\n", pl130_gic_ICCABPR_binary_point_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pl130_gic_ICCIIDR_t
 * Description: Implicit type of CPU Interface Identification register
 * Fields:
 *   implementer	(size 12, offset 0, init 0):	RO	JEP106 code of the implementer
 *   revision	(size 4, offset 12, init 0):	RO	Revision number for the CPU Interface
 *   arch_version	(size 4, offset 16, init 0):	RO	Implemented GIC architecture version
 *   product_id	(size 12, offset 20, init 0):	RO	Product ID
 */
typedef uint32_t pl130_gic_ICCIIDR_t;
#define pl130_gic_ICCIIDR_default 0x0
static inline uint16_t pl130_gic_ICCIIDR_implementer_extract(pl130_gic_ICCIIDR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCIIDR_implementer_extract(pl130_gic_ICCIIDR_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_implementer_insert(pl130_gic_ICCIIDR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_implementer_insert(pl130_gic_ICCIIDR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((pl130_gic_ICCIIDR_t )(_fieldval)) << 0)));
}

static inline uint8_t pl130_gic_ICCIIDR_revision_extract(pl130_gic_ICCIIDR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCIIDR_revision_extract(pl130_gic_ICCIIDR_t _regval)
{
    return((uint8_t )((_regval & 0xf000) >> 12));
}

static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_revision_insert(pl130_gic_ICCIIDR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_revision_insert(pl130_gic_ICCIIDR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff0fff) | (0xf000 & (((pl130_gic_ICCIIDR_t )(_fieldval)) << 12)));
}

static inline uint8_t pl130_gic_ICCIIDR_arch_version_extract(pl130_gic_ICCIIDR_t _regval) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCIIDR_arch_version_extract(pl130_gic_ICCIIDR_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_arch_version_insert(pl130_gic_ICCIIDR_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_arch_version_insert(pl130_gic_ICCIIDR_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((pl130_gic_ICCIIDR_t )(_fieldval)) << 16)));
}

static inline uint16_t pl130_gic_ICCIIDR_product_id_extract(pl130_gic_ICCIIDR_t _regval) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCIIDR_product_id_extract(pl130_gic_ICCIIDR_t _regval)
{
    return((uint16_t )((_regval & 0xfff00000) >> 20));
}

static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_product_id_insert(pl130_gic_ICCIIDR_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_product_id_insert(pl130_gic_ICCIIDR_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff) | (0xfff00000 & (((pl130_gic_ICCIIDR_t )(_fieldval)) << 20)));
}

static inline int pl130_gic_ICCIIDR_prtval(char *_s, size_t _size, pl130_gic_ICCIIDR_t _regval) __attribute__ ((always_inline));
static inline int pl130_gic_ICCIIDR_prtval(char *_s, size_t _size, pl130_gic_ICCIIDR_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " implementer =\t%" PRIx16 "\t(JEP106 code of the implementer)\n", pl130_gic_ICCIIDR_implementer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " revision =\t%" PRIx8 "\t(Revision number for the CPU Interface)\n", pl130_gic_ICCIIDR_revision_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arch_version =\t%" PRIx8 "\t(Implemented GIC architecture version)\n", pl130_gic_ICCIIDR_arch_version_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " product_id =\t%" PRIx16 "\t(Product ID)\n", pl130_gic_ICCIIDR_product_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t dist_base;
    mackerel_addr_t cpu_base;
    pl130_gic_ICDSGIR_t ICDSGIR_shadow;
    pl130_gic_ICCEOIR_t ICCEOIR_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum pl130_gic_initials {
    pl130_gic_ICDDCR_initial = 0x0,
    pl130_gic_ICDICTR_initial = 0x0,
    pl130_gic_ICDIIDR_initial = 0x0,
    pl130_gic_ICDISR_initial = 0x0,
    pl130_gic_ICDISER_initial = 0x0,
    pl130_gic_ICDICER_initial = 0x0,
    pl130_gic_ICDISPR_initial = 0x0,
    pl130_gic_ICDICPR_initial = 0x0,
    pl130_gic_ICDABR_initial = 0x0,
    pl130_gic_ICDIPR_initial = 0x0,
    pl130_gic_ICDIPTR_initial = 0x0,
    pl130_gic_ICDICR_initial = 0x0,
    pl130_gic_PPI_STATUS_initial = 0x0,
    pl130_gic_SPI_STATUS_initial = 0x0,
    pl130_gic_ICDSGIR_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID0_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID1_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID2_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID3_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID4_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID5_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID6_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID7_initial = 0x0,
    pl130_gic_DIST_PERIPH_ID8_initial = 0x0,
    pl130_gic_DIST_COMPONENT_ID0_initial = 0x0,
    pl130_gic_DIST_COMPONENT_ID1_initial = 0x0,
    pl130_gic_DIST_COMPONENT_ID2_initial = 0x0,
    pl130_gic_DIST_COMPONENT_ID3_initial = 0x0,
    pl130_gic_ICCICR_initial = 0x0,
    pl130_gic_ICCPMR_initial = 0x0,
    pl130_gic_ICCBPR_initial = 0x0,
    pl130_gic_ICCIAR_initial = 0x0,
    pl130_gic_ICCEOIR_initial = 0x0,
    pl130_gic_ICCRPR_initial = 0x0,
    pl130_gic_ICCHPIR_initial = 0x0,
    pl130_gic_ICCABPR_initial = 0x0,
    pl130_gic_ICCIIDR_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void pl130_gic_initialize(__DN(t) *_dev, mackerel_addr_t dist_base, mackerel_addr_t cpu_base) __attribute__ ((always_inline));
static inline void pl130_gic_initialize(__DN(t) *_dev, mackerel_addr_t dist_base, mackerel_addr_t cpu_base)
{
    _dev->dist_base = dist_base;
    _dev->cpu_base = cpu_base;
}

/*
 * Register ICDDCR: Distributor Control
 * Type: pl130_gic.ICDDCR (Implicit type of Distributor Control register)
 *   enable	(size 1, offset 0, init 0):	RW	enable forwarding to CPU interface
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline pl130_gic_ICDDCR_t pl130_gic_ICDDCR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDDCR_t pl130_gic_ICDDCR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x0));
}

static inline pl130_gic_ICDDCR_t pl130_gic_ICDDCR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDDCR_t pl130_gic_ICDDCR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x0));
}

static inline void pl130_gic_ICDDCR_rawwr(__DN(t) *_dev, pl130_gic_ICDDCR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDDCR_rawwr(__DN(t) *_dev, pl130_gic_ICDDCR_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x0, _regval);
}

static inline void pl130_gic_ICDDCR_wr(__DN(t) *_dev, pl130_gic_ICDDCR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDDCR_wr(__DN(t) *_dev, pl130_gic_ICDDCR_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->dist_base, 0x0)));
    mackerel_write_addr_32(_dev->dist_base, 0x0, _regval);
}

static inline int pl130_gic_ICDDCR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDDCR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICDDCR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICDDCR (Distributor Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(enable forwarding to CPU interface)\n", pl130_gic_ICDDCR_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICDDCR_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDDCR_enable_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDDCR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x0);
    return(pl130_gic_ICDDCR_enable_extract(_regval));
}

static inline void pl130_gic_ICDDCR_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDDCR_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICDDCR_t _regval = 0x1 & (((pl130_gic_ICDDCR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->dist_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register ICDICTR: Interrupt Controller Type
 * Type: pl130_gic.ICDICTR (Implicit type of Interrupt Controller Type register)
 *   it_lines_num	(size 5, offset 0, init 0):	RO	max. num. (N) interrupts supported 32(N+1)
 *   cpu_number	(size 3, offset 5, init 0):	RO	number of implemented CPU interfaces
 *   _anon8	(size 2, offset 8, init 0):	RSVD	_
 *   TZ	(size 1, offset 10, init 0):	RO	GIC implements Security Extensions
 *   LSPI	(size 5, offset 11, init 0):	RO	maximum number of lockable SPIs
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x4));
}

static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDICTR_t pl130_gic_ICDICTR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x4));
}

static inline void pl130_gic_ICDICTR_rawwr(__DN(t) *_dev, pl130_gic_ICDICTR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICTR_rawwr(__DN(t) *_dev, pl130_gic_ICDICTR_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x4, _regval);
}

// Register ICDICTR is not writeable
static inline int pl130_gic_ICDICTR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICTR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICDICTR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICDICTR (Interrupt Controller Type): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " it_lines_num =\t%" PRIx8 "\t(max. num. (N) interrupts supported 32(N+1))\n", pl130_gic_ICDICTR_it_lines_num_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_number =\t%" PRIx8 "\t(number of implemented CPU interfaces)\n", pl130_gic_ICDICTR_cpu_number_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TZ =\t%" PRIx8 "\t(GIC implements Security Extensions)\n", pl130_gic_ICDICTR_TZ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LSPI =\t%" PRIx8 "\t(maximum number of lockable SPIs)\n", pl130_gic_ICDICTR_LSPI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICDICTR_it_lines_num_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_it_lines_num_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDICTR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x4);
    return(pl130_gic_ICDICTR_it_lines_num_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICTR_cpu_number_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_cpu_number_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDICTR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x4);
    return(pl130_gic_ICDICTR_cpu_number_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICTR_TZ_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_TZ_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDICTR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x4);
    return(pl130_gic_ICDICTR_TZ_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICTR_LSPI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICTR_LSPI_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDICTR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x4);
    return(pl130_gic_ICDICTR_LSPI_extract(_regval));
}

/*
 * Register ICDIIDR: Distributor Implementer Ident.
 * Type: pl130_gic.ICDIIDR (Implicit type of Distributor Implementer Ident. register)
 *   implementer	(size 12, offset 0, init 0):	RO	JEP106 code of implementing company
 *   rev_num	(size 12, offset 12, init 0):	RO	Revision number
 *   product_id	(size 8, offset 24, init 0):	RO	Product identifier
 */
static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x8));
}

static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDIIDR_t pl130_gic_ICDIIDR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x8));
}

static inline void pl130_gic_ICDIIDR_rawwr(__DN(t) *_dev, pl130_gic_ICDIIDR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIIDR_rawwr(__DN(t) *_dev, pl130_gic_ICDIIDR_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x8, _regval);
}

// Register ICDIIDR is not writeable
static inline int pl130_gic_ICDIIDR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDIIDR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICDIIDR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICDIIDR (Distributor Implementer Ident.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " implementer =\t%" PRIx16 "\t(JEP106 code of implementing company)\n", pl130_gic_ICDIIDR_implementer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev_num =\t%" PRIx16 "\t(Revision number)\n", pl130_gic_ICDIIDR_rev_num_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " product_id =\t%" PRIx8 "\t(Product identifier)\n", pl130_gic_ICDIIDR_product_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t pl130_gic_ICDIIDR_implementer_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICDIIDR_implementer_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDIIDR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x8);
    return(pl130_gic_ICDIIDR_implementer_extract(_regval));
}

static inline uint16_t pl130_gic_ICDIIDR_rev_num_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICDIIDR_rev_num_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDIIDR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x8);
    return(pl130_gic_ICDIIDR_rev_num_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIIDR_product_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIIDR_product_id_rdf(__DN(t) *_dev)
{
    pl130_gic_ICDIIDR_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x8);
    return(pl130_gic_ICDIIDR_product_id_extract(_regval));
}

/*
 * Register array ICDISR: SPI Interrupt Security
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_ICDISR_length = 32;
static inline uint32_t pl130_gic_ICDISR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDISR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x80 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_ICDISR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDISR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x80 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDISR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDISR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x80 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDISR_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDISR_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x80 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDISR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDISR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x80 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDISR", _i, "SPI Interrupt Security");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDISR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDISR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDISR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ICDISER: Interrupt Set-Enable
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_ICDISER_length = 32;
static inline uint32_t pl130_gic_ICDISER_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDISER_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x100 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_ICDISER_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDISER_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x100 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDISER_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDISER_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x100 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDISER_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDISER_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x100 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDISER_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDISER_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x100 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDISER", _i, "Interrupt Set-Enable");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDISER_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDISER_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDISER_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ICDICER: Interrupt Clear-Enable
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_ICDICER_length = 32;
static inline uint32_t pl130_gic_ICDICER_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDICER_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x180 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_ICDICER_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDICER_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x180 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDICER_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICER_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x180 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDICER_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICER_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x180 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDICER_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICER_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x180 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDICER", _i, "Interrupt Clear-Enable");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDICER_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICER_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDICER_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ICDISPR: Interrupt Set-Pending
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_ICDISPR_length = 32;
static inline uint32_t pl130_gic_ICDISPR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDISPR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x200 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_ICDISPR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDISPR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x200 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDISPR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDISPR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x200 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDISPR_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDISPR_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x200 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDISPR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDISPR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x200 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDISPR", _i, "Interrupt Set-Pending");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDISPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDISPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDISPR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ICDICPR: Interrupt Clear-Pending
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_ICDICPR_length = 32;
static inline uint32_t pl130_gic_ICDICPR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDICPR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x280 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_ICDICPR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDICPR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x280 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDICPR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICPR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x280 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDICPR_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICPR_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x280 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDICPR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICPR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x280 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDICPR", _i, "Interrupt Clear-Pending");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDICPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDICPR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ICDABR: Interrupt Active Bit
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_ICDABR_length = 32;
static inline uint32_t pl130_gic_ICDABR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDABR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x300 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_ICDABR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_ICDABR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x300 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDABR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDABR_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x300 + (_i * (32 / 8)), _regval);
}

// Register ICDABR is not writeable
static inline int pl130_gic_ICDABR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDABR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x300 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDABR", _i, "Interrupt Active Bit");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDABR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDABR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDABR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ICDIPR: Priority Level
 * Type: pl130_gic.priority_reg (Interrupt priority register)
 *   prio_off0	(size 8, offset 0, init 0):	RW	Priority, byte offset 0
 *   prio_off1	(size 8, offset 8, init 0):	RW	Priority, byte offset 1
 *   prio_off2	(size 8, offset 16, init 0):	RW	Priority, byte offset 2
 *   prio_off3	(size 8, offset 24, init 0):	RW	Priority, byte offset 3
 */
static const size_t pl130_gic_ICDIPR_length = 31;
static inline pl130_gic_priority_reg_t pl130_gic_ICDIPR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline pl130_gic_priority_reg_t pl130_gic_ICDIPR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8))));
}

static inline pl130_gic_priority_reg_t pl130_gic_ICDIPR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline pl130_gic_priority_reg_t pl130_gic_ICDIPR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDIPR_rawwr(__DN(t) *_dev, int _i, pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPR_rawwr(__DN(t) *_dev, int _i, pl130_gic_priority_reg_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDIPR_wr(__DN(t) *_dev, int _i, pl130_gic_priority_reg_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPR_wr(__DN(t) *_dev, int _i, pl130_gic_priority_reg_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDIPR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDIPR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_priority_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDIPR", _i, "Priority Level");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off0 =\t%" PRIx8 "\t(Priority, byte offset 0)\n", pl130_gic_priority_reg_prio_off0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off1 =\t%" PRIx8 "\t(Priority, byte offset 1)\n", pl130_gic_priority_reg_prio_off1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off2 =\t%" PRIx8 "\t(Priority, byte offset 2)\n", pl130_gic_priority_reg_prio_off2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prio_off3 =\t%" PRIx8 "\t(Priority, byte offset 3)\n", pl130_gic_priority_reg_prio_off3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDIPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDIPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 31; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDIPR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t pl130_gic_ICDIPR_prio_off0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPR_prio_off0_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_priority_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)));
    return(pl130_gic_priority_reg_prio_off0_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIPR_prio_off1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPR_prio_off1_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_priority_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)));
    return(pl130_gic_priority_reg_prio_off1_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIPR_prio_off2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPR_prio_off2_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_priority_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)));
    return(pl130_gic_priority_reg_prio_off2_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIPR_prio_off3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPR_prio_off3_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_priority_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)));
    return(pl130_gic_priority_reg_prio_off3_extract(_regval));
}

static inline void pl130_gic_ICDIPR_prio_off0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPR_prio_off0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_priority_reg_t _regval = 0xff & (((pl130_gic_priority_reg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDIPR_prio_off1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPR_prio_off1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_priority_reg_t _regval = 0xff00 & (((pl130_gic_priority_reg_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDIPR_prio_off2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPR_prio_off2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_priority_reg_t _regval = 0xff0000 & (((pl130_gic_priority_reg_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDIPR_prio_off3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPR_prio_off3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_priority_reg_t _regval = 0xff000000 & (((pl130_gic_priority_reg_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array ICDIPTR: Interrupt Processor Targets
 * Type: pl130_gic.cpu_targets_reg (CPU targets)
 *   targets_off0	(size 8, offset 0, init 0):	RW	CPU targets, byte offset 0
 *   targets_off1	(size 8, offset 8, init 0):	RW	CPU targets, byte offset 1
 *   targets_off2	(size 8, offset 16, init 0):	RW	CPU targets, byte offset 2
 *   targets_off3	(size 8, offset 24, init 0):	RW	CPU targets, byte offset 3
 */
static const size_t pl130_gic_ICDIPTR_length = 31;
static inline pl130_gic_cpu_targets_reg_t pl130_gic_ICDIPTR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline pl130_gic_cpu_targets_reg_t pl130_gic_ICDIPTR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8))));
}

static inline pl130_gic_cpu_targets_reg_t pl130_gic_ICDIPTR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline pl130_gic_cpu_targets_reg_t pl130_gic_ICDIPTR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDIPTR_rawwr(__DN(t) *_dev, int _i, pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPTR_rawwr(__DN(t) *_dev, int _i, pl130_gic_cpu_targets_reg_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDIPTR_wr(__DN(t) *_dev, int _i, pl130_gic_cpu_targets_reg_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPTR_wr(__DN(t) *_dev, int _i, pl130_gic_cpu_targets_reg_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDIPTR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDIPTR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_cpu_targets_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDIPTR", _i, "Interrupt Processor Targets");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off0 =\t%" PRIx8 "\t(CPU targets, byte offset 0)\n", pl130_gic_cpu_targets_reg_targets_off0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off1 =\t%" PRIx8 "\t(CPU targets, byte offset 1)\n", pl130_gic_cpu_targets_reg_targets_off1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off2 =\t%" PRIx8 "\t(CPU targets, byte offset 2)\n", pl130_gic_cpu_targets_reg_targets_off2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " targets_off3 =\t%" PRIx8 "\t(CPU targets, byte offset 3)\n", pl130_gic_cpu_targets_reg_targets_off3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDIPTR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDIPTR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 31; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDIPTR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t pl130_gic_ICDIPTR_targets_off0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPTR_targets_off0_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_cpu_targets_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)));
    return(pl130_gic_cpu_targets_reg_targets_off0_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIPTR_targets_off1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPTR_targets_off1_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_cpu_targets_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)));
    return(pl130_gic_cpu_targets_reg_targets_off1_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIPTR_targets_off2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPTR_targets_off2_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_cpu_targets_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)));
    return(pl130_gic_cpu_targets_reg_targets_off2_extract(_regval));
}

static inline uint8_t pl130_gic_ICDIPTR_targets_off3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDIPTR_targets_off3_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_cpu_targets_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)));
    return(pl130_gic_cpu_targets_reg_targets_off3_extract(_regval));
}

static inline void pl130_gic_ICDIPTR_targets_off0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPTR_targets_off0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_cpu_targets_reg_t _regval = 0xff & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDIPTR_targets_off1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPTR_targets_off1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_cpu_targets_reg_t _regval = 0xff00 & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDIPTR_targets_off2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPTR_targets_off2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_cpu_targets_reg_t _regval = 0xff0000 & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDIPTR_targets_off3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDIPTR_targets_off3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_cpu_targets_reg_t _regval = 0xff000000 & (((pl130_gic_cpu_targets_reg_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0x800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array ICDICR: Interrupt Configuration Reigsters
 * Type: pl130_gic.conf_reg (Configuration registers)
 *   conf0	(size 2, offset 0, init 0):	RW	Configuration 0
 *   conf1	(size 2, offset 2, init 0):	RW	Configuration 1
 *   conf2	(size 2, offset 4, init 0):	RW	Configuration 2
 *   conf3	(size 2, offset 6, init 0):	RW	Configuration 3
 *   conf4	(size 2, offset 8, init 0):	RW	Configuration 4
 *   conf5	(size 2, offset 10, init 0):	RW	Configuration 5
 *   conf6	(size 2, offset 12, init 0):	RW	Configuration 6
 *   conf7	(size 2, offset 14, init 0):	RW	Configuration 7
 *   conf8	(size 2, offset 16, init 0):	RW	Configuration 8
 *   conf9	(size 2, offset 18, init 0):	RW	Configuration 9
 *   conf10	(size 2, offset 20, init 0):	RW	Configuration 10
 *   conf11	(size 2, offset 22, init 0):	RW	Configuration 11
 *   conf12	(size 2, offset 24, init 0):	RW	Configuration 12
 *   conf13	(size 2, offset 26, init 0):	RW	Configuration 13
 *   conf14	(size 2, offset 28, init 0):	RW	Configuration 14
 *   conf15	(size 2, offset 30, init 0):	RW	Configuration 15
 */
static const size_t pl130_gic_ICDICR_length = 16;
static inline pl130_gic_conf_reg_t pl130_gic_ICDICR_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_ICDICR_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8))));
}

static inline pl130_gic_conf_reg_t pl130_gic_ICDICR_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline pl130_gic_conf_reg_t pl130_gic_ICDICR_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8))));
}

static inline void pl130_gic_ICDICR_rawwr(__DN(t) *_dev, int _i, pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_rawwr(__DN(t) *_dev, int _i, pl130_gic_conf_reg_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
}

static inline void pl130_gic_ICDICR_wr(__DN(t) *_dev, int _i, pl130_gic_conf_reg_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_wr(__DN(t) *_dev, int _i, pl130_gic_conf_reg_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
}

static inline int pl130_gic_ICDICR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICR_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ICDICR", _i, "Interrupt Configuration Reigsters");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf0 =\t%" PRIx8 "\t(Configuration 0)\n", pl130_gic_conf_reg_conf0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf1 =\t%" PRIx8 "\t(Configuration 1)\n", pl130_gic_conf_reg_conf1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf2 =\t%" PRIx8 "\t(Configuration 2)\n", pl130_gic_conf_reg_conf2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf3 =\t%" PRIx8 "\t(Configuration 3)\n", pl130_gic_conf_reg_conf3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf4 =\t%" PRIx8 "\t(Configuration 4)\n", pl130_gic_conf_reg_conf4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf5 =\t%" PRIx8 "\t(Configuration 5)\n", pl130_gic_conf_reg_conf5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf6 =\t%" PRIx8 "\t(Configuration 6)\n", pl130_gic_conf_reg_conf6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf7 =\t%" PRIx8 "\t(Configuration 7)\n", pl130_gic_conf_reg_conf7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf8 =\t%" PRIx8 "\t(Configuration 8)\n", pl130_gic_conf_reg_conf8_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf9 =\t%" PRIx8 "\t(Configuration 9)\n", pl130_gic_conf_reg_conf9_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf10 =\t%" PRIx8 "\t(Configuration 10)\n", pl130_gic_conf_reg_conf10_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf11 =\t%" PRIx8 "\t(Configuration 11)\n", pl130_gic_conf_reg_conf11_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf12 =\t%" PRIx8 "\t(Configuration 12)\n", pl130_gic_conf_reg_conf12_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf13 =\t%" PRIx8 "\t(Configuration 13)\n", pl130_gic_conf_reg_conf13_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf14 =\t%" PRIx8 "\t(Configuration 14)\n", pl130_gic_conf_reg_conf14_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " conf15 =\t%" PRIx8 "\t(Configuration 15)\n", pl130_gic_conf_reg_conf15_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_ICDICR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDICR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_ICDICR_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t pl130_gic_ICDICR_conf0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf0_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf0_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf1_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf1_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf2_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf2_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf3_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf3_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf4_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf4_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf4_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf5_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf5_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf5_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf6_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf6_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf6_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf7_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf7_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf7_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf8_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf8_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf8_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf9_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf9_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf9_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf10_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf10_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf10_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf11_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf11_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf11_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf12_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf12_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf12_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf13_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf13_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf13_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf14_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf14_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf14_extract(_regval));
}

static inline uint8_t pl130_gic_ICDICR_conf15_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDICR_conf15_rdf(__DN(t) *_dev, int _i)
{
    pl130_gic_conf_reg_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)));
    return(pl130_gic_conf_reg_conf15_extract(_regval));
}

static inline void pl130_gic_ICDICR_conf0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x3 & (((pl130_gic_conf_reg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc & (((pl130_gic_conf_reg_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x30 & (((pl130_gic_conf_reg_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffcf & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc0 & (((pl130_gic_conf_reg_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffff3f & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf4_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf4_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x300 & (((pl130_gic_conf_reg_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffcff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf5_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf5_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc00 & (((pl130_gic_conf_reg_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffff3ff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf6_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf6_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x3000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffcfff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf7_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf7_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffff3fff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf8_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf8_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x30000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffcffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf9_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf9_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc0000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff3ffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf10_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf10_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x300000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffcfffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf11_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf11_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc00000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 22);
    _regval = (_regval | (0xff3fffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf12_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf12_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x3000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfcffffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf13_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf13_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf3ffffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf14_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf14_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0x30000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 28);
    _regval = (_regval | (0xcfffffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void pl130_gic_ICDICR_conf15_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDICR_conf15_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    pl130_gic_conf_reg_t _regval = 0xc0000000 & (((pl130_gic_conf_reg_t )(_fieldval)) << 30);
    _regval = (_regval | (0x3fffffff & mackerel_read_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register PPI_STATUS: PPI Status
 * Type: pl130_gic.PPI_STATUS (Implicit type of PPI Status register)
 *   ppi_status	(size 16, offset 0, init 0):	RO	Status of PPI0 - PPI15
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline pl130_gic_PPI_STATUS_t pl130_gic_PPI_STATUS_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_PPI_STATUS_t pl130_gic_PPI_STATUS_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xd00));
}

static inline pl130_gic_PPI_STATUS_t pl130_gic_PPI_STATUS_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_PPI_STATUS_t pl130_gic_PPI_STATUS_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xd00));
}

static inline void pl130_gic_PPI_STATUS_rawwr(__DN(t) *_dev, pl130_gic_PPI_STATUS_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_PPI_STATUS_rawwr(__DN(t) *_dev, pl130_gic_PPI_STATUS_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xd00, _regval);
}

// Register PPI_STATUS is not writeable
static inline int pl130_gic_PPI_STATUS_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_PPI_STATUS_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_PPI_STATUS_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xd00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register PPI_STATUS (PPI Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppi_status =\t%" PRIx16 "\t(Status of PPI0 - PPI15)\n", pl130_gic_PPI_STATUS_ppi_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t pl130_gic_PPI_STATUS_ppi_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_PPI_STATUS_ppi_status_rdf(__DN(t) *_dev)
{
    pl130_gic_PPI_STATUS_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xd00);
    return(pl130_gic_PPI_STATUS_ppi_status_extract(_regval));
}

/*
 * Register array SPI_STATUS: SPI Status
 * Type: pl130_gic.uint32 (primitive type)
 */
static const size_t pl130_gic_SPI_STATUS_length = 30;
static inline uint32_t pl130_gic_SPI_STATUS_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_SPI_STATUS_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xd04 + (_i * (32 / 8))));
}

static inline uint32_t pl130_gic_SPI_STATUS_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t pl130_gic_SPI_STATUS_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xd04 + (_i * (32 / 8))));
}

static inline void pl130_gic_SPI_STATUS_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_SPI_STATUS_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xd04 + (_i * (32 / 8)), _regval);
}

// Register SPI_STATUS is not writeable
static inline int pl130_gic_SPI_STATUS_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int pl130_gic_SPI_STATUS_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xd04 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "SPI_STATUS", _i, "SPI Status");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pl130_gic_SPI_STATUS_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_SPI_STATUS_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 30; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = pl130_gic_SPI_STATUS_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register ICDSGIR: Software Generated Interrupt
 * Type: pl130_gic.ICDSGIR (Implicit type of Software Generated Interrupt register)
 *   SGIINTID	(size 4, offset 0, init 0):	WO	SGI Interrupt ID
 *   _anon4	(size 11, offset 4, init 0):	MBZ	_
 *   SATT	(size 1, offset 15, init 0):	WO	Secure Access Bit
 *   cpu_target_list	(size 8, offset 16, init 0):	WO	CPU Target List
 *   target_list_filter	(size 2, offset 24, init 0):	WO	Target List Filter
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xf00));
}

static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICDSGIR_t pl130_gic_ICDSGIR_rd(__DN(t) *_dev)
{
    return(_dev->ICDSGIR_shadow);
}

static inline void pl130_gic_ICDSGIR_rawwr(__DN(t) *_dev, pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDSGIR_rawwr(__DN(t) *_dev, pl130_gic_ICDSGIR_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xf00, _regval);
}

static inline void pl130_gic_ICDSGIR_wr(__DN(t) *_dev, pl130_gic_ICDSGIR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDSGIR_wr(__DN(t) *_dev, pl130_gic_ICDSGIR_t _regval)
{
    _regval = (_regval & 0x3ff800f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->dist_base, 0xf00, _regval);
}

static inline int pl130_gic_ICDSGIR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICDSGIR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICDSGIR_t _regval = _dev->ICDSGIR_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICDSGIR (Software Generated Interrupt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SGIINTID =\t%" PRIx8 "\t(SGI Interrupt ID)\n", pl130_gic_ICDSGIR_SGIINTID_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SATT =\t%" PRIx8 "\t(Secure Access Bit)\n", pl130_gic_ICDSGIR_SATT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_target_list =\t%" PRIx8 "\t(CPU Target List)\n", pl130_gic_ICDSGIR_cpu_target_list_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " target_list_filter =\t%" PRIx8 "\t(Target List Filter)\n", pl130_gic_ICDSGIR_target_list_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICDSGIR_SGIINTID_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_SGIINTID_rd_shadow(__DN(t) *_dev)
{
    return(pl130_gic_ICDSGIR_SGIINTID_extract(_dev->ICDSGIR_shadow));
}

static inline uint8_t pl130_gic_ICDSGIR_SATT_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_SATT_rd_shadow(__DN(t) *_dev)
{
    return(pl130_gic_ICDSGIR_SATT_extract(_dev->ICDSGIR_shadow));
}

static inline uint8_t pl130_gic_ICDSGIR_cpu_target_list_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_cpu_target_list_rd_shadow(__DN(t) *_dev)
{
    return(pl130_gic_ICDSGIR_cpu_target_list_extract(_dev->ICDSGIR_shadow));
}

static inline uint8_t pl130_gic_ICDSGIR_target_list_filter_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICDSGIR_target_list_filter_rd_shadow(__DN(t) *_dev)
{
    return(pl130_gic_ICDSGIR_target_list_filter_extract(_dev->ICDSGIR_shadow));
}

static inline void pl130_gic_ICDSGIR_SGIINTID_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDSGIR_SGIINTID_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICDSGIR_t _regval = 0xf & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 0);
    // No pre-read of register required
    _regval = (_regval | (0x3ff8000 & (_dev->ICDSGIR_shadow)));
    _regval = (_regval & 0x3ff800f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xf00, _regval);
    _dev->ICDSGIR_shadow = _regval;
}

static inline void pl130_gic_ICDSGIR_SATT_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDSGIR_SATT_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICDSGIR_t _regval = 0x8000 & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 15);
    // No pre-read of register required
    _regval = (_regval | (0x3ff000f & (_dev->ICDSGIR_shadow)));
    _regval = (_regval & 0x3ff800f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xf00, _regval);
    _dev->ICDSGIR_shadow = _regval;
}

static inline void pl130_gic_ICDSGIR_cpu_target_list_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDSGIR_cpu_target_list_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICDSGIR_t _regval = 0xff0000 & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 16);
    // No pre-read of register required
    _regval = (_regval | (0x300800f & (_dev->ICDSGIR_shadow)));
    _regval = (_regval & 0x3ff800f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xf00, _regval);
    _dev->ICDSGIR_shadow = _regval;
}

static inline void pl130_gic_ICDSGIR_target_list_filter_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICDSGIR_target_list_filter_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICDSGIR_t _regval = 0x3000000 & (((pl130_gic_ICDSGIR_t )(_fieldval)) << 24);
    // No pre-read of register required
    _regval = (_regval | (0xff800f & (_dev->ICDSGIR_shadow)));
    _regval = (_regval & 0x3ff800f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dist_base, 0xf00, _regval);
    _dev->ICDSGIR_shadow = _regval;
}

/*
 * Register DIST_PERIPH_ID0: Peripheral Ident. 0
 * Type: pl130_gic.DIST_PERIPH_ID0 (Implicit type of Peripheral Ident. 0 register)
 *   part_number_0	(size 8, offset 0, init 0):	RO	Part Number 0
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID0_t pl130_gic_DIST_PERIPH_ID0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID0_t pl130_gic_DIST_PERIPH_ID0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfec));
}

static inline pl130_gic_DIST_PERIPH_ID0_t pl130_gic_DIST_PERIPH_ID0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID0_t pl130_gic_DIST_PERIPH_ID0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfec));
}

static inline void pl130_gic_DIST_PERIPH_ID0_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID0_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID0_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID0_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfec, _regval);
}

// Register DIST_PERIPH_ID0 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID0_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID0 (Peripheral Ident. 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " part_number_0 =\t%" PRIx8 "\t(Part Number 0)\n", pl130_gic_DIST_PERIPH_ID0_part_number_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID0_part_number_0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID0_part_number_0_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID0_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfec);
    return(pl130_gic_DIST_PERIPH_ID0_part_number_0_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID1: Peripheral Ident. 1
 * Type: pl130_gic.DIST_PERIPH_ID1 (Implicit type of Peripheral Ident. 1 register)
 *   part_number_1	(size 4, offset 0, init 0):	RO	Part Number 1
 *   jep106_id_3_0	(size 4, offset 4, init 0):	RO	JEP106 identity code [3:0]
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfe8));
}

static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID1_t pl130_gic_DIST_PERIPH_ID1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfe8));
}

static inline void pl130_gic_DIST_PERIPH_ID1_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID1_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID1_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID1_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfe8, _regval);
}

// Register DIST_PERIPH_ID1 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID1_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID1 (Peripheral Ident. 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " part_number_1 =\t%" PRIx8 "\t(Part Number 1)\n", pl130_gic_DIST_PERIPH_ID1_part_number_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jep106_id_3_0 =\t%" PRIx8 "\t(JEP106 identity code [3:0])\n", pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID1_part_number_1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID1_part_number_1_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID1_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe8);
    return(pl130_gic_DIST_PERIPH_ID1_part_number_1_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID1_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe8);
    return(pl130_gic_DIST_PERIPH_ID1_jep106_id_3_0_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID2: Peripheral Ident. 2
 * Type: pl130_gic.DIST_PERIPH_ID2 (Implicit type of Peripheral Ident. 2 register)
 *   jep106_id_6_4	(size 3, offset 0, init 0):	RO	JEP106 identity code [6:4]
 *   jedec_used	(size 1, offset 3, init 0):	RO	is ID allocated by JEDEC
 *   architecure	(size 4, offset 4, init 0):	RO	Architecture vers. of GIC
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfe4));
}

static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID2_t pl130_gic_DIST_PERIPH_ID2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfe4));
}

static inline void pl130_gic_DIST_PERIPH_ID2_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID2_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID2_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID2_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfe4, _regval);
}

// Register DIST_PERIPH_ID2 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID2_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID2 (Peripheral Ident. 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jep106_id_6_4 =\t%" PRIx8 "\t(JEP106 identity code [6:4])\n", pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jedec_used =\t%" PRIx8 "\t(is ID allocated by JEDEC)\n", pl130_gic_DIST_PERIPH_ID2_jedec_used_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " architecure =\t%" PRIx8 "\t(Architecture vers. of GIC)\n", pl130_gic_DIST_PERIPH_ID2_architecure_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID2_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe4);
    return(pl130_gic_DIST_PERIPH_ID2_jep106_id_6_4_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jedec_used_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_jedec_used_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID2_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe4);
    return(pl130_gic_DIST_PERIPH_ID2_jedec_used_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID2_architecure_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID2_architecure_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID2_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe4);
    return(pl130_gic_DIST_PERIPH_ID2_architecure_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID3: Peripheral Ident. 3
 * Type: pl130_gic.DIST_PERIPH_ID3 (Implicit type of Peripheral Ident. 3 register)
 *   mod_number	(size 4, offset 0, init 0):	RO	Modification Number
 *   rev_and	(size 4, offset 4, init 0):	RO	Revision of AND Gates
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfe0));
}

static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID3_t pl130_gic_DIST_PERIPH_ID3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfe0));
}

static inline void pl130_gic_DIST_PERIPH_ID3_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID3_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID3_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID3_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfe0, _regval);
}

// Register DIST_PERIPH_ID3 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID3_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID3 (Peripheral Ident. 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mod_number =\t%" PRIx8 "\t(Modification Number)\n", pl130_gic_DIST_PERIPH_ID3_mod_number_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev_and =\t%" PRIx8 "\t(Revision of AND Gates)\n", pl130_gic_DIST_PERIPH_ID3_rev_and_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID3_mod_number_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID3_mod_number_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID3_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe0);
    return(pl130_gic_DIST_PERIPH_ID3_mod_number_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID3_rev_and_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID3_rev_and_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID3_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfe0);
    return(pl130_gic_DIST_PERIPH_ID3_rev_and_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID4: Peripheral Ident. 4
 * Type: pl130_gic.DIST_PERIPH_ID4 (Implicit type of Peripheral Ident. 4 register)
 *   jep106_c_code	(size 4, offset 0, init 0):	RO	JEP106 continuation code
 *   page_count	(size 4, offset 4, init 0):	RO	# of 4KB blocks needed
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfdc));
}

static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID4_t pl130_gic_DIST_PERIPH_ID4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfdc));
}

static inline void pl130_gic_DIST_PERIPH_ID4_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID4_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID4_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID4_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfdc, _regval);
}

// Register DIST_PERIPH_ID4 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID4_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfdc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID4 (Peripheral Ident. 4): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jep106_c_code =\t%" PRIx8 "\t(JEP106 continuation code)\n", pl130_gic_DIST_PERIPH_ID4_jep106_c_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " page_count =\t%" PRIx8 "\t(# of 4KB blocks needed)\n", pl130_gic_DIST_PERIPH_ID4_page_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID4_jep106_c_code_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID4_jep106_c_code_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID4_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfdc);
    return(pl130_gic_DIST_PERIPH_ID4_jep106_c_code_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID4_page_count_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID4_page_count_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID4_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfdc);
    return(pl130_gic_DIST_PERIPH_ID4_page_count_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID5: Peripheral Ident. 5
 * Type: pl130_gic.DIST_PERIPH_ID5 (Implicit type of Peripheral Ident. 5 register)
 *   sgi_number	(size 4, offset 0, init 0):	RO	# of SGIs in GIC
 *   ppi_number_0	(size 4, offset 4, init 0):	RO	LSBs of # of PPIs in FIC
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfd8));
}

static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID5_t pl130_gic_DIST_PERIPH_ID5_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfd8));
}

static inline void pl130_gic_DIST_PERIPH_ID5_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID5_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID5_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID5_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfd8, _regval);
}

// Register DIST_PERIPH_ID5 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID5_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID5 (Peripheral Ident. 5): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgi_number =\t%" PRIx8 "\t(# of SGIs in GIC)\n", pl130_gic_DIST_PERIPH_ID5_sgi_number_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppi_number_0 =\t%" PRIx8 "\t(LSBs of # of PPIs in FIC)\n", pl130_gic_DIST_PERIPH_ID5_ppi_number_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID5_sgi_number_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID5_sgi_number_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID5_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd8);
    return(pl130_gic_DIST_PERIPH_ID5_sgi_number_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID5_ppi_number_0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID5_ppi_number_0_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID5_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd8);
    return(pl130_gic_DIST_PERIPH_ID5_ppi_number_0_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID6: Peripheral Ident. 6
 * Type: pl130_gic.DIST_PERIPH_ID6 (Implicit type of Peripheral Ident. 6 register)
 *   ppi_number_1	(size 4, offset 0, init 0):	RO	MSBs of #PPIs GIC provides
 *   spi_number_0	(size 4, offset 4, init 0):	RO	LSBs of #SPIs GIC provides
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfd4));
}

static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID6_t pl130_gic_DIST_PERIPH_ID6_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfd4));
}

static inline void pl130_gic_DIST_PERIPH_ID6_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID6_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID6_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID6_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfd4, _regval);
}

// Register DIST_PERIPH_ID6 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID6_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID6_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID6_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID6 (Peripheral Ident. 6): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppi_number_1 =\t%" PRIx8 "\t(MSBs of #PPIs GIC provides)\n", pl130_gic_DIST_PERIPH_ID6_ppi_number_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spi_number_0 =\t%" PRIx8 "\t(LSBs of #SPIs GIC provides)\n", pl130_gic_DIST_PERIPH_ID6_spi_number_0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID6_ppi_number_1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID6_ppi_number_1_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID6_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd4);
    return(pl130_gic_DIST_PERIPH_ID6_ppi_number_1_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID6_spi_number_0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID6_spi_number_0_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID6_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd4);
    return(pl130_gic_DIST_PERIPH_ID6_spi_number_0_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID7: Peripheral Ident. 7
 * Type: pl130_gic.DIST_PERIPH_ID7 (Implicit type of Peripheral Ident. 7 register)
 *   spi_number_1	(size 4, offset 0, init 0):	RO	MSBs of # SPIs GIC provides
 *   priority	(size 3, offset 4, init 0):	RO	# priority lvls GIC provides
 *   tz	(size 1, offset 7, init 0):	RO	# secure states
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfd0));
}

static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID7_t pl130_gic_DIST_PERIPH_ID7_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfd0));
}

static inline void pl130_gic_DIST_PERIPH_ID7_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID7_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID7_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID7_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfd0, _regval);
}

// Register DIST_PERIPH_ID7 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID7_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID7_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID7_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID7 (Peripheral Ident. 7): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spi_number_1 =\t%" PRIx8 "\t(MSBs of # SPIs GIC provides)\n", pl130_gic_DIST_PERIPH_ID7_spi_number_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(# priority lvls GIC provides)\n", pl130_gic_DIST_PERIPH_ID7_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tz =\t%" PRIx8 "\t(# secure states)\n", pl130_gic_DIST_PERIPH_ID7_tz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID7_spi_number_1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_spi_number_1_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID7_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd0);
    return(pl130_gic_DIST_PERIPH_ID7_spi_number_1_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID7_priority_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_priority_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID7_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd0);
    return(pl130_gic_DIST_PERIPH_ID7_priority_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID7_tz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID7_tz_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID7_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfd0);
    return(pl130_gic_DIST_PERIPH_ID7_tz_extract(_regval));
}

/*
 * Register DIST_PERIPH_ID8: Peripheral Ident. 8
 * Type: pl130_gic.DIST_PERIPH_ID8 (Implicit type of Peripheral Ident. 8 register)
 *   irq_legacy	(size 1, offset 0, init 0):	RO	Legacy IRQ signals supported
 *   fiq_legacy	(size 1, offset 1, init 0):	RO	Legacy FIQ signals supported
 *   cpu_if	(size 3, offset 2, init 0):	RO	# of CPU interfaces
 *   if_type	(size 2, offset 5, init 0):	RO	AMBA protocoll
 *   identifier	(size 1, offset 7, init 0):	RO	AMBA interface ID
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfc0));
}

static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_PERIPH_ID8_t pl130_gic_DIST_PERIPH_ID8_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xfc0));
}

static inline void pl130_gic_DIST_PERIPH_ID8_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID8_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_PERIPH_ID8_rawwr(__DN(t) *_dev, pl130_gic_DIST_PERIPH_ID8_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xfc0, _regval);
}

// Register DIST_PERIPH_ID8 is not writeable
static inline int pl130_gic_DIST_PERIPH_ID8_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_PERIPH_ID8_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_PERIPH_ID8_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfc0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_PERIPH_ID8 (Peripheral Ident. 8): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irq_legacy =\t%" PRIx8 "\t(Legacy IRQ signals supported)\n", pl130_gic_DIST_PERIPH_ID8_irq_legacy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fiq_legacy =\t%" PRIx8 "\t(Legacy FIQ signals supported)\n", pl130_gic_DIST_PERIPH_ID8_fiq_legacy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_if =\t%" PRIx8 "\t(# of CPU interfaces)\n", pl130_gic_DIST_PERIPH_ID8_cpu_if_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " if_type =\t%" PRIx8 "\t(AMBA protocoll)\n", pl130_gic_DIST_PERIPH_ID8_if_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " identifier =\t%" PRIx8 "\t(AMBA interface ID)\n", pl130_gic_DIST_PERIPH_ID8_identifier_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_irq_legacy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_irq_legacy_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID8_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfc0);
    return(pl130_gic_DIST_PERIPH_ID8_irq_legacy_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_fiq_legacy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_fiq_legacy_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID8_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfc0);
    return(pl130_gic_DIST_PERIPH_ID8_fiq_legacy_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_cpu_if_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_cpu_if_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID8_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfc0);
    return(pl130_gic_DIST_PERIPH_ID8_cpu_if_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_if_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_if_type_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID8_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfc0);
    return(pl130_gic_DIST_PERIPH_ID8_if_type_extract(_regval));
}

static inline uint8_t pl130_gic_DIST_PERIPH_ID8_identifier_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_PERIPH_ID8_identifier_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_PERIPH_ID8_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xfc0);
    return(pl130_gic_DIST_PERIPH_ID8_identifier_extract(_regval));
}

/*
 * Register DIST_COMPONENT_ID0: PrimeCell Ident. 0
 * Type: pl130_gic.DIST_COMPONENT_ID0 (Implicit type of PrimeCell Ident. 0 register)
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_COMPONENT_ID0_t pl130_gic_DIST_COMPONENT_ID0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID0_t pl130_gic_DIST_COMPONENT_ID0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xffc));
}

static inline pl130_gic_DIST_COMPONENT_ID0_t pl130_gic_DIST_COMPONENT_ID0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID0_t pl130_gic_DIST_COMPONENT_ID0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xffc));
}

static inline void pl130_gic_DIST_COMPONENT_ID0_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID0_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_COMPONENT_ID0_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID0_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xffc, _regval);
}

// Register DIST_COMPONENT_ID0 is not writeable
static inline int pl130_gic_DIST_COMPONENT_ID0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_COMPONENT_ID0_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xffc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_COMPONENT_ID0 (PrimeCell Ident. 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID0_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_COMPONENT_ID0_component_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID0_component_id_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_COMPONENT_ID0_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xffc);
    return(pl130_gic_DIST_COMPONENT_ID0_component_id_extract(_regval));
}

/*
 * Register DIST_COMPONENT_ID1: PrimeCell Ident. 1
 * Type: pl130_gic.DIST_COMPONENT_ID1 (Implicit type of PrimeCell Ident. 1 register)
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_COMPONENT_ID1_t pl130_gic_DIST_COMPONENT_ID1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID1_t pl130_gic_DIST_COMPONENT_ID1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xff8));
}

static inline pl130_gic_DIST_COMPONENT_ID1_t pl130_gic_DIST_COMPONENT_ID1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID1_t pl130_gic_DIST_COMPONENT_ID1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xff8));
}

static inline void pl130_gic_DIST_COMPONENT_ID1_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID1_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_COMPONENT_ID1_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID1_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xff8, _regval);
}

// Register DIST_COMPONENT_ID1 is not writeable
static inline int pl130_gic_DIST_COMPONENT_ID1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_COMPONENT_ID1_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xff8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_COMPONENT_ID1 (PrimeCell Ident. 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID1_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_COMPONENT_ID1_component_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID1_component_id_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_COMPONENT_ID1_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xff8);
    return(pl130_gic_DIST_COMPONENT_ID1_component_id_extract(_regval));
}

/*
 * Register DIST_COMPONENT_ID2: PrimeCell Ident. 2
 * Type: pl130_gic.DIST_COMPONENT_ID2 (Implicit type of PrimeCell Ident. 2 register)
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_COMPONENT_ID2_t pl130_gic_DIST_COMPONENT_ID2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID2_t pl130_gic_DIST_COMPONENT_ID2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xff4));
}

static inline pl130_gic_DIST_COMPONENT_ID2_t pl130_gic_DIST_COMPONENT_ID2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID2_t pl130_gic_DIST_COMPONENT_ID2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xff4));
}

static inline void pl130_gic_DIST_COMPONENT_ID2_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID2_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_COMPONENT_ID2_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID2_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xff4, _regval);
}

// Register DIST_COMPONENT_ID2 is not writeable
static inline int pl130_gic_DIST_COMPONENT_ID2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_COMPONENT_ID2_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xff4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_COMPONENT_ID2 (PrimeCell Ident. 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID2_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_COMPONENT_ID2_component_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID2_component_id_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_COMPONENT_ID2_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xff4);
    return(pl130_gic_DIST_COMPONENT_ID2_component_id_extract(_regval));
}

/*
 * Register DIST_COMPONENT_ID3: PrimeCell Ident. 3
 * Type: pl130_gic.DIST_COMPONENT_ID3 (Implicit type of PrimeCell Ident. 3 register)
 *   component_id	(size 8, offset 0, init 0):	RO	component_id
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_DIST_COMPONENT_ID3_t pl130_gic_DIST_COMPONENT_ID3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID3_t pl130_gic_DIST_COMPONENT_ID3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xff0));
}

static inline pl130_gic_DIST_COMPONENT_ID3_t pl130_gic_DIST_COMPONENT_ID3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_DIST_COMPONENT_ID3_t pl130_gic_DIST_COMPONENT_ID3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dist_base, 0xff0));
}

static inline void pl130_gic_DIST_COMPONENT_ID3_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID3_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_DIST_COMPONENT_ID3_rawwr(__DN(t) *_dev, pl130_gic_DIST_COMPONENT_ID3_t _regval)
{
    mackerel_write_addr_32(_dev->dist_base, 0xff0, _regval);
}

// Register DIST_COMPONENT_ID3 is not writeable
static inline int pl130_gic_DIST_COMPONENT_ID3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_DIST_COMPONENT_ID3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_DIST_COMPONENT_ID3_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xff0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register DIST_COMPONENT_ID3 (PrimeCell Ident. 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " component_id =\t%" PRIx8 "\t(component_id)\n", pl130_gic_DIST_COMPONENT_ID3_component_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_DIST_COMPONENT_ID3_component_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_DIST_COMPONENT_ID3_component_id_rdf(__DN(t) *_dev)
{
    pl130_gic_DIST_COMPONENT_ID3_t _regval = mackerel_read_addr_32(_dev->dist_base, 0xff0);
    return(pl130_gic_DIST_COMPONENT_ID3_component_id_extract(_regval));
}

/*
 * Register ICCICR: CPU Interface Control
 * Type: pl130_gic.ICCICR (Implicit type of CPU Interface Control register)
 *   enable	(size 1, offset 0, init 0):	RW	en. fwding to connected processors
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline pl130_gic_ICCICR_t pl130_gic_ICCICR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCICR_t pl130_gic_ICCICR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x0));
}

static inline pl130_gic_ICCICR_t pl130_gic_ICCICR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCICR_t pl130_gic_ICCICR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x0));
}

static inline void pl130_gic_ICCICR_rawwr(__DN(t) *_dev, pl130_gic_ICCICR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCICR_rawwr(__DN(t) *_dev, pl130_gic_ICCICR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x0, _regval);
}

static inline void pl130_gic_ICCICR_wr(__DN(t) *_dev, pl130_gic_ICCICR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCICR_wr(__DN(t) *_dev, pl130_gic_ICCICR_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->cpu_base, 0x0)));
    mackerel_write_addr_32(_dev->cpu_base, 0x0, _regval);
}

static inline int pl130_gic_ICCICR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCICR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCICR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCICR (CPU Interface Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(en. fwding to connected processors)\n", pl130_gic_ICCICR_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICCICR_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCICR_enable_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCICR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x0);
    return(pl130_gic_ICCICR_enable_extract(_regval));
}

static inline void pl130_gic_ICCICR_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCICR_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICCICR_t _regval = 0x1 & (((pl130_gic_ICCICR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->cpu_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->cpu_base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register ICCPMR: Interrupt Priority Mask
 * Type: pl130_gic.ICCPMR (Implicit type of Interrupt Priority Mask register)
 *   priority	(size 8, offset 0, init 0):	RW	Priority mask level for CPU Interface
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_ICCPMR_t pl130_gic_ICCPMR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCPMR_t pl130_gic_ICCPMR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x4));
}

static inline pl130_gic_ICCPMR_t pl130_gic_ICCPMR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCPMR_t pl130_gic_ICCPMR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x4));
}

static inline void pl130_gic_ICCPMR_rawwr(__DN(t) *_dev, pl130_gic_ICCPMR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCPMR_rawwr(__DN(t) *_dev, pl130_gic_ICCPMR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x4, _regval);
}

static inline void pl130_gic_ICCPMR_wr(__DN(t) *_dev, pl130_gic_ICCPMR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCPMR_wr(__DN(t) *_dev, pl130_gic_ICCPMR_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->cpu_base, 0x4)));
    mackerel_write_addr_32(_dev->cpu_base, 0x4, _regval);
}

static inline int pl130_gic_ICCPMR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCPMR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCPMR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCPMR (Interrupt Priority Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority mask level for CPU Interface)\n", pl130_gic_ICCPMR_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICCPMR_priority_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCPMR_priority_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCPMR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x4);
    return(pl130_gic_ICCPMR_priority_extract(_regval));
}

static inline void pl130_gic_ICCPMR_priority_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCPMR_priority_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICCPMR_t _regval = 0xff & (((pl130_gic_ICCPMR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->cpu_base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->cpu_base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register ICCBPR: Binary Point
 * Type: pl130_gic.ICCBPR (Implicit type of Binary Point register)
 *   binary_point	(size 3, offset 0, init 0):	RW	Split Group- and subpriority
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline pl130_gic_ICCBPR_t pl130_gic_ICCBPR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCBPR_t pl130_gic_ICCBPR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x8));
}

static inline pl130_gic_ICCBPR_t pl130_gic_ICCBPR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCBPR_t pl130_gic_ICCBPR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x8));
}

static inline void pl130_gic_ICCBPR_rawwr(__DN(t) *_dev, pl130_gic_ICCBPR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCBPR_rawwr(__DN(t) *_dev, pl130_gic_ICCBPR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x8, _regval);
}

static inline void pl130_gic_ICCBPR_wr(__DN(t) *_dev, pl130_gic_ICCBPR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCBPR_wr(__DN(t) *_dev, pl130_gic_ICCBPR_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->cpu_base, 0x8)));
    mackerel_write_addr_32(_dev->cpu_base, 0x8, _regval);
}

static inline int pl130_gic_ICCBPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCBPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCBPR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCBPR (Binary Point): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " binary_point =\t%" PRIx8 "\t(Split Group- and subpriority)\n", pl130_gic_ICCBPR_binary_point_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICCBPR_binary_point_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCBPR_binary_point_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCBPR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x8);
    return(pl130_gic_ICCBPR_binary_point_extract(_regval));
}

static inline void pl130_gic_ICCBPR_binary_point_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCBPR_binary_point_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICCBPR_t _regval = 0x7 & (((pl130_gic_ICCBPR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->cpu_base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->cpu_base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register ICCIAR: Interrupt Acknowledge
 * Type: pl130_gic.ICCIAR (Implicit type of Interrupt Acknowledge register)
 *   ack_int_id	(size 10, offset 0, init 0):	RO	Interrupt ID
 *   cpu_id	(size 3, offset 10, init 0):	RO	Processor ID of interrupting processor
 *   _anon13	(size 19, offset 13, init 0):	RSVD	_
 */
static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0xc));
}

static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCIAR_t pl130_gic_ICCIAR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0xc));
}

static inline void pl130_gic_ICCIAR_rawwr(__DN(t) *_dev, pl130_gic_ICCIAR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCIAR_rawwr(__DN(t) *_dev, pl130_gic_ICCIAR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0xc, _regval);
}

// Register ICCIAR is not writeable
static inline int pl130_gic_ICCIAR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCIAR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCIAR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCIAR (Interrupt Acknowledge): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack_int_id =\t%" PRIx16 "\t(Interrupt ID)\n", pl130_gic_ICCIAR_ack_int_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_id =\t%" PRIx8 "\t(Processor ID of interrupting processor)\n", pl130_gic_ICCIAR_cpu_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline uint16_t pl130_gic_ICCIAR_ack_int_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCIAR_ack_int_id_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCIAR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xc);
    return(pl130_gic_ICCIAR_ack_int_id_extract(_regval));
}

static inline uint8_t pl130_gic_ICCIAR_cpu_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCIAR_cpu_id_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCIAR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xc);
    return(pl130_gic_ICCIAR_cpu_id_extract(_regval));
}

/*
 * Register ICCEOIR: End of Interrupt
 * Type: pl130_gic.ICCEOIR (Implicit type of End of Interrupt register)
 *   eoi_int_id	(size 10, offset 0, init 0):	WO	ACKINTID of ICCIAR access
 *   cpu_id	(size 3, offset 10, init 0):	WO	Proc ID of ICCIAR access
 *   _anon13	(size 19, offset 13, init 0):	MBZ	_
 */
static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x10));
}

static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCEOIR_t pl130_gic_ICCEOIR_rd(__DN(t) *_dev)
{
    return(_dev->ICCEOIR_shadow);
}

static inline void pl130_gic_ICCEOIR_rawwr(__DN(t) *_dev, pl130_gic_ICCEOIR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCEOIR_rawwr(__DN(t) *_dev, pl130_gic_ICCEOIR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x10, _regval);
}

static inline void pl130_gic_ICCEOIR_wr(__DN(t) *_dev, pl130_gic_ICCEOIR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCEOIR_wr(__DN(t) *_dev, pl130_gic_ICCEOIR_t _regval)
{
    _regval = (_regval & 0x1fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->cpu_base, 0x10, _regval);
}

static inline int pl130_gic_ICCEOIR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCEOIR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCEOIR_t _regval = _dev->ICCEOIR_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCEOIR (End of Interrupt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eoi_int_id =\t%" PRIx16 "\t(ACKINTID of ICCIAR access)\n", pl130_gic_ICCEOIR_eoi_int_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_id =\t%" PRIx8 "\t(Proc ID of ICCIAR access)\n", pl130_gic_ICCEOIR_cpu_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline uint16_t pl130_gic_ICCEOIR_eoi_int_id_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCEOIR_eoi_int_id_rd_shadow(__DN(t) *_dev)
{
    return(pl130_gic_ICCEOIR_eoi_int_id_extract(_dev->ICCEOIR_shadow));
}

static inline uint8_t pl130_gic_ICCEOIR_cpu_id_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCEOIR_cpu_id_rd_shadow(__DN(t) *_dev)
{
    return(pl130_gic_ICCEOIR_cpu_id_extract(_dev->ICCEOIR_shadow));
}

static inline void pl130_gic_ICCEOIR_eoi_int_id_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCEOIR_eoi_int_id_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    pl130_gic_ICCEOIR_t _regval = 0x3ff & (((pl130_gic_ICCEOIR_t )(_fieldval)) << 0);
    // No pre-read of register required
    _regval = (_regval | (0x1c00 & (_dev->ICCEOIR_shadow)));
    _regval = (_regval & 0x1fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->cpu_base, 0x10, _regval);
    _dev->ICCEOIR_shadow = _regval;
}

static inline void pl130_gic_ICCEOIR_cpu_id_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCEOIR_cpu_id_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICCEOIR_t _regval = 0x1c00 & (((pl130_gic_ICCEOIR_t )(_fieldval)) << 10);
    // No pre-read of register required
    _regval = (_regval | (0x3ff & (_dev->ICCEOIR_shadow)));
    _regval = (_regval & 0x1fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->cpu_base, 0x10, _regval);
    _dev->ICCEOIR_shadow = _regval;
}

/*
 * Register ICCRPR: Running Priority
 * Type: pl130_gic.ICCRPR (Implicit type of Running Priority register)
 *   priority	(size 8, offset 0, init 0):	RO	Highest priority active interrupt
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline pl130_gic_ICCRPR_t pl130_gic_ICCRPR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCRPR_t pl130_gic_ICCRPR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x14));
}

static inline pl130_gic_ICCRPR_t pl130_gic_ICCRPR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCRPR_t pl130_gic_ICCRPR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x14));
}

static inline void pl130_gic_ICCRPR_rawwr(__DN(t) *_dev, pl130_gic_ICCRPR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCRPR_rawwr(__DN(t) *_dev, pl130_gic_ICCRPR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x14, _regval);
}

// Register ICCRPR is not writeable
static inline int pl130_gic_ICCRPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCRPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCRPR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCRPR (Running Priority): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Highest priority active interrupt)\n", pl130_gic_ICCRPR_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICCRPR_priority_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCRPR_priority_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCRPR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x14);
    return(pl130_gic_ICCRPR_priority_extract(_regval));
}

/*
 * Register ICCHPIR: Highest Pending Interrupt
 * Type: pl130_gic.ICCHPIR (Implicit type of Highest Pending Interrupt register)
 *   pend_int_id	(size 10, offset 0, init 0):	RO	ID of highest pri. pending int.
 *   cpu_id	(size 3, offset 10, init 0):	RO	ID of interrupting processor
 *   _anon13	(size 19, offset 13, init 0):	RSVD	_
 */
static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x18));
}

static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCHPIR_t pl130_gic_ICCHPIR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x18));
}

static inline void pl130_gic_ICCHPIR_rawwr(__DN(t) *_dev, pl130_gic_ICCHPIR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCHPIR_rawwr(__DN(t) *_dev, pl130_gic_ICCHPIR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x18, _regval);
}

// Register ICCHPIR is not writeable
static inline int pl130_gic_ICCHPIR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCHPIR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCHPIR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCHPIR (Highest Pending Interrupt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pend_int_id =\t%" PRIx16 "\t(ID of highest pri. pending int.)\n", pl130_gic_ICCHPIR_pend_int_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_id =\t%" PRIx8 "\t(ID of interrupting processor)\n", pl130_gic_ICCHPIR_cpu_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline uint16_t pl130_gic_ICCHPIR_pend_int_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCHPIR_pend_int_id_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCHPIR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x18);
    return(pl130_gic_ICCHPIR_pend_int_id_extract(_regval));
}

static inline uint8_t pl130_gic_ICCHPIR_cpu_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCHPIR_cpu_id_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCHPIR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x18);
    return(pl130_gic_ICCHPIR_cpu_id_extract(_regval));
}

/*
 * Register ICCABPR: Aliased Binary Point
 * Type: pl130_gic.ICCABPR (Implicit type of Aliased Binary Point register)
 *   binary_point	(size 3, offset 0, init 0):	RW	Split Group- and subpriority
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline pl130_gic_ICCABPR_t pl130_gic_ICCABPR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCABPR_t pl130_gic_ICCABPR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x1c));
}

static inline pl130_gic_ICCABPR_t pl130_gic_ICCABPR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCABPR_t pl130_gic_ICCABPR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0x1c));
}

static inline void pl130_gic_ICCABPR_rawwr(__DN(t) *_dev, pl130_gic_ICCABPR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCABPR_rawwr(__DN(t) *_dev, pl130_gic_ICCABPR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0x1c, _regval);
}

static inline void pl130_gic_ICCABPR_wr(__DN(t) *_dev, pl130_gic_ICCABPR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCABPR_wr(__DN(t) *_dev, pl130_gic_ICCABPR_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->cpu_base, 0x1c)));
    mackerel_write_addr_32(_dev->cpu_base, 0x1c, _regval);
}

static inline int pl130_gic_ICCABPR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCABPR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCABPR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCABPR (Aliased Binary Point): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " binary_point =\t%" PRIx8 "\t(Split Group- and subpriority)\n", pl130_gic_ICCABPR_binary_point_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t pl130_gic_ICCABPR_binary_point_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCABPR_binary_point_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCABPR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0x1c);
    return(pl130_gic_ICCABPR_binary_point_extract(_regval));
}

static inline void pl130_gic_ICCABPR_binary_point_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCABPR_binary_point_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pl130_gic_ICCABPR_t _regval = 0x7 & (((pl130_gic_ICCABPR_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->cpu_base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->cpu_base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register ICCIIDR: CPU Interface Identification
 * Type: pl130_gic.ICCIIDR (Implicit type of CPU Interface Identification register)
 *   implementer	(size 12, offset 0, init 0):	RO	JEP106 code of the implementer
 *   revision	(size 4, offset 12, init 0):	RO	Revision number for the CPU Interface
 *   arch_version	(size 4, offset 16, init 0):	RO	Implemented GIC architecture version
 *   product_id	(size 12, offset 20, init 0):	RO	Product ID
 */
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0xfc));
}

static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pl130_gic_ICCIIDR_t pl130_gic_ICCIIDR_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cpu_base, 0xfc));
}

static inline void pl130_gic_ICCIIDR_rawwr(__DN(t) *_dev, pl130_gic_ICCIIDR_t _regval) __attribute__ ((always_inline));
static inline void pl130_gic_ICCIIDR_rawwr(__DN(t) *_dev, pl130_gic_ICCIIDR_t _regval)
{
    mackerel_write_addr_32(_dev->cpu_base, 0xfc, _regval);
}

// Register ICCIIDR is not writeable
static inline int pl130_gic_ICCIIDR_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_ICCIIDR_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pl130_gic_ICCIIDR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xfc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ICCIIDR (CPU Interface Identification): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " implementer =\t%" PRIx16 "\t(JEP106 code of the implementer)\n", pl130_gic_ICCIIDR_implementer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " revision =\t%" PRIx8 "\t(Revision number for the CPU Interface)\n", pl130_gic_ICCIIDR_revision_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arch_version =\t%" PRIx8 "\t(Implemented GIC architecture version)\n", pl130_gic_ICCIIDR_arch_version_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " product_id =\t%" PRIx16 "\t(Product ID)\n", pl130_gic_ICCIIDR_product_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t pl130_gic_ICCIIDR_implementer_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCIIDR_implementer_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCIIDR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xfc);
    return(pl130_gic_ICCIIDR_implementer_extract(_regval));
}

static inline uint8_t pl130_gic_ICCIIDR_revision_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCIIDR_revision_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCIIDR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xfc);
    return(pl130_gic_ICCIIDR_revision_extract(_regval));
}

static inline uint8_t pl130_gic_ICCIIDR_arch_version_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pl130_gic_ICCIIDR_arch_version_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCIIDR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xfc);
    return(pl130_gic_ICCIIDR_arch_version_extract(_regval));
}

static inline uint16_t pl130_gic_ICCIIDR_product_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pl130_gic_ICCIIDR_product_id_rdf(__DN(t) *_dev)
{
    pl130_gic_ICCIIDR_t _regval = mackerel_read_addr_32(_dev->cpu_base, 0xfc);
    return(pl130_gic_ICCIIDR_product_id_extract(_regval));
}

static inline int pl130_gic_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pl130_gic_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device pl130_gic (PrimeCell PL130 Generic Interrupt Controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDDCR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDICTR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDIIDR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDISR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDISER_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDICER_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDISPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDICPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDABR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDIPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDIPTR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDICR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_PPI_STATUS_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_SPI_STATUS_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICDSGIR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID6_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID7_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_PERIPH_ID8_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_COMPONENT_ID0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_COMPONENT_ID1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_COMPONENT_ID2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_DIST_COMPONENT_ID3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCICR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCPMR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCBPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCIAR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCEOIR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCRPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCHPIR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCABPR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pl130_gic_ICCIIDR_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device pl130_gic\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __pl130_gic_DEV_H
