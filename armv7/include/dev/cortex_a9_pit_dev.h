#ifndef __cortex_a9_pit_DEV_H
#define __cortex_a9_pit_DEV_H 1
/*
 * DEVICE DEFINITION: Cortex A9 Private Timer and watchdog
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) cortex_a9_pit ## _ ## x
/*
 * Register type: cortex_a9_pit_TimerControl_t
 * Description: Implicit type of Private Timer Control Register register
 * Fields:
 *   timer_enable	(size 1, offset 0, init 0):	RW	Timer enable bit
 *   auto_reload	(size 1, offset 1, init 0):	RW	Single shot or reload mode
 *   int_enable	(size 1, offset 2, init 0):	RW	Interrupt enable bit
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   prescale	(size 8, offset 8, init 0):	RW	Prescale factor
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t cortex_a9_pit_TimerControl_t;
#define cortex_a9_pit_TimerControl_default 0x0
static inline uint8_t cortex_a9_pit_TimerControl_timer_enable_extract(cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_timer_enable_extract(cortex_a9_pit_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_timer_enable_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_timer_enable_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 0)));
}

static inline uint8_t cortex_a9_pit_TimerControl_auto_reload_extract(cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_auto_reload_extract(cortex_a9_pit_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_auto_reload_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_auto_reload_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 1)));
}

static inline uint8_t cortex_a9_pit_TimerControl_int_enable_extract(cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_int_enable_extract(cortex_a9_pit_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_int_enable_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_int_enable_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 2)));
}

static inline uint8_t cortex_a9_pit_TimerControl_prescale_extract(cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_prescale_extract(cortex_a9_pit_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_prescale_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_prescale_insert(cortex_a9_pit_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 8)));
}

static inline int cortex_a9_pit_TimerControl_prtval(char *_s, size_t _size, cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_pit_TimerControl_prtval(char *_s, size_t _size, cortex_a9_pit_TimerControl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timer_enable =\t%" PRIx8 "\t(Timer enable bit)\n", cortex_a9_pit_TimerControl_timer_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_reload =\t%" PRIx8 "\t(Single shot or reload mode)\n", cortex_a9_pit_TimerControl_auto_reload_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_enable =\t%" PRIx8 "\t(Interrupt enable bit)\n", cortex_a9_pit_TimerControl_int_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescale =\t%" PRIx8 "\t(Prescale factor)\n", cortex_a9_pit_TimerControl_prescale_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_pit_TimerIntStat_t
 * Description: Implicit type of Private Timer Interrupt Status Register register
 * Fields:
 *   event_flag	(size 1, offset 0, init 0):	RWC	event_flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t cortex_a9_pit_TimerIntStat_t;
#define cortex_a9_pit_TimerIntStat_default 0x0
static inline uint8_t cortex_a9_pit_TimerIntStat_event_flag_extract(cortex_a9_pit_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerIntStat_event_flag_extract(cortex_a9_pit_TimerIntStat_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_pit_TimerIntStat_t cortex_a9_pit_TimerIntStat_event_flag_insert(cortex_a9_pit_TimerIntStat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerIntStat_t cortex_a9_pit_TimerIntStat_event_flag_insert(cortex_a9_pit_TimerIntStat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_pit_TimerIntStat_t )(_fieldval)) << 0)));
}

static inline int cortex_a9_pit_TimerIntStat_prtval(char *_s, size_t _size, cortex_a9_pit_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_pit_TimerIntStat_prtval(char *_s, size_t _size, cortex_a9_pit_TimerIntStat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_flag =\t%" PRIx8 "\t(event_flag)\n", cortex_a9_pit_TimerIntStat_event_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_pit_WatchdogControl_t
 * Description: Implicit type of Watchdog Control Register register
 * Fields:
 *   wd_enable	(size 1, offset 0, init 0):	RW	Timer enable bit
 *   auto_reload	(size 1, offset 1, init 0):	RW	Single shot or reload mode
 *   int_enable	(size 1, offset 2, init 0):	RW	Interrupt enable bit
 *   wd_mode	(size 1, offset 3, init 0):	RW	Selects Watchdog or Timer mode
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   prescale	(size 8, offset 8, init 0):	RW	Prescale factor
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t cortex_a9_pit_WatchdogControl_t;
#define cortex_a9_pit_WatchdogControl_default 0x0
static inline uint8_t cortex_a9_pit_WatchdogControl_wd_enable_extract(cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_wd_enable_extract(cortex_a9_pit_WatchdogControl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_wd_enable_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_wd_enable_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 0)));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_auto_reload_extract(cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_auto_reload_extract(cortex_a9_pit_WatchdogControl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_auto_reload_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_auto_reload_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 1)));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_int_enable_extract(cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_int_enable_extract(cortex_a9_pit_WatchdogControl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_int_enable_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_int_enable_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 2)));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_wd_mode_extract(cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_wd_mode_extract(cortex_a9_pit_WatchdogControl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_wd_mode_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_wd_mode_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 3)));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_prescale_extract(cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_prescale_extract(cortex_a9_pit_WatchdogControl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_prescale_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_prescale_insert(cortex_a9_pit_WatchdogControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 8)));
}

static inline int cortex_a9_pit_WatchdogControl_prtval(char *_s, size_t _size, cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogControl_prtval(char *_s, size_t _size, cortex_a9_pit_WatchdogControl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wd_enable =\t%" PRIx8 "\t(Timer enable bit)\n", cortex_a9_pit_WatchdogControl_wd_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_reload =\t%" PRIx8 "\t(Single shot or reload mode)\n", cortex_a9_pit_WatchdogControl_auto_reload_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_enable =\t%" PRIx8 "\t(Interrupt enable bit)\n", cortex_a9_pit_WatchdogControl_int_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wd_mode =\t%" PRIx8 "\t(Selects Watchdog or Timer mode)\n", cortex_a9_pit_WatchdogControl_wd_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescale =\t%" PRIx8 "\t(Prescale factor)\n", cortex_a9_pit_WatchdogControl_prescale_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_pit_WatchdogIntStat_t
 * Description: Implicit type of Watchdog Interrupt Status Register register
 * Fields:
 *   event_flag	(size 1, offset 0, init 0):	RWC	event_flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t cortex_a9_pit_WatchdogIntStat_t;
#define cortex_a9_pit_WatchdogIntStat_default 0x0
static inline uint8_t cortex_a9_pit_WatchdogIntStat_event_flag_extract(cortex_a9_pit_WatchdogIntStat_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogIntStat_event_flag_extract(cortex_a9_pit_WatchdogIntStat_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_pit_WatchdogIntStat_t cortex_a9_pit_WatchdogIntStat_event_flag_insert(cortex_a9_pit_WatchdogIntStat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogIntStat_t cortex_a9_pit_WatchdogIntStat_event_flag_insert(cortex_a9_pit_WatchdogIntStat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_pit_WatchdogIntStat_t )(_fieldval)) << 0)));
}

static inline int cortex_a9_pit_WatchdogIntStat_prtval(char *_s, size_t _size, cortex_a9_pit_WatchdogIntStat_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogIntStat_prtval(char *_s, size_t _size, cortex_a9_pit_WatchdogIntStat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_flag =\t%" PRIx8 "\t(event_flag)\n", cortex_a9_pit_WatchdogIntStat_event_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_pit_WatchdogResStat_t
 * Description: Implicit type of Watchdog Reset Status Register register
 * Fields:
 *   reset_flag	(size 1, offset 0, init 0):	RWC	reset_flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t cortex_a9_pit_WatchdogResStat_t;
#define cortex_a9_pit_WatchdogResStat_default 0x0
static inline uint8_t cortex_a9_pit_WatchdogResStat_reset_flag_extract(cortex_a9_pit_WatchdogResStat_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogResStat_reset_flag_extract(cortex_a9_pit_WatchdogResStat_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_pit_WatchdogResStat_t cortex_a9_pit_WatchdogResStat_reset_flag_insert(cortex_a9_pit_WatchdogResStat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogResStat_t cortex_a9_pit_WatchdogResStat_reset_flag_insert(cortex_a9_pit_WatchdogResStat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_pit_WatchdogResStat_t )(_fieldval)) << 0)));
}

static inline int cortex_a9_pit_WatchdogResStat_prtval(char *_s, size_t _size, cortex_a9_pit_WatchdogResStat_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogResStat_prtval(char *_s, size_t _size, cortex_a9_pit_WatchdogResStat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset_flag =\t%" PRIx8 "\t(reset_flag)\n", cortex_a9_pit_WatchdogResStat_reset_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    uint32_t WatchdogDisable_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum cortex_a9_pit_initials {
    cortex_a9_pit_TimerLoad_initial = 0x0,
    cortex_a9_pit_TimerCounter_initial = 0x0,
    cortex_a9_pit_TimerControl_initial = 0x0,
    cortex_a9_pit_TimerIntStat_initial = 0x0,
    cortex_a9_pit_WatchdogLoad_initial = 0x0,
    cortex_a9_pit_WatchdogCounter_initial = 0x0,
    cortex_a9_pit_WatchdogControl_initial = 0x0,
    cortex_a9_pit_WatchdogIntStat_initial = 0x0,
    cortex_a9_pit_WatchdogResStat_initial = 0x0,
    cortex_a9_pit_WatchdogDisable_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void cortex_a9_pit_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void cortex_a9_pit_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register TimerLoad: Private Timer Load Register
 * Type: cortex_a9_pit.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_pit_TimerLoad_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_TimerLoad_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t cortex_a9_pit_TimerLoad_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_TimerLoad_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void cortex_a9_pit_TimerLoad_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerLoad_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void cortex_a9_pit_TimerLoad_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerLoad_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int cortex_a9_pit_TimerLoad_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_TimerLoad_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerLoad (Private Timer Load Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register TimerCounter: Private Timer Counter Register
 * Type: cortex_a9_pit.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_pit_TimerCounter_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_TimerCounter_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline uint32_t cortex_a9_pit_TimerCounter_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_TimerCounter_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void cortex_a9_pit_TimerCounter_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerCounter_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void cortex_a9_pit_TimerCounter_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerCounter_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int cortex_a9_pit_TimerCounter_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_TimerCounter_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerCounter (Private Timer Counter Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register TimerControl: Private Timer Control Register
 * Type: cortex_a9_pit.TimerControl (Implicit type of Private Timer Control Register register)
 *   timer_enable	(size 1, offset 0, init 0):	RW	Timer enable bit
 *   auto_reload	(size 1, offset 1, init 0):	RW	Single shot or reload mode
 *   int_enable	(size 1, offset 2, init 0):	RW	Interrupt enable bit
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   prescale	(size 8, offset 8, init 0):	RW	Prescale factor
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerControl_t cortex_a9_pit_TimerControl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void cortex_a9_pit_TimerControl_rawwr(__DN(t) *_dev, cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerControl_rawwr(__DN(t) *_dev, cortex_a9_pit_TimerControl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void cortex_a9_pit_TimerControl_wr(__DN(t) *_dev, cortex_a9_pit_TimerControl_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerControl_wr(__DN(t) *_dev, cortex_a9_pit_TimerControl_t _regval)
{
    _regval = (_regval & 0xff07);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int cortex_a9_pit_TimerControl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_TimerControl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_pit_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerControl (Private Timer Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timer_enable =\t%" PRIx8 "\t(Timer enable bit)\n", cortex_a9_pit_TimerControl_timer_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_reload =\t%" PRIx8 "\t(Single shot or reload mode)\n", cortex_a9_pit_TimerControl_auto_reload_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_enable =\t%" PRIx8 "\t(Interrupt enable bit)\n", cortex_a9_pit_TimerControl_int_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescale =\t%" PRIx8 "\t(Prescale factor)\n", cortex_a9_pit_TimerControl_prescale_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_pit_TimerControl_timer_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_timer_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_pit_TimerControl_timer_enable_extract(_regval));
}

static inline uint8_t cortex_a9_pit_TimerControl_auto_reload_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_auto_reload_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_pit_TimerControl_auto_reload_extract(_regval));
}

static inline uint8_t cortex_a9_pit_TimerControl_int_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_int_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_pit_TimerControl_int_enable_extract(_regval));
}

static inline uint8_t cortex_a9_pit_TimerControl_prescale_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerControl_prescale_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_pit_TimerControl_prescale_extract(_regval));
}

static inline void cortex_a9_pit_TimerControl_timer_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerControl_timer_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_TimerControl_t _regval = 0x1 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff06 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_TimerControl_auto_reload_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerControl_auto_reload_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_TimerControl_t _regval = 0x2 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xff05 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_TimerControl_int_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerControl_int_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_TimerControl_t _regval = 0x4 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xff03 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_TimerControl_prescale_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerControl_prescale_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_TimerControl_t _regval = 0xff00 & (((cortex_a9_pit_TimerControl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0xff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register TimerIntStat: Private Timer Interrupt Status Register
 * Type: cortex_a9_pit.TimerIntStat (Implicit type of Private Timer Interrupt Status Register register)
 *   event_flag	(size 1, offset 0, init 0):	RWC	event_flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline cortex_a9_pit_TimerIntStat_t cortex_a9_pit_TimerIntStat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerIntStat_t cortex_a9_pit_TimerIntStat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline cortex_a9_pit_TimerIntStat_t cortex_a9_pit_TimerIntStat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_TimerIntStat_t cortex_a9_pit_TimerIntStat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void cortex_a9_pit_TimerIntStat_rawwr(__DN(t) *_dev, cortex_a9_pit_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerIntStat_rawwr(__DN(t) *_dev, cortex_a9_pit_TimerIntStat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void cortex_a9_pit_TimerIntStat_wr(__DN(t) *_dev, cortex_a9_pit_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerIntStat_wr(__DN(t) *_dev, cortex_a9_pit_TimerIntStat_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int cortex_a9_pit_TimerIntStat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_TimerIntStat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_pit_TimerIntStat_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerIntStat (Private Timer Interrupt Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_flag =\t%" PRIx8 "\t(event_flag)\n", cortex_a9_pit_TimerIntStat_event_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_pit_TimerIntStat_event_flag_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_TimerIntStat_event_flag_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_TimerIntStat_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(cortex_a9_pit_TimerIntStat_event_flag_extract(_regval));
}

static inline void cortex_a9_pit_TimerIntStat_event_flag_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_TimerIntStat_event_flag_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_TimerIntStat_t _regval = 0x1 & (((cortex_a9_pit_TimerIntStat_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register WatchdogLoad: Watchdog Load Register
 * Type: cortex_a9_pit.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_pit_WatchdogLoad_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_WatchdogLoad_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline uint32_t cortex_a9_pit_WatchdogLoad_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_WatchdogLoad_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void cortex_a9_pit_WatchdogLoad_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogLoad_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void cortex_a9_pit_WatchdogLoad_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogLoad_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int cortex_a9_pit_WatchdogLoad_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogLoad_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register WatchdogLoad (Watchdog Load Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register WatchdogCounter: Watchdog Counter Register
 * Type: cortex_a9_pit.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_pit_WatchdogCounter_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_WatchdogCounter_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline uint32_t cortex_a9_pit_WatchdogCounter_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_WatchdogCounter_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void cortex_a9_pit_WatchdogCounter_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogCounter_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void cortex_a9_pit_WatchdogCounter_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogCounter_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int cortex_a9_pit_WatchdogCounter_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogCounter_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register WatchdogCounter (Watchdog Counter Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register WatchdogControl: Watchdog Control Register
 * Type: cortex_a9_pit.WatchdogControl (Implicit type of Watchdog Control Register register)
 *   wd_enable	(size 1, offset 0, init 0):	RW	Timer enable bit
 *   auto_reload	(size 1, offset 1, init 0):	RW	Single shot or reload mode
 *   int_enable	(size 1, offset 2, init 0):	RW	Interrupt enable bit
 *   wd_mode	(size 1, offset 3, init 0):	RW	Selects Watchdog or Timer mode
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 *   prescale	(size 8, offset 8, init 0):	RW	Prescale factor
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogControl_t cortex_a9_pit_WatchdogControl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void cortex_a9_pit_WatchdogControl_rawwr(__DN(t) *_dev, cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_rawwr(__DN(t) *_dev, cortex_a9_pit_WatchdogControl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void cortex_a9_pit_WatchdogControl_wr(__DN(t) *_dev, cortex_a9_pit_WatchdogControl_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_wr(__DN(t) *_dev, cortex_a9_pit_WatchdogControl_t _regval)
{
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int cortex_a9_pit_WatchdogControl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogControl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_pit_WatchdogControl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register WatchdogControl (Watchdog Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wd_enable =\t%" PRIx8 "\t(Timer enable bit)\n", cortex_a9_pit_WatchdogControl_wd_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_reload =\t%" PRIx8 "\t(Single shot or reload mode)\n", cortex_a9_pit_WatchdogControl_auto_reload_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_enable =\t%" PRIx8 "\t(Interrupt enable bit)\n", cortex_a9_pit_WatchdogControl_int_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wd_mode =\t%" PRIx8 "\t(Selects Watchdog or Timer mode)\n", cortex_a9_pit_WatchdogControl_wd_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescale =\t%" PRIx8 "\t(Prescale factor)\n", cortex_a9_pit_WatchdogControl_prescale_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_pit_WatchdogControl_wd_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_wd_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogControl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(cortex_a9_pit_WatchdogControl_wd_enable_extract(_regval));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_auto_reload_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_auto_reload_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogControl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(cortex_a9_pit_WatchdogControl_auto_reload_extract(_regval));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_int_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_int_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogControl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(cortex_a9_pit_WatchdogControl_int_enable_extract(_regval));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_wd_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_wd_mode_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogControl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(cortex_a9_pit_WatchdogControl_wd_mode_extract(_regval));
}

static inline uint8_t cortex_a9_pit_WatchdogControl_prescale_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogControl_prescale_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogControl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(cortex_a9_pit_WatchdogControl_prescale_extract(_regval));
}

static inline void cortex_a9_pit_WatchdogControl_wd_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_wd_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogControl_t _regval = 0x1 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff0e & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_WatchdogControl_auto_reload_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_auto_reload_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogControl_t _regval = 0x2 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xff0d & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_WatchdogControl_int_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_int_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogControl_t _regval = 0x4 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xff0b & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_WatchdogControl_wd_mode_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_wd_mode_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogControl_t _regval = 0x8 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xff07 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_pit_WatchdogControl_prescale_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogControl_prescale_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogControl_t _regval = 0xff00 & (((cortex_a9_pit_WatchdogControl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register WatchdogIntStat: Watchdog Interrupt Status Register
 * Type: cortex_a9_pit.WatchdogIntStat (Implicit type of Watchdog Interrupt Status Register register)
 *   event_flag	(size 1, offset 0, init 0):	RWC	event_flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline cortex_a9_pit_WatchdogIntStat_t cortex_a9_pit_WatchdogIntStat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogIntStat_t cortex_a9_pit_WatchdogIntStat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline cortex_a9_pit_WatchdogIntStat_t cortex_a9_pit_WatchdogIntStat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogIntStat_t cortex_a9_pit_WatchdogIntStat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void cortex_a9_pit_WatchdogIntStat_rawwr(__DN(t) *_dev, cortex_a9_pit_WatchdogIntStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogIntStat_rawwr(__DN(t) *_dev, cortex_a9_pit_WatchdogIntStat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void cortex_a9_pit_WatchdogIntStat_wr(__DN(t) *_dev, cortex_a9_pit_WatchdogIntStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogIntStat_wr(__DN(t) *_dev, cortex_a9_pit_WatchdogIntStat_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int cortex_a9_pit_WatchdogIntStat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogIntStat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_pit_WatchdogIntStat_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register WatchdogIntStat (Watchdog Interrupt Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_flag =\t%" PRIx8 "\t(event_flag)\n", cortex_a9_pit_WatchdogIntStat_event_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_pit_WatchdogIntStat_event_flag_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogIntStat_event_flag_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogIntStat_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(cortex_a9_pit_WatchdogIntStat_event_flag_extract(_regval));
}

static inline void cortex_a9_pit_WatchdogIntStat_event_flag_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogIntStat_event_flag_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogIntStat_t _regval = 0x1 & (((cortex_a9_pit_WatchdogIntStat_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register WatchdogResStat: Watchdog Reset Status Register
 * Type: cortex_a9_pit.WatchdogResStat (Implicit type of Watchdog Reset Status Register register)
 *   reset_flag	(size 1, offset 0, init 0):	RWC	reset_flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline cortex_a9_pit_WatchdogResStat_t cortex_a9_pit_WatchdogResStat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogResStat_t cortex_a9_pit_WatchdogResStat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline cortex_a9_pit_WatchdogResStat_t cortex_a9_pit_WatchdogResStat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_pit_WatchdogResStat_t cortex_a9_pit_WatchdogResStat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void cortex_a9_pit_WatchdogResStat_rawwr(__DN(t) *_dev, cortex_a9_pit_WatchdogResStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogResStat_rawwr(__DN(t) *_dev, cortex_a9_pit_WatchdogResStat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void cortex_a9_pit_WatchdogResStat_wr(__DN(t) *_dev, cortex_a9_pit_WatchdogResStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogResStat_wr(__DN(t) *_dev, cortex_a9_pit_WatchdogResStat_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int cortex_a9_pit_WatchdogResStat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogResStat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_pit_WatchdogResStat_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register WatchdogResStat (Watchdog Reset Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset_flag =\t%" PRIx8 "\t(reset_flag)\n", cortex_a9_pit_WatchdogResStat_reset_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_pit_WatchdogResStat_reset_flag_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_pit_WatchdogResStat_reset_flag_rdf(__DN(t) *_dev)
{
    cortex_a9_pit_WatchdogResStat_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(cortex_a9_pit_WatchdogResStat_reset_flag_extract(_regval));
}

static inline void cortex_a9_pit_WatchdogResStat_reset_flag_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogResStat_reset_flag_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_pit_WatchdogResStat_t _regval = 0x1 & (((cortex_a9_pit_WatchdogResStat_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register WatchdogDisable: Watchdog Disable Register
 * Type: cortex_a9_pit.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_pit_WatchdogDisable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_WatchdogDisable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline uint32_t cortex_a9_pit_WatchdogDisable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_pit_WatchdogDisable_rd(__DN(t) *_dev)
{
    return(_dev->WatchdogDisable_shadow);
}

static inline void cortex_a9_pit_WatchdogDisable_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogDisable_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void cortex_a9_pit_WatchdogDisable_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_pit_WatchdogDisable_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int cortex_a9_pit_WatchdogDisable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_WatchdogDisable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = _dev->WatchdogDisable_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register WatchdogDisable (Watchdog Disable Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int cortex_a9_pit_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_pit_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device cortex_a9_pit (Cortex A9 Private Timer and watchdog):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_TimerLoad_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_TimerCounter_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_TimerControl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_TimerIntStat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_WatchdogLoad_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_WatchdogCounter_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_WatchdogControl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_WatchdogIntStat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_WatchdogResStat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_pit_WatchdogDisable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device cortex_a9_pit\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __cortex_a9_pit_DEV_H
