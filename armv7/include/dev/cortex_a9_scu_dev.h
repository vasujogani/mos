#ifndef __cortex_a9_scu_DEV_H
#define __cortex_a9_scu_DEV_H 1
/*
 * DEVICE DEFINITION: Cortex A9 SCU
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) cortex_a9_scu ## _ ## x
/*
 * Constants defn: cortex_a9_scu.cpu_status (CPU Status)
 *  - no width specified
 */
typedef uint8_t cortex_a9_scu_cpu_status_t;
#define cortex_a9_scu_normal ((cortex_a9_scu_cpu_status_t)0x0)
#define cortex_a9_scu_dormant ((cortex_a9_scu_cpu_status_t)0x2)
#define cortex_a9_scu_off ((cortex_a9_scu_cpu_status_t)0x3)

static inline char *cortex_a9_scu_cpu_status_describe(cortex_a9_scu_cpu_status_t _e) __attribute__ ((always_inline));
static inline char *cortex_a9_scu_cpu_status_describe(cortex_a9_scu_cpu_status_t _e)
{
    switch (_e) {
    case cortex_a9_scu_normal:
        return("normal: Normal mode");
    case cortex_a9_scu_dormant:
        return("dormant: Dormant mode");
    case cortex_a9_scu_off:
        return("off: Powered-off mode");
    default:
        return(NULL);
    }
}

static inline int cortex_a9_scu_cpu_status_prtval(char *_s, size_t _size, cortex_a9_scu_cpu_status_t _e) __attribute__ ((always_inline));
static inline int cortex_a9_scu_cpu_status_prtval(char *_s, size_t _size, cortex_a9_scu_cpu_status_t _e)
{
    char *d = cortex_a9_scu_cpu_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "cortex_a9_scu_cpu_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: cortex_a9_scu_control_t
 * Description: Implicit type of SCU Control register
 * Fields:
 *   enable	(size 1, offset 0, init 0):	RW	SCU enable
 *   address_filtering	(size 1, offset 1, init 0):	RW	Address Filtering enable
 *   ram_parity	(size 1, offset 2, init 0):	RW	SCU RAMs parity enable
 *   spec_linefill	(size 1, offset 3, init 0):	RW	SCU speculative linefills enable
 *   all_device_to_port0	(size 1, offset 4, init 0):	RW	Force all Device to port 0 enable
 *   scu_standby	(size 1, offset 5, init 0):	RW	SCU standby enable
 *   ic_standby	(size 1, offset 6, init 0):	RW	IC standby enable
 *   _anon7	(size 25, offset 7, init 0):	RSVD	_
 */
typedef uint32_t cortex_a9_scu_control_t;
#define cortex_a9_scu_control_default 0x0
static inline uint8_t cortex_a9_scu_control_enable_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_enable_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_enable_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_enable_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_scu_control_t )(_fieldval)) << 0)));
}

static inline uint8_t cortex_a9_scu_control_address_filtering_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_address_filtering_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_address_filtering_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_address_filtering_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((cortex_a9_scu_control_t )(_fieldval)) << 1)));
}

static inline uint8_t cortex_a9_scu_control_ram_parity_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_ram_parity_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_ram_parity_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_ram_parity_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((cortex_a9_scu_control_t )(_fieldval)) << 2)));
}

static inline uint8_t cortex_a9_scu_control_spec_linefill_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_spec_linefill_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_spec_linefill_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_spec_linefill_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((cortex_a9_scu_control_t )(_fieldval)) << 3)));
}

static inline uint8_t cortex_a9_scu_control_all_device_to_port0_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_all_device_to_port0_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_all_device_to_port0_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_all_device_to_port0_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((cortex_a9_scu_control_t )(_fieldval)) << 4)));
}

static inline uint8_t cortex_a9_scu_control_scu_standby_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_scu_standby_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_scu_standby_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_scu_standby_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((cortex_a9_scu_control_t )(_fieldval)) << 5)));
}

static inline uint8_t cortex_a9_scu_control_ic_standby_extract(cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_ic_standby_extract(cortex_a9_scu_control_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_ic_standby_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_ic_standby_insert(cortex_a9_scu_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((cortex_a9_scu_control_t )(_fieldval)) << 6)));
}

static inline int cortex_a9_scu_control_prtval(char *_s, size_t _size, cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_scu_control_prtval(char *_s, size_t _size, cortex_a9_scu_control_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(SCU enable)\n", cortex_a9_scu_control_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address_filtering =\t%" PRIx8 "\t(Address Filtering enable)\n", cortex_a9_scu_control_address_filtering_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ram_parity =\t%" PRIx8 "\t(SCU RAMs parity enable)\n", cortex_a9_scu_control_ram_parity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spec_linefill =\t%" PRIx8 "\t(SCU speculative linefills enable)\n", cortex_a9_scu_control_spec_linefill_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " all_device_to_port0 =\t%" PRIx8 "\t(Force all Device to port 0 enable)\n", cortex_a9_scu_control_all_device_to_port0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " scu_standby =\t%" PRIx8 "\t(SCU standby enable)\n", cortex_a9_scu_control_scu_standby_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ic_standby =\t%" PRIx8 "\t(IC standby enable)\n", cortex_a9_scu_control_ic_standby_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_scu_config_t
 * Description: Implicit type of SCU Configuration register
 * Fields:
 *   numcpus	(size 2, offset 0, init 0):	RO	Number of CPUs present
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   cpu_smp	(size 4, offset 4, init 0):	RO	CPUs SMP bits
 *   tag_ram_sizes	(size 8, offset 8, init 0):	RO	Tag RAM sizes
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t cortex_a9_scu_config_t;
#define cortex_a9_scu_config_default 0x0
static inline uint8_t cortex_a9_scu_config_numcpus_extract(cortex_a9_scu_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_config_numcpus_extract(cortex_a9_scu_config_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline cortex_a9_scu_config_t cortex_a9_scu_config_numcpus_insert(cortex_a9_scu_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_config_t cortex_a9_scu_config_numcpus_insert(cortex_a9_scu_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((cortex_a9_scu_config_t )(_fieldval)) << 0)));
}

static inline uint8_t cortex_a9_scu_config_cpu_smp_extract(cortex_a9_scu_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_config_cpu_smp_extract(cortex_a9_scu_config_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline cortex_a9_scu_config_t cortex_a9_scu_config_cpu_smp_insert(cortex_a9_scu_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_config_t cortex_a9_scu_config_cpu_smp_insert(cortex_a9_scu_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((cortex_a9_scu_config_t )(_fieldval)) << 4)));
}

static inline uint8_t cortex_a9_scu_config_tag_ram_sizes_extract(cortex_a9_scu_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_config_tag_ram_sizes_extract(cortex_a9_scu_config_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline cortex_a9_scu_config_t cortex_a9_scu_config_tag_ram_sizes_insert(cortex_a9_scu_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_config_t cortex_a9_scu_config_tag_ram_sizes_insert(cortex_a9_scu_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((cortex_a9_scu_config_t )(_fieldval)) << 8)));
}

static inline int cortex_a9_scu_config_prtval(char *_s, size_t _size, cortex_a9_scu_config_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_scu_config_prtval(char *_s, size_t _size, cortex_a9_scu_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " numcpus =\t%" PRIx8 "\t(Number of CPUs present)\n", cortex_a9_scu_config_numcpus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_smp =\t%" PRIx8 "\t(CPUs SMP bits)\n", cortex_a9_scu_config_cpu_smp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tag_ram_sizes =\t%" PRIx8 "\t(Tag RAM sizes)\n", cortex_a9_scu_config_tag_ram_sizes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_scu_powerstatus_t
 * Description: Implicit type of SCU CPU Power Status register
 * Fields:
 *   cpu0	(size 2, offset 0, init 0):	RW	Status CPU0
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   cpu1	(size 2, offset 8, init 0):	RW	Status CPU1
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   cpu2	(size 2, offset 16, init 0):	RW	Status CPU2
 *   _anon18	(size 6, offset 18, init 0):	RSVD	_
 *   cpu3	(size 2, offset 24, init 0):	RW	Status CPU3
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
typedef uint32_t cortex_a9_scu_powerstatus_t;
#define cortex_a9_scu_powerstatus_default 0x0
static inline uint8_t cortex_a9_scu_powerstatus_cpu0_extract(cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu0_extract(cortex_a9_scu_powerstatus_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu0_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu0_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 0)));
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu1_extract(cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu1_extract(cortex_a9_scu_powerstatus_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu1_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu1_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 8)));
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu2_extract(cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu2_extract(cortex_a9_scu_powerstatus_t _regval)
{
    return((uint8_t )((_regval & 0x30000) >> 16));
}

static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu2_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu2_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 16)));
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu3_extract(cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu3_extract(cortex_a9_scu_powerstatus_t _regval)
{
    return((uint8_t )((_regval & 0x3000000) >> 24));
}

static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu3_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_cpu3_insert(cortex_a9_scu_powerstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 24)));
}

static inline int cortex_a9_scu_powerstatus_prtval(char *_s, size_t _size, cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_scu_powerstatus_prtval(char *_s, size_t _size, cortex_a9_scu_powerstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu0 =\t%" PRIx8 "\t(Status CPU0)\n", cortex_a9_scu_powerstatus_cpu0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu1 =\t%" PRIx8 "\t(Status CPU1)\n", cortex_a9_scu_powerstatus_cpu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu2 =\t%" PRIx8 "\t(Status CPU2)\n", cortex_a9_scu_powerstatus_cpu2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu3 =\t%" PRIx8 "\t(Status CPU3)\n", cortex_a9_scu_powerstatus_cpu3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_scu_filterstart_t
 * Description: Implicit type of Filtering Start Address register
 * Fields:
 *   _anon0	(size 20, offset 0, init 0):	RSVD	_
 *   addr	(size 12, offset 20, init 0):	RW	Filtering Start address
 */
typedef uint32_t cortex_a9_scu_filterstart_t;
#define cortex_a9_scu_filterstart_default 0x0
static inline uint16_t cortex_a9_scu_filterstart_addr_extract(cortex_a9_scu_filterstart_t _regval) __attribute__ ((always_inline));
static inline uint16_t cortex_a9_scu_filterstart_addr_extract(cortex_a9_scu_filterstart_t _regval)
{
    return((uint16_t )((_regval & 0xfff00000) >> 20));
}

static inline cortex_a9_scu_filterstart_t cortex_a9_scu_filterstart_addr_insert(cortex_a9_scu_filterstart_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_filterstart_t cortex_a9_scu_filterstart_addr_insert(cortex_a9_scu_filterstart_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff) | (0xfff00000 & (((cortex_a9_scu_filterstart_t )(_fieldval)) << 20)));
}

static inline int cortex_a9_scu_filterstart_prtval(char *_s, size_t _size, cortex_a9_scu_filterstart_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_scu_filterstart_prtval(char *_s, size_t _size, cortex_a9_scu_filterstart_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Filtering Start address)\n", cortex_a9_scu_filterstart_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_scu_filterend_t
 * Description: Implicit type of Filtering End Address register
 * Fields:
 *   _anon0	(size 20, offset 0, init 0):	RSVD	_
 *   addr	(size 12, offset 20, init 0):	RW	Filtering Start address
 */
typedef uint32_t cortex_a9_scu_filterend_t;
#define cortex_a9_scu_filterend_default 0x0
static inline uint16_t cortex_a9_scu_filterend_addr_extract(cortex_a9_scu_filterend_t _regval) __attribute__ ((always_inline));
static inline uint16_t cortex_a9_scu_filterend_addr_extract(cortex_a9_scu_filterend_t _regval)
{
    return((uint16_t )((_regval & 0xfff00000) >> 20));
}

static inline cortex_a9_scu_filterend_t cortex_a9_scu_filterend_addr_insert(cortex_a9_scu_filterend_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_scu_filterend_t cortex_a9_scu_filterend_addr_insert(cortex_a9_scu_filterend_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff) | (0xfff00000 & (((cortex_a9_scu_filterend_t )(_fieldval)) << 20)));
}

static inline int cortex_a9_scu_filterend_prtval(char *_s, size_t _size, cortex_a9_scu_filterend_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_scu_filterend_prtval(char *_s, size_t _size, cortex_a9_scu_filterend_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Filtering Start address)\n", cortex_a9_scu_filterend_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum cortex_a9_scu_initials {
    cortex_a9_scu_control_initial = 0x0,
    cortex_a9_scu_config_initial = 0x0,
    cortex_a9_scu_powerstatus_initial = 0x0,
    cortex_a9_scu_filterstart_initial = 0x0,
    cortex_a9_scu_filterend_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void cortex_a9_scu_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void cortex_a9_scu_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register control: SCU Control
 * Type: cortex_a9_scu.control (Implicit type of SCU Control register)
 *   enable	(size 1, offset 0, init 0):	RW	SCU enable
 *   address_filtering	(size 1, offset 1, init 0):	RW	Address Filtering enable
 *   ram_parity	(size 1, offset 2, init 0):	RW	SCU RAMs parity enable
 *   spec_linefill	(size 1, offset 3, init 0):	RW	SCU speculative linefills enable
 *   all_device_to_port0	(size 1, offset 4, init 0):	RW	Force all Device to port 0 enable
 *   scu_standby	(size 1, offset 5, init 0):	RW	SCU standby enable
 *   ic_standby	(size 1, offset 6, init 0):	RW	IC standby enable
 *   _anon7	(size 25, offset 7, init 0):	RSVD	_
 */
static inline cortex_a9_scu_control_t cortex_a9_scu_control_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline cortex_a9_scu_control_t cortex_a9_scu_control_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_control_t cortex_a9_scu_control_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void cortex_a9_scu_control_rawwr(__DN(t) *_dev, cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_rawwr(__DN(t) *_dev, cortex_a9_scu_control_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void cortex_a9_scu_control_wr(__DN(t) *_dev, cortex_a9_scu_control_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_wr(__DN(t) *_dev, cortex_a9_scu_control_t _regval)
{
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->base, 0x0)));
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int cortex_a9_scu_control_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_scu_control_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control (SCU Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(SCU enable)\n", cortex_a9_scu_control_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address_filtering =\t%" PRIx8 "\t(Address Filtering enable)\n", cortex_a9_scu_control_address_filtering_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ram_parity =\t%" PRIx8 "\t(SCU RAMs parity enable)\n", cortex_a9_scu_control_ram_parity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spec_linefill =\t%" PRIx8 "\t(SCU speculative linefills enable)\n", cortex_a9_scu_control_spec_linefill_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " all_device_to_port0 =\t%" PRIx8 "\t(Force all Device to port 0 enable)\n", cortex_a9_scu_control_all_device_to_port0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " scu_standby =\t%" PRIx8 "\t(SCU standby enable)\n", cortex_a9_scu_control_scu_standby_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ic_standby =\t%" PRIx8 "\t(IC standby enable)\n", cortex_a9_scu_control_ic_standby_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_scu_control_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_enable_extract(_regval));
}

static inline uint8_t cortex_a9_scu_control_address_filtering_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_address_filtering_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_address_filtering_extract(_regval));
}

static inline uint8_t cortex_a9_scu_control_ram_parity_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_ram_parity_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_ram_parity_extract(_regval));
}

static inline uint8_t cortex_a9_scu_control_spec_linefill_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_spec_linefill_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_spec_linefill_extract(_regval));
}

static inline uint8_t cortex_a9_scu_control_all_device_to_port0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_all_device_to_port0_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_all_device_to_port0_extract(_regval));
}

static inline uint8_t cortex_a9_scu_control_scu_standby_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_scu_standby_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_scu_standby_extract(_regval));
}

static inline uint8_t cortex_a9_scu_control_ic_standby_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_control_ic_standby_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_control_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(cortex_a9_scu_control_ic_standby_extract(_regval));
}

static inline void cortex_a9_scu_control_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x1 & (((cortex_a9_scu_control_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_control_address_filtering_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_address_filtering_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x2 & (((cortex_a9_scu_control_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_control_ram_parity_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_ram_parity_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x4 & (((cortex_a9_scu_control_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_control_spec_linefill_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_spec_linefill_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x8 & (((cortex_a9_scu_control_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_control_all_device_to_port0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_all_device_to_port0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x10 & (((cortex_a9_scu_control_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_control_scu_standby_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_scu_standby_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x20 & (((cortex_a9_scu_control_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_control_ic_standby_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_control_ic_standby_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_control_t _regval = 0x40 & (((cortex_a9_scu_control_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register config: SCU Configuration
 * Type: cortex_a9_scu.config (Implicit type of SCU Configuration register)
 *   numcpus	(size 2, offset 0, init 0):	RO	Number of CPUs present
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   cpu_smp	(size 4, offset 4, init 0):	RO	CPUs SMP bits
 *   tag_ram_sizes	(size 8, offset 8, init 0):	RO	Tag RAM sizes
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline cortex_a9_scu_config_t cortex_a9_scu_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_config_t cortex_a9_scu_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline cortex_a9_scu_config_t cortex_a9_scu_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_config_t cortex_a9_scu_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void cortex_a9_scu_config_rawwr(__DN(t) *_dev, cortex_a9_scu_config_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_config_rawwr(__DN(t) *_dev, cortex_a9_scu_config_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

// Register config is not writeable
static inline int cortex_a9_scu_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_scu_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_scu_config_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config (SCU Configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " numcpus =\t%" PRIx8 "\t(Number of CPUs present)\n", cortex_a9_scu_config_numcpus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu_smp =\t%" PRIx8 "\t(CPUs SMP bits)\n", cortex_a9_scu_config_cpu_smp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tag_ram_sizes =\t%" PRIx8 "\t(Tag RAM sizes)\n", cortex_a9_scu_config_tag_ram_sizes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_scu_config_numcpus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_config_numcpus_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_config_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(cortex_a9_scu_config_numcpus_extract(_regval));
}

static inline uint8_t cortex_a9_scu_config_cpu_smp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_config_cpu_smp_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_config_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(cortex_a9_scu_config_cpu_smp_extract(_regval));
}

static inline uint8_t cortex_a9_scu_config_tag_ram_sizes_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_config_tag_ram_sizes_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_config_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(cortex_a9_scu_config_tag_ram_sizes_extract(_regval));
}

/*
 * Register powerstatus: SCU CPU Power Status
 * Type: cortex_a9_scu.powerstatus (Implicit type of SCU CPU Power Status register)
 *   cpu0	(size 2, offset 0, init 0):	RW	Status CPU0
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   cpu1	(size 2, offset 8, init 0):	RW	Status CPU1
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   cpu2	(size 2, offset 16, init 0):	RW	Status CPU2
 *   _anon18	(size 6, offset 18, init 0):	RSVD	_
 *   cpu3	(size 2, offset 24, init 0):	RW	Status CPU3
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_powerstatus_t cortex_a9_scu_powerstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void cortex_a9_scu_powerstatus_rawwr(__DN(t) *_dev, cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_powerstatus_rawwr(__DN(t) *_dev, cortex_a9_scu_powerstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void cortex_a9_scu_powerstatus_wr(__DN(t) *_dev, cortex_a9_scu_powerstatus_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_powerstatus_wr(__DN(t) *_dev, cortex_a9_scu_powerstatus_t _regval)
{
    _regval = (_regval & 0x3030303);
    // No MB1 fields present
    _regval = (_regval | (0xfcfcfcfc & mackerel_read_addr_32(_dev->base, 0x8)));
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int cortex_a9_scu_powerstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_scu_powerstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_scu_powerstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register powerstatus (SCU CPU Power Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu0 =\t%" PRIx8 "\t(Status CPU0)\n", cortex_a9_scu_powerstatus_cpu0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu1 =\t%" PRIx8 "\t(Status CPU1)\n", cortex_a9_scu_powerstatus_cpu1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu2 =\t%" PRIx8 "\t(Status CPU2)\n", cortex_a9_scu_powerstatus_cpu2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpu3 =\t%" PRIx8 "\t(Status CPU3)\n", cortex_a9_scu_powerstatus_cpu3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu0_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_powerstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_scu_powerstatus_cpu0_extract(_regval));
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu1_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_powerstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_scu_powerstatus_cpu1_extract(_regval));
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu2_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_powerstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_scu_powerstatus_cpu2_extract(_regval));
}

static inline uint8_t cortex_a9_scu_powerstatus_cpu3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_scu_powerstatus_cpu3_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_powerstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_scu_powerstatus_cpu3_extract(_regval));
}

static inline void cortex_a9_scu_powerstatus_cpu0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_powerstatus_cpu0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_powerstatus_t _regval = 0x3 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_powerstatus_cpu1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_powerstatus_cpu1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_powerstatus_t _regval = 0x300 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffcff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_powerstatus_cpu2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_powerstatus_cpu2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_powerstatus_t _regval = 0x30000 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffcffff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_scu_powerstatus_cpu3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_powerstatus_cpu3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_scu_powerstatus_t _regval = 0x3000000 & (((cortex_a9_scu_powerstatus_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfcffffff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register filterstart: Filtering Start Address
 * Type: cortex_a9_scu.filterstart (Implicit type of Filtering Start Address register)
 *   _anon0	(size 20, offset 0, init 0):	RSVD	_
 *   addr	(size 12, offset 20, init 0):	RW	Filtering Start address
 */
static inline cortex_a9_scu_filterstart_t cortex_a9_scu_filterstart_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_filterstart_t cortex_a9_scu_filterstart_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline cortex_a9_scu_filterstart_t cortex_a9_scu_filterstart_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_filterstart_t cortex_a9_scu_filterstart_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void cortex_a9_scu_filterstart_rawwr(__DN(t) *_dev, cortex_a9_scu_filterstart_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_filterstart_rawwr(__DN(t) *_dev, cortex_a9_scu_filterstart_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void cortex_a9_scu_filterstart_wr(__DN(t) *_dev, cortex_a9_scu_filterstart_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_filterstart_wr(__DN(t) *_dev, cortex_a9_scu_filterstart_t _regval)
{
    _regval = (_regval & 0xfff00000);
    // No MB1 fields present
    _regval = (_regval | (0xfffff & mackerel_read_addr_32(_dev->base, 0x40)));
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int cortex_a9_scu_filterstart_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_scu_filterstart_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_scu_filterstart_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register filterstart (Filtering Start Address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Filtering Start address)\n", cortex_a9_scu_filterstart_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t cortex_a9_scu_filterstart_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t cortex_a9_scu_filterstart_addr_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_filterstart_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(cortex_a9_scu_filterstart_addr_extract(_regval));
}

static inline void cortex_a9_scu_filterstart_addr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_filterstart_addr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    cortex_a9_scu_filterstart_t _regval = 0xfff00000 & (((cortex_a9_scu_filterstart_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfffff & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register filterend: Filtering End Address
 * Type: cortex_a9_scu.filterend (Implicit type of Filtering End Address register)
 *   _anon0	(size 20, offset 0, init 0):	RSVD	_
 *   addr	(size 12, offset 20, init 0):	RW	Filtering Start address
 */
static inline cortex_a9_scu_filterend_t cortex_a9_scu_filterend_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_filterend_t cortex_a9_scu_filterend_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline cortex_a9_scu_filterend_t cortex_a9_scu_filterend_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_scu_filterend_t cortex_a9_scu_filterend_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void cortex_a9_scu_filterend_rawwr(__DN(t) *_dev, cortex_a9_scu_filterend_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_filterend_rawwr(__DN(t) *_dev, cortex_a9_scu_filterend_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void cortex_a9_scu_filterend_wr(__DN(t) *_dev, cortex_a9_scu_filterend_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_filterend_wr(__DN(t) *_dev, cortex_a9_scu_filterend_t _regval)
{
    _regval = (_regval & 0xfff00000);
    // No MB1 fields present
    _regval = (_regval | (0xfffff & mackerel_read_addr_32(_dev->base, 0x44)));
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int cortex_a9_scu_filterend_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_scu_filterend_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_scu_filterend_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register filterend (Filtering End Address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Filtering Start address)\n", cortex_a9_scu_filterend_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t cortex_a9_scu_filterend_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t cortex_a9_scu_filterend_addr_rdf(__DN(t) *_dev)
{
    cortex_a9_scu_filterend_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(cortex_a9_scu_filterend_addr_extract(_regval));
}

static inline void cortex_a9_scu_filterend_addr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_scu_filterend_addr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    cortex_a9_scu_filterend_t _regval = 0xfff00000 & (((cortex_a9_scu_filterend_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfffff & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline int cortex_a9_scu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_scu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device cortex_a9_scu (Cortex A9 SCU):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_scu_control_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_scu_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_scu_powerstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_scu_filterstart_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_scu_filterend_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device cortex_a9_scu\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __cortex_a9_scu_DEV_H
