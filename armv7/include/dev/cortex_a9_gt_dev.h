#ifndef __cortex_a9_gt_DEV_H
#define __cortex_a9_gt_DEV_H 1
/*
 * DEVICE DEFINITION: Cortex A9 Global Timer
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) cortex_a9_gt ## _ ## x
/*
 * Register type: cortex_a9_gt_TimerControl_t
 * Description: Implicit type of Control register
 * Fields:
 *   timer_enable	(size 1, offset 0, init 0):	RW	Timer enable bit
 *   comp_enable	(size 1, offset 1, init 0):	RW	Enable comparision between counter and comparator
 *   int_enable	(size 1, offset 2, init 0):	RW	Interrupt enable bit
 *   auto_increment	(size 1, offset 3, init 0):	RW	Single shot or increment mode
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   prescale	(size 8, offset 8, init 0):	RW	Prescale factor
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t cortex_a9_gt_TimerControl_t;
#define cortex_a9_gt_TimerControl_default 0x0
static inline uint8_t cortex_a9_gt_TimerControl_timer_enable_extract(cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_timer_enable_extract(cortex_a9_gt_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_timer_enable_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_timer_enable_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 0)));
}

static inline uint8_t cortex_a9_gt_TimerControl_comp_enable_extract(cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_comp_enable_extract(cortex_a9_gt_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_comp_enable_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_comp_enable_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 1)));
}

static inline uint8_t cortex_a9_gt_TimerControl_int_enable_extract(cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_int_enable_extract(cortex_a9_gt_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_int_enable_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_int_enable_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 2)));
}

static inline uint8_t cortex_a9_gt_TimerControl_auto_increment_extract(cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_auto_increment_extract(cortex_a9_gt_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_auto_increment_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_auto_increment_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 3)));
}

static inline uint8_t cortex_a9_gt_TimerControl_prescale_extract(cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_prescale_extract(cortex_a9_gt_TimerControl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_prescale_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_prescale_insert(cortex_a9_gt_TimerControl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 8)));
}

static inline int cortex_a9_gt_TimerControl_prtval(char *_s, size_t _size, cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerControl_prtval(char *_s, size_t _size, cortex_a9_gt_TimerControl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timer_enable =\t%" PRIx8 "\t(Timer enable bit)\n", cortex_a9_gt_TimerControl_timer_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " comp_enable =\t%" PRIx8 "\t(Enable comparision between counter and comparator)\n", cortex_a9_gt_TimerControl_comp_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_enable =\t%" PRIx8 "\t(Interrupt enable bit)\n", cortex_a9_gt_TimerControl_int_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_increment =\t%" PRIx8 "\t(Single shot or increment mode)\n", cortex_a9_gt_TimerControl_auto_increment_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescale =\t%" PRIx8 "\t(Prescale factor)\n", cortex_a9_gt_TimerControl_prescale_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: cortex_a9_gt_TimerIntStat_t
 * Description: Implicit type of Interrupt Status register
 * Fields:
 *   event_flag	(size 1, offset 0, init 0):	RW	event_flag
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t cortex_a9_gt_TimerIntStat_t;
#define cortex_a9_gt_TimerIntStat_default 0x0
static inline uint8_t cortex_a9_gt_TimerIntStat_event_flag_extract(cortex_a9_gt_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerIntStat_event_flag_extract(cortex_a9_gt_TimerIntStat_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline cortex_a9_gt_TimerIntStat_t cortex_a9_gt_TimerIntStat_event_flag_insert(cortex_a9_gt_TimerIntStat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerIntStat_t cortex_a9_gt_TimerIntStat_event_flag_insert(cortex_a9_gt_TimerIntStat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((cortex_a9_gt_TimerIntStat_t )(_fieldval)) << 0)));
}

static inline int cortex_a9_gt_TimerIntStat_prtval(char *_s, size_t _size, cortex_a9_gt_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerIntStat_prtval(char *_s, size_t _size, cortex_a9_gt_TimerIntStat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_flag =\t%" PRIx8 "\t(event_flag)\n", cortex_a9_gt_TimerIntStat_event_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum cortex_a9_gt_initials {
    cortex_a9_gt_TimerCounterLow_initial = 0x0,
    cortex_a9_gt_TimerCounterHigh_initial = 0x0,
    cortex_a9_gt_TimerControl_initial = 0x0,
    cortex_a9_gt_TimerIntStat_initial = 0x0,
    cortex_a9_gt_TimerComparatorLow_initial = 0x0,
    cortex_a9_gt_TimerComparatorHigh_initial = 0x0,
    cortex_a9_gt_TimerAutoIncrement_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void cortex_a9_gt_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void cortex_a9_gt_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register TimerCounterLow: Counter (Lower Word)
 * Type: cortex_a9_gt.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_gt_TimerCounterLow_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerCounterLow_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline uint32_t cortex_a9_gt_TimerCounterLow_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerCounterLow_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void cortex_a9_gt_TimerCounterLow_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerCounterLow_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void cortex_a9_gt_TimerCounterLow_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerCounterLow_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int cortex_a9_gt_TimerCounterLow_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerCounterLow_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerCounterLow (Counter (Lower Word)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register TimerCounterHigh: Counter (Upper Word)
 * Type: cortex_a9_gt.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_gt_TimerCounterHigh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerCounterHigh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline uint32_t cortex_a9_gt_TimerCounterHigh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerCounterHigh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void cortex_a9_gt_TimerCounterHigh_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerCounterHigh_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void cortex_a9_gt_TimerCounterHigh_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerCounterHigh_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int cortex_a9_gt_TimerCounterHigh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerCounterHigh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerCounterHigh (Counter (Upper Word)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register TimerControl: Control
 * Type: cortex_a9_gt.TimerControl (Implicit type of Control register)
 *   timer_enable	(size 1, offset 0, init 0):	RW	Timer enable bit
 *   comp_enable	(size 1, offset 1, init 0):	RW	Enable comparision between counter and comparator
 *   int_enable	(size 1, offset 2, init 0):	RW	Interrupt enable bit
 *   auto_increment	(size 1, offset 3, init 0):	RW	Single shot or increment mode
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   prescale	(size 8, offset 8, init 0):	RW	Prescale factor
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerControl_t cortex_a9_gt_TimerControl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void cortex_a9_gt_TimerControl_rawwr(__DN(t) *_dev, cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_rawwr(__DN(t) *_dev, cortex_a9_gt_TimerControl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void cortex_a9_gt_TimerControl_wr(__DN(t) *_dev, cortex_a9_gt_TimerControl_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_wr(__DN(t) *_dev, cortex_a9_gt_TimerControl_t _regval)
{
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    _regval = (_regval | (0xffff00f0 & mackerel_read_addr_32(_dev->base, 0x8)));
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int cortex_a9_gt_TimerControl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerControl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_gt_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerControl (Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timer_enable =\t%" PRIx8 "\t(Timer enable bit)\n", cortex_a9_gt_TimerControl_timer_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " comp_enable =\t%" PRIx8 "\t(Enable comparision between counter and comparator)\n", cortex_a9_gt_TimerControl_comp_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_enable =\t%" PRIx8 "\t(Interrupt enable bit)\n", cortex_a9_gt_TimerControl_int_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_increment =\t%" PRIx8 "\t(Single shot or increment mode)\n", cortex_a9_gt_TimerControl_auto_increment_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prescale =\t%" PRIx8 "\t(Prescale factor)\n", cortex_a9_gt_TimerControl_prescale_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_gt_TimerControl_timer_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_timer_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_gt_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_gt_TimerControl_timer_enable_extract(_regval));
}

static inline uint8_t cortex_a9_gt_TimerControl_comp_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_comp_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_gt_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_gt_TimerControl_comp_enable_extract(_regval));
}

static inline uint8_t cortex_a9_gt_TimerControl_int_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_int_enable_rdf(__DN(t) *_dev)
{
    cortex_a9_gt_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_gt_TimerControl_int_enable_extract(_regval));
}

static inline uint8_t cortex_a9_gt_TimerControl_auto_increment_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_auto_increment_rdf(__DN(t) *_dev)
{
    cortex_a9_gt_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_gt_TimerControl_auto_increment_extract(_regval));
}

static inline uint8_t cortex_a9_gt_TimerControl_prescale_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerControl_prescale_rdf(__DN(t) *_dev)
{
    cortex_a9_gt_TimerControl_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(cortex_a9_gt_TimerControl_prescale_extract(_regval));
}

static inline void cortex_a9_gt_TimerControl_timer_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_timer_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_gt_TimerControl_t _regval = 0x1 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_gt_TimerControl_comp_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_comp_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_gt_TimerControl_t _regval = 0x2 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_gt_TimerControl_int_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_int_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_gt_TimerControl_t _regval = 0x4 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_gt_TimerControl_auto_increment_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_auto_increment_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_gt_TimerControl_t _regval = 0x8 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void cortex_a9_gt_TimerControl_prescale_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerControl_prescale_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_gt_TimerControl_t _regval = 0xff00 & (((cortex_a9_gt_TimerControl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register TimerIntStat: Interrupt Status
 * Type: cortex_a9_gt.TimerIntStat (Implicit type of Interrupt Status register)
 *   event_flag	(size 1, offset 0, init 0):	RW	event_flag
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline cortex_a9_gt_TimerIntStat_t cortex_a9_gt_TimerIntStat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerIntStat_t cortex_a9_gt_TimerIntStat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline cortex_a9_gt_TimerIntStat_t cortex_a9_gt_TimerIntStat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline cortex_a9_gt_TimerIntStat_t cortex_a9_gt_TimerIntStat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void cortex_a9_gt_TimerIntStat_rawwr(__DN(t) *_dev, cortex_a9_gt_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerIntStat_rawwr(__DN(t) *_dev, cortex_a9_gt_TimerIntStat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void cortex_a9_gt_TimerIntStat_wr(__DN(t) *_dev, cortex_a9_gt_TimerIntStat_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerIntStat_wr(__DN(t) *_dev, cortex_a9_gt_TimerIntStat_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xc)));
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int cortex_a9_gt_TimerIntStat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerIntStat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    cortex_a9_gt_TimerIntStat_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerIntStat (Interrupt Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event_flag =\t%" PRIx8 "\t(event_flag)\n", cortex_a9_gt_TimerIntStat_event_flag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t cortex_a9_gt_TimerIntStat_event_flag_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t cortex_a9_gt_TimerIntStat_event_flag_rdf(__DN(t) *_dev)
{
    cortex_a9_gt_TimerIntStat_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(cortex_a9_gt_TimerIntStat_event_flag_extract(_regval));
}

static inline void cortex_a9_gt_TimerIntStat_event_flag_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerIntStat_event_flag_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    cortex_a9_gt_TimerIntStat_t _regval = 0x1 & (((cortex_a9_gt_TimerIntStat_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register TimerComparatorLow: Comparator (Lower Word)
 * Type: cortex_a9_gt.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_gt_TimerComparatorLow_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerComparatorLow_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline uint32_t cortex_a9_gt_TimerComparatorLow_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerComparatorLow_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void cortex_a9_gt_TimerComparatorLow_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerComparatorLow_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void cortex_a9_gt_TimerComparatorLow_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerComparatorLow_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int cortex_a9_gt_TimerComparatorLow_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerComparatorLow_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerComparatorLow (Comparator (Lower Word)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register TimerComparatorHigh: Comparator (Upper Word)
 * Type: cortex_a9_gt.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_gt_TimerComparatorHigh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerComparatorHigh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline uint32_t cortex_a9_gt_TimerComparatorHigh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerComparatorHigh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void cortex_a9_gt_TimerComparatorHigh_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerComparatorHigh_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void cortex_a9_gt_TimerComparatorHigh_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerComparatorHigh_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int cortex_a9_gt_TimerComparatorHigh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerComparatorHigh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerComparatorHigh (Comparator (Upper Word)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register TimerAutoIncrement: Comparator Auto-Increment
 * Type: cortex_a9_gt.uint32 (primitive type)
 */
static inline uint32_t cortex_a9_gt_TimerAutoIncrement_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerAutoIncrement_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline uint32_t cortex_a9_gt_TimerAutoIncrement_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t cortex_a9_gt_TimerAutoIncrement_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void cortex_a9_gt_TimerAutoIncrement_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerAutoIncrement_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void cortex_a9_gt_TimerAutoIncrement_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void cortex_a9_gt_TimerAutoIncrement_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int cortex_a9_gt_TimerAutoIncrement_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_TimerAutoIncrement_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register TimerAutoIncrement (Comparator Auto-Increment): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int cortex_a9_gt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int cortex_a9_gt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device cortex_a9_gt (Cortex A9 Global Timer):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerCounterLow_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerCounterHigh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerControl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerIntStat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerComparatorLow_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerComparatorHigh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = cortex_a9_gt_TimerAutoIncrement_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device cortex_a9_gt\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __cortex_a9_gt_DEV_H
